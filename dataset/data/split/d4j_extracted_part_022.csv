code_snippet,type,score
"            if (i < mLinesPerEditText - 1) {
                sb.append('\n'); // all but last line
            }",method,
"        public MyAdapter(Context context, List<String> bodies) {
            super(context, 0, bodies);
        }",method,
"        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            String body = getItem(position);
            if (convertView != null) {
                ((EditText) convertView).setText(body);
                return convertView;                
            }
            EditText editText = new EditText(getContext());
            editText.setText(body);
            return editText;
        }",method,
"            if (convertView != null) {
                ((EditText) convertView).setText(body);
                return convertView;                
            }",method,
"public class MemberSpecialNameFilter implements MemberVisitor
{
    private final MemberVisitor memberVisitor;
    public MemberSpecialNameFilter(MemberVisitor memberVisitor)
    {
        this.memberVisitor = memberVisitor;
    }
    // Implementations for MemberVisitor.
    public void visitProgramField(ProgramClass programClass, ProgramField programField)
    {
        if (hasSpecialName(programField))
        {
            memberVisitor.visitProgramField(programClass, programField);
        }
    }
    public void visitProgramMethod(ProgramClass programClass, ProgramMethod programMethod)
    {
        if (hasSpecialName(programMethod))
        {
            memberVisitor.visitProgramMethod(programClass, programMethod);
        }
    }
    public void visitLibraryField(LibraryClass libraryClass, LibraryField libraryField)
    {
        if (hasSpecialName(libraryField))
        {
            memberVisitor.visitLibraryField(libraryClass, libraryField);
        }
    }
    public void visitLibraryMethod(LibraryClass libraryClass, LibraryMethod libraryMethod)
    {
        if (hasSpecialName(libraryMethod))
        {
            memberVisitor.visitLibraryMethod(libraryClass, libraryMethod);
        }
    }
    // Small utility methods.
    private static boolean hasSpecialName(Member member)
    {
        return SpecialNameFactory.isSpecialName(MemberObfuscator.newMemberName(member));
    }
}",class,
"public class MultiMappingProcessor
implements   MappingProcessor
{
    private final MappingProcessor[] mappingProcessors;
    public MultiMappingProcessor(MappingProcessor[] mappingProcessors)
    {
        this.mappingProcessors = mappingProcessors;
    }
    // Implementations for MappingProcessor.
    public boolean processClassMapping(String className,
                                       String newClassName)
    {
        boolean result = false;
        for (int index = 0; index < mappingProcessors.length; index++)
        {
            result |= mappingProcessors[index].processClassMapping(className,
                                                                   newClassName);
        }
        return result;
    }
    public void processFieldMapping(String className,
                                    String fieldType,
                                    String fieldName,
                                    String newClassName,
                                    String newFieldName)
    {
        for (int index = 0; index < mappingProcessors.length; index++)
        {
            mappingProcessors[index].processFieldMapping(className,
                                                         fieldType,
                                                         fieldName,
                                                         newClassName,
                                                         newFieldName);
        }
    }
    public void processMethodMapping(String className,
                                     int    firstLineNumber,
                                     int    lastLineNumber,
                                     String methodReturnType,
                                     String methodName,
                                     String methodArguments,
                                     String newClassName,
                                     int    newFirstLineNumber,
                                     int    newLastLineNumber,
                                     String newMethodName)
    {
        for (int index = 0; index < mappingProcessors.length; index++)
        {
            mappingProcessors[index].processMethodMapping(className,
                                                          firstLineNumber,
                                                          lastLineNumber,
                                                          methodReturnType,
                                                          methodName,
                                                          methodArguments,
                                                          newClassName,
                                                          newFirstLineNumber,
                                                          newLastLineNumber,
                                                          newMethodName);
        }
    }
}",class,
"    public MemberSpecialNameFilter(MemberVisitor memberVisitor)
    {
        this.memberVisitor = memberVisitor;
    }",method,
"    public void visitProgramField(ProgramClass programClass, ProgramField programField)
    {
        if (hasSpecialName(programField))
        {
            memberVisitor.visitProgramField(programClass, programField);
        }
    }",method,
"    public void visitProgramMethod(ProgramClass programClass, ProgramMethod programMethod)
    {
        if (hasSpecialName(programMethod))
        {
            memberVisitor.visitProgramMethod(programClass, programMethod);
        }
    }",method,
"    public void visitLibraryField(LibraryClass libraryClass, LibraryField libraryField)
    {
        if (hasSpecialName(libraryField))
        {
            memberVisitor.visitLibraryField(libraryClass, libraryField);
        }
    }",method,
"    public void visitLibraryMethod(LibraryClass libraryClass, LibraryMethod libraryMethod)
    {
        if (hasSpecialName(libraryMethod))
        {
            memberVisitor.visitLibraryMethod(libraryClass, libraryMethod);
        }
    }",method,
"    private static boolean hasSpecialName(Member member)
    {
        return SpecialNameFactory.isSpecialName(MemberObfuscator.newMemberName(member));
    }",method,
"    public MultiMappingProcessor(MappingProcessor[] mappingProcessors)
    {
        this.mappingProcessors = mappingProcessors;
    }",method,
"    public boolean processClassMapping(String className,
                                       String newClassName)
    {
        boolean result = false;
        for (int index = 0; index < mappingProcessors.length; index++)
        {
            result |= mappingProcessors[index].processClassMapping(className,
                                                                   newClassName);
        }
        return result;
    }",method,
"        for (int index = 0; index < mappingProcessors.length; index++)
        {
            result |= mappingProcessors[index].processClassMapping(className,
                                                                   newClassName);
        }",method,
"    public void processFieldMapping(String className,
                                    String fieldType,
                                    String fieldName,
                                    String newClassName,
                                    String newFieldName)
    {
        for (int index = 0; index < mappingProcessors.length; index++)
        {
            mappingProcessors[index].processFieldMapping(className,
                                                         fieldType,
                                                         fieldName,
                                                         newClassName,
                                                         newFieldName);
        }
    }",method,
"        for (int index = 0; index < mappingProcessors.length; index++)
        {
            mappingProcessors[index].processFieldMapping(className,
                                                         fieldType,
                                                         fieldName,
                                                         newClassName,
                                                         newFieldName);
        }",method,
"    public void processMethodMapping(String className,
                                     int    firstLineNumber,
                                     int    lastLineNumber,
                                     String methodReturnType,
                                     String methodName,
                                     String methodArguments,
                                     String newClassName,
                                     int    newFirstLineNumber,
                                     int    newLastLineNumber,
                                     String newMethodName)
    {
        for (int index = 0; index < mappingProcessors.length; index++)
        {
            mappingProcessors[index].processMethodMapping(className,
                                                          firstLineNumber,
                                                          lastLineNumber,
                                                          methodReturnType,
                                                          methodName,
                                                          methodArguments,
                                                          newClassName,
                                                          newFirstLineNumber,
                                                          newLastLineNumber,
                                                          newMethodName);
        }
    }",method,
"        for (int index = 0; index < mappingProcessors.length; index++)
        {
            mappingProcessors[index].processMethodMapping(className,
                                                          firstLineNumber,
                                                          lastLineNumber,
                                                          methodReturnType,
                                                          methodName,
                                                          methodArguments,
                                                          newClassName,
                                                          newFirstLineNumber,
                                                          newLastLineNumber,
                                                          newMethodName);
        }",method,
"public class ZipkinElasticsearchAwsStorageAutoConfiguration {
  static final Pattern AWS_URL =
      Pattern.compile(""^https://[^.]+\\.([^.]+)\\.es\\.amazonaws\\.com"", Pattern.CASE_INSENSITIVE);
  static final Logger log =
      Logger.getLogger(ZipkinElasticsearchAwsStorageAutoConfiguration.class.getName());
  @Bean
  @Qualifier(""zipkinElasticsearchHttp"")
  Interceptor awsSignatureVersion4(
      ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws,
      AWSCredentials.Provider credentials) {
    return new AWSSignatureVersion4(region(es, aws), ""es"", credentials);
  }
  @Bean String region(ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws) {
    List<String> hosts = es.getHosts();
    String domain = aws.getDomain();
    if (hosts != null && domain != null) {
      log.warning(
          format(""Expected exactly one of hosts or domain: instead saw hosts '%s' and domain '%s'.""
              + "" Ignoring hosts and proceeding to look for domain. Either unset ES_HOSTS or ""
              + ""ES_AWS_DOMAIN to suppress this message."", hosts, domain));
    }
    if (aws.getRegion() != null) {
      return aws.getRegion();
    } else if (domain != null) {
      return new DefaultAwsRegionProviderChain().getRegion();
    } else {
      String awsRegion = regionFromAwsUrls(hosts);
      checkArgument(awsRegion != null, ""Couldn't awsRegion in '%s'"", hosts);
      return awsRegion;
    }
  }
  @Bean
  @ConditionalOnMissingBean
  AWSCredentials.Provider credentials() {
    return new AWSCredentials.Provider() {
      AWSCredentialsProvider delegate = new DefaultAWSCredentialsProviderChain();
      @Override public AWSCredentials get() {
        com.amazonaws.auth.AWSCredentials result = delegate.getCredentials();
        String sessionToken = result instanceof AWSSessionCredentials
            ? ((AWSSessionCredentials) result).getSessionToken()
            : null;
        return new AWSCredentials(
            result.getAWSAccessKeyId(),
            result.getAWSSecretKey(),
            sessionToken
        );
      }
    };
  }
  @Bean
  @Conditional(AwsDomainSetCondition.class)
  StorageComponent storage(
      ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws,
      @Qualifier(""zipkinElasticsearchHttp"") OkHttpClient client,
      @Value(""${zipkin.storage.strict-trace-id:true}"") boolean strictTraceId) {
    String domain = aws.getDomain();
    String region = region(es, aws);
    ElasticsearchDomainEndpoint hosts = new ElasticsearchDomainEndpoint(
        client, HttpUrl.parse(""https://es."" + region + "".amazonaws.com""), domain);
    return V2StorageComponent.create(
      es.toBuilder(client).strictTraceId(strictTraceId).hostsSupplier(hosts).build());
  }",class,
"  static final class AwsDomainSetCondition extends SpringBootCondition {
    static final String PROPERTY_NAME = ""zipkin.storage.elasticsearch.aws.domain"";
    @Override
    public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata a) {
      String domain = context.getEnvironment().getProperty(PROPERTY_NAME);
      return domain == null || domain.isEmpty() ?
          ConditionOutcome.noMatch(PROPERTY_NAME + "" isn't set"") :
          ConditionOutcome.match();
    }
  }",class,
"  static final class AwsMagic implements Condition {
    @Override public boolean matches(ConditionContext condition, AnnotatedTypeMetadata md) {
      String hosts = condition.getEnvironment().getProperty(""zipkin.storage.elasticsearch.hosts"");
      String domain = condition.getEnvironment()
          .getProperty(""zipkin.storage.elasticsearch.aws.domain"");
      // If neither hosts nor domain, no AWS magic
      if (isEmpty(hosts) && isEmpty(domain)) return false;
      // Either we have a domain, or we check the hosts auto-detection magic
      return !isEmpty(domain) || regionFromAwsUrls(Arrays.asList(hosts.split("",""))) != null;
    }
  }",class,
"  @Bean
  @Qualifier(""zipkinElasticsearchHttp"")
  Interceptor awsSignatureVersion4(
      ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws,
      AWSCredentials.Provider credentials) {
    return new AWSSignatureVersion4(region(es, aws), ""es"", credentials);
  }
  @Bean String region(ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws) {
    List<String> hosts = es.getHosts();
    String domain = aws.getDomain();
    if (hosts != null && domain != null) {
      log.warning(
          format(""Expected exactly one of hosts or domain: instead saw hosts '%s' and domain '%s'.""
              + "" Ignoring hosts and proceeding to look for domain. Either unset ES_HOSTS or ""
              + ""ES_AWS_DOMAIN to suppress this message."", hosts, domain));
    }
    if (aws.getRegion() != null) {
      return aws.getRegion();
    } else if (domain != null) {
      return new DefaultAwsRegionProviderChain().getRegion();
    } else {
      String awsRegion = regionFromAwsUrls(hosts);
      checkArgument(awsRegion != null, ""Couldn't awsRegion in '%s'"", hosts);
      return awsRegion;
    }
  }
  @Bean
  @ConditionalOnMissingBean
  AWSCredentials.Provider credentials() {
    return new AWSCredentials.Provider() {
      AWSCredentialsProvider delegate = new DefaultAWSCredentialsProviderChain();
      @Override public AWSCredentials get() {
        com.amazonaws.auth.AWSCredentials result = delegate.getCredentials();
        String sessionToken = result instanceof AWSSessionCredentials
            ? ((AWSSessionCredentials) result).getSessionToken()
            : null;
        return new AWSCredentials(
            result.getAWSAccessKeyId(),
            result.getAWSSecretKey(),
            sessionToken
        );
      }
    };
  }
  @Bean
  @Conditional(AwsDomainSetCondition.class)
  StorageComponent storage(
      ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws,
      @Qualifier(""zipkinElasticsearchHttp"") OkHttpClient client,
      @Value(""${zipkin.storage.strict-trace-id:true}",method,
"    if (hosts != null && domain != null) {
      log.warning(
          format(""Expected exactly one of hosts or domain: instead saw hosts '%s' and domain '%s'.""
              + "" Ignoring hosts and proceeding to look for domain. Either unset ES_HOSTS or ""
              + ""ES_AWS_DOMAIN to suppress this message."", hosts, domain));
    }
    if (aws.getRegion() != null) {
      return aws.getRegion();
    } else if (domain != null) {
      return new DefaultAwsRegionProviderChain().getRegion();
    } else {
      String awsRegion = regionFromAwsUrls(hosts);
      checkArgument(awsRegion != null, ""Couldn't awsRegion in '%s'"", hosts);
      return awsRegion;
    }
  }
  @Bean
  @ConditionalOnMissingBean
  AWSCredentials.Provider credentials() {
    return new AWSCredentials.Provider() {
      AWSCredentialsProvider delegate = new DefaultAWSCredentialsProviderChain();
      @Override public AWSCredentials get() {
        com.amazonaws.auth.AWSCredentials result = delegate.getCredentials();
        String sessionToken = result instanceof AWSSessionCredentials
            ? ((AWSSessionCredentials) result).getSessionToken()
            : null;
        return new AWSCredentials(
            result.getAWSAccessKeyId(),
            result.getAWSSecretKey(),
            sessionToken
        );
      }
    };
  }
  @Bean
  @Conditional(AwsDomainSetCondition.class)
  StorageComponent storage(
      ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws,
      @Qualifier(""zipkinElasticsearchHttp"") OkHttpClient client,
      @Value(""${zipkin.storage.strict-trace-id:true}",method,
"  @Bean
  @ConditionalOnMissingBean
  AWSCredentials.Provider credentials() {
    return new AWSCredentials.Provider() {
      AWSCredentialsProvider delegate = new DefaultAWSCredentialsProviderChain();
      @Override public AWSCredentials get() {
        com.amazonaws.auth.AWSCredentials result = delegate.getCredentials();
        String sessionToken = result instanceof AWSSessionCredentials
            ? ((AWSSessionCredentials) result).getSessionToken()
            : null;
        return new AWSCredentials(
            result.getAWSAccessKeyId(),
            result.getAWSSecretKey(),
            sessionToken
        );
      }
    };
  }
  @Bean
  @Conditional(AwsDomainSetCondition.class)
  StorageComponent storage(
      ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws,
      @Qualifier(""zipkinElasticsearchHttp"") OkHttpClient client,
      @Value(""${zipkin.storage.strict-trace-id:true}",method,
"    return new AWSCredentials.Provider() {
      AWSCredentialsProvider delegate = new DefaultAWSCredentialsProviderChain();
      @Override public AWSCredentials get() {
        com.amazonaws.auth.AWSCredentials result = delegate.getCredentials();
        String sessionToken = result instanceof AWSSessionCredentials
            ? ((AWSSessionCredentials) result).getSessionToken()
            : null;
        return new AWSCredentials(
            result.getAWSAccessKeyId(),
            result.getAWSSecretKey(),
            sessionToken
        );
      }
    };
  }
  @Bean
  @Conditional(AwsDomainSetCondition.class)
  StorageComponent storage(
      ZipkinElasticsearchHttpStorageProperties es,
      ZipkinElasticsearchAwsStorageProperties aws,
      @Qualifier(""zipkinElasticsearchHttp"") OkHttpClient client,
      @Value(""${zipkin.storage.strict-trace-id:true}",method,
"    @Override
    public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata a) {
      String domain = context.getEnvironment().getProperty(PROPERTY_NAME);
      return domain == null || domain.isEmpty() ?
          ConditionOutcome.noMatch(PROPERTY_NAME + "" isn't set"") :
          ConditionOutcome.match();
    }",method,
"  static String regionFromAwsUrls(List<String> hosts) {
    String awsRegion = null;
    for (String url : hosts) {
      Matcher matcher = AWS_URL.matcher(url);
      if (matcher.find()) {
        String matched = matcher.group(1);
        checkArgument(awsRegion == null,
            ""too many regions: saw '%s' and '%s'"", awsRegion, matched);
        awsRegion = matcher.group(1);
      } else {
        checkArgument(awsRegion == null,
            ""mismatched regions; saw '%s' but no awsRegion found in '%s'"", awsRegion,
            url);
      }
    }
    return awsRegion;
  }",method,
"    for (String url : hosts) {
      Matcher matcher = AWS_URL.matcher(url);
      if (matcher.find()) {
        String matched = matcher.group(1);
        checkArgument(awsRegion == null,
            ""too many regions: saw '%s' and '%s'"", awsRegion, matched);
        awsRegion = matcher.group(1);
      } else {
        checkArgument(awsRegion == null,
            ""mismatched regions; saw '%s' but no awsRegion found in '%s'"", awsRegion,
            url);
      }
    }",method,
"  private static boolean isEmpty(String s) {
    return s == null || s.isEmpty();
  }",method,
"public class Location {
	private final Resource resource;
	@Nullable
	private final Object source;
	public Location(Resource resource) {
		this(resource, null);
	}
	public Location(Resource resource, @Nullable Object source) {
		Assert.notNull(resource, ""Resource must not be null"");
		this.resource = resource;
		this.source = source;
	}
	public Resource getResource() {
		return this.resource;
	}
	@Nullable
	public Object getSource() {
		return this.source;
	}
}",class,
"	public Location(Resource resource) {
		this(resource, null);
	}",method,
"	public Location(Resource resource, @Nullable Object source) {
		Assert.notNull(resource, ""Resource must not be null"");
		this.resource = resource;
		this.source = source;
	}",method,
"	public Resource getResource() {
		return this.resource;
	}",method,
"	@Nullable
	public Object getSource() {
		return this.source;
	}",method,
"public class OldCharArrayReaderTest extends junit.framework.TestCase {
    char[] hw = { 'H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd' };
    CharArrayReader cr;
    public void test_Constructor$C() {
        // Test for method java.io.CharArrayReader(char [])
        try {
            cr = new CharArrayReader(hw);
            assertTrue(""Failed to create reader"", cr.ready());
        } catch (IOException e) {
            fail(""Exception determining ready state : "" + e.getMessage());
        }
    }
    public void test_Constructor$CII() throws IOException {
        try {
            cr = new CharArrayReader(null, 0, 0);
            fail(""Test 1: NullPointerException expected."");
        } catch (NullPointerException e) {
            // Expected.
        }
        try {
            cr = new CharArrayReader(hw, -1, 0);
            fail(""Test 2: IllegalArgumentException expected."");
        } catch (IllegalArgumentException e) {
            // Expected.
        }
        try {
            cr = new CharArrayReader(hw, 0, -1);
            fail(""Test 3: IllegalArgumentException expected."");
        } catch (IllegalArgumentException e) {
            // Expected.
        }
        try {
            cr = new CharArrayReader(hw, hw.length + 1, 1);
            fail(""Test 4: IllegalArgumentException expected."");
        } catch (IllegalArgumentException e) {
            // Expected.
        }
        cr = new CharArrayReader(hw, 5, 5);
        assertTrue(""Test 5: Failed to create reader"", cr.ready());
        assertEquals(""Test 6: Incorrect character read;"",
                'W', cr.read());
    }
    public void test_close() {
        cr = new CharArrayReader(hw);
        cr.close();
        try {
            cr.read();
            fail(""Failed to throw exception on read from closed stream"");
        } catch (IOException e) {
            // Expected.
        }
    }
    public void test_markI() throws IOException {
        cr = new CharArrayReader(hw);
        cr.skip(5L);
        cr.mark(100);
        cr.read();
        cr.reset();
        assertEquals(""Test 1: Failed to mark correct position;"",
                'W', cr.read());
        cr.close();
        try {
            cr.mark(100);
            fail(""Test 2: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }
    public void test_markSupported() {
        cr = new CharArrayReader(hw);
        assertTrue(""markSupported returned false"", cr.markSupported());
    }
    public void test_read() throws IOException {
        cr = new CharArrayReader(hw);
        assertEquals(""Test 1: Read returned incorrect char;"",
                'H', cr.read());
        cr = new CharArrayReader(new char[] { '\u8765' });
        assertTrue(""Test 2: Incorrect double byte char;"",
                cr.read() == '\u8765');
        cr.close();
        try {
            cr.read();
            fail(""Test 3: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }
    public void test_read$CII() throws IOException {
        // Test for method int java.io.CharArrayReader.read(char [], int, int)
        char[] c = new char[11];
        cr = new CharArrayReader(hw);
        cr.read(c, 1, 10);
        assertTrue(""Test 1: Read returned incorrect chars."",
                new String(c, 1, 10).equals(new String(hw, 0, 10)));
        // Illegal argument checks.
        try {
            cr.read(null, 1, 0);
            fail(""Test 2: NullPointerException expected."");
        } catch (NullPointerException e) {
            // Expected.
        }
        try {
            cr.read(c , -1, 1);
            fail(""Test 3: ArrayIndexOutOfBoundsException expected."");
        } catch (IndexOutOfBoundsException e) {
            // Expected
        }
        try {
            cr.read(c , 1, -1);
            fail(""Test 4: ArrayIndexOutOfBoundsException expected."");
        } catch (IndexOutOfBoundsException e) {
            // Expected
        }
        try {
            cr.read(c, 1, c.length);
            fail(""Test 5: ArrayIndexOutOfBoundsException expected."");
        } catch (IndexOutOfBoundsException e) {
            // Expected
        }
        cr.close();
        try {
            cr.read(c, 1, 1);
            fail(""Test 6: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }
    public void test_ready() {
        // Test for method boolean java.io.CharArrayReader.ready()
        cr = new CharArrayReader(hw);
        boolean expectException = false;
        try {
            assertTrue(""ready returned false"", cr.ready());
            cr.skip(1000);
            assertTrue(""ready returned true"", !cr.ready());
            cr.close();
            expectException = true;
            cr.ready();
            fail(""No exception 1"");
        } catch (IOException e) {
            if (!expectException)
                fail(""Unexpected: "" + e);
        }
        try {
            cr = new CharArrayReader(hw);
            cr.close();
            cr.ready();
            fail(""No exception 2"");
        } catch (IOException e) {
        }
    }
    public void test_reset() throws IOException {
        cr = new CharArrayReader(hw);
        cr.skip(5L);
        cr.mark(100);
        cr.read();
        cr.reset();
        assertEquals(""Test 1: Reset failed to return to marker position."",
                'W', cr.read());
        cr.close();
        try {
            cr.reset();
            fail(""Test 2: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }
    public void test_skipJ() throws IOException {
        long skipped = 0;
        cr = new CharArrayReader(hw);
        skipped = cr.skip(5L);
        assertEquals(""Test 1: Failed to skip correct number of chars;"",
                5L, skipped);
        assertEquals(""Test 2: Skip skipped wrong chars;"",
                'W', cr.read());
        cr.close();
        try {
            cr.skip(1);
            fail(""Test 3: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }
    protected void tearDown() {
        if (cr != null)
            cr.close();
    }
}",class,
"    public void test_Constructor$C() {
        // Test for method java.io.CharArrayReader(char [])
        try {
            cr = new CharArrayReader(hw);
            assertTrue(""Failed to create reader"", cr.ready());
        } catch (IOException e) {
            fail(""Exception determining ready state : "" + e.getMessage());
        }
    }",method,
"    public void test_Constructor$CII() throws IOException {
        try {
            cr = new CharArrayReader(null, 0, 0);
            fail(""Test 1: NullPointerException expected."");
        } catch (NullPointerException e) {
            // Expected.
        }
        try {
            cr = new CharArrayReader(hw, -1, 0);
            fail(""Test 2: IllegalArgumentException expected."");
        } catch (IllegalArgumentException e) {
            // Expected.
        }
        try {
            cr = new CharArrayReader(hw, 0, -1);
            fail(""Test 3: IllegalArgumentException expected."");
        } catch (IllegalArgumentException e) {
            // Expected.
        }
        try {
            cr = new CharArrayReader(hw, hw.length + 1, 1);
            fail(""Test 4: IllegalArgumentException expected."");
        } catch (IllegalArgumentException e) {
            // Expected.
        }
        cr = new CharArrayReader(hw, 5, 5);
        assertTrue(""Test 5: Failed to create reader"", cr.ready());
        assertEquals(""Test 6: Incorrect character read;"",
                'W', cr.read());
    }",method,
"    public void test_close() {
        cr = new CharArrayReader(hw);
        cr.close();
        try {
            cr.read();
            fail(""Failed to throw exception on read from closed stream"");
        } catch (IOException e) {
            // Expected.
        }
    }",method,
"    public void test_markI() throws IOException {
        cr = new CharArrayReader(hw);
        cr.skip(5L);
        cr.mark(100);
        cr.read();
        cr.reset();
        assertEquals(""Test 1: Failed to mark correct position;"",
                'W', cr.read());
        cr.close();
        try {
            cr.mark(100);
            fail(""Test 2: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }",method,
"    public void test_markSupported() {
        cr = new CharArrayReader(hw);
        assertTrue(""markSupported returned false"", cr.markSupported());
    }",method,
"    public void test_read() throws IOException {
        cr = new CharArrayReader(hw);
        assertEquals(""Test 1: Read returned incorrect char;"",
                'H', cr.read());
        cr = new CharArrayReader(new char[] { '\u8765' });
        assertTrue(""Test 2: Incorrect double byte char;"",
                cr.read() == '\u8765');
        cr.close();
        try {
            cr.read();
            fail(""Test 3: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }",method,
"    public void test_read$CII() throws IOException {
        // Test for method int java.io.CharArrayReader.read(char [], int, int)
        char[] c = new char[11];
        cr = new CharArrayReader(hw);
        cr.read(c, 1, 10);
        assertTrue(""Test 1: Read returned incorrect chars."",
                new String(c, 1, 10).equals(new String(hw, 0, 10)));
        // Illegal argument checks.
        try {
            cr.read(null, 1, 0);
            fail(""Test 2: NullPointerException expected."");
        } catch (NullPointerException e) {
            // Expected.
        }
        try {
            cr.read(c , -1, 1);
            fail(""Test 3: ArrayIndexOutOfBoundsException expected."");
        } catch (IndexOutOfBoundsException e) {
            // Expected
        }
        try {
            cr.read(c , 1, -1);
            fail(""Test 4: ArrayIndexOutOfBoundsException expected."");
        } catch (IndexOutOfBoundsException e) {
            // Expected
        }
        try {
            cr.read(c, 1, c.length);
            fail(""Test 5: ArrayIndexOutOfBoundsException expected."");
        } catch (IndexOutOfBoundsException e) {
            // Expected
        }
        cr.close();
        try {
            cr.read(c, 1, 1);
            fail(""Test 6: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }",method,
"    public void test_ready() {
        // Test for method boolean java.io.CharArrayReader.ready()
        cr = new CharArrayReader(hw);
        boolean expectException = false;
        try {
            assertTrue(""ready returned false"", cr.ready());
            cr.skip(1000);
            assertTrue(""ready returned true"", !cr.ready());
            cr.close();
            expectException = true;
            cr.ready();
            fail(""No exception 1"");
        } catch (IOException e) {
            if (!expectException)
                fail(""Unexpected: "" + e);
        }
        try {
            cr = new CharArrayReader(hw);
            cr.close();
            cr.ready();
            fail(""No exception 2"");
        } catch (IOException e) {
        }
    }",method,
"    public void test_reset() throws IOException {
        cr = new CharArrayReader(hw);
        cr.skip(5L);
        cr.mark(100);
        cr.read();
        cr.reset();
        assertEquals(""Test 1: Reset failed to return to marker position."",
                'W', cr.read());
        cr.close();
        try {
            cr.reset();
            fail(""Test 2: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }",method,
"    public void test_skipJ() throws IOException {
        long skipped = 0;
        cr = new CharArrayReader(hw);
        skipped = cr.skip(5L);
        assertEquals(""Test 1: Failed to skip correct number of chars;"",
                5L, skipped);
        assertEquals(""Test 2: Skip skipped wrong chars;"",
                'W', cr.read());
        cr.close();
        try {
            cr.skip(1);
            fail(""Test 3: IOException expected."");
        } catch (IOException e) {
            // Expected.
        }
    }",method,
"    protected void tearDown() {
        if (cr != null)
            cr.close();
    }",method,
"public class DLQEntry implements Cloneable, Queueable {
    private final Event event;
    private final String pluginType;
    private final String pluginId;
    private final String reason;
    private final Timestamp entryTime;
    public DLQEntry(Event event, String pluginType, String pluginId, String reason) {
        this(event, pluginType, pluginId, reason, Timestamp.now());
    }
    public DLQEntry(Event event, String pluginType, String pluginId, String reason, Timestamp entryTime) {
        this.event = event;
        this.pluginType = pluginType;
        this.pluginId = pluginId;
        this.reason = reason;
        this.entryTime = entryTime;
    }
    @Override
    public byte[] serialize() throws IOException {
        byte[] entryTimeInBytes = entryTime.serialize();
        byte[] eventInBytes = this.event.serialize();
        byte[] pluginTypeBytes = pluginType.getBytes();
        byte[] pluginIdBytes = pluginId.getBytes();
        byte[] reasonBytes = reason.getBytes();
        ByteBuffer buffer = ByteBuffer.allocate(entryTimeInBytes.length
                + eventInBytes.length
                + pluginTypeBytes.length
                + pluginIdBytes.length
                + reasonBytes.length
                + (Integer.BYTES * 5)); // magic number represents the five byte[] + lengths
        putLengthAndBytes(buffer, entryTimeInBytes);
        putLengthAndBytes(buffer, eventInBytes);
        putLengthAndBytes(buffer, pluginTypeBytes);
        putLengthAndBytes(buffer, pluginIdBytes);
        putLengthAndBytes(buffer, reasonBytes);
        return buffer.array();
    }
    public static DLQEntry deserialize(byte[] bytes) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(bytes.length);
        buffer.put(bytes);
        buffer.position(0);
        Timestamp entryTime = new Timestamp(new String(getLengthPrefixedBytes(buffer)));
        Event event = Event.deserialize(getLengthPrefixedBytes(buffer));
        String pluginType = new String(getLengthPrefixedBytes(buffer));
        String pluginId = new String(getLengthPrefixedBytes(buffer));
        String reason = new String(getLengthPrefixedBytes(buffer));
        return new DLQEntry(event, pluginType, pluginId, reason, entryTime);
    }
    private static void putLengthAndBytes(ByteBuffer buffer, byte[] bytes) {
        buffer.putInt(bytes.length);
        buffer.put(bytes);
    }
    private static byte[] getLengthPrefixedBytes(ByteBuffer buffer) {
        int length = buffer.getInt();
        byte[] bytes = new byte[length];
        buffer.get(bytes);
        return bytes;
    }
    public Event getEvent() {
        return event;
    }
    public String getPluginType() {
        return pluginType;
    }
    public String getPluginId() {
        return pluginId;
    }
    public String getReason() {
        return reason;
    }
    public Timestamp getEntryTime() {
        return entryTime;
    }
    @Override
    public String toString() {
        return ""DLQEntry{"" +
                ""event="" + event +
                "", pluginType='"" + pluginType + '\'' +
                "", pluginId='"" + pluginId + '\'' +
                "", reason='"" + reason + '\'' +
                "", entryTime="" + entryTime +
                '}';
    }
}",class,
"    public DLQEntry(Event event, String pluginType, String pluginId, String reason) {
        this(event, pluginType, pluginId, reason, Timestamp.now());
    }",method,
"    public DLQEntry(Event event, String pluginType, String pluginId, String reason, Timestamp entryTime) {
        this.event = event;
        this.pluginType = pluginType;
        this.pluginId = pluginId;
        this.reason = reason;
        this.entryTime = entryTime;
    }",method,
"    @Override
    public byte[] serialize() throws IOException {
        byte[] entryTimeInBytes = entryTime.serialize();
        byte[] eventInBytes = this.event.serialize();
        byte[] pluginTypeBytes = pluginType.getBytes();
        byte[] pluginIdBytes = pluginId.getBytes();
        byte[] reasonBytes = reason.getBytes();
        ByteBuffer buffer = ByteBuffer.allocate(entryTimeInBytes.length
                + eventInBytes.length
                + pluginTypeBytes.length
                + pluginIdBytes.length
                + reasonBytes.length
                + (Integer.BYTES * 5)); // magic number represents the five byte[] + lengths
        putLengthAndBytes(buffer, entryTimeInBytes);
        putLengthAndBytes(buffer, eventInBytes);
        putLengthAndBytes(buffer, pluginTypeBytes);
        putLengthAndBytes(buffer, pluginIdBytes);
        putLengthAndBytes(buffer, reasonBytes);
        return buffer.array();
    }",method,
"    public static DLQEntry deserialize(byte[] bytes) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(bytes.length);
        buffer.put(bytes);
        buffer.position(0);
        Timestamp entryTime = new Timestamp(new String(getLengthPrefixedBytes(buffer)));
        Event event = Event.deserialize(getLengthPrefixedBytes(buffer));
        String pluginType = new String(getLengthPrefixedBytes(buffer));
        String pluginId = new String(getLengthPrefixedBytes(buffer));
        String reason = new String(getLengthPrefixedBytes(buffer));
        return new DLQEntry(event, pluginType, pluginId, reason, entryTime);
    }",method,
"    private static void putLengthAndBytes(ByteBuffer buffer, byte[] bytes) {
        buffer.putInt(bytes.length);
        buffer.put(bytes);
    }",method,
"    private static byte[] getLengthPrefixedBytes(ByteBuffer buffer) {
        int length = buffer.getInt();
        byte[] bytes = new byte[length];
        buffer.get(bytes);
        return bytes;
    }",method,
"    public Event getEvent() {
        return event;
    }",method,
"    public String getPluginType() {
        return pluginType;
    }",method,
"    public String getPluginId() {
        return pluginId;
    }",method,
"    public String getReason() {
        return reason;
    }",method,
"    public Timestamp getEntryTime() {
        return entryTime;
    }",method,
"    @Override
    public String toString() {
        return ""DLQEntry{"" +
                ""event="" + event +
                "", pluginType='"" + pluginType + '\'' +
                "", pluginId='"" + pluginId + '\'' +
                "", reason='"" + reason + '\'' +
                "", entryTime="" + entryTime +
                '}';
    }",method,
"public class SpecialNamesEntityDao extends AbstractDao<SpecialNamesEntity, Long> {
    public static final String TABLENAME = ""ORDER TRANSACTION GROUP BY"";
    public static class Properties {
        public final static Property Id = new Property(0, Long.class, ""id"", true, ""_id"");
        public final static Property Count = new Property(1, String.class, ""count"", false, ""COUNT"");
        public final static Property Select = new Property(2, String.class, ""select"", false, ""SELECT"");
        public final static Property Sum = new Property(3, String.class, ""sum"", false, ""SUM"");
        public final static Property Avg = new Property(4, String.class, ""avg"", false, ""AVG"");
        public final static Property Join = new Property(5, String.class, ""join"", false, ""JOIN"");
        public final static Property Distinct = new Property(6, String.class, ""distinct"", false, ""DISTINCT"");
        public final static Property On = new Property(7, String.class, ""on"", false, ""ON"");
        public final static Property Index = new Property(8, String.class, ""index"", false, ""INDEX"");
        public final static Property Order = new Property(9, Integer.class, ""order"", false, ""ORDER"");
    }
    public SpecialNamesEntityDao(DaoConfig config) {
        super(config);
    }
    public SpecialNamesEntityDao(DaoConfig config, DaoSession daoSession) {
        super(config, daoSession);
    }
    public static void createTable(Database db, boolean ifNotExists) {
        String constraint = ifNotExists? ""IF NOT EXISTS "": """";
        db.execSQL(""CREATE TABLE "" + constraint + ""\""ORDER TRANSACTION GROUP BY\"" ("" + //
                ""\""_id\"" INTEGER PRIMARY KEY ,"" + // 0: id
                ""\""COUNT\"" TEXT,"" + // 1: count
                ""\""SELECT\"" TEXT,"" + // 2: select
                ""\""SUM\"" TEXT,"" + // 3: sum
                ""\""AVG\"" TEXT,"" + // 4: avg
                ""\""JOIN\"" TEXT,"" + // 5: join
                ""\""DISTINCT\"" TEXT,"" + // 6: distinct
                ""\""ON\"" TEXT,"" + // 7: on
                ""\""INDEX\"" TEXT,"" + // 8: index
                ""\""ORDER\"" INTEGER);""); // 9: order
    }
    public static void dropTable(Database db, boolean ifExists) {
        String sql = ""DROP TABLE "" + (ifExists ? ""IF EXISTS "" : """") + ""\""ORDER TRANSACTION GROUP BY\"""";
        db.execSQL(sql);
    }
    @Override
    protected final void bindValues(DatabaseStatement stmt, SpecialNamesEntity entity) {
        stmt.clearBindings();
        Long id = entity.getId();
        if (id != null) {
            stmt.bindLong(1, id);
        }
        String count = entity.getCount();
        if (count != null) {
            stmt.bindString(2, count);
        }
        String select = entity.getSelect();
        if (select != null) {
            stmt.bindString(3, select);
        }
        String sum = entity.getSum();
        if (sum != null) {
            stmt.bindString(4, sum);
        }
        String avg = entity.getAvg();
        if (avg != null) {
            stmt.bindString(5, avg);
        }
        String join = entity.getJoin();
        if (join != null) {
            stmt.bindString(6, join);
        }
        String distinct = entity.getDistinct();
        if (distinct != null) {
            stmt.bindString(7, distinct);
        }
        String on = entity.getOn();
        if (on != null) {
            stmt.bindString(8, on);
        }
        String index = entity.getIndex();
        if (index != null) {
            stmt.bindString(9, index);
        }
        Integer order = entity.getOrder();
        if (order != null) {
            stmt.bindLong(10, order);
        }
    }
    @Override
    protected final void bindValues(SQLiteStatement stmt, SpecialNamesEntity entity) {
        stmt.clearBindings();
        Long id = entity.getId();
        if (id != null) {
            stmt.bindLong(1, id);
        }
        String count = entity.getCount();
        if (count != null) {
            stmt.bindString(2, count);
        }
        String select = entity.getSelect();
        if (select != null) {
            stmt.bindString(3, select);
        }
        String sum = entity.getSum();
        if (sum != null) {
            stmt.bindString(4, sum);
        }
        String avg = entity.getAvg();
        if (avg != null) {
            stmt.bindString(5, avg);
        }
        String join = entity.getJoin();
        if (join != null) {
            stmt.bindString(6, join);
        }
        String distinct = entity.getDistinct();
        if (distinct != null) {
            stmt.bindString(7, distinct);
        }
        String on = entity.getOn();
        if (on != null) {
            stmt.bindString(8, on);
        }
        String index = entity.getIndex();
        if (index != null) {
            stmt.bindString(9, index);
        }
        Integer order = entity.getOrder();
        if (order != null) {
            stmt.bindLong(10, order);
        }
    }
    @Override
    public Long readKey(Cursor cursor, int offset) {
        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
    }    
    @Override
    public SpecialNamesEntity readEntity(Cursor cursor, int offset) {
        SpecialNamesEntity entity = new SpecialNamesEntity( //
            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // count
            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // select
            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3), // sum
            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // avg
            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // join
            cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // distinct
            cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7), // on
            cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8), // index
            cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9) // order
        );
        return entity;
    }
    @Override
    public void readEntity(Cursor cursor, SpecialNamesEntity entity, int offset) {
        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
        entity.setCount(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
        entity.setSelect(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
        entity.setSum(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
        entity.setAvg(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
        entity.setJoin(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
        entity.setDistinct(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
        entity.setOn(cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7));
        entity.setIndex(cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8));
        entity.setOrder(cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9));
     }
    @Override
    protected final Long updateKeyAfterInsert(SpecialNamesEntity entity, long rowId) {
        entity.setId(rowId);
        return rowId;
    }
    @Override
    public Long getKey(SpecialNamesEntity entity) {
        if(entity != null) {
            return entity.getId();
        } else {
            return null;
        }
    }
    @Override
    public boolean hasKey(SpecialNamesEntity entity) {
        return entity.getId() != null;
    }
    @Override
    protected final boolean isEntityUpdateable() {
        return true;
    }
}",class,
"    public static class Properties {
        public final static Property Id = new Property(0, Long.class, ""id"", true, ""_id"");
        public final static Property Count = new Property(1, String.class, ""count"", false, ""COUNT"");
        public final static Property Select = new Property(2, String.class, ""select"", false, ""SELECT"");
        public final static Property Sum = new Property(3, String.class, ""sum"", false, ""SUM"");
        public final static Property Avg = new Property(4, String.class, ""avg"", false, ""AVG"");
        public final static Property Join = new Property(5, String.class, ""join"", false, ""JOIN"");
        public final static Property Distinct = new Property(6, String.class, ""distinct"", false, ""DISTINCT"");
        public final static Property On = new Property(7, String.class, ""on"", false, ""ON"");
        public final static Property Index = new Property(8, String.class, ""index"", false, ""INDEX"");
        public final static Property Order = new Property(9, Integer.class, ""order"", false, ""ORDER"");
    }",class,
"    public SpecialNamesEntityDao(DaoConfig config) {
        super(config);
    }",method,
"    public SpecialNamesEntityDao(DaoConfig config, DaoSession daoSession) {
        super(config, daoSession);
    }",method,
"    public static void createTable(Database db, boolean ifNotExists) {
        String constraint = ifNotExists? ""IF NOT EXISTS "": """";
        db.execSQL(""CREATE TABLE "" + constraint + ""\""ORDER TRANSACTION GROUP BY\"" ("" + //
                ""\""_id\"" INTEGER PRIMARY KEY ,"" + // 0: id
                ""\""COUNT\"" TEXT,"" + // 1: count
                ""\""SELECT\"" TEXT,"" + // 2: select
                ""\""SUM\"" TEXT,"" + // 3: sum
                ""\""AVG\"" TEXT,"" + // 4: avg
                ""\""JOIN\"" TEXT,"" + // 5: join
                ""\""DISTINCT\"" TEXT,"" + // 6: distinct
                ""\""ON\"" TEXT,"" + // 7: on
                ""\""INDEX\"" TEXT,"" + // 8: index
                ""\""ORDER\"" INTEGER);""); // 9: order
    }",method,
"    public static void dropTable(Database db, boolean ifExists) {
        String sql = ""DROP TABLE "" + (ifExists ? ""IF EXISTS "" : """") + ""\""ORDER TRANSACTION GROUP BY\"""";
        db.execSQL(sql);
    }",method,
"    @Override
    protected final void bindValues(DatabaseStatement stmt, SpecialNamesEntity entity) {
        stmt.clearBindings();
        Long id = entity.getId();
        if (id != null) {
            stmt.bindLong(1, id);
        }
        String count = entity.getCount();
        if (count != null) {
            stmt.bindString(2, count);
        }
        String select = entity.getSelect();
        if (select != null) {
            stmt.bindString(3, select);
        }
        String sum = entity.getSum();
        if (sum != null) {
            stmt.bindString(4, sum);
        }
        String avg = entity.getAvg();
        if (avg != null) {
            stmt.bindString(5, avg);
        }
        String join = entity.getJoin();
        if (join != null) {
            stmt.bindString(6, join);
        }
        String distinct = entity.getDistinct();
        if (distinct != null) {
            stmt.bindString(7, distinct);
        }
        String on = entity.getOn();
        if (on != null) {
            stmt.bindString(8, on);
        }
        String index = entity.getIndex();
        if (index != null) {
            stmt.bindString(9, index);
        }
        Integer order = entity.getOrder();
        if (order != null) {
            stmt.bindLong(10, order);
        }
    }",method,
"        if (id != null) {
            stmt.bindLong(1, id);
        }",method,
"        if (count != null) {
            stmt.bindString(2, count);
        }",method,
"        if (select != null) {
            stmt.bindString(3, select);
        }",method,
"        if (sum != null) {
            stmt.bindString(4, sum);
        }",method,
"        if (avg != null) {
            stmt.bindString(5, avg);
        }",method,
"        if (join != null) {
            stmt.bindString(6, join);
        }",method,
"        if (distinct != null) {
            stmt.bindString(7, distinct);
        }",method,
"        if (on != null) {
            stmt.bindString(8, on);
        }",method,
"        if (index != null) {
            stmt.bindString(9, index);
        }",method,
"        if (order != null) {
            stmt.bindLong(10, order);
        }",method,
"    @Override
    protected final void bindValues(SQLiteStatement stmt, SpecialNamesEntity entity) {
        stmt.clearBindings();
        Long id = entity.getId();
        if (id != null) {
            stmt.bindLong(1, id);
        }
        String count = entity.getCount();
        if (count != null) {
            stmt.bindString(2, count);
        }
        String select = entity.getSelect();
        if (select != null) {
            stmt.bindString(3, select);
        }
        String sum = entity.getSum();
        if (sum != null) {
            stmt.bindString(4, sum);
        }
        String avg = entity.getAvg();
        if (avg != null) {
            stmt.bindString(5, avg);
        }
        String join = entity.getJoin();
        if (join != null) {
            stmt.bindString(6, join);
        }
        String distinct = entity.getDistinct();
        if (distinct != null) {
            stmt.bindString(7, distinct);
        }
        String on = entity.getOn();
        if (on != null) {
            stmt.bindString(8, on);
        }
        String index = entity.getIndex();
        if (index != null) {
            stmt.bindString(9, index);
        }
        Integer order = entity.getOrder();
        if (order != null) {
            stmt.bindLong(10, order);
        }
    }",method,
"        if (id != null) {
            stmt.bindLong(1, id);
        }",method,
"        if (count != null) {
            stmt.bindString(2, count);
        }",method,
"        if (select != null) {
            stmt.bindString(3, select);
        }",method,
"        if (sum != null) {
            stmt.bindString(4, sum);
        }",method,
"        if (avg != null) {
            stmt.bindString(5, avg);
        }",method,
"        if (join != null) {
            stmt.bindString(6, join);
        }",method,
"        if (distinct != null) {
            stmt.bindString(7, distinct);
        }",method,
"        if (on != null) {
            stmt.bindString(8, on);
        }",method,
"        if (index != null) {
            stmt.bindString(9, index);
        }",method,
"        if (order != null) {
            stmt.bindLong(10, order);
        }",method,
"    @Override
    public Long readKey(Cursor cursor, int offset) {
        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
    }",method,
"    @Override
    public SpecialNamesEntity readEntity(Cursor cursor, int offset) {
        SpecialNamesEntity entity = new SpecialNamesEntity( //
            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // count
            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // select
            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3), // sum
            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // avg
            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // join
            cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // distinct
            cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7), // on
            cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8), // index
            cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9) // order
        );
        return entity;
    }",method,
"    @Override
    public void readEntity(Cursor cursor, SpecialNamesEntity entity, int offset) {
        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
        entity.setCount(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
        entity.setSelect(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
        entity.setSum(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
        entity.setAvg(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
        entity.setJoin(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
        entity.setDistinct(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
        entity.setOn(cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7));
        entity.setIndex(cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8));
        entity.setOrder(cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9));
     }",method,
"    @Override
    protected final Long updateKeyAfterInsert(SpecialNamesEntity entity, long rowId) {
        entity.setId(rowId);
        return rowId;
    }",method,
"    @Override
    public Long getKey(SpecialNamesEntity entity) {
        if(entity != null) {
            return entity.getId();
        } else {
            return null;
        }
    }",method,
"        if(entity != null) {
            return entity.getId();
        }",method,
"    @Override
    public boolean hasKey(SpecialNamesEntity entity) {
        return entity.getId() != null;
    }",method,
"    @Override
    protected final boolean isEntityUpdateable() {
        return true;
    }",method,
"public class JavacTransitive {
  private final ImmutableSet<String> platformJars;
  public JavacTransitive(ImmutableSet<String> platformJars) {
    this.platformJars = platformJars;
  }
  private final Set<ClassSymbol> closure = new LinkedHashSet<>();
  private Map<String, byte[]> transitive = new LinkedHashMap<>();
  public Map<String, byte[]> collectTransitiveDependencies() {
    Map<String, byte[]> result = transitive;
    transitive = new LinkedHashMap<>();
    return result;
  }
  public void postAttribute(Env<AttrContext> result) {
    result.toplevel.accept(
        new TreeScanner() {
          @Override
          public void visitClassDef(JCClassDecl tree) {
            recordSuperClosure(tree.sym);
            super.visitClassDef(tree);
          }
        });
  }
  public void finish() {
    Set<ClassSymbol> directChildren = new LinkedHashSet<>();
    for (ClassSymbol sym : closure) {
      for (Symbol member : sym.getEnclosedElements()) {
        if (member instanceof ClassSymbol) {
          directChildren.add((ClassSymbol) member);
        }
      }
    }
    closure.addAll(directChildren);
    for (ClassSymbol sym : closure) {
      String name = sym.flatName().toString().replace('.', '/');
      if (transitive.containsKey(name)) {
        continue;
      }
      if (StrictJavaDepsPlugin.getJarName(sym, platformJars) == null) {
        // Don't repackage symbols we wouldn't report in jdeps, e.g. because they're on the
        // bootclasspath.
        continue;
      }
      JavaFileObject jfo = sym.classfile;
      if (jfo == null || jfo.getKind() != Kind.CLASS) {
        continue;
      }
      ClassFile cf;
      try {
        cf = ClassReader.read(ByteStreams.toByteArray(jfo.openInputStream()));
      } catch (IOException e) {
        throw new IOError(e);
      }
      transitive.put(name, ClassWriter.writeClass(Transitive.trimClass(cf)));
    }
    closure.clear();
  }
  private void recordSuperClosure(Symbol bound) {
    if (!(bound instanceof ClassSymbol)) {
      return;
    }
    ClassSymbol info = (ClassSymbol) bound;
    closure.add(info);
    recordSuperClosure(info.getSuperclass().asElement());
    for (Type i : info.getInterfaces()) {
      recordSuperClosure(i.asElement());
    }
  }
}",class,
"  public JavacTransitive(ImmutableSet<String> platformJars) {
    this.platformJars = platformJars;
  }",method,
"  public Map<String, byte[]> collectTransitiveDependencies() {
    Map<String, byte[]> result = transitive;
    transitive = new LinkedHashMap<>();
    return result;
  }",method,
"  public void postAttribute(Env<AttrContext> result) {
    result.toplevel.accept(
        new TreeScanner() {
          @Override
          public void visitClassDef(JCClassDecl tree) {
            recordSuperClosure(tree.sym);
            super.visitClassDef(tree);
          }
        });
  }",method,
"    result.toplevel.accept(
        new TreeScanner() {
          @Override
          public void visitClassDef(JCClassDecl tree) {
            recordSuperClosure(tree.sym);
            super.visitClassDef(tree);
          }
        }",method,

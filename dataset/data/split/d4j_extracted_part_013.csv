code_snippet,type,score
"			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) {
					if (i == j || (j + 1) % n == i) continue;
					int i1 = (i - 1 + n) % n;
					int j1 = (j + 1) % n;
					double delta = dist(x[res[i1]], y[res[i1]], x[res[j]], y[res[j]])
							+ dist(x[res[i]], y[res[i]], x[res[j1]], y[res[j1]])
							- dist(x[res[i1]], y[res[i1]], x[res[i]], y[res[i]])
							- dist(x[res[j]], y[res[j]], x[res[j1]], y[res[j1]]);
					if (delta < -1e-9) {
						reverse(res, i, j);
						improved = true;
					}
				}
			}",method,
"				for (int j = 0; j < n; j++) {
					if (i == j || (j + 1) % n == i) continue;
					int i1 = (i - 1 + n) % n;
					int j1 = (j + 1) % n;
					double delta = dist(x[res[i1]], y[res[i1]], x[res[j]], y[res[j]])
							+ dist(x[res[i]], y[res[i]], x[res[j1]], y[res[j1]])
							- dist(x[res[i1]], y[res[i1]], x[res[i]], y[res[i]])
							- dist(x[res[j]], y[res[j]], x[res[j1]], y[res[j1]]);
					if (delta < -1e-9) {
						reverse(res, i, j);
						improved = true;
					}
				}",method,
"					if (delta < -1e-9) {
						reverse(res, i, j);
						improved = true;
					}",method,
"		public Chromosome(int[] p) {
			this.p = p;
		}",method,
"		public double getCost() {
			return Double.isNaN(cost) ? cost = eval(p) : cost;
		}",method,
"		@Override
		public int compareTo(Chromosome o) {
			return Double.compare(getCost(), o.getCost());
		}",method,
"		public Population(int populationLimit) {
			this.populationLimit = populationLimit;
		}",method,
"		public void nextGeneration() {
			Collections.sort(chromosomes);
			chromosomes = new ArrayList<>(chromosomes.subList(0, (chromosomes.size() + 1) / 2));
		}",method,
"	public GeneticAlgorithm() {
		setContentPane(new JPanel() {
			protected void paintComponent(Graphics g) {
				super.paintComponent(g);
				((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
				((Graphics2D) g).setStroke(new BasicStroke(3));
				g.setColor(Color.BLUE);
				int w = getWidth() - 5;
				int h = getHeight() - 30;
				for (int i = 0, j = n - 1; i < n; j = i++)
					g.drawLine((int) (x[bestState[i]] * w), (int) ((1 - y[bestState[i]]) * h),
							(int) (x[bestState[j]] * w), (int) ((1 - y[bestState[j]]) * h));
				g.setColor(Color.RED);
				for (int i = 0; i < n; i++)
					g.drawOval((int) (x[i] * w) - 1, (int) ((1 - y[i]) * h) - 1, 3, 3);
				g.setColor(Color.BLACK);
				g.drawString(String.format(""length: %.3f"", eval(bestState)), 5, h + 20);
				g.drawString(String.format(""generation: %d"", generation), 150, h + 20);
			}
		});
		setSize(new Dimension(600, 600));
		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
		setVisible(true);
		new Thread(this::geneticAlgorithm).start();
	}",method,
"		setContentPane(new JPanel() {
			protected void paintComponent(Graphics g) {
				super.paintComponent(g);
				((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
				((Graphics2D) g).setStroke(new BasicStroke(3));
				g.setColor(Color.BLUE);
				int w = getWidth() - 5;
				int h = getHeight() - 30;
				for (int i = 0, j = n - 1; i < n; j = i++)
					g.drawLine((int) (x[bestState[i]] * w), (int) ((1 - y[bestState[i]]) * h),
							(int) (x[bestState[j]] * w), (int) ((1 - y[bestState[j]]) * h));
				g.setColor(Color.RED);
				for (int i = 0; i < n; i++)
					g.drawOval((int) (x[i] * w) - 1, (int) ((1 - y[i]) * h) - 1, 3, 3);
				g.setColor(Color.BLACK);
				g.drawString(String.format(""length: %.3f"", eval(bestState)), 5, h + 20);
				g.drawString(String.format(""generation: %d"", generation), 150, h + 20);
			}
		}",method,
"			protected void paintComponent(Graphics g) {
				super.paintComponent(g);
				((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
				((Graphics2D) g).setStroke(new BasicStroke(3));
				g.setColor(Color.BLUE);
				int w = getWidth() - 5;
				int h = getHeight() - 30;
				for (int i = 0, j = n - 1; i < n; j = i++)
					g.drawLine((int) (x[bestState[i]] * w), (int) ((1 - y[bestState[i]]) * h),
							(int) (x[bestState[j]] * w), (int) ((1 - y[bestState[j]]) * h));
				g.setColor(Color.RED);
				for (int i = 0; i < n; i++)
					g.drawOval((int) (x[i] * w) - 1, (int) ((1 - y[i]) * h) - 1, 3, 3);
				g.setColor(Color.BLACK);
				g.drawString(String.format(""length: %.3f"", eval(bestState)), 5, h + 20);
				g.drawString(String.format(""generation: %d"", generation), 150, h + 20);
			}",method,
"	public static void main(String[] args) {
		new GeneticAlgorithm();
	}",method,
"public class ReachableCodeMarker
extends      SimplifiedVisitor
implements   AttributeVisitor,
             InstructionVisitor,
             ExceptionInfoVisitor
{
    private boolean[] isReachable = new boolean[ClassConstants.TYPICAL_CODE_LENGTH];
    private boolean next;
    private boolean evaluateExceptions;
    public boolean isReachable(int offset)
    {
        return isReachable[offset];
    }
    public boolean isReachable(int startOffset, int endOffset)
    {
        // Check if any of the instructions is reachable.
        for (int offset = startOffset; offset < endOffset; offset++)
        {
            if (isReachable[offset])
            {
                return true;
            }
        }
        return false;
    }
    // Implementations for AttributeVisitor.
    public void visitAnyAttribute(Clazz clazz, Attribute attribute) {}
    public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
        // Make sure there is a sufficiently large array.
        int codeLength = codeAttribute.u4codeLength;
        if (isReachable.length < codeLength)
        {
            // Create a new array.
            isReachable = new boolean[codeLength];
        }
        else
        {
            // Reset the array.
            Arrays.fill(isReachable, 0, codeLength, false);
        }
        // Mark the code, starting at the entry point.
        markCode(clazz, method, codeAttribute, 0);
        // Mark the exception handlers, iterating as long as necessary.
        do
        {
            evaluateExceptions = false;
            codeAttribute.exceptionsAccept(clazz, method, this);
        }
        while (evaluateExceptions);
    }
    // Implementations for InstructionVisitor.
    public void visitSimpleInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SimpleInstruction simpleInstruction)
    {
        byte opcode = simpleInstruction.opcode;
        if (opcode == InstructionConstants.OP_IRETURN ||
            opcode == InstructionConstants.OP_LRETURN ||
            opcode == InstructionConstants.OP_FRETURN ||
            opcode == InstructionConstants.OP_DRETURN ||
            opcode == InstructionConstants.OP_ARETURN ||
            opcode == InstructionConstants.OP_RETURN  ||
            opcode == InstructionConstants.OP_ATHROW)
        {
            next = false;
        }
    }
    public void visitConstantInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, ConstantInstruction constantInstruction)
    {
    }
    public void visitVariableInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, VariableInstruction variableInstruction)
    {
        if (variableInstruction.opcode == InstructionConstants.OP_RET)
        {
            next = false;
        }
    }
    public void visitBranchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, BranchInstruction branchInstruction)
    {
        // Mark the branch target.
        markBranchTarget(clazz,
                         method,
                         codeAttribute,
                         offset + branchInstruction.branchOffset);
        byte opcode = branchInstruction.opcode;
        if (opcode == InstructionConstants.OP_GOTO ||
            opcode == InstructionConstants.OP_GOTO_W)
        {
            next = false;
        }
    }
    public void visitAnySwitchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SwitchInstruction switchInstruction)
    {
        // Mark the branch targets of the default jump offset.
        markBranchTarget(clazz,
                         method,
                         codeAttribute,
                         offset + switchInstruction.defaultOffset);
        // Mark the branch targets of the jump offsets.
        markBranchTargets(clazz,
                          method,
                          codeAttribute,
                          offset,
                          switchInstruction.jumpOffsets);
        next = false;
    }
    // Implementations for ExceptionInfoVisitor.
    public void visitExceptionInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, ExceptionInfo exceptionInfo)
    {
        // Mark the exception handler if it's relevant.
        if (!isReachable(exceptionInfo.u2handlerPC) &&
            isReachable(exceptionInfo.u2startPC, exceptionInfo.u2endPC))
        {
            markCode(clazz, method, codeAttribute, exceptionInfo.u2handlerPC);
            evaluateExceptions = true;
        }
    }
    // Small utility methods.
    private void markBranchTargets(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, int[] jumpOffsets)
    {
        for (int index = 0; index < jumpOffsets.length; index++)
        {
            markCode(clazz, method, codeAttribute, offset + jumpOffsets[index]);
        }
    }
    private void markBranchTarget(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset)
    {
        boolean oldNext = next;
        markCode(clazz, method, codeAttribute, offset);
        next = oldNext;
    }
    private void markCode(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset)
    {
        boolean oldNext = next;
        byte[] code = codeAttribute.code;
        // Continue with the current instruction as long as we haven't marked it
        // yet.
        while (!isReachable[offset])
        {
            // Get the current instruction.
            Instruction instruction = InstructionFactory.create(code, offset);
            // Mark it as reachable.
            isReachable[offset] = true;
            // By default, we'll assume we can continue with the next
            // instruction in a moment.
            next = true;
            // Mark the branch targets, if any.
            instruction.accept(clazz, method, codeAttribute, offset, this);
            // Can we really continue with the next instruction?
            if (!next)
            {
                break;
            }
            // Go to the next instruction.
            offset += instruction.length(offset);
        }
        next = oldNext;
    }
}",class,
"    public boolean isReachable(int offset)
    {
        return isReachable[offset];
    }",method,
"    public boolean isReachable(int startOffset, int endOffset)
    {
        // Check if any of the instructions is reachable.
        for (int offset = startOffset; offset < endOffset; offset++)
        {
            if (isReachable[offset])
            {
                return true;
            }
        }
        return false;
    }",method,
"        for (int offset = startOffset; offset < endOffset; offset++)
        {
            if (isReachable[offset])
            {
                return true;
            }
        }",method,
"            if (isReachable[offset])
            {
                return true;
            }",method,
"    public void visitAnyAttribute(Clazz clazz, Attribute attribute) {}",method,
"    public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
        // Make sure there is a sufficiently large array.
        int codeLength = codeAttribute.u4codeLength;
        if (isReachable.length < codeLength)
        {
            // Create a new array.
            isReachable = new boolean[codeLength];
        }
        else
        {
            // Reset the array.
            Arrays.fill(isReachable, 0, codeLength, false);
        }
        // Mark the code, starting at the entry point.
        markCode(clazz, method, codeAttribute, 0);
        // Mark the exception handlers, iterating as long as necessary.
        do
        {
            evaluateExceptions = false;
            codeAttribute.exceptionsAccept(clazz, method, this);
        }
        while (evaluateExceptions);
    }",method,
"        if (isReachable.length < codeLength)
        {
            // Create a new array.
            isReachable = new boolean[codeLength];
        }",method,
"    public void visitSimpleInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SimpleInstruction simpleInstruction)
    {
        byte opcode = simpleInstruction.opcode;
        if (opcode == InstructionConstants.OP_IRETURN ||
            opcode == InstructionConstants.OP_LRETURN ||
            opcode == InstructionConstants.OP_FRETURN ||
            opcode == InstructionConstants.OP_DRETURN ||
            opcode == InstructionConstants.OP_ARETURN ||
            opcode == InstructionConstants.OP_RETURN  ||
            opcode == InstructionConstants.OP_ATHROW)
        {
            next = false;
        }
    }",method,
"        if (opcode == InstructionConstants.OP_IRETURN ||
            opcode == InstructionConstants.OP_LRETURN ||
            opcode == InstructionConstants.OP_FRETURN ||
            opcode == InstructionConstants.OP_DRETURN ||
            opcode == InstructionConstants.OP_ARETURN ||
            opcode == InstructionConstants.OP_RETURN  ||
            opcode == InstructionConstants.OP_ATHROW)
        {
            next = false;
        }",method,
"    public void visitConstantInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, ConstantInstruction constantInstruction)
    {
    }",method,
"    public void visitVariableInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, VariableInstruction variableInstruction)
    {
        if (variableInstruction.opcode == InstructionConstants.OP_RET)
        {
            next = false;
        }
    }",method,
"        if (variableInstruction.opcode == InstructionConstants.OP_RET)
        {
            next = false;
        }",method,
"    public void visitBranchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, BranchInstruction branchInstruction)
    {
        // Mark the branch target.
        markBranchTarget(clazz,
                         method,
                         codeAttribute,
                         offset + branchInstruction.branchOffset);
        byte opcode = branchInstruction.opcode;
        if (opcode == InstructionConstants.OP_GOTO ||
            opcode == InstructionConstants.OP_GOTO_W)
        {
            next = false;
        }
    }",method,
"        if (opcode == InstructionConstants.OP_GOTO ||
            opcode == InstructionConstants.OP_GOTO_W)
        {
            next = false;
        }",method,
"    public void visitAnySwitchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SwitchInstruction switchInstruction)
    {
        // Mark the branch targets of the default jump offset.
        markBranchTarget(clazz,
                         method,
                         codeAttribute,
                         offset + switchInstruction.defaultOffset);
        // Mark the branch targets of the jump offsets.
        markBranchTargets(clazz,
                          method,
                          codeAttribute,
                          offset,
                          switchInstruction.jumpOffsets);
        next = false;
    }",method,
"    public void visitExceptionInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, ExceptionInfo exceptionInfo)
    {
        // Mark the exception handler if it's relevant.
        if (!isReachable(exceptionInfo.u2handlerPC) &&
            isReachable(exceptionInfo.u2startPC, exceptionInfo.u2endPC))
        {
            markCode(clazz, method, codeAttribute, exceptionInfo.u2handlerPC);
            evaluateExceptions = true;
        }
    }",method,
"    private void markBranchTargets(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, int[] jumpOffsets)
    {
        for (int index = 0; index < jumpOffsets.length; index++)
        {
            markCode(clazz, method, codeAttribute, offset + jumpOffsets[index]);
        }
    }",method,
"        for (int index = 0; index < jumpOffsets.length; index++)
        {
            markCode(clazz, method, codeAttribute, offset + jumpOffsets[index]);
        }",method,
"    private void markBranchTarget(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset)
    {
        boolean oldNext = next;
        markCode(clazz, method, codeAttribute, offset);
        next = oldNext;
    }",method,
"    private void markCode(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset)
    {
        boolean oldNext = next;
        byte[] code = codeAttribute.code;
        // Continue with the current instruction as long as we haven't marked it
        // yet.
        while (!isReachable[offset])
        {
            // Get the current instruction.
            Instruction instruction = InstructionFactory.create(code, offset);
            // Mark it as reachable.
            isReachable[offset] = true;
            // By default, we'll assume we can continue with the next
            // instruction in a moment.
            next = true;
            // Mark the branch targets, if any.
            instruction.accept(clazz, method, codeAttribute, offset, this);
            // Can we really continue with the next instruction?
            if (!next)
            {
                break;
            }
            // Go to the next instruction.
            offset += instruction.length(offset);
        }
        next = oldNext;
    }",method,
"        while (!isReachable[offset])
        {
            // Get the current instruction.
            Instruction instruction = InstructionFactory.create(code, offset);
            // Mark it as reachable.
            isReachable[offset] = true;
            // By default, we'll assume we can continue with the next
            // instruction in a moment.
            next = true;
            // Mark the branch targets, if any.
            instruction.accept(clazz, method, codeAttribute, offset, this);
            // Can we really continue with the next instruction?
            if (!next)
            {
                break;
            }
            // Go to the next instruction.
            offset += instruction.length(offset);
        }",method,
"            if (!next)
            {
                break;
            }",method,
"public abstract class LazyDelegateLexer extends LexerBase {
  public static final EmptyLexer EMPTY_LEXER = new EmptyLexer();
  private Lexer myDelegate = EMPTY_LEXER;
  protected abstract Lexer createDelegate();
  @Override
  public void start(@NotNull CharSequence buffer, int startOffset, int endOffset, int initialState) {
    if (myDelegate == EMPTY_LEXER) {
      myDelegate = createDelegate();
    }
    myDelegate.start(buffer, startOffset, endOffset, initialState);
  }
  @Override
  @NotNull
  public CharSequence getTokenSequence() {
    return myDelegate.getTokenSequence();
  }
  @Override
  @NotNull
  public String getTokenText() {
    return myDelegate.getTokenText();
  }
  @Override
  public int getState() {
    return myDelegate.getState();
  }
  @Override
  @Nullable
  public IElementType getTokenType() {
    return myDelegate.getTokenType();
  }
  @Override
  public int getTokenStart() {
    return myDelegate.getTokenStart();
  }
  @Override
  public int getTokenEnd() {
    return myDelegate.getTokenEnd();
  }
  @Override
  public void advance() {
    myDelegate.advance();
  }
  @Override
  @NotNull
  public LexerPosition getCurrentPosition() {
    return myDelegate.getCurrentPosition();
  }
  @Override
  public void restore(@NotNull LexerPosition position) {
    myDelegate.restore(position);
  }
  @Override
  @NotNull
  public CharSequence getBufferSequence() {
    return myDelegate.getBufferSequence();
  }
  @Override
  public int getBufferEnd() {
    return myDelegate.getBufferEnd();
  }
}",class,
"  @Override
  public void start(@NotNull CharSequence buffer, int startOffset, int endOffset, int initialState) {
    if (myDelegate == EMPTY_LEXER) {
      myDelegate = createDelegate();
    }
    myDelegate.start(buffer, startOffset, endOffset, initialState);
  }",method,
"    if (myDelegate == EMPTY_LEXER) {
      myDelegate = createDelegate();
    }",method,
"  @Override
  @NotNull
  public CharSequence getTokenSequence() {
    return myDelegate.getTokenSequence();
  }",method,
"  @Override
  @NotNull
  public String getTokenText() {
    return myDelegate.getTokenText();
  }",method,
"  @Override
  public int getState() {
    return myDelegate.getState();
  }",method,
"  @Override
  @Nullable
  public IElementType getTokenType() {
    return myDelegate.getTokenType();
  }",method,
"  @Override
  public int getTokenStart() {
    return myDelegate.getTokenStart();
  }",method,
"  @Override
  public int getTokenEnd() {
    return myDelegate.getTokenEnd();
  }",method,
"  @Override
  public void advance() {
    myDelegate.advance();
  }",method,
"  @Override
  @NotNull
  public LexerPosition getCurrentPosition() {
    return myDelegate.getCurrentPosition();
  }",method,
"  @Override
  public void restore(@NotNull LexerPosition position) {
    myDelegate.restore(position);
  }",method,
"  @Override
  @NotNull
  public CharSequence getBufferSequence() {
    return myDelegate.getBufferSequence();
  }",method,
"  @Override
  public int getBufferEnd() {
    return myDelegate.getBufferEnd();
  }",method,
"public class JavadocManagerImpl implements JavadocManager {
  private final List<JavadocTagInfo> myInfos;
  public JavadocManagerImpl(Project project) {
    myInfos = new ArrayList<>();
    myInfos.add(new AuthorDocTagInfo());
    myInfos.add(new SimpleDocTagInfo(""deprecated"", LanguageLevel.JDK_1_3, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""serialData"", LanguageLevel.JDK_1_3, false, PsiMethod.class));
    myInfos.add(new SimpleDocTagInfo(""serialField"", LanguageLevel.JDK_1_3, false, PsiField.class));
    myInfos.add(new SimpleDocTagInfo(""since"", LanguageLevel.JDK_1_3, false, PsiElement.class, PsiPackage.class));
    myInfos.add(new SimpleDocTagInfo(""version"", LanguageLevel.JDK_1_3, false, PsiClass.class, PsiPackage.class));
    myInfos.add(new SimpleDocTagInfo(""apiNote"", LanguageLevel.JDK_1_8, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""implNote"", LanguageLevel.JDK_1_8, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""implSpec"", LanguageLevel.JDK_1_8, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""hidden"", LanguageLevel.JDK_1_9, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""docRoot"", LanguageLevel.JDK_1_3, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""inheritDoc"", LanguageLevel.JDK_1_4, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""literal"", LanguageLevel.JDK_1_5, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""code"", LanguageLevel.JDK_1_5, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""index"", LanguageLevel.JDK_1_9, true, PsiElement.class));
    // not a standard tag, used by IDEA for suppressing inspections
    myInfos.add(new SimpleDocTagInfo(SuppressionUtilCore.SUPPRESS_INSPECTIONS_TAG_NAME, LanguageLevel.JDK_1_3, false, PsiElement.class));
    myInfos.add(new ParamDocTagInfo());
    myInfos.add(new ReturnDocTagInfo());
    myInfos.add(new SerialDocTagInfo());
    myInfos.add(new SeeDocTagInfo(""see"", false));
    myInfos.add(new SeeDocTagInfo(""link"", true));
    myInfos.add(new SeeDocTagInfo(""linkplain"", true));
    myInfos.add(new ExceptionTagInfo(""exception""));
    myInfos.add(new ExceptionTagInfo(""throws""));
    myInfos.add(new ServiceReferenceTagInfo(""provides""));
    myInfos.add(new ServiceReferenceTagInfo(""uses""));
    myInfos.add(new ValueDocTagInfo());
    Collections.addAll(myInfos, Extensions.getExtensions(JavadocTagInfo.EP_NAME, project));
    for (CustomJavadocTagProvider extension : Extensions.getExtensions(CustomJavadocTagProvider.EP_NAME)) {
      myInfos.addAll(extension.getSupportedTags());
    }
  }
  @Override
  @NotNull
  public JavadocTagInfo[] getTagInfos(PsiElement context) {
    List<JavadocTagInfo> result = new ArrayList<>();
    for (JavadocTagInfo info : myInfos) {
      if (info.isValidInContext(context)) {
        result.add(info);
      }
    }
    return result.toArray(new JavadocTagInfo[result.size()]);
  }
  @Override
  @Nullable
  public JavadocTagInfo getTagInfo(String name) {
    for (JavadocTagInfo info : myInfos) {
      if (info.getName().equals(name)) {
        return info;
      }
    }
    return null;
  }
}",class,
"  public JavadocManagerImpl(Project project) {
    myInfos = new ArrayList<>();
    myInfos.add(new AuthorDocTagInfo());
    myInfos.add(new SimpleDocTagInfo(""deprecated"", LanguageLevel.JDK_1_3, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""serialData"", LanguageLevel.JDK_1_3, false, PsiMethod.class));
    myInfos.add(new SimpleDocTagInfo(""serialField"", LanguageLevel.JDK_1_3, false, PsiField.class));
    myInfos.add(new SimpleDocTagInfo(""since"", LanguageLevel.JDK_1_3, false, PsiElement.class, PsiPackage.class));
    myInfos.add(new SimpleDocTagInfo(""version"", LanguageLevel.JDK_1_3, false, PsiClass.class, PsiPackage.class));
    myInfos.add(new SimpleDocTagInfo(""apiNote"", LanguageLevel.JDK_1_8, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""implNote"", LanguageLevel.JDK_1_8, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""implSpec"", LanguageLevel.JDK_1_8, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""hidden"", LanguageLevel.JDK_1_9, false, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""docRoot"", LanguageLevel.JDK_1_3, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""inheritDoc"", LanguageLevel.JDK_1_4, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""literal"", LanguageLevel.JDK_1_5, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""code"", LanguageLevel.JDK_1_5, true, PsiElement.class));
    myInfos.add(new SimpleDocTagInfo(""index"", LanguageLevel.JDK_1_9, true, PsiElement.class));
    // not a standard tag, used by IDEA for suppressing inspections
    myInfos.add(new SimpleDocTagInfo(SuppressionUtilCore.SUPPRESS_INSPECTIONS_TAG_NAME, LanguageLevel.JDK_1_3, false, PsiElement.class));
    myInfos.add(new ParamDocTagInfo());
    myInfos.add(new ReturnDocTagInfo());
    myInfos.add(new SerialDocTagInfo());
    myInfos.add(new SeeDocTagInfo(""see"", false));
    myInfos.add(new SeeDocTagInfo(""link"", true));
    myInfos.add(new SeeDocTagInfo(""linkplain"", true));
    myInfos.add(new ExceptionTagInfo(""exception""));
    myInfos.add(new ExceptionTagInfo(""throws""));
    myInfos.add(new ServiceReferenceTagInfo(""provides""));
    myInfos.add(new ServiceReferenceTagInfo(""uses""));
    myInfos.add(new ValueDocTagInfo());
    Collections.addAll(myInfos, Extensions.getExtensions(JavadocTagInfo.EP_NAME, project));
    for (CustomJavadocTagProvider extension : Extensions.getExtensions(CustomJavadocTagProvider.EP_NAME)) {
      myInfos.addAll(extension.getSupportedTags());
    }
  }",method,
"  @Override
  @NotNull
  public JavadocTagInfo[] getTagInfos(PsiElement context) {
    List<JavadocTagInfo> result = new ArrayList<>();
    for (JavadocTagInfo info : myInfos) {
      if (info.isValidInContext(context)) {
        result.add(info);
      }
    }
    return result.toArray(new JavadocTagInfo[result.size()]);
  }",method,
"    for (JavadocTagInfo info : myInfos) {
      if (info.isValidInContext(context)) {
        result.add(info);
      }
    }",method,
"  @Override
  @Nullable
  public JavadocTagInfo getTagInfo(String name) {
    for (JavadocTagInfo info : myInfos) {
      if (info.getName().equals(name)) {
        return info;
      }
    }
    return null;
  }",method,
"    for (JavadocTagInfo info : myInfos) {
      if (info.getName().equals(name)) {
        return info;
      }
    }",method,
"public class GrInplaceParameterIntroducer extends GrAbstractInplaceIntroducer<GrIntroduceParameterSettings> {
  private final IntroduceParameterInfo myInfo;
  private final TIntArrayList myParametersToRemove;
  private JBCheckBox myDelegateCB;
  private final LinkedHashSet<String> mySuggestedNames;
  public GrInplaceParameterIntroducer(IntroduceParameterInfo info, GrIntroduceContext context, OccurrencesChooser.ReplaceChoice choice) {
    super(GrIntroduceParameterHandler.REFACTORING_NAME, choice, context);
    myInfo = info;
    GrVariable localVar = GrIntroduceHandlerBase.resolveLocalVar(context);
    mySuggestedNames = GroovyIntroduceParameterUtil.suggestNames(localVar, context.getExpression(), context.getStringPart(), info.getToReplaceIn(), context.getProject());
    myParametersToRemove = new TIntArrayList(GroovyIntroduceParameterUtil.findParametersToRemove(info).getValues());
  }
  @Override
  protected String getActionName() {
    return GrIntroduceParameterHandler.REFACTORING_NAME;
  }
  @NotNull
  @Override
  protected String[] suggestNames(boolean replaceAll, @Nullable GrVariable variable) {
    return ArrayUtil.toStringArray(mySuggestedNames);
  }
  @Override
  protected JComponent getComponent() {
    JPanel previewPanel = new JPanel(new BorderLayout());
    previewPanel.add(getPreviewEditor().getComponent(), BorderLayout.CENTER);
    previewPanel.setBorder(new EmptyBorder(2, 2, 6, 2));
    myDelegateCB = new JBCheckBox(""Delegate via overloading method"");
    myDelegateCB.setMnemonic('l');
    myDelegateCB.setFocusable(false);
    JPanel panel = new JPanel(new BorderLayout());
    panel.add(previewPanel, BorderLayout.CENTER);
    panel.add(myDelegateCB, BorderLayout.SOUTH);
    return panel;
  }
  @Override
  protected void saveSettings(@NotNull GrVariable variable) {
  }
  @Override
  protected void updateTitle(@Nullable GrVariable variable) {
    if (variable == null) return;
    updateTitle(variable, variable.getName());
  }
  @Override
  protected void updateTitle(@Nullable GrVariable variable, String value) {
    if (getPreviewEditor() == null || variable == null) return;
    final PsiElement declarationScope = ((PsiParameter)variable).getDeclarationScope();
    if (declarationScope instanceof PsiMethod) {
      final PsiMethod psiMethod = (PsiMethod)declarationScope;
      final StringBuilder buf = new StringBuilder();
      buf.append(psiMethod.getName()).append("" ("");
      boolean frst = true;
      final List<TextRange> ranges2Remove = new ArrayList<>();
      TextRange addedRange = null;
      int i = 0;
      for (PsiParameter parameter : psiMethod.getParameterList().getParameters()) {
        if (frst) {
          frst = false;
        }
        else {
          buf.append("", "");
        }
        int startOffset = buf.length();
        buf.append(parameter.getType().getPresentableText()).append("" "").append(variable == parameter ? value : parameter.getName());
        int endOffset = buf.length();
        if (variable == parameter) {
          addedRange = new TextRange(startOffset, endOffset);
        }
        else if (myParametersToRemove.contains(i)) {
          ranges2Remove.add(new TextRange(startOffset, endOffset));
        }
        i++;
      }
      assert addedRange != null;
      buf.append("")"");
      setPreviewText(buf.toString());
      final MarkupModel markupModel = DocumentMarkupModel.forDocument(getPreviewEditor().getDocument(), myProject, true);
      markupModel.removeAllHighlighters();
      for (TextRange textRange : ranges2Remove) {
        markupModel.addRangeHighlighter(textRange.getStartOffset(), textRange.getEndOffset(), 0, getTestAttributesForRemoval(), HighlighterTargetArea.EXACT_RANGE);
      }
      markupModel.addRangeHighlighter(addedRange.getStartOffset(), addedRange.getEndOffset(), 0, getTextAttributesForAdd(), HighlighterTargetArea.EXACT_RANGE);
      //revalidate();
    }
  }
  private static TextAttributes getTextAttributesForAdd() {
    final TextAttributes textAttributes = new TextAttributes();
    textAttributes.setEffectType(EffectType.ROUNDED_BOX);
    textAttributes.setEffectColor(JBColor.RED);
    return textAttributes;
  }
  private static TextAttributes getTestAttributesForRemoval() {
    final TextAttributes textAttributes = new TextAttributes();
    textAttributes.setEffectType(EffectType.STRIKEOUT);
    textAttributes.setEffectColor(JBColor.BLACK);
    return textAttributes;
  }
  @Override
  protected GrVariable runRefactoring(GrIntroduceContext context, GrIntroduceParameterSettings settings, boolean processUsages) {
    GrExpressionWrapper wrapper = createExpressionWrapper(context);
    if (processUsages) {
      GrIntroduceExpressionSettingsImpl patchedSettings =
        new GrIntroduceExpressionSettingsImpl(settings, settings.getName(), settings.declareFinal(), settings.parametersToRemove(),
                                              settings.generateDelegate(), settings.replaceFieldsWithGetters(), context.getExpression(),
                                              context.getVar(), settings.getSelectedType(), context.getVar() != null || settings.replaceAllOccurrences(),
                                              context.getVar() != null, settings.isForceReturn());
      GrIntroduceParameterProcessor processor = new GrIntroduceParameterProcessor(patchedSettings, wrapper);
      processor.run();
    }
    else {
      WriteAction.run(() -> new GrIntroduceParameterProcessor(settings, wrapper).performRefactoring(UsageInfo.EMPTY_ARRAY));
    }
    GrParametersOwner owner = settings.getToReplaceIn();
    return ArrayUtil.getLastElement(owner.getParameters());
  }
  @NotNull
  private static GrExpressionWrapper createExpressionWrapper(@NotNull GrIntroduceContext context) {
    GrExpression expression = context.getExpression();
    GrVariable var = context.getVar();
    assert expression != null || var != null ;
    GrExpression initializer = expression != null ? expression : var.getInitializerGroovy();
    return new GrExpressionWrapper(initializer);
  }
  @Nullable
  @Override
  protected GrIntroduceParameterSettings getInitialSettingsForInplace(@NotNull GrIntroduceContext context,
                                                                      @NotNull OccurrencesChooser.ReplaceChoice choice,
                                                                      String[] names) {
    GrExpression expression = context.getExpression();
    GrVariable var = context.getVar();
    PsiType type = var != null ? var.getDeclaredType() :
                   expression != null ? expression.getType() :
                   null;
    return new GrIntroduceExpressionSettingsImpl(myInfo, names[0], false, new TIntArrayList(), false,
                                                 IntroduceParameterRefactoring.REPLACE_FIELDS_WITH_GETTERS_NONE, expression,
                                                 var, type, false, false, false);
  }
  @Override
  protected GrIntroduceParameterSettings getSettings() {
    return new GrIntroduceExpressionSettingsImpl(myInfo, getInputName(), false, myParametersToRemove, myDelegateCB.isSelected(),
                                                 IntroduceParameterRefactoring.REPLACE_FIELDS_WITH_GETTERS_NONE, null,
                                                 null, getSelectedType(), isReplaceAllOccurrences(), false, false);
  }
}",class,
"  public GrInplaceParameterIntroducer(IntroduceParameterInfo info, GrIntroduceContext context, OccurrencesChooser.ReplaceChoice choice) {
    super(GrIntroduceParameterHandler.REFACTORING_NAME, choice, context);
    myInfo = info;
    GrVariable localVar = GrIntroduceHandlerBase.resolveLocalVar(context);
    mySuggestedNames = GroovyIntroduceParameterUtil.suggestNames(localVar, context.getExpression(), context.getStringPart(), info.getToReplaceIn(), context.getProject());
    myParametersToRemove = new TIntArrayList(GroovyIntroduceParameterUtil.findParametersToRemove(info).getValues());
  }",method,
"  @Override
  protected String getActionName() {
    return GrIntroduceParameterHandler.REFACTORING_NAME;
  }",method,
"  @NotNull
  @Override
  protected String[] suggestNames(boolean replaceAll, @Nullable GrVariable variable) {
    return ArrayUtil.toStringArray(mySuggestedNames);
  }",method,
"  @Override
  protected JComponent getComponent() {
    JPanel previewPanel = new JPanel(new BorderLayout());
    previewPanel.add(getPreviewEditor().getComponent(), BorderLayout.CENTER);
    previewPanel.setBorder(new EmptyBorder(2, 2, 6, 2));
    myDelegateCB = new JBCheckBox(""Delegate via overloading method"");
    myDelegateCB.setMnemonic('l');
    myDelegateCB.setFocusable(false);
    JPanel panel = new JPanel(new BorderLayout());
    panel.add(previewPanel, BorderLayout.CENTER);
    panel.add(myDelegateCB, BorderLayout.SOUTH);
    return panel;
  }",method,
"  @Override
  protected void saveSettings(@NotNull GrVariable variable) {
  }",method,
"  @Override
  protected void updateTitle(@Nullable GrVariable variable) {
    if (variable == null) return;
    updateTitle(variable, variable.getName());
  }",method,
"  @Override
  protected void updateTitle(@Nullable GrVariable variable, String value) {
    if (getPreviewEditor() == null || variable == null) return;
    final PsiElement declarationScope = ((PsiParameter)variable).getDeclarationScope();
    if (declarationScope instanceof PsiMethod) {
      final PsiMethod psiMethod = (PsiMethod)declarationScope;
      final StringBuilder buf = new StringBuilder();
      buf.append(psiMethod.getName()).append("" ("");
      boolean frst = true;
      final List<TextRange> ranges2Remove = new ArrayList<>();
      TextRange addedRange = null;
      int i = 0;
      for (PsiParameter parameter : psiMethod.getParameterList().getParameters()) {
        if (frst) {
          frst = false;
        }
        else {
          buf.append("", "");
        }
        int startOffset = buf.length();
        buf.append(parameter.getType().getPresentableText()).append("" "").append(variable == parameter ? value : parameter.getName());
        int endOffset = buf.length();
        if (variable == parameter) {
          addedRange = new TextRange(startOffset, endOffset);
        }
        else if (myParametersToRemove.contains(i)) {
          ranges2Remove.add(new TextRange(startOffset, endOffset));
        }
        i++;
      }
      assert addedRange != null;
      buf.append("")"");
      setPreviewText(buf.toString());
      final MarkupModel markupModel = DocumentMarkupModel.forDocument(getPreviewEditor().getDocument(), myProject, true);
      markupModel.removeAllHighlighters();
      for (TextRange textRange : ranges2Remove) {
        markupModel.addRangeHighlighter(textRange.getStartOffset(), textRange.getEndOffset(), 0, getTestAttributesForRemoval(), HighlighterTargetArea.EXACT_RANGE);
      }
      markupModel.addRangeHighlighter(addedRange.getStartOffset(), addedRange.getEndOffset(), 0, getTextAttributesForAdd(), HighlighterTargetArea.EXACT_RANGE);
      //revalidate();
    }
  }",method,
"    if (declarationScope instanceof PsiMethod) {
      final PsiMethod psiMethod = (PsiMethod)declarationScope;
      final StringBuilder buf = new StringBuilder();
      buf.append(psiMethod.getName()).append("" ("");
      boolean frst = true;
      final List<TextRange> ranges2Remove = new ArrayList<>();
      TextRange addedRange = null;
      int i = 0;
      for (PsiParameter parameter : psiMethod.getParameterList().getParameters()) {
        if (frst) {
          frst = false;
        }
        else {
          buf.append("", "");
        }
        int startOffset = buf.length();
        buf.append(parameter.getType().getPresentableText()).append("" "").append(variable == parameter ? value : parameter.getName());
        int endOffset = buf.length();
        if (variable == parameter) {
          addedRange = new TextRange(startOffset, endOffset);
        }
        else if (myParametersToRemove.contains(i)) {
          ranges2Remove.add(new TextRange(startOffset, endOffset));
        }
        i++;
      }
      assert addedRange != null;
      buf.append("")"");
      setPreviewText(buf.toString());
      final MarkupModel markupModel = DocumentMarkupModel.forDocument(getPreviewEditor().getDocument(), myProject, true);
      markupModel.removeAllHighlighters();
      for (TextRange textRange : ranges2Remove) {
        markupModel.addRangeHighlighter(textRange.getStartOffset(), textRange.getEndOffset(), 0, getTestAttributesForRemoval(), HighlighterTargetArea.EXACT_RANGE);
      }
      markupModel.addRangeHighlighter(addedRange.getStartOffset(), addedRange.getEndOffset(), 0, getTextAttributesForAdd(), HighlighterTargetArea.EXACT_RANGE);
      //revalidate();
    }",method,
"        if (frst) {
          frst = false;
        }",method,
"        if (variable == parameter) {
          addedRange = new TextRange(startOffset, endOffset);
        }",method,
"      for (TextRange textRange : ranges2Remove) {
        markupModel.addRangeHighlighter(textRange.getStartOffset(), textRange.getEndOffset(), 0, getTestAttributesForRemoval(), HighlighterTargetArea.EXACT_RANGE);
      }",method,
"  private static TextAttributes getTextAttributesForAdd() {
    final TextAttributes textAttributes = new TextAttributes();
    textAttributes.setEffectType(EffectType.ROUNDED_BOX);
    textAttributes.setEffectColor(JBColor.RED);
    return textAttributes;
  }",method,
"  private static TextAttributes getTestAttributesForRemoval() {
    final TextAttributes textAttributes = new TextAttributes();
    textAttributes.setEffectType(EffectType.STRIKEOUT);
    textAttributes.setEffectColor(JBColor.BLACK);
    return textAttributes;
  }",method,
"  @Override
  protected GrVariable runRefactoring(GrIntroduceContext context, GrIntroduceParameterSettings settings, boolean processUsages) {
    GrExpressionWrapper wrapper = createExpressionWrapper(context);
    if (processUsages) {
      GrIntroduceExpressionSettingsImpl patchedSettings =
        new GrIntroduceExpressionSettingsImpl(settings, settings.getName(), settings.declareFinal(), settings.parametersToRemove(),
                                              settings.generateDelegate(), settings.replaceFieldsWithGetters(), context.getExpression(),
                                              context.getVar(), settings.getSelectedType(), context.getVar() != null || settings.replaceAllOccurrences(),
                                              context.getVar() != null, settings.isForceReturn());
      GrIntroduceParameterProcessor processor = new GrIntroduceParameterProcessor(patchedSettings, wrapper);
      processor.run();
    }
    else {
      WriteAction.run(() -> new GrIntroduceParameterProcessor(settings, wrapper).performRefactoring(UsageInfo.EMPTY_ARRAY));
    }
    GrParametersOwner owner = settings.getToReplaceIn();
    return ArrayUtil.getLastElement(owner.getParameters());
  }",method,
"    if (processUsages) {
      GrIntroduceExpressionSettingsImpl patchedSettings =
        new GrIntroduceExpressionSettingsImpl(settings, settings.getName(), settings.declareFinal(), settings.parametersToRemove(),
                                              settings.generateDelegate(), settings.replaceFieldsWithGetters(), context.getExpression(),
                                              context.getVar(), settings.getSelectedType(), context.getVar() != null || settings.replaceAllOccurrences(),
                                              context.getVar() != null, settings.isForceReturn());
      GrIntroduceParameterProcessor processor = new GrIntroduceParameterProcessor(patchedSettings, wrapper);
      processor.run();
    }",method,
"  @NotNull
  private static GrExpressionWrapper createExpressionWrapper(@NotNull GrIntroduceContext context) {
    GrExpression expression = context.getExpression();
    GrVariable var = context.getVar();
    assert expression != null || var != null ;
    GrExpression initializer = expression != null ? expression : var.getInitializerGroovy();
    return new GrExpressionWrapper(initializer);
  }",method,
"  @Nullable
  @Override
  protected GrIntroduceParameterSettings getInitialSettingsForInplace(@NotNull GrIntroduceContext context,
                                                                      @NotNull OccurrencesChooser.ReplaceChoice choice,
                                                                      String[] names) {
    GrExpression expression = context.getExpression();
    GrVariable var = context.getVar();
    PsiType type = var != null ? var.getDeclaredType() :
                   expression != null ? expression.getType() :
                   null;
    return new GrIntroduceExpressionSettingsImpl(myInfo, names[0], false, new TIntArrayList(), false,
                                                 IntroduceParameterRefactoring.REPLACE_FIELDS_WITH_GETTERS_NONE, expression,
                                                 var, type, false, false, false);
  }",method,
"  @Override
  protected GrIntroduceParameterSettings getSettings() {
    return new GrIntroduceExpressionSettingsImpl(myInfo, getInputName(), false, myParametersToRemove, myDelegateCB.isSelected(),
                                                 IntroduceParameterRefactoring.REPLACE_FIELDS_WITH_GETTERS_NONE, null,
                                                 null, getSelectedType(), isReplaceAllOccurrences(), false, false);
  }",method,
"                             @NotNull Set<LibraryDependencyData> toImport,
                             @NotNull Map<OrderEntry, OrderAware> orderEntryDataMap,
                             @NotNull ModifiableRootModel moduleRootModel,
                             @NotNull LibraryTable moduleLibraryTable,
                             @NotNull Module module) {
    for (final LibraryDependencyData dependencyData : toImport) {
      final LibraryData libraryData = dependencyData.getTarget();
      final String libraryName = libraryData.getInternalName();
      switch (dependencyData.getLevel()) {
        case MODULE:
          final Library moduleLib;
          if (libraryName.isEmpty()) {
            moduleLib = moduleLibraryTable.createLibrary();
          }
          else {
            moduleLib = moduleLibraryTable.createLibrary(libraryName);
          }
          final LibraryOrderEntry existingLibraryDependency =
            syncExistingLibraryDependency(modelsProvider, dependencyData, moduleLib, moduleRootModel, module);
          orderEntryDataMap.put(existingLibraryDependency, dependencyData);
          break;
        case PROJECT:
          final Library projectLib = modelsProvider.getLibraryByName(libraryName);
          if (projectLib == null) {
            final LibraryOrderEntry existingProjectLibraryDependency = syncExistingLibraryDependency(
              modelsProvider, dependencyData, moduleLibraryTable.createLibrary(libraryName), moduleRootModel, module);
            orderEntryDataMap.put(existingProjectLibraryDependency, dependencyData);
            break;
          }
          LibraryOrderEntry orderEntry = moduleRootModel.addLibraryEntry(projectLib);
          setLibraryScope(orderEntry, projectLib, module, dependencyData);
          ModuleOrderEntry substitutionEntry = modelsProvider.trySubstitute(module, orderEntry, libraryData);
          if (substitutionEntry != null) {
            orderEntryDataMap.put(substitutionEntry, dependencyData);
          }
          else {
            orderEntryDataMap.put(orderEntry, dependencyData);
          }
      }
    }",method,
"          if (projectLib == null) {
            final LibraryOrderEntry existingProjectLibraryDependency = syncExistingLibraryDependency(
              modelsProvider, dependencyData, moduleLibraryTable.createLibrary(libraryName), moduleRootModel, module);
            orderEntryDataMap.put(existingProjectLibraryDependency, dependencyData);
            break;
          }",method,
"          if (substitutionEntry != null) {
            orderEntryDataMap.put(substitutionEntry, dependencyData);
          }",method,
"  private static void setLibraryScope(@NotNull LibraryOrderEntry orderEntry,
                                      @NotNull Library lib,
                                      @NotNull Module module,
                                      @NotNull LibraryDependencyData dependencyData) {
    orderEntry.setExported(dependencyData.isExported());
    orderEntry.setScope(dependencyData.getScope());
    if(LOG.isDebugEnabled()) {
      LOG.debug(String.format(
        ""Configuring library '%s' of module '%s' to be%s exported and have scope %s"",
        lib, module.getName(), dependencyData.isExported() ? "" not"" : """", dependencyData.getScope()
      ));
    }
  }",method,
"      if (entry instanceof ModuleLibraryOrderEntryImpl) {
        ModuleLibraryOrderEntryImpl moduleLibraryOrderEntry = (ModuleLibraryOrderEntryImpl)entry;
        Library library = moduleLibraryOrderEntry.getLibrary();
        if (library == null) {
          LOG.warn(""Skipping module-level library entry because it doesn't have backing Library object. Entry: "" + entry);
          continue;
        }
        final VirtualFile[] libraryFiles = library.getFiles(OrderRootType.CLASSES);
        final Set<String> moduleLibraryKey = ContainerUtilRt.newHashSet(libraryFiles.length);
        for (VirtualFile file : libraryFiles) {
          moduleLibraryKey.add(ExternalSystemApiUtil.getLocalFileSystemPath(file) + moduleLibraryOrderEntry.getScope().name());
        }
        LibraryDependencyData existing = moduleLibrariesToImport.remove(moduleLibraryKey);
        if (existing == null || !StringUtil.equals(StringUtil.nullize(existing.getInternalName()), library.getName())) {
          moduleRootModel.removeOrderEntry(entry);
        }
        else {
          orderEntryDataMap.put(entry, existing);
          syncExistingLibraryDependency(modelsProvider, existing, library, moduleRootModel, moduleLibraryOrderEntry.getOwnerModule());
          toImport.remove(existing);
        }
      }",method,
"        if (library == null) {
          LOG.warn(""Skipping module-level library entry because it doesn't have backing Library object. Entry: "" + entry);
          continue;
        }",method,
"        for (VirtualFile file : libraryFiles) {
          moduleLibraryKey.add(ExternalSystemApiUtil.getLocalFileSystemPath(file) + moduleLibraryOrderEntry.getScope().name());
        }",method,
"        if (existing != null) {
          String module = modelsProvider.findModuleByPublication(existing.getTarget());
          if(module == null) {
            toImport.remove(existing);
            orderEntryDataMap.put(entry, existing);
            libraryOrderEntry.setExported(existing.isExported());
            libraryOrderEntry.setScope(existing.getScope());
          } else {
            moduleRootModel.removeOrderEntry(entry);
          }
        }",method,
"          if(module == null) {
            toImport.remove(existing);
            orderEntryDataMap.put(entry, existing);
            libraryOrderEntry.setExported(existing.isExported());
            libraryOrderEntry.setScope(existing.getScope());
          }",method,
"importMissing(@NotNull IdeModifiableModelsProvider modelsProvider,
                             @NotNull Set<LibraryDependencyData> toImport,
                             @NotNull Map<OrderEntry, OrderAware> orderEntryDataMap,
                             @NotNull ModifiableRootModel moduleRootModel,
                             @NotNull LibraryTable moduleLibraryTable,
                             @NotNull Module module) {
    for (final LibraryDependencyData dependencyData : toImport) {
      final LibraryData libraryData = dependencyData.getTarget();
      final String libraryName = libraryData.getInternalName();
      switch (dependencyData.getLevel()) {
        case MODULE:
          final Library moduleLib;
          if (libraryName.isEmpty()) {
            moduleLib = moduleLibraryTable.createLibrary();
          }
          else {
            moduleLib = moduleLibraryTable.createLibrary(libraryName);
          }
          final LibraryOrderEntry existingLibraryDependency =
            syncExistingLibraryDependency(modelsProvider, dependencyData, moduleLib, moduleRootModel, module);
          orderEntryDataMap.put(existingLibraryDependency, dependencyData);
          break;
        case PROJECT:
          final Library projectLib = modelsProvider.getLibraryByName(libraryName);
          if (projectLib == null) {
            final LibraryOrderEntry existingProjectLibraryDependency = syncExistingLibraryDependency(
              modelsProvider, dependencyData, moduleLibraryTable.createLibrary(libraryName), moduleRootModel, module);
            orderEntryDataMap.put(existingProjectLibraryDependency, dependencyData);
            break;
          }
          LibraryOrderEntry orderEntry = moduleRootModel.addLibraryEntry(projectLib);
          setLibraryScope(orderEntry, projectLib, module, dependencyData);
          ModuleOrderEntry substitutionEntry = modelsProvider.trySubstitute(module, orderEntry, libraryData);
          if (substitutionEntry != null) {
            orderEntryDataMap.put(substitutionEntry, dependencyData);
          }
          else {
            orderEntryDataMap.put(orderEntry, dependencyData);
          }
      }
    }
  }",method,
"    for (final LibraryDependencyData dependencyData : toImport) {
      final LibraryData libraryData = dependencyData.getTarget();
      final String libraryName = libraryData.getInternalName();
      switch (dependencyData.getLevel()) {
        case MODULE:
          final Library moduleLib;
          if (libraryName.isEmpty()) {
            moduleLib = moduleLibraryTable.createLibrary();
          }
          else {
            moduleLib = moduleLibraryTable.createLibrary(libraryName);
          }
          final LibraryOrderEntry existingLibraryDependency =
            syncExistingLibraryDependency(modelsProvider, dependencyData, moduleLib, moduleRootModel, module);
          orderEntryDataMap.put(existingLibraryDependency, dependencyData);
          break;
        case PROJECT:
          final Library projectLib = modelsProvider.getLibraryByName(libraryName);
          if (projectLib == null) {
            final LibraryOrderEntry existingProjectLibraryDependency = syncExistingLibraryDependency(
              modelsProvider, dependencyData, moduleLibraryTable.createLibrary(libraryName), moduleRootModel, module);
            orderEntryDataMap.put(existingProjectLibraryDependency, dependencyData);
            break;
          }
          LibraryOrderEntry orderEntry = moduleRootModel.addLibraryEntry(projectLib);
          setLibraryScope(orderEntry, projectLib, module, dependencyData);
          ModuleOrderEntry substitutionEntry = modelsProvider.trySubstitute(module, orderEntry, libraryData);
          if (substitutionEntry != null) {
            orderEntryDataMap.put(substitutionEntry, dependencyData);
          }
          else {
            orderEntryDataMap.put(orderEntry, dependencyData);
          }
      }
    }",method,
"public class CodeReferenceMap {
  public static class Builder {
    private final Set<String> deadClasses = new HashSet<String>();
    private final Table<String, String, Set<String>> deadMethods = HashBasedTable.create();
    private final ListMultimap<String, String> deadFields =
        MultimapBuilder.hashKeys().arrayListValues().build();
    public CodeReferenceMap build() {
      ImmutableTable.Builder<String, String, ImmutableSet<String>> deadMethodsBuilder =
          ImmutableTable.builder();
      for (Table.Cell<String, String, Set<String>> cell : this.deadMethods.cellSet()) {
        deadMethodsBuilder.put(
            cell.getRowKey(),
            cell.getColumnKey(),
            ImmutableSet.copyOf(cell.getValue()));
      }
      return new CodeReferenceMap(
          ImmutableSet.copyOf(deadClasses),
          deadMethodsBuilder.build(),
          ImmutableMultimap.copyOf(deadFields));
    }
    public Builder addClass(String clazz) {
      deadClasses.add(clazz);
      return this;
    }
    public Builder addMethod(String clazz, String name, String signature) {
      if (!deadMethods.contains(clazz, name)) {
        deadMethods.put(clazz, name, new HashSet<String>());
      }
      deadMethods.get(clazz, name).add(signature);
      return this;
    }
    public Builder addField(String clazz, String field) {
      deadFields.put(clazz, field);
      return this;
    }
  }
  public static Builder builder() {
    return new Builder();
  }
  private final ImmutableSet<String> referencedClasses;
  private final ImmutableTable<String, String, ImmutableSet<String>> referencedMethods;
  private final ImmutableMultimap<String, String> referencedFields;
  private final Set<String> hasConstructorRemovedClasses = new HashSet<>();
  private CodeReferenceMap(
      ImmutableSet<String> referencedClasses,
      ImmutableTable<String, String, ImmutableSet<String>> referencedMethods,
      ImmutableMultimap<String, String> referencedFields) {
    this.referencedClasses = referencedClasses;
    this.referencedMethods = referencedMethods;
    this.referencedFields = referencedFields;
  }
  public ImmutableSet<String> getReferencedClasses() {
    return referencedClasses;
  }
  public ImmutableTable<String, String, ImmutableSet<String>> getReferencedMethods() {
    return referencedMethods;
  }
  public ImmutableMultimap<String, String> getReferencedFields() {
    return referencedFields;
  }
  public boolean containsClass(String clazz) {
    return referencedClasses.contains(clazz);
  }
  public boolean containsClass(TypeElement clazz, ElementUtil elementUtil) {
    return containsClass(elementUtil.getBinaryName(clazz));
  }
  public boolean containsMethod(String clazz, String name, String signature) {
    return referencedClasses.contains(clazz)
        || (referencedMethods.contains(clazz, name)
           && referencedMethods.get(clazz, name).contains(signature));
  }
  public boolean containsMethod(ExecutableElement method, TypeUtil typeUtil) {
    String className = typeUtil.elementUtil().getBinaryName(ElementUtil.getDeclaringClass(method));
    String methodName = typeUtil.getReferenceName(method);
    String methodSig = typeUtil.getReferenceSignature(method);
    return containsMethod(className, methodName, methodSig);
  }
  public boolean containsField(String clazz, String field) {
    return referencedClasses.contains(clazz) || referencedFields.containsEntry(clazz, field);
  }
  public boolean isEmpty() {
    return referencedClasses.isEmpty() && referencedMethods.isEmpty() && referencedFields.isEmpty();
  }
  public void addConstructorRemovedClass(String clazz) {
    hasConstructorRemovedClasses.add(clazz);
  }
  public boolean classHasConstructorRemoved(String clazz) {
    return hasConstructorRemovedClasses.contains(clazz);
  }
  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(referencedClasses.asList().toString() + ""\n"");
    builder.append(referencedFields.toString() + ""\n"");
    builder.append(referencedMethods.toString());
    return builder.toString();
  }
}",class,
"  public static class Builder {
    private final Set<String> deadClasses = new HashSet<String>();
    private final Table<String, String, Set<String>> deadMethods = HashBasedTable.create();
    private final ListMultimap<String, String> deadFields =
        MultimapBuilder.hashKeys().arrayListValues().build();
    public CodeReferenceMap build() {
      ImmutableTable.Builder<String, String, ImmutableSet<String>> deadMethodsBuilder =
          ImmutableTable.builder();
      for (Table.Cell<String, String, Set<String>> cell : this.deadMethods.cellSet()) {
        deadMethodsBuilder.put(
            cell.getRowKey(),
            cell.getColumnKey(),
            ImmutableSet.copyOf(cell.getValue()));
      }
      return new CodeReferenceMap(
          ImmutableSet.copyOf(deadClasses),
          deadMethodsBuilder.build(),
          ImmutableMultimap.copyOf(deadFields));
    }
    public Builder addClass(String clazz) {
      deadClasses.add(clazz);
      return this;
    }
    public Builder addMethod(String clazz, String name, String signature) {
      if (!deadMethods.contains(clazz, name)) {
        deadMethods.put(clazz, name, new HashSet<String>());
      }
      deadMethods.get(clazz, name).add(signature);
      return this;
    }
    public Builder addField(String clazz, String field) {
      deadFields.put(clazz, field);
      return this;
    }
  }",class,
"    public CodeReferenceMap build() {
      ImmutableTable.Builder<String, String, ImmutableSet<String>> deadMethodsBuilder =
          ImmutableTable.builder();
      for (Table.Cell<String, String, Set<String>> cell : this.deadMethods.cellSet()) {
        deadMethodsBuilder.put(
            cell.getRowKey(),
            cell.getColumnKey(),
            ImmutableSet.copyOf(cell.getValue()));
      }
      return new CodeReferenceMap(
          ImmutableSet.copyOf(deadClasses),
          deadMethodsBuilder.build(),
          ImmutableMultimap.copyOf(deadFields));
    }",method,
"    public Builder addClass(String clazz) {
      deadClasses.add(clazz);
      return this;
    }",method,
"    public Builder addMethod(String clazz, String name, String signature) {
      if (!deadMethods.contains(clazz, name)) {
        deadMethods.put(clazz, name, new HashSet<String>());
      }
      deadMethods.get(clazz, name).add(signature);
      return this;
    }",method,
"    public Builder addField(String clazz, String field) {
      deadFields.put(clazz, field);
      return this;
    }",method,
"  public static Builder builder() {
    return new Builder();
  }",method,
"  private CodeReferenceMap(
      ImmutableSet<String> referencedClasses,
      ImmutableTable<String, String, ImmutableSet<String>> referencedMethods,
      ImmutableMultimap<String, String> referencedFields) {
    this.referencedClasses = referencedClasses;
    this.referencedMethods = referencedMethods;
    this.referencedFields = referencedFields;
  }",method,
"  public ImmutableSet<String> getReferencedClasses() {
    return referencedClasses;
  }",method,
"  public ImmutableTable<String, String, ImmutableSet<String>> getReferencedMethods() {
    return referencedMethods;
  }",method,
"  public ImmutableMultimap<String, String> getReferencedFields() {
    return referencedFields;
  }",method,
"  public boolean containsClass(String clazz) {
    return referencedClasses.contains(clazz);
  }",method,
"  public boolean containsClass(TypeElement clazz, ElementUtil elementUtil) {
    return containsClass(elementUtil.getBinaryName(clazz));
  }",method,
"  public boolean containsMethod(String clazz, String name, String signature) {
    return referencedClasses.contains(clazz)
        || (referencedMethods.contains(clazz, name)
           && referencedMethods.get(clazz, name).contains(signature));
  }",method,
"  public boolean containsMethod(ExecutableElement method, TypeUtil typeUtil) {
    String className = typeUtil.elementUtil().getBinaryName(ElementUtil.getDeclaringClass(method));
    String methodName = typeUtil.getReferenceName(method);
    String methodSig = typeUtil.getReferenceSignature(method);
    return containsMethod(className, methodName, methodSig);
  }",method,
"  public boolean containsField(String clazz, String field) {
    return referencedClasses.contains(clazz) || referencedFields.containsEntry(clazz, field);
  }",method,

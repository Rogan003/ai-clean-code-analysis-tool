code_snippet,type,score
"            for (int i = 0; i < 797; i++) {
                long ref = randomLong();
                long count = hash.size();
                long key = hash.add(ref);
                if (key >= 0) {
                    assertTrue(longs.add(ref));
                    assertEquals(uniqueCount, key);
                    assertEquals(hash.size(), count + 1);
                    uniqueCount++;
                } else {
                    assertFalse(longs.add(ref));
                    assertTrue((-key) - 1 < count);
                    assertEquals(ref, hash.get((-key) - 1));
                    assertEquals(count, hash.size());
                }
            }",method,
"                if (key >= 0) {
                    assertTrue(longs.add(ref));
                    assertEquals(uniqueCount, key);
                    assertEquals(hash.size(), count + 1);
                    uniqueCount++;
                }",method,
"    public void testFind() throws Exception {
        int num = scaledRandomIntBetween(2, 20);
        for (int j = 0; j < num; j++) {
            Set<Long> longs = new HashSet<>();
            int uniqueCount = 0;
            for (int i = 0; i < 797; i++) {
                long ref = randomLong();
                long count = hash.size();
                long key = hash.find(ref);
                if (key >= 0) { // found in hash
                    assertFalse(longs.add(ref));
                    assertTrue(key < count);
                    assertEquals(ref, hash.get(key));
                    assertEquals(count, hash.size());
                } else {
                    key = hash.add(ref);
                    assertTrue(longs.add(ref));
                    assertEquals(uniqueCount, key);
                    assertEquals(hash.size(), count + 1);
                    uniqueCount++;
                }
            }
            assertAllIn(longs, hash);
            newHash();
        }
        hash.close();
    }",method,
"        for (int j = 0; j < num; j++) {
            Set<Long> longs = new HashSet<>();
            int uniqueCount = 0;
            for (int i = 0; i < 797; i++) {
                long ref = randomLong();
                long count = hash.size();
                long key = hash.find(ref);
                if (key >= 0) { // found in hash
                    assertFalse(longs.add(ref));
                    assertTrue(key < count);
                    assertEquals(ref, hash.get(key));
                    assertEquals(count, hash.size());
                } else {
                    key = hash.add(ref);
                    assertTrue(longs.add(ref));
                    assertEquals(uniqueCount, key);
                    assertEquals(hash.size(), count + 1);
                    uniqueCount++;
                }
            }
            assertAllIn(longs, hash);
            newHash();
        }",method,
"            for (int i = 0; i < 797; i++) {
                long ref = randomLong();
                long count = hash.size();
                long key = hash.find(ref);
                if (key >= 0) { // found in hash
                    assertFalse(longs.add(ref));
                    assertTrue(key < count);
                    assertEquals(ref, hash.get(key));
                    assertEquals(count, hash.size());
                } else {
                    key = hash.add(ref);
                    assertTrue(longs.add(ref));
                    assertEquals(uniqueCount, key);
                    assertEquals(hash.size(), count + 1);
                    uniqueCount++;
                }
            }",method,
"                if (key >= 0) { // found in hash
                    assertFalse(longs.add(ref));
                    assertTrue(key < count);
                    assertEquals(ref, hash.get(key));
                    assertEquals(count, hash.size());
                }",method,
"    private static void assertAllIn(Set<Long> longs, LongHash hash) {
        long count = hash.size();
        for (Long l : longs) {
            long key = hash.add(l); // add again to check duplicates
            assertEquals(l.longValue(), hash.get((-key) - 1));
            assertEquals(count, hash.size());
            assertTrue(""key: "" + key + "" count: "" + count + "" long: "" + l, key < count);
        }
    }",method,
"        for (Long l : longs) {
            long key = hash.add(l); // add again to check duplicates
            assertEquals(l.longValue(), hash.get((-key) - 1));
            assertEquals(count, hash.size());
            assertTrue(""key: "" + key + "" count: "" + count + "" long: "" + l, key < count);
        }",method,
"public class RegExpElementVisitor extends PsiElementVisitor {
    public void visitRegExpElement(RegExpElement element) {
        visitElement(element);
    }
    public void visitRegExpChar(RegExpChar ch) {
        visitRegExpElement(ch);
    }
    public void visitRegExpCharRange(RegExpCharRange range) {
        visitRegExpElement(range);
    }
    public void visitSimpleClass(RegExpSimpleClass simpleClass) {
        visitRegExpElement(simpleClass);
    }
    public void visitRegExpClass(RegExpClass expClass) {
        visitRegExpElement(expClass);
    }
    public void visitRegExpGroup(RegExpGroup group) {
        visitRegExpElement(group);
    }
    public void visitRegExpOptions(RegExpOptions options) {
        visitRegExpElement(options);
    }
    public void visitRegExpProperty(RegExpProperty property) {
        visitRegExpElement(property);
    }
    public void visitRegExpNamedCharacter(RegExpNamedCharacter namedCharacter) {
        visitRegExpChar(namedCharacter);
    }
    public void visitRegExpBranch(RegExpBranch branch) {
        visitRegExpElement(branch);
    }
    public void visitRegExpPattern(RegExpPattern pattern) {
        visitRegExpElement(pattern);
    }
    public void visitRegExpBackref(RegExpBackref backref) {
        visitRegExpElement(backref);
    }
    public void visitRegExpClosure(RegExpClosure closure) {
        visitRegExpElement(closure);
    }
    public void visitRegExpQuantifier(RegExpQuantifier quantifier) {
        visitRegExpElement(quantifier);
    }
    public void visitRegExpBoundary(RegExpBoundary boundary) {
        visitRegExpElement(boundary);
    }
    public void visitRegExpSetOptions(RegExpSetOptions options) {
        visitRegExpElement(options);
    }
    public void visitRegExpIntersection(RegExpIntersection intersection) {
        visitRegExpElement(intersection);
    }
    public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
        visitRegExpElement(groupRef);
    }
    public void visitRegExpPyCondRef(RegExpPyCondRef condRef) {
        visitRegExpElement(condRef);
    }
    public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {
        visitRegExpElement(posixBracketExpression);
    }
    public void visitRegExpNumber(RegExpNumber number) {
        visitRegExpElement(number);
    }
}",class,
"    public void visitRegExpElement(RegExpElement element) {
        visitElement(element);
    }",method,
"    public void visitRegExpChar(RegExpChar ch) {
        visitRegExpElement(ch);
    }",method,
"    public void visitRegExpCharRange(RegExpCharRange range) {
        visitRegExpElement(range);
    }",method,
"    public void visitSimpleClass(RegExpSimpleClass simpleClass) {
        visitRegExpElement(simpleClass);
    }",method,
"    public void visitRegExpClass(RegExpClass expClass) {
        visitRegExpElement(expClass);
    }",method,
"    public void visitRegExpGroup(RegExpGroup group) {
        visitRegExpElement(group);
    }",method,
"    public void visitRegExpOptions(RegExpOptions options) {
        visitRegExpElement(options);
    }",method,
"    public void visitRegExpProperty(RegExpProperty property) {
        visitRegExpElement(property);
    }",method,
"    public void visitRegExpNamedCharacter(RegExpNamedCharacter namedCharacter) {
        visitRegExpChar(namedCharacter);
    }",method,
"    public void visitRegExpBranch(RegExpBranch branch) {
        visitRegExpElement(branch);
    }",method,
"    public void visitRegExpPattern(RegExpPattern pattern) {
        visitRegExpElement(pattern);
    }",method,
"    public void visitRegExpBackref(RegExpBackref backref) {
        visitRegExpElement(backref);
    }",method,
"    public void visitRegExpClosure(RegExpClosure closure) {
        visitRegExpElement(closure);
    }",method,
"    public void visitRegExpQuantifier(RegExpQuantifier quantifier) {
        visitRegExpElement(quantifier);
    }",method,
"    public void visitRegExpBoundary(RegExpBoundary boundary) {
        visitRegExpElement(boundary);
    }",method,
"    public void visitRegExpSetOptions(RegExpSetOptions options) {
        visitRegExpElement(options);
    }",method,
"    public void visitRegExpIntersection(RegExpIntersection intersection) {
        visitRegExpElement(intersection);
    }",method,
"    public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {
        visitRegExpElement(groupRef);
    }",method,
"    public void visitRegExpPyCondRef(RegExpPyCondRef condRef) {
        visitRegExpElement(condRef);
    }",method,
"    public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {
        visitRegExpElement(posixBracketExpression);
    }",method,
"    public void visitRegExpNumber(RegExpNumber number) {
        visitRegExpElement(number);
    }",method,
"public class RowVisitorAsRecordVisitor implements RecordVisitor {
    final protected RowVisitor _rowVisitor;
    public RowVisitorAsRecordVisitor(RowVisitor rowVisitor) {
        _rowVisitor = rowVisitor;
    }
    @Override
    public void start(Project project) {
        _rowVisitor.start(project);
    }
    @Override
    public void end(Project project) {
        _rowVisitor.end(project);
    }
    @Override
    public boolean visit(Project project, Record record) {
        for (int r = record.fromRowIndex; r < record.toRowIndex; r++) {
            if (_rowVisitor.visit(project, r, project.rows.get(r))) {
                return true;
            }
        }
        return false;
    }
}",class,
"    public RowVisitorAsRecordVisitor(RowVisitor rowVisitor) {
        _rowVisitor = rowVisitor;
    }",method,
"    @Override
    public void start(Project project) {
        _rowVisitor.start(project);
    }",method,
"    @Override
    public void end(Project project) {
        _rowVisitor.end(project);
    }",method,
"    @Override
    public boolean visit(Project project, Record record) {
        for (int r = record.fromRowIndex; r < record.toRowIndex; r++) {
            if (_rowVisitor.visit(project, r, project.rows.get(r))) {
                return true;
            }
        }
        return false;
    }",method,
"        for (int r = record.fromRowIndex; r < record.toRowIndex; r++) {
            if (_rowVisitor.visit(project, r, project.rows.get(r))) {
                return true;
            }
        }",method,
"public class DoubleUtilsTest extends TestCase {
  @AndroidIncompatible // no FpUtils and no Math.nextDown in old versions
  public void testNextDown() throws Exception {
    Method jdkNextDown = getJdkNextDown();
    for (double d : FINITE_DOUBLE_CANDIDATES) {
      assertEquals(jdkNextDown.invoke(null, d), DoubleUtils.nextDown(d));
    }
  }
  private static Method getJdkNextDown() throws Exception {
    try {
      return Math.class.getMethod(""nextDown"", double.class);
    } catch (NoSuchMethodException expectedBeforeJava8) {
      return Class.forName(""sun.misc.FpUtils"").getMethod(""nextDown"", double.class);
    }
  }
  @AndroidIncompatible // TODO(cpovirk): File bug for BigDecimal.doubleValue().
  public void testBigToDouble() {
    for (BigInteger b : ALL_BIGINTEGER_CANDIDATES) {
      if (b.doubleValue() != DoubleUtils.bigToDouble(b)) {
        failFormat(
            ""Converting %s to double: expected doubleValue %s but got bigToDouble %s"",
            b,
            b.doubleValue(),
            DoubleUtils.bigToDouble(b));
      }
    }
  }
  public void testEnsureNonNegative() {
    assertEquals(0.0, DoubleUtils.ensureNonNegative(0.0));
    for (double positiveValue : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      assertEquals(positiveValue, DoubleUtils.ensureNonNegative(positiveValue));
      assertEquals(0.0, DoubleUtils.ensureNonNegative(-positiveValue));
    }
    assertEquals(Double.POSITIVE_INFINITY, DoubleUtils.ensureNonNegative(Double.POSITIVE_INFINITY));
    assertEquals(0.0, DoubleUtils.ensureNonNegative(Double.NEGATIVE_INFINITY));
    try {
      DoubleUtils.ensureNonNegative(Double.NaN);
      fail(""Expected IllegalArgumentException from ensureNonNegative(Double.NaN)"");
    } catch (IllegalArgumentException expected) {
    }
  }
  public void testOneBits() {
    assertEquals(DoubleUtils.ONE_BITS, Double.doubleToRawLongBits(1.0));
  }
  private static void failFormat(String template, Object... args) {
    fail(String.format(template, args));
  }
}",class,
"  @AndroidIncompatible // no FpUtils and no Math.nextDown in old versions
  public void testNextDown() throws Exception {
    Method jdkNextDown = getJdkNextDown();
    for (double d : FINITE_DOUBLE_CANDIDATES) {
      assertEquals(jdkNextDown.invoke(null, d), DoubleUtils.nextDown(d));
    }
  }",method,
"    for (double d : FINITE_DOUBLE_CANDIDATES) {
      assertEquals(jdkNextDown.invoke(null, d), DoubleUtils.nextDown(d));
    }",method,
"  private static Method getJdkNextDown() throws Exception {
    try {
      return Math.class.getMethod(""nextDown"", double.class);
    } catch (NoSuchMethodException expectedBeforeJava8) {
      return Class.forName(""sun.misc.FpUtils"").getMethod(""nextDown"", double.class);
    }
  }",method,
"  @AndroidIncompatible // TODO(cpovirk): File bug for BigDecimal.doubleValue().
  public void testBigToDouble() {
    for (BigInteger b : ALL_BIGINTEGER_CANDIDATES) {
      if (b.doubleValue() != DoubleUtils.bigToDouble(b)) {
        failFormat(
            ""Converting %s to double: expected doubleValue %s but got bigToDouble %s"",
            b,
            b.doubleValue(),
            DoubleUtils.bigToDouble(b));
      }
    }
  }",method,
"    for (BigInteger b : ALL_BIGINTEGER_CANDIDATES) {
      if (b.doubleValue() != DoubleUtils.bigToDouble(b)) {
        failFormat(
            ""Converting %s to double: expected doubleValue %s but got bigToDouble %s"",
            b,
            b.doubleValue(),
            DoubleUtils.bigToDouble(b));
      }
    }",method,
"  public void testEnsureNonNegative() {
    assertEquals(0.0, DoubleUtils.ensureNonNegative(0.0));
    for (double positiveValue : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      assertEquals(positiveValue, DoubleUtils.ensureNonNegative(positiveValue));
      assertEquals(0.0, DoubleUtils.ensureNonNegative(-positiveValue));
    }
    assertEquals(Double.POSITIVE_INFINITY, DoubleUtils.ensureNonNegative(Double.POSITIVE_INFINITY));
    assertEquals(0.0, DoubleUtils.ensureNonNegative(Double.NEGATIVE_INFINITY));
    try {
      DoubleUtils.ensureNonNegative(Double.NaN);
      fail(""Expected IllegalArgumentException from ensureNonNegative(Double.NaN)"");
    } catch (IllegalArgumentException expected) {
    }
  }",method,
"    for (double positiveValue : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      assertEquals(positiveValue, DoubleUtils.ensureNonNegative(positiveValue));
      assertEquals(0.0, DoubleUtils.ensureNonNegative(-positiveValue));
    }",method,
"  public void testOneBits() {
    assertEquals(DoubleUtils.ONE_BITS, Double.doubleToRawLongBits(1.0));
  }",method,
"  private static void failFormat(String template, Object... args) {
    fail(String.format(template, args));
  }",method,
"public class SlidingPreferenceActivity extends PreferenceActivity implements SlidingActivityBase {
	private SlidingActivityHelper mHelper;
	@Override
	public void onCreate(Bundle savedInstanceState) {
		mHelper = new SlidingActivityHelper(this);
		super.onCreate(savedInstanceState);
		mHelper.onCreate(savedInstanceState);
	}
	@Override
	public void onPostCreate(Bundle savedInstanceState) {
		super.onPostCreate(savedInstanceState);
		mHelper.onPostCreate(savedInstanceState);
	}
	@Override
	public View findViewById(int id) {
		View v = super.findViewById(id);
		if (v != null)
			return v;
		return mHelper.findViewById(id);
	}
	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		mHelper.onSaveInstanceState(outState);
	}
	@Override
	public void setContentView(int id) {
		setContentView(getLayoutInflater().inflate(id, null));
	}
	@Override
	public void setContentView(View v) {
		setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
	}
	@Override
	public void setContentView(View v, LayoutParams params) {
		super.setContentView(v, params);
		mHelper.registerAboveContentView(v, params);
	}
	public void setBehindContentView(int id) {
		setBehindContentView(getLayoutInflater().inflate(id, null));
	}
	public void setBehindContentView(View v) {
		setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
	}
	public void setBehindContentView(View v, LayoutParams params) {
		mHelper.setBehindContentView(v, params);
	}
	public SlidingMenu getSlidingMenu() {
		return mHelper.getSlidingMenu();
	}
	public void toggle() {
		mHelper.toggle();
	}
	public void showContent() {
		mHelper.showContent();
	}
	public void showMenu() {
		mHelper.showMenu();
	}
	public void showSecondaryMenu() {
		mHelper.showSecondaryMenu();
	}
	public void setSlidingActionBarEnabled(boolean b) {
		mHelper.setSlidingActionBarEnabled(b);
	}
	@Override
	public boolean onKeyUp(int keyCode, KeyEvent event) {
		boolean b = mHelper.onKeyUp(keyCode, event);
		if (b) return b;
		return super.onKeyUp(keyCode, event);
	}
}",class,
"	@Override
	public void onCreate(Bundle savedInstanceState) {
		mHelper = new SlidingActivityHelper(this);
		super.onCreate(savedInstanceState);
		mHelper.onCreate(savedInstanceState);
	}",method,
"	@Override
	public void onPostCreate(Bundle savedInstanceState) {
		super.onPostCreate(savedInstanceState);
		mHelper.onPostCreate(savedInstanceState);
	}",method,
"	@Override
	public View findViewById(int id) {
		View v = super.findViewById(id);
		if (v != null)
			return v;
		return mHelper.findViewById(id);
	}",method,
"	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		mHelper.onSaveInstanceState(outState);
	}",method,
"	@Override
	public void setContentView(int id) {
		setContentView(getLayoutInflater().inflate(id, null));
	}",method,
"	@Override
	public void setContentView(View v) {
		setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
	}",method,
"	@Override
	public void setContentView(View v, LayoutParams params) {
		super.setContentView(v, params);
		mHelper.registerAboveContentView(v, params);
	}",method,
"	public void setBehindContentView(int id) {
		setBehindContentView(getLayoutInflater().inflate(id, null));
	}",method,
"	public void setBehindContentView(View v) {
		setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
	}",method,
"	public void setBehindContentView(View v, LayoutParams params) {
		mHelper.setBehindContentView(v, params);
	}",method,
"	public SlidingMenu getSlidingMenu() {
		return mHelper.getSlidingMenu();
	}",method,
"	public void toggle() {
		mHelper.toggle();
	}",method,
"	public void showContent() {
		mHelper.showContent();
	}",method,
"	public void showMenu() {
		mHelper.showMenu();
	}",method,
"	public void showSecondaryMenu() {
		mHelper.showSecondaryMenu();
	}",method,
"	public void setSlidingActionBarEnabled(boolean b) {
		mHelper.setSlidingActionBarEnabled(b);
	}",method,
"	@Override
	public boolean onKeyUp(int keyCode, KeyEvent event) {
		boolean b = mHelper.onKeyUp(keyCode, event);
		if (b) return b;
		return super.onKeyUp(keyCode, event);
	}",method,
"public class FrontSearchController extends BaseController{
	@Autowired
	private ArticleService articleService;
	@Autowired
	private GuestbookService guestbookService;
	@RequestMapping(value = """")
	public String search(String t, @RequestParam(required=false) String q, @RequestParam(required=false) String qand, @RequestParam(required=false) String qnot, 
			@RequestParam(required=false) String a, @RequestParam(required=false) String cid, @RequestParam(required=false) String bd,
			@RequestParam(required=false) String ed, HttpServletRequest request, HttpServletResponse response, Model model) {
		long start = System.currentTimeMillis();
		Site site = CmsUtils.getSite(Site.defaultSiteId());
		model.addAttribute(""site"", site);
		// 重建索引（需要超级管理员权限）
		if (""cmd:reindex"".equals(q)){
			if (UserUtils.getUser().isAdmin()){
				// 文章模型
				if (StringUtils.isBlank(t) || ""article"".equals(t)){
					articleService.createIndex();
				}
				// 留言模型
				else if (""guestbook"".equals(t)){
					guestbookService.createIndex();
				}
				model.addAttribute(""message"", ""重建索引成功，共耗时 "" + (System.currentTimeMillis() - start) + ""毫秒。"");
			}else{
				model.addAttribute(""message"", ""你没有执行权限。"");
			}
		}
		// 执行检索
		else{
			String qStr = StringUtils.replace(StringUtils.replace(q, ""，"", "" ""), "", "", "" "");
			// 如果是高级搜索
			if (""1"".equals(a)){
				if (StringUtils.isNotBlank(qand)){
					qStr += "" +"" + StringUtils.replace(StringUtils.replace(StringUtils.replace(qand, ""，"", "" ""), "", "", "" ""), "" "", "" +""); 
				}
				if (StringUtils.isNotBlank(qnot)){
					qStr += "" -"" + StringUtils.replace(StringUtils.replace(StringUtils.replace(qnot, ""，"", "" ""), "", "", "" ""), "" "", "" -""); 
				}
			}
			// 文章检索
			if (StringUtils.isBlank(t) || ""article"".equals(t)){
				Page<Article> page = articleService.search(new Page<Article>(request, response), qStr, cid, bd, ed);
				page.setMessage(""匹配结果，共耗时 "" + (System.currentTimeMillis() - start) + ""毫秒。"");
				model.addAttribute(""page"", page);
			}
			// 留言检索
			else if (""guestbook"".equals(t)){
				Page<Guestbook> page = guestbookService.search(new Page<Guestbook>(request, response), qStr, bd, ed);
				page.setMessage(""匹配结果，共耗时 "" + (System.currentTimeMillis() - start) + ""毫秒。"");
				model.addAttribute(""page"", page);
			}
		}
		model.addAttribute(""t"", t);// 搜索类型
		model.addAttribute(""q"", q);// 搜索关键字
		model.addAttribute(""qand"", qand);// 包含以下全部的关键词
		model.addAttribute(""qnot"", qnot);// 不包含以下关键词
		model.addAttribute(""cid"", cid);// 搜索类型
		return ""modules/cms/front/themes/""+site.getTheme()+""/frontSearch"";
	}
}",class,
"public class FieldAttributesTest extends TestCase {
  private FieldAttributes fieldAttributes;
  @Override
  protected void setUp() throws Exception {
    super.setUp();
    fieldAttributes = new FieldAttributes(Foo.class.getField(""bar""));
  }
  public void testNullField() throws Exception {
    try {
      new FieldAttributes(null);
      fail(""Field parameter can not be null"");
    } catch (NullPointerException expected) { }
  }
  public void testDeclaringClass() throws Exception {
    assertEquals(Foo.class, fieldAttributes.getDeclaringClass());
  }
  public void testModifiers() throws Exception {
    assertFalse(fieldAttributes.hasModifier(Modifier.STATIC));
    assertFalse(fieldAttributes.hasModifier(Modifier.FINAL));
    assertFalse(fieldAttributes.hasModifier(Modifier.ABSTRACT));
    assertFalse(fieldAttributes.hasModifier(Modifier.VOLATILE));
    assertFalse(fieldAttributes.hasModifier(Modifier.PROTECTED));
    assertTrue(fieldAttributes.hasModifier(Modifier.PUBLIC));
    assertTrue(fieldAttributes.hasModifier(Modifier.TRANSIENT));
  }
  public void testIsSynthetic() throws Exception {
    assertFalse(fieldAttributes.isSynthetic());
  }
  public void testName() throws Exception {
    assertEquals(""bar"", fieldAttributes.getName());
  }
  public void testDeclaredTypeAndClass() throws Exception {
    Type expectedType = new TypeToken<List<String>>() {}.getType();
    assertEquals(expectedType, fieldAttributes.getDeclaredType());
    assertEquals(List.class, fieldAttributes.getDeclaredClass());
  }
  private static class Foo {
    @SuppressWarnings(""unused"")
    public transient List<String> bar;
  }
}",class,
"  private static class Foo {
    @SuppressWarnings(""unused"")
    public transient List<String> bar;
  }",class,
"  @Override
  protected void setUp() throws Exception {
    super.setUp();
    fieldAttributes = new FieldAttributes(Foo.class.getField(""bar""));
  }",method,
"  public void testNullField() throws Exception {
    try {
      new FieldAttributes(null);
      fail(""Field parameter can not be null"");
    } catch (NullPointerException expected) { }
  }",method,
"  public void testDeclaringClass() throws Exception {
    assertEquals(Foo.class, fieldAttributes.getDeclaringClass());
  }",method,
"  public void testModifiers() throws Exception {
    assertFalse(fieldAttributes.hasModifier(Modifier.STATIC));
    assertFalse(fieldAttributes.hasModifier(Modifier.FINAL));
    assertFalse(fieldAttributes.hasModifier(Modifier.ABSTRACT));
    assertFalse(fieldAttributes.hasModifier(Modifier.VOLATILE));
    assertFalse(fieldAttributes.hasModifier(Modifier.PROTECTED));
    assertTrue(fieldAttributes.hasModifier(Modifier.PUBLIC));
    assertTrue(fieldAttributes.hasModifier(Modifier.TRANSIENT));
  }",method,
"  public void testIsSynthetic() throws Exception {
    assertFalse(fieldAttributes.isSynthetic());
  }",method,
"  public void testName() throws Exception {
    assertEquals(""bar"", fieldAttributes.getName());
  }",method,
"  public void testDeclaredTypeAndClass() throws Exception {
    Type expectedType = new TypeToken<List<String>>() {}.getType();
    assertEquals(expectedType, fieldAttributes.getDeclaredType());
    assertEquals(List.class, fieldAttributes.getDeclaredClass());
  }",method,
"public final class ObservableSkipLast<T> extends AbstractObservableWithUpstream<T, T> {
    final int skip;
    public ObservableSkipLast(ObservableSource<T> source, int skip) {
        super(source);
        this.skip = skip;
    }
    @Override
    public void subscribeActual(Observer<? super T> s) {
        source.subscribe(new SkipLastObserver<T>(s, skip));
    }
    static final class SkipLastObserver<T> extends ArrayDeque<T> implements Observer<T>, Disposable {
        private static final long serialVersionUID = -3807491841935125653L;
        final Observer<? super T> actual;
        final int skip;
        Disposable s;
        SkipLastObserver(Observer<? super T> actual, int skip) {
            super(skip);
            this.actual = actual;
            this.skip = skip;
        }
        @Override
        public void onSubscribe(Disposable s) {
            if (DisposableHelper.validate(this.s, s)) {
                this.s = s;
                actual.onSubscribe(this);
            }
        }
        @Override
        public void dispose() {
            s.dispose();
        }
        @Override
        public boolean isDisposed() {
            return s.isDisposed();
        }
        @Override
        public void onNext(T t) {
            if (skip == size()) {
                actual.onNext(poll());
            }
            offer(t);
        }
        @Override
        public void onError(Throwable t) {
            actual.onError(t);
        }
        @Override
        public void onComplete() {
            actual.onComplete();
        }
    }
}",class,
"    static final class SkipLastObserver<T> extends ArrayDeque<T> implements Observer<T>, Disposable {
        private static final long serialVersionUID = -3807491841935125653L;
        final Observer<? super T> actual;
        final int skip;
        Disposable s;
        SkipLastObserver(Observer<? super T> actual, int skip) {
            super(skip);
            this.actual = actual;
            this.skip = skip;
        }
        @Override
        public void onSubscribe(Disposable s) {
            if (DisposableHelper.validate(this.s, s)) {
                this.s = s;
                actual.onSubscribe(this);
            }
        }
        @Override
        public void dispose() {
            s.dispose();
        }
        @Override
        public boolean isDisposed() {
            return s.isDisposed();
        }
        @Override
        public void onNext(T t) {
            if (skip == size()) {
                actual.onNext(poll());
            }
            offer(t);
        }
        @Override
        public void onError(Throwable t) {
            actual.onError(t);
        }
        @Override
        public void onComplete() {
            actual.onComplete();
        }
    }",class,
"    public ObservableSkipLast(ObservableSource<T> source, int skip) {
        super(source);
        this.skip = skip;
    }",method,
"    @Override
    public void subscribeActual(Observer<? super T> s) {
        source.subscribe(new SkipLastObserver<T>(s, skip));
    }",method,
"        SkipLastObserver(Observer<? super T> actual, int skip) {
            super(skip);
            this.actual = actual;
            this.skip = skip;
        }",method,
"        @Override
        public void onSubscribe(Disposable s) {
            if (DisposableHelper.validate(this.s, s)) {
                this.s = s;
                actual.onSubscribe(this);
            }
        }",method,
"        @Override
        public void dispose() {
            s.dispose();
        }",method,
"        @Override
        public boolean isDisposed() {
            return s.isDisposed();
        }",method,
"        @Override
        public void onNext(T t) {
            if (skip == size()) {
                actual.onNext(poll());
            }
            offer(t);
        }",method,
"        @Override
        public void onError(Throwable t) {
            actual.onError(t);
        }",method,
"        @Override
        public void onComplete() {
            actual.onComplete();
        }",method,
"public class InsertionSorter<T> extends Sorter<T> {
	// ===========================================================
	// Constants
	// ===========================================================
	// ===========================================================
	// Fields
	// ===========================================================
	// ===========================================================
	// Constructors
	// ===========================================================
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	@Override
	public void sort(final T[] pArray, final int pStart, final int pEnd, final Comparator<T> pComparator) {
		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pArray[i];
			T prev = pArray[i - 1];
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pArray[j--] = prev;
				} while(j > pStart && pComparator.compare(current, prev = pArray[j - 1]) < 0);
				pArray[j] = current;
			}
		}
		return;
	}
	@Override
	public void sort(final List<T> pList, final int pStart, final int pEnd, final Comparator<T> pComparator) {
		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pList.get(i);
			T prev = pList.get(i - 1);
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pList.set(j--, prev);
				} while(j > pStart && pComparator.compare(current, prev = pList.get(j - 1)) < 0);
				pList.set(j, current);
			}
		}
		return;
	}
	@Override
	public void sort(final IList<T> pList, final int pStart, final int pEnd, final Comparator<T> pComparator) {
		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pList.get(i);
			T prev = pList.get(i - 1);
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pList.set(j--, prev);
				} while(j > pStart && pComparator.compare(current, prev = pList.get(j - 1)) < 0);
				pList.set(j, current);
			}
		}
		return;
	}
	// ===========================================================
	// Methods
	// ===========================================================
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	@Override
	public void sort(final T[] pArray, final int pStart, final int pEnd, final Comparator<T> pComparator) {
		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pArray[i];
			T prev = pArray[i - 1];
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pArray[j--] = prev;
				} while(j > pStart && pComparator.compare(current, prev = pArray[j - 1]) < 0);
				pArray[j] = current;
			}
		}
		return;
	}",method,
"		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pArray[i];
			T prev = pArray[i - 1];
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pArray[j--] = prev;
				} while(j > pStart && pComparator.compare(current, prev = pArray[j - 1]) < 0);
				pArray[j] = current;
			}
		}",method,
"	@Override
	public void sort(final List<T> pList, final int pStart, final int pEnd, final Comparator<T> pComparator) {
		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pList.get(i);
			T prev = pList.get(i - 1);
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pList.set(j--, prev);
				} while(j > pStart && pComparator.compare(current, prev = pList.get(j - 1)) < 0);
				pList.set(j, current);
			}
		}
		return;
	}",method,
"		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pList.get(i);
			T prev = pList.get(i - 1);
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pList.set(j--, prev);
				} while(j > pStart && pComparator.compare(current, prev = pList.get(j - 1)) < 0);
				pList.set(j, current);
			}
		}",method,
"	@Override
	public void sort(final IList<T> pList, final int pStart, final int pEnd, final Comparator<T> pComparator) {
		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pList.get(i);
			T prev = pList.get(i - 1);
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pList.set(j--, prev);
				} while(j > pStart && pComparator.compare(current, prev = pList.get(j - 1)) < 0);
				pList.set(j, current);
			}
		}
		return;
	}",method,
"		for(int i = pStart + 1; i < pEnd; i++) {
			final T current = pList.get(i);
			T prev = pList.get(i - 1);
			if(pComparator.compare(current, prev) < 0) {
				int j = i;
				do {
					pList.set(j--, prev);
				} while(j > pStart && pComparator.compare(current, prev = pList.get(j - 1)) < 0);
				pList.set(j, current);
			}
		}",method,
"public class Change {
  private int myHash;
  public enum Type {
    MODIFICATION,
    NEW,
    DELETED,
    MOVED
  }
  private final ContentRevision myBeforeRevision;
  private final ContentRevision myAfterRevision;
  private final FileStatus myFileStatus;
  protected String myMoveRelativePath;
  protected boolean myRenamed;
  protected boolean myMoved;
  protected boolean myRenameOrMoveCached = false;
  private boolean myIsReplaced;
  private Type myType;
  private Map<String, Change> myOtherLayers;
  public Change(@Nullable final ContentRevision beforeRevision, @Nullable final ContentRevision afterRevision) {
    this(beforeRevision, afterRevision, convertStatus(beforeRevision, afterRevision));
  }
  public Change(@Nullable final ContentRevision beforeRevision, @Nullable final ContentRevision afterRevision, @Nullable FileStatus fileStatus) {
    assert beforeRevision != null || afterRevision != null;
    myBeforeRevision = beforeRevision;
    myAfterRevision = afterRevision;
    myFileStatus = fileStatus == null ? convertStatus(beforeRevision, afterRevision) : fileStatus;
    myHash = -1;
    myOtherLayers = null;
  }
  private static FileStatus convertStatus(@Nullable ContentRevision beforeRevision, @Nullable ContentRevision afterRevision) {
    if (beforeRevision == null) return FileStatus.ADDED;
    if (afterRevision == null) return FileStatus.DELETED;
    return FileStatus.MODIFIED;
  }
  public void addAdditionalLayerElement(final String name, final Change change) {
    if (myOtherLayers == null) myOtherLayers = new HashMap<>(1);
    myOtherLayers.put(name, change);
  }
  @NotNull
  public Map<String, Change> getOtherLayers() {
    return ContainerUtil.notNullize(myOtherLayers);
  }
  public Type getType() {
    Type type = myType;
    if (type == null) {
      myType = type = calcType();
    }
    return type;
  }
  @NotNull
  private Type calcType() {
    if (myBeforeRevision == null) return Type.NEW;
    if (myAfterRevision == null) return Type.DELETED;
    FilePath bFile = myBeforeRevision.getFile();
    FilePath aFile = myAfterRevision.getFile();
    if (!Comparing.equal(bFile, aFile)) return Type.MOVED;
    // enforce case-sensitive check
    if (!SystemInfo.isFileSystemCaseSensitive) {
      String bPath = bFile.getPath();
      String aPath = aFile.getPath();
      if (!bPath.equals(aPath) && bPath.equalsIgnoreCase(aPath)) return Type.MOVED;
    }
    return Type.MODIFICATION;
  }
  @Nullable
  public ContentRevision getBeforeRevision() {
    return myBeforeRevision;
  }
  @Nullable
  public ContentRevision getAfterRevision() {
    return myAfterRevision;
  }
  @NotNull
  public FileStatus getFileStatus() {
    return myFileStatus;
  }
  @Nullable
  public VirtualFile getVirtualFile() {
    return myAfterRevision == null ? null : myAfterRevision.getFile().getVirtualFile();
  }
  public boolean equals(final Object o) {
    if (this == o) return true;
    if (o == null || (! (o instanceof Change))) return false;
    final Change otherChange = ((Change)o);
    final ContentRevision br1 = getBeforeRevision();
    final ContentRevision br2 = otherChange.getBeforeRevision();
    final ContentRevision ar1 = getAfterRevision();
    final ContentRevision ar2 = otherChange.getAfterRevision();
    FilePath fbr1 = br1 != null ? br1.getFile() : null;
    FilePath fbr2 = br2 != null ? br2.getFile() : null;
    FilePath far1 = ar1 != null ? ar1.getFile() : null;
    FilePath far2 = ar2 != null ? ar2.getFile() : null;
    return Comparing.equal(fbr1, fbr2) && Comparing.equal(far1, far2);
  }
  public int hashCode() {
    if (myHash == -1) {
      myHash = calculateHash();
    }
    return myHash;
  }
  private int calculateHash() {
    return revisionHashCode(getBeforeRevision()) * 27 + revisionHashCode(getAfterRevision());
  }
  private static int revisionHashCode(@Nullable ContentRevision rev) {
    return rev != null ? rev.getFile().hashCode() : 0;
  }
  public boolean affectsFile(File ioFile) {
    if (myBeforeRevision != null && myBeforeRevision.getFile().getIOFile().equals(ioFile)) return true;
    if (myAfterRevision != null && myAfterRevision.getFile().getIOFile().equals(ioFile)) return true;
    return false;
  }
  public boolean isRenamed() {
    cacheRenameOrMove(null);
    return myRenamed;
  }
  public boolean isMoved() {
    cacheRenameOrMove(null);
    return myMoved;
  }
  public String getMoveRelativePath(Project project) {
    cacheRenameOrMove(project);
    return myMoveRelativePath;
  }
  private void cacheRenameOrMove(final Project project) {
    if (myBeforeRevision != null && myAfterRevision != null && (! revisionPathsSame())) {
      if (!myRenameOrMoveCached) {
        myRenameOrMoveCached = true;
        if (Comparing.equal(myBeforeRevision.getFile().getParentPath(), myAfterRevision.getFile().getParentPath())) {
          myRenamed = true;
        }
        else {
          myMoved = true;
        }
      }
      if (myMoved && myMoveRelativePath == null && project != null) {
        myMoveRelativePath = VcsPathPresenter.getInstance(project).getPresentableRelativePath(myBeforeRevision, myAfterRevision);
      }
    }
  }
  private boolean revisionPathsSame() {
    final String path1 = myBeforeRevision.getFile().getPath();
    final String path2 = myAfterRevision.getFile().getPath();
    // intentionally comparing case-sensitively even on case-insensitive OS to identify case-only renames
    return path1.equals(path2);
  }
  @NonNls
  public String toString() {
    final Type type = getType();
    //noinspection EnumSwitchStatementWhichMissesCases
    switch (type) {
      case NEW: return ""A: "" + myAfterRevision;
      case DELETED: return ""D: "" + myBeforeRevision;
      case MOVED: return ""M: "" + myBeforeRevision + "" -> "" + myAfterRevision;
      default: return ""M: "" + myAfterRevision;
    }
  }
  @Nullable
  public String getOriginText(final Project project) {
    cacheRenameOrMove(project);
    if (isMoved()) {
      return getMovedText(project);
    } else if (isRenamed()) {
      return getRenamedText();
    }
    return myIsReplaced ? VcsBundle.message(""change.file.replaced.text"") : null;
  }
  @Nullable
  protected String getRenamedText() {
    return VcsBundle.message(""change.file.renamed.from.text"", myBeforeRevision.getFile().getName());
  }
  @Nullable
  protected String getMovedText(final Project project) {
    return VcsBundle.message(""change.file.moved.from.text"", getMoveRelativePath(project));
  }
  public boolean isIsReplaced() {
    return myIsReplaced;
  }
  public void setIsReplaced(final boolean isReplaced) {
    myIsReplaced = isReplaced;
  }
  @Nullable
  public Icon getAdditionalIcon() {
    return null;
  }
  @Nullable
  public String getDescription() {
    return null;
  }
}",class,
"  public Change(@Nullable final ContentRevision beforeRevision, @Nullable final ContentRevision afterRevision) {
    this(beforeRevision, afterRevision, convertStatus(beforeRevision, afterRevision));
  }",method,
"  public Change(@Nullable final ContentRevision beforeRevision, @Nullable final ContentRevision afterRevision, @Nullable FileStatus fileStatus) {
    assert beforeRevision != null || afterRevision != null;
    myBeforeRevision = beforeRevision;
    myAfterRevision = afterRevision;
    myFileStatus = fileStatus == null ? convertStatus(beforeRevision, afterRevision) : fileStatus;
    myHash = -1;
    myOtherLayers = null;
  }",method,
"  private static FileStatus convertStatus(@Nullable ContentRevision beforeRevision, @Nullable ContentRevision afterRevision) {
    if (beforeRevision == null) return FileStatus.ADDED;
    if (afterRevision == null) return FileStatus.DELETED;
    return FileStatus.MODIFIED;
  }",method,
"  public void addAdditionalLayerElement(final String name, final Change change) {
    if (myOtherLayers == null) myOtherLayers = new HashMap<>(1);
    myOtherLayers.put(name, change);
  }",method,
"  @NotNull
  public Map<String, Change> getOtherLayers() {
    return ContainerUtil.notNullize(myOtherLayers);
  }",method,
"  public Type getType() {
    Type type = myType;
    if (type == null) {
      myType = type = calcType();
    }
    return type;
  }",method,
"    if (type == null) {
      myType = type = calcType();
    }",method,
"  @NotNull
  private Type calcType() {
    if (myBeforeRevision == null) return Type.NEW;
    if (myAfterRevision == null) return Type.DELETED;
    FilePath bFile = myBeforeRevision.getFile();
    FilePath aFile = myAfterRevision.getFile();
    if (!Comparing.equal(bFile, aFile)) return Type.MOVED;
    // enforce case-sensitive check
    if (!SystemInfo.isFileSystemCaseSensitive) {
      String bPath = bFile.getPath();
      String aPath = aFile.getPath();
      if (!bPath.equals(aPath) && bPath.equalsIgnoreCase(aPath)) return Type.MOVED;
    }
    return Type.MODIFICATION;
  }",method,

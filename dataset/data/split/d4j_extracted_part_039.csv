code_snippet,type,score
"  @Override
  public ByteBuffer read(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    int read = socketChannel.read(buffer);
    buffer.flip();
    if (read == -1) {
      throw new IOException(""Socket closed"");
    }
    return buffer;
  }",method,
"    if (read == -1) {
      throw new IOException(""Socket closed"");
    }",method,
"  @Override
  public void bind() throws IOException {
    ((ServerSocketChannel) getJavaChannel()).socket().bind(
        new InetSocketAddress(InetAddress.getLocalHost(), port));
    ((ServerSocketChannel) getJavaChannel()).configureBlocking(false);
    LOGGER.info(""Bound TCP socket at port: {}"", port);
  }",method,
"  @Override
  protected void doWrite(Object pendingWrite, SelectionKey key) throws IOException {
    ByteBuffer pendingBuffer = (ByteBuffer) pendingWrite;
    ((SocketChannel) key.channel()).write(pendingBuffer);
  }",method,
"public class PXLoader {
	// ===========================================================
	// Constants
	// ===========================================================
	// ===========================================================
	// Fields
	// ===========================================================
	private final Context mContext;
	private final TextureManager mTextureManager;
	private final TextureOptions mTextureOptions;
	// ===========================================================
	// Constructors
	// ===========================================================
	public PXLoader(final Context pContext, final TextureManager pTextureManager) {
		this(pContext, pTextureManager, TextureOptions.DEFAULT);
	}
	public PXLoader(final Context pContext, final TextureManager pTextureManager, final TextureOptions pTextureOptions) {
		this.mContext = pContext;
		this.mTextureManager = pTextureManager;
		this.mTextureOptions = pTextureOptions;
	}
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	// ===========================================================
	// Methods
	// ===========================================================
	public ParticleSystem createFromAsset(final Context pContext, final String pAssetPath) throws PXLoadException {
		try {
			return this.load(pContext.getAssets().open(pAssetPath));
		} catch (final IOException e) {
			throw new PXLoadException(""Could not load ParticleSystem from asset: "" + pAssetPath, e);
		}
	}
	public ParticleSystem load(final InputStream pInputStream) throws PXLoadException {
		try{
			final SAXParserFactory spf = SAXParserFactory.newInstance();
			final SAXParser sp = spf.newSAXParser();
			final XMLReader xr = sp.getXMLReader();
			final PXParser pxParser = new PXParser(this.mContext, this.mTextureManager, this.mTextureOptions);
			xr.setContentHandler(pxParser);
			xr.parse(new InputSource(new BufferedInputStream(pInputStream)));
			return pxParser.getPXSystem();
		} catch (final SAXException e) {
			throw new PXLoadException(e);
		} catch (final ParserConfigurationException pe) {
			return null;
		} catch (final IOException e) {
			throw new PXLoadException(e);
		}
	}
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
		// ===========================================================
		// Final Fields
		// ===========================================================
		// ===========================================================
		// Methods
		// ===========================================================
}",class,
"public class PXLoadException extends Exception {
		// ===========================================================
		// Constants
		// ===========================================================
		//private static final long serialVersionUID = -8295358631698809883L;
		// ===========================================================
		// Fields
		// ===========================================================
		// ===========================================================
		// Constructors
		// ===========================================================
		public PXLoadException() {
			super();
		}
		public PXLoadException(final String pDetailMessage, final Throwable pThrowable) {
			super(pDetailMessage, pThrowable);
		}
		public PXLoadException(final String pDetailMessage) {
			super(pDetailMessage);
		}
		public PXLoadException(final Throwable pThrowable) {
			super(pThrowable);
		}
		// ===========================================================
		// Getter & Setter
		// ===========================================================
		// ===========================================================
		// Methods for/from SuperClass/Interfaces
		// ===========================================================
		// ===========================================================
		// Methods
		// ===========================================================
		// ===========================================================
		// Inner and Anonymous Classes
		// ===========================================================
}",class,
"	public PXLoader(final Context pContext, final TextureManager pTextureManager) {
		this(pContext, pTextureManager, TextureOptions.DEFAULT);
	}",method,
"	public PXLoader(final Context pContext, final TextureManager pTextureManager, final TextureOptions pTextureOptions) {
		this.mContext = pContext;
		this.mTextureManager = pTextureManager;
		this.mTextureOptions = pTextureOptions;
	}",method,
"	public ParticleSystem createFromAsset(final Context pContext, final String pAssetPath) throws PXLoadException {
		try {
			return this.load(pContext.getAssets().open(pAssetPath));
		} catch (final IOException e) {
			throw new PXLoadException(""Could not load ParticleSystem from asset: "" + pAssetPath, e);
		}
	}",method,
"	public ParticleSystem load(final InputStream pInputStream) throws PXLoadException {
		try{
			final SAXParserFactory spf = SAXParserFactory.newInstance();
			final SAXParser sp = spf.newSAXParser();
			final XMLReader xr = sp.getXMLReader();
			final PXParser pxParser = new PXParser(this.mContext, this.mTextureManager, this.mTextureOptions);
			xr.setContentHandler(pxParser);
			xr.parse(new InputSource(new BufferedInputStream(pInputStream)));
			return pxParser.getPXSystem();
		} catch (final SAXException e) {
			throw new PXLoadException(e);
		} catch (final ParserConfigurationException pe) {
			return null;
		} catch (final IOException e) {
			throw new PXLoadException(e);
		}
	}",method,
"		public PXLoadException() {
			super();
		}",method,
"		public PXLoadException(final String pDetailMessage, final Throwable pThrowable) {
			super(pDetailMessage, pThrowable);
		}",method,
"		public PXLoadException(final String pDetailMessage) {
			super(pDetailMessage);
		}",method,
"		public PXLoadException(final Throwable pThrowable) {
			super(pThrowable);
		}",method,
"public abstract class ProxyResultSet implements ResultSet
{
   protected final ProxyConnection connection;
   protected final ProxyStatement statement;
   final ResultSet delegate;
   protected ProxyResultSet(ProxyConnection connection, ProxyStatement statement, ResultSet resultSet)
   {
      this.connection = connection;
      this.statement = statement;
      this.delegate = resultSet;
   }
   @SuppressWarnings(""unused"")
   final SQLException checkException(SQLException e)
   {
      return connection.checkException(e);
   }
   @Override
   public String toString()
   {
      return this.getClass().getSimpleName() + '@' + System.identityHashCode(this) + "" wrapping "" + delegate;
   }
   // **********************************************************************
   //                 Overridden java.sql.ResultSet Methods
   // **********************************************************************
   @Override
   public final Statement getStatement() throws SQLException
   {
      return statement;
   }
   @Override
   public void updateRow() throws SQLException
   {
      connection.markCommitStateDirty();
      delegate.updateRow();
   }
   @Override
   public void insertRow() throws SQLException
   {
      connection.markCommitStateDirty();
      delegate.insertRow();
   }
   @Override
   public void deleteRow() throws SQLException
   {
      connection.markCommitStateDirty();
      delegate.deleteRow();
   }
   @Override
   @SuppressWarnings(""unchecked"")
   public final <T> T unwrap(Class<T> iface) throws SQLException
   {
      if (iface.isInstance(delegate)) {
         return (T) delegate;
      }
      else if (delegate != null) {
          return delegate.unwrap(iface);
      }
      throw new SQLException(""Wrapped ResultSet is not an instance of "" + iface);
   }
}",class,
"   protected ProxyResultSet(ProxyConnection connection, ProxyStatement statement, ResultSet resultSet)
   {
      this.connection = connection;
      this.statement = statement;
      this.delegate = resultSet;
   }",method,
"   @SuppressWarnings(""unused"")
   final SQLException checkException(SQLException e)
   {
      return connection.checkException(e);
   }",method,
"   @Override
   public String toString()
   {
      return this.getClass().getSimpleName() + '@' + System.identityHashCode(this) + "" wrapping "" + delegate;
   }",method,
"   @Override
   public final Statement getStatement() throws SQLException
   {
      return statement;
   }",method,
"   @Override
   public void updateRow() throws SQLException
   {
      connection.markCommitStateDirty();
      delegate.updateRow();
   }",method,
"   @Override
   public void insertRow() throws SQLException
   {
      connection.markCommitStateDirty();
      delegate.insertRow();
   }",method,
"   @Override
   public void deleteRow() throws SQLException
   {
      connection.markCommitStateDirty();
      delegate.deleteRow();
   }",method,
"   @Override
   @SuppressWarnings(""unchecked"")
   public final <T> T unwrap(Class<T> iface) throws SQLException
   {
      if (iface.isInstance(delegate)) {
         return (T) delegate;
      }
      else if (delegate != null) {
          return delegate.unwrap(iface);
      }
      throw new SQLException(""Wrapped ResultSet is not an instance of "" + iface);
   }",method,
"      else if (delegate != null) {
          return delegate.unwrap(iface);
      }",method,
"public class LineCountEmitter extends com.icl.saxon.output.Emitter {
  protected int numLines = 0;
  public LineCountEmitter() {
    numLines = 0;
  }
  public void reset() {
    numLines = 0;
  }
  public int lineCount() {
    return numLines;
  }
  public void characters(char[] chars, int start, int len)
    throws javax.xml.transform.TransformerException {
    if (numLines == 0) {
      // If there are any characters at all, there's at least one line
      numLines++;
    }
    for (int count = start; count < start+len; count++) {
      if (chars[count] == '\n') {
	numLines++;
      }
    }
  }
  public void comment(char[] chars, int start, int length)
    throws javax.xml.transform.TransformerException {
    // nop
  }
  public void endDocument()
    throws javax.xml.transform.TransformerException {
    // nop
  }
  public void endElement(int nameCode)
    throws javax.xml.transform.TransformerException {
    // nop
  }
  public void processingInstruction(java.lang.String name,
				    java.lang.String data)
    throws javax.xml.transform.TransformerException {
    // nop
  }
  public void setDocumentLocator(org.xml.sax.Locator locator) {
    // nop
  }
  public void setEscaping(boolean escaping)
    throws javax.xml.transform.TransformerException {
    // nop
  }
  public void setNamePool(NamePool namePool) {
    // nop
  }
  public void setUnparsedEntity(java.lang.String name, java.lang.String uri)
    throws javax.xml.transform.TransformerException {
    // nop
  }
  public void setWriter(java.io.Writer writer) {
    // nop
  }
  public void startDocument()
    throws javax.xml.transform.TransformerException {
    // nop
  }
  public void startElement(int nameCode,
		    org.xml.sax.Attributes attributes,
		    int[] namespaces, int nscount)
    throws javax.xml.transform.TransformerException {
    // nop
  }
}",class,
"  public LineCountEmitter() {
    numLines = 0;
  }",method,
"  public void reset() {
    numLines = 0;
  }",method,
"  public int lineCount() {
    return numLines;
  }",method,
"  public void characters(char[] chars, int start, int len)
    throws javax.xml.transform.TransformerException {
    if (numLines == 0) {
      // If there are any characters at all, there's at least one line
      numLines++;
    }
    for (int count = start; count < start+len; count++) {
      if (chars[count] == '\n') {
	numLines++;
      }
    }
  }",method,
"    if (numLines == 0) {
      // If there are any characters at all, there's at least one line
      numLines++;
    }",method,
"    for (int count = start; count < start+len; count++) {
      if (chars[count] == '\n') {
	numLines++;
      }
    }",method,
"      if (chars[count] == '\n') {
	numLines++;
      }",method,
"  public void comment(char[] chars, int start, int length)
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"  public void endDocument()
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"  public void endElement(int nameCode)
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"  public void processingInstruction(java.lang.String name,
				    java.lang.String data)
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"  public void setDocumentLocator(org.xml.sax.Locator locator) {
    // nop
  }",method,
"  public void setEscaping(boolean escaping)
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"  public void setNamePool(NamePool namePool) {
    // nop
  }",method,
"  public void setUnparsedEntity(java.lang.String name, java.lang.String uri)
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"  public void setWriter(java.io.Writer writer) {
    // nop
  }",method,
"  public void startDocument()
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"  public void startElement(int nameCode,
		    org.xml.sax.Attributes attributes,
		    int[] namespaces, int nscount)
    throws javax.xml.transform.TransformerException {
    // nop
  }",method,
"    public String toHtmlTable() {
        List<ConfigKey> configs = sortedConfigs();
        StringBuilder b = new StringBuilder();
        b.append(""<table class=\""data-table\""><tbody>\n"");
        b.append(""<tr>\n"");
        // print column headers
        for (String headerName : headers()) {
            b.append(""<th>"");
            b.append(headerName);
            b.append(""</th>\n"");
        }
        b.append(""</tr>\n"");
        for (ConfigKey key : configs) {
            if (key.internalConfig) {
                continue;
            }
            b.append(""<tr>\n"");
            // print column values
            for (String headerName : headers()) {
                b.append(""<td>"");
                b.append(getConfigValue(key, headerName));
                b.append(""</td>"");
            }
            b.append(""</tr>\n"");
        }
        b.append(""</tbody></table>"");
        return b.toString();
    }",method,
"        for (ConfigKey key : configs) {
            if (key.internalConfig) {
                continue;
            }
            b.append(""<tr>\n"");
            // print column values
            for (String headerName : headers()) {
                b.append(""<td>"");
                b.append(getConfigValue(key, headerName));
                b.append(""</td>"");
            }
            b.append(""</tr>\n"");
        }",method,
"            if (key.internalConfig) {
                continue;
            }",method,
"    public String toRst() {
        StringBuilder b = new StringBuilder();
        for (ConfigKey key : sortedConfigs()) {
            if (key.internalConfig) {
                continue;
            }
            getConfigKeyRst(key, b);
            b.append(""\n"");
        }
        return b.toString();
    }",method,
"            if (key.internalConfig) {
                continue;
            }",method,
"    public String toEnrichedRst() {
        StringBuilder b = new StringBuilder();
        String lastKeyGroupName = """";
        for (ConfigKey key : sortedConfigs()) {
            if (key.internalConfig) {
                continue;
            }
            if (key.group != null) {
                if (!lastKeyGroupName.equalsIgnoreCase(key.group)) {
                    b.append(key.group).append(""\n"");
                    char[] underLine = new char[key.group.length()];
                    Arrays.fill(underLine, '^');
                    b.append(new String(underLine)).append(""\n\n"");
                }
                lastKeyGroupName = key.group;
            }
            getConfigKeyRst(key, b);
            if (key.dependents != null && key.dependents.size() > 0) {
                int j = 0;
                b.append(""  * Dependents: "");
                for (String dependent : key.dependents) {
                    b.append(""``"");
                    b.append(dependent);
                    if (++j == key.dependents.size())
                        b.append(""``"");
                    else
                        b.append(""``, "");
                }
                b.append(""\n"");
            }
            b.append(""\n"");
        }
        return b.toString();
    }",method,
"            if (key.internalConfig) {
                continue;
            }",method,
"            if (key.group != null) {
                if (!lastKeyGroupName.equalsIgnoreCase(key.group)) {
                    b.append(key.group).append(""\n"");
                    char[] underLine = new char[key.group.length()];
                    Arrays.fill(underLine, '^');
                    b.append(new String(underLine)).append(""\n\n"");
                }
                lastKeyGroupName = key.group;
            }",method,
"                for (String dependent : key.dependents) {
                    b.append(""``"");
                    b.append(dependent);
                    if (++j == key.dependents.size())
                        b.append(""``"");
                    else
                        b.append(""``, "");
                }",method,
"    private void getConfigKeyRst(ConfigKey key, StringBuilder b) {
        b.append(""``"").append(key.name).append(""``"").append(""\n"");
        for (String docLine : key.documentation.split(""\n"")) {
            if (docLine.length() == 0) {
                continue;
            }
            b.append(""  "").append(docLine).append(""\n\n"");
        }
        b.append(""  * Type: "").append(getConfigValue(key, ""Type"")).append(""\n"");
        if (key.hasDefault()) {
            b.append(""  * Default: "").append(getConfigValue(key, ""Default"")).append(""\n"");
        }
        if (key.validator != null) {
            b.append(""  * Valid Values: "").append(getConfigValue(key, ""Valid Values"")).append(""\n"");
        }
        b.append(""  * Importance: "").append(getConfigValue(key, ""Importance"")).append(""\n"");
    }",method,
"        if (key.validator != null) {
            b.append(""  * Valid Values: "").append(getConfigValue(key, ""Valid Values"")).append(""\n"");
        }",method,
"public class NetJavaSocketImpl implements Socket {
	private java.net.Socket socket;
	public NetJavaSocketImpl (Protocol protocol, String host, int port, SocketHints hints) {
		try {
			// create the socket
			socket = new java.net.Socket();
			applyHints(hints); // better to call BEFORE socket is connected!
			// and connect...
			InetSocketAddress address = new InetSocketAddress(host, port);
			if (hints != null) {
				socket.connect(address, hints.connectTimeout);
			} else {
				socket.connect(address);
			}
		} catch (Exception e) {
			throw new GdxRuntimeException(""Error making a socket connection to "" + host + "":"" + port, e);
		}
	}
	public NetJavaSocketImpl (java.net.Socket socket, SocketHints hints) {
		this.socket = socket;
		applyHints(hints);
	}
	private void applyHints (SocketHints hints) {
		if (hints != null) {
			try {
				socket.setPerformancePreferences(hints.performancePrefConnectionTime, hints.performancePrefLatency,
					hints.performancePrefBandwidth);
				socket.setTrafficClass(hints.trafficClass);
				socket.setTcpNoDelay(hints.tcpNoDelay);
				socket.setKeepAlive(hints.keepAlive);
				socket.setSendBufferSize(hints.sendBufferSize);
				socket.setReceiveBufferSize(hints.receiveBufferSize);
				socket.setSoLinger(hints.linger, hints.lingerDuration);
				socket.setSoTimeout(hints.socketTimeout);
			} catch (Exception e) {
				throw new GdxRuntimeException(""Error setting socket hints."", e);
			}
		}
	}
	@Override
	public boolean isConnected () {
		if (socket != null) {
			return socket.isConnected();
		} else {
			return false;
		}
	}
	@Override
	public InputStream getInputStream () {
		try {
			return socket.getInputStream();
		} catch (Exception e) {
			throw new GdxRuntimeException(""Error getting input stream from socket."", e);
		}
	}
	@Override
	public OutputStream getOutputStream () {
		try {
			return socket.getOutputStream();
		} catch (Exception e) {
			throw new GdxRuntimeException(""Error getting output stream from socket."", e);
		}
	}
	@Override
	public String getRemoteAddress () {
		return socket.getRemoteSocketAddress().toString();
	}
	@Override
	public void dispose () {
		if (socket != null) {
			try {
				socket.close();
				socket = null;
			} catch (Exception e) {
				throw new GdxRuntimeException(""Error closing socket."", e);
			}
		}
	}
}",class,
"	public NetJavaSocketImpl (Protocol protocol, String host, int port, SocketHints hints) {
		try {
			// create the socket
			socket = new java.net.Socket();
			applyHints(hints); // better to call BEFORE socket is connected!
			// and connect...
			InetSocketAddress address = new InetSocketAddress(host, port);
			if (hints != null) {
				socket.connect(address, hints.connectTimeout);
			} else {
				socket.connect(address);
			}
		} catch (Exception e) {
			throw new GdxRuntimeException(""Error making a socket connection to "" + host + "":"" + port, e);
		}
	}",method,
"			if (hints != null) {
				socket.connect(address, hints.connectTimeout);
			}",method,
"	public NetJavaSocketImpl (java.net.Socket socket, SocketHints hints) {
		this.socket = socket;
		applyHints(hints);
	}",method,
"	private void applyHints (SocketHints hints) {
		if (hints != null) {
			try {
				socket.setPerformancePreferences(hints.performancePrefConnectionTime, hints.performancePrefLatency,
					hints.performancePrefBandwidth);
				socket.setTrafficClass(hints.trafficClass);
				socket.setTcpNoDelay(hints.tcpNoDelay);
				socket.setKeepAlive(hints.keepAlive);
				socket.setSendBufferSize(hints.sendBufferSize);
				socket.setReceiveBufferSize(hints.receiveBufferSize);
				socket.setSoLinger(hints.linger, hints.lingerDuration);
				socket.setSoTimeout(hints.socketTimeout);
			} catch (Exception e) {
				throw new GdxRuntimeException(""Error setting socket hints."", e);
			}
		}
	}",method,
"		if (hints != null) {
			try {
				socket.setPerformancePreferences(hints.performancePrefConnectionTime, hints.performancePrefLatency,
					hints.performancePrefBandwidth);
				socket.setTrafficClass(hints.trafficClass);
				socket.setTcpNoDelay(hints.tcpNoDelay);
				socket.setKeepAlive(hints.keepAlive);
				socket.setSendBufferSize(hints.sendBufferSize);
				socket.setReceiveBufferSize(hints.receiveBufferSize);
				socket.setSoLinger(hints.linger, hints.lingerDuration);
				socket.setSoTimeout(hints.socketTimeout);
			} catch (Exception e) {
				throw new GdxRuntimeException(""Error setting socket hints."", e);
			}
		}",method,
"	@Override
	public boolean isConnected () {
		if (socket != null) {
			return socket.isConnected();
		} else {
			return false;
		}
	}",method,
"		if (socket != null) {
			return socket.isConnected();
		}",method,
"	@Override
	public InputStream getInputStream () {
		try {
			return socket.getInputStream();
		} catch (Exception e) {
			throw new GdxRuntimeException(""Error getting input stream from socket."", e);
		}
	}",method,
"	@Override
	public OutputStream getOutputStream () {
		try {
			return socket.getOutputStream();
		} catch (Exception e) {
			throw new GdxRuntimeException(""Error getting output stream from socket."", e);
		}
	}",method,
"	@Override
	public String getRemoteAddress () {
		return socket.getRemoteSocketAddress().toString();
	}",method,
"	@Override
	public void dispose () {
		if (socket != null) {
			try {
				socket.close();
				socket = null;
			} catch (Exception e) {
				throw new GdxRuntimeException(""Error closing socket."", e);
			}
		}
	}",method,
"		if (socket != null) {
			try {
				socket.close();
				socket = null;
			} catch (Exception e) {
				throw new GdxRuntimeException(""Error closing socket."", e);
			}
		}",method,
"public class ExternalKotlinc implements Kotlinc {
  private static final KotlincVersion DEFAULT_VERSION = KotlincVersion.of(""unknown version"");
  private final Path pathToKotlinc;
  private final Supplier<KotlincVersion> version;
  public ExternalKotlinc(final Path pathToKotlinc) {
    this.pathToKotlinc = pathToKotlinc;
    this.version =
        Suppliers.memoize(
            () -> {
              ProcessExecutorParams params =
                  ProcessExecutorParams.builder()
                      .setCommand(ImmutableList.of(pathToKotlinc.toString(), ""-version""))
                      .build();
              ProcessExecutor.Result result;
              try {
                result = createProcessExecutor().launchAndExecute(params);
              } catch (InterruptedException | IOException e) {
                throw new RuntimeException(e);
              }
              Optional<String> stderr = result.getStderr();
              String output = stderr.orElse("""").trim();
              if (Strings.isNullOrEmpty(output)) {
                return DEFAULT_VERSION;
              } else {
                return KotlincVersion.of(output);
              }
            });
  }
  @Override
  public void appendToRuleKey(RuleKeyObjectSink sink) {
    if (DEFAULT_VERSION.equals(getVersion())) {
      // What we really want to do here is use a VersionedTool, however, this will suffice for now.
      sink.setReflectively(""kotlinc"", getShortName());
    } else {
      sink.setReflectively(""kotlinc.version"", getVersion().toString());
    }
  }
  @Override
  public ImmutableCollection<BuildRule> getDeps(SourcePathRuleFinder ruleFinder) {
    return ruleFinder.filterBuildRuleInputs(getInputs());
  }
  @Override
  public ImmutableCollection<SourcePath> getInputs() {
    return ImmutableSortedSet.of();
  }
  @Override
  public ImmutableList<String> getCommandPrefix(SourcePathResolver resolver) {
    return ImmutableList.of(pathToKotlinc.toString());
  }
  @Override
  public KotlincVersion getVersion() {
    return version.get();
  }
  @Override
  public int buildWithClasspath(
      ExecutionContext context,
      BuildTarget invokingRule,
      ImmutableList<String> options,
      ImmutableSortedSet<Path> kotlinSourceFilePaths,
      Path pathToSrcsList,
      Optional<Path> workingDirectory,
      ProjectFilesystem projectFilesystem)
      throws InterruptedException {
    ImmutableList<String> command =
        ImmutableList.<String>builder()
            .add(pathToKotlinc.toString())
            .addAll(
                transform(
                    kotlinSourceFilePaths,
                    path -> projectFilesystem.resolve(path).toAbsolutePath().toString()))
            .build();
    // Run the command
    int exitCode = -1;
    try {
      ProcessExecutorParams params =
          ProcessExecutorParams.builder()
              .setCommand(command)
              .setEnvironment(context.getEnvironment())
              .setDirectory(projectFilesystem.getRootPath().toAbsolutePath())
              .build();
      ProcessExecutor.Result result = context.getProcessExecutor().launchAndExecute(params);
      exitCode = result.getExitCode();
    } catch (IOException e) {
      e.printStackTrace(context.getStdErr());
      return exitCode;
    }
    return exitCode;
  }
  @VisibleForTesting
  ProcessExecutor createProcessExecutor() {
    return new DefaultProcessExecutor(Console.createNullConsole());
  }
  @Override
  public String getDescription(
      ImmutableList<String> options,
      ImmutableSortedSet<Path> kotlinSourceFilePaths,
      Path pathToSrcsList) {
    StringBuilder builder = new StringBuilder(getShortName());
    builder.append("" "");
    Joiner.on("" "").appendTo(builder, options);
    builder.append("" "");
    builder.append(""@"").append(pathToSrcsList);
    return builder.toString();
  }
  @Override
  public String getShortName() {
    return pathToKotlinc.toString();
  }
  @Override
  public ImmutableMap<String, String> getEnvironment(SourcePathResolver resolver) {
    return ImmutableMap.of();
  }
}",class,
"  public ExternalKotlinc(final Path pathToKotlinc) {
    this.pathToKotlinc = pathToKotlinc;
    this.version =
        Suppliers.memoize(
            () -> {
              ProcessExecutorParams params =
                  ProcessExecutorParams.builder()
                      .setCommand(ImmutableList.of(pathToKotlinc.toString(), ""-version""))
                      .build();
              ProcessExecutor.Result result;
              try {
                result = createProcessExecutor().launchAndExecute(params);
              } catch (InterruptedException | IOException e) {
                throw new RuntimeException(e);
              }
              Optional<String> stderr = result.getStderr();
              String output = stderr.orElse("""").trim();
              if (Strings.isNullOrEmpty(output)) {
                return DEFAULT_VERSION;
              } else {
                return KotlincVersion.of(output);
              }
            });
  }",method,
"  @Override
  public void appendToRuleKey(RuleKeyObjectSink sink) {
    if (DEFAULT_VERSION.equals(getVersion())) {
      // What we really want to do here is use a VersionedTool, however, this will suffice for now.
      sink.setReflectively(""kotlinc"", getShortName());
    } else {
      sink.setReflectively(""kotlinc.version"", getVersion().toString());
    }
  }",method,
"  @Override
  public ImmutableCollection<BuildRule> getDeps(SourcePathRuleFinder ruleFinder) {
    return ruleFinder.filterBuildRuleInputs(getInputs());
  }",method,
"  @Override
  public ImmutableCollection<SourcePath> getInputs() {
    return ImmutableSortedSet.of();
  }",method,
"  @Override
  public ImmutableList<String> getCommandPrefix(SourcePathResolver resolver) {
    return ImmutableList.of(pathToKotlinc.toString());
  }",method,
"  @Override
  public KotlincVersion getVersion() {
    return version.get();
  }",method,
"  @Override
  public int buildWithClasspath(
      ExecutionContext context,
      BuildTarget invokingRule,
      ImmutableList<String> options,
      ImmutableSortedSet<Path> kotlinSourceFilePaths,
      Path pathToSrcsList,
      Optional<Path> workingDirectory,
      ProjectFilesystem projectFilesystem)
      throws InterruptedException {
    ImmutableList<String> command =
        ImmutableList.<String>builder()
            .add(pathToKotlinc.toString())
            .addAll(
                transform(
                    kotlinSourceFilePaths,
                    path -> projectFilesystem.resolve(path).toAbsolutePath().toString()))
            .build();
    // Run the command
    int exitCode = -1;
    try {
      ProcessExecutorParams params =
          ProcessExecutorParams.builder()
              .setCommand(command)
              .setEnvironment(context.getEnvironment())
              .setDirectory(projectFilesystem.getRootPath().toAbsolutePath())
              .build();
      ProcessExecutor.Result result = context.getProcessExecutor().launchAndExecute(params);
      exitCode = result.getExitCode();
    } catch (IOException e) {
      e.printStackTrace(context.getStdErr());
      return exitCode;
    }
    return exitCode;
  }",method,
"  @VisibleForTesting
  ProcessExecutor createProcessExecutor() {
    return new DefaultProcessExecutor(Console.createNullConsole());
  }",method,
"  @Override
  public String getDescription(
      ImmutableList<String> options,
      ImmutableSortedSet<Path> kotlinSourceFilePaths,
      Path pathToSrcsList) {
    StringBuilder builder = new StringBuilder(getShortName());
    builder.append("" "");
    Joiner.on("" "").appendTo(builder, options);
    builder.append("" "");
    builder.append(""@"").append(pathToSrcsList);
    return builder.toString();
  }",method,
"  @Override
  public String getShortName() {
    return pathToKotlinc.toString();
  }",method,
"  @Override
  public ImmutableMap<String, String> getEnvironment(SourcePathResolver resolver) {
    return ImmutableMap.of();
  }",method,
"public class PauseExample extends SimpleBaseGameActivity {
	// ===========================================================
	// Constants
	// ===========================================================
	private static final int CAMERA_WIDTH = 720;
	private static final int CAMERA_HEIGHT = 480;
	// ===========================================================
	// Fields
	// ===========================================================
	private Camera mCamera;
	private BitmapTextureAtlas mBitmapTextureAtlas;
	private Scene mMainScene;
	private ITextureRegion mFaceTextureRegion;
	private ITextureRegion mPausedTextureRegion;
	private CameraScene mPauseScene;
	// ===========================================================
	// Constructors
	// ===========================================================
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	@Override
	public EngineOptions onCreateEngineOptions() {
		this.mCamera = new Camera(0, 0, CAMERA_WIDTH, CAMERA_HEIGHT);
		return new EngineOptions(true, ScreenOrientation.LANDSCAPE_FIXED, new RatioResolutionPolicy(CAMERA_WIDTH, CAMERA_HEIGHT), this.mCamera);
	}
	@Override
	public void onCreateResources() {
		BitmapTextureAtlasTextureRegionFactory.setAssetBasePath(""gfx/"");
		this.mBitmapTextureAtlas = new BitmapTextureAtlas(this.getTextureManager(), 256, 128, TextureOptions.BILINEAR);
		this.mPausedTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(this.mBitmapTextureAtlas, this, ""paused.png"", 0, 0);
		this.mFaceTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(this.mBitmapTextureAtlas, this, ""face_box_menu.png"", 0, 50);
		this.mBitmapTextureAtlas.load();
	}
	@Override
	public Scene onCreateScene() {
		this.mEngine.registerUpdateHandler(new FPSLogger());
		this.mPauseScene = new CameraScene(this.mCamera);
		final float centerX = (CAMERA_WIDTH - this.mPausedTextureRegion.getWidth()) / 2;
		final float centerY = (CAMERA_HEIGHT - this.mPausedTextureRegion.getHeight()) / 2;
		final Sprite pausedSprite = new Sprite(centerX, centerY, this.mPausedTextureRegion, this.getVertexBufferObjectManager());
		this.mPauseScene.attachChild(pausedSprite);
		this.mPauseScene.setBackgroundEnabled(false);
		this.mMainScene = new Scene();
		this.mMainScene.setBackground(new Background(0.09804f, 0.6274f, 0.8784f));
		final Sprite face = new Sprite(0, 0, this.mFaceTextureRegion, this.getVertexBufferObjectManager());
		face.registerEntityModifier(new MoveModifier(30, 0, CAMERA_WIDTH - face.getWidth(), 0, CAMERA_HEIGHT - face.getHeight()));
		this.mMainScene.attachChild(face);
		return this.mMainScene;
	}
	@Override
	public boolean onKeyDown(final int pKeyCode, final KeyEvent pEvent) {
		if(pKeyCode == KeyEvent.KEYCODE_MENU && pEvent.getAction() == KeyEvent.ACTION_DOWN) {
			if(this.mEngine.isRunning()) {
				this.mMainScene.setChildScene(this.mPauseScene, false, true, true);
				this.mEngine.stop();
			} else {
				this.mMainScene.clearChildScene();
				this.mEngine.start();
			}
			return true;
		} else {
			return super.onKeyDown(pKeyCode, pEvent);
		}
	}
	// ===========================================================
	// Methods
	// ===========================================================
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	@Override
	public EngineOptions onCreateEngineOptions() {
		this.mCamera = new Camera(0, 0, CAMERA_WIDTH, CAMERA_HEIGHT);
		return new EngineOptions(true, ScreenOrientation.LANDSCAPE_FIXED, new RatioResolutionPolicy(CAMERA_WIDTH, CAMERA_HEIGHT), this.mCamera);
	}",method,
"	@Override
	public void onCreateResources() {
		BitmapTextureAtlasTextureRegionFactory.setAssetBasePath(""gfx/"");
		this.mBitmapTextureAtlas = new BitmapTextureAtlas(this.getTextureManager(), 256, 128, TextureOptions.BILINEAR);
		this.mPausedTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(this.mBitmapTextureAtlas, this, ""paused.png"", 0, 0);
		this.mFaceTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(this.mBitmapTextureAtlas, this, ""face_box_menu.png"", 0, 50);
		this.mBitmapTextureAtlas.load();
	}",method,
"	@Override
	public Scene onCreateScene() {
		this.mEngine.registerUpdateHandler(new FPSLogger());
		this.mPauseScene = new CameraScene(this.mCamera);
		final float centerX = (CAMERA_WIDTH - this.mPausedTextureRegion.getWidth()) / 2;
		final float centerY = (CAMERA_HEIGHT - this.mPausedTextureRegion.getHeight()) / 2;
		final Sprite pausedSprite = new Sprite(centerX, centerY, this.mPausedTextureRegion, this.getVertexBufferObjectManager());
		this.mPauseScene.attachChild(pausedSprite);
		this.mPauseScene.setBackgroundEnabled(false);
		this.mMainScene = new Scene();
		this.mMainScene.setBackground(new Background(0.09804f, 0.6274f, 0.8784f));
		final Sprite face = new Sprite(0, 0, this.mFaceTextureRegion, this.getVertexBufferObjectManager());
		face.registerEntityModifier(new MoveModifier(30, 0, CAMERA_WIDTH - face.getWidth(), 0, CAMERA_HEIGHT - face.getHeight()));
		this.mMainScene.attachChild(face);
		return this.mMainScene;
	}",method,
"	@Override
	public boolean onKeyDown(final int pKeyCode, final KeyEvent pEvent) {
		if(pKeyCode == KeyEvent.KEYCODE_MENU && pEvent.getAction() == KeyEvent.ACTION_DOWN) {
			if(this.mEngine.isRunning()) {
				this.mMainScene.setChildScene(this.mPauseScene, false, true, true);
				this.mEngine.stop();
			} else {
				this.mMainScene.clearChildScene();
				this.mEngine.start();
			}
			return true;
		} else {
			return super.onKeyDown(pKeyCode, pEvent);
		}
	}",method,
"public class NegationBroadScopeFix implements IntentionAction {
  private final PsiPrefixExpression myPrefixExpression;
  public NegationBroadScopeFix(@NotNull PsiPrefixExpression prefixExpression) {
    myPrefixExpression = prefixExpression;
  }
  @Override
  @NotNull
  public String getText() {
    PsiExpression operand = myPrefixExpression.getOperand();
    String text = operand == null ? """" : operand.getText() + "" "";
    PsiElement parent = myPrefixExpression.getParent();
    String rop;
    if (parent instanceof PsiInstanceOfExpression) {
      text += PsiKeyword.INSTANCEOF + "" "";
      final PsiTypeElement type = ((PsiInstanceOfExpression)parent).getCheckType();
      rop = type == null ? """" : type.getText();
    }
    else if (parent instanceof PsiBinaryExpression) {
      text += ((PsiBinaryExpression)parent).getOperationSign().getText() + "" "";
      final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();
      rop = rOperand == null ? """" : rOperand.getText();
    }
    else {
      rop = ""<expr>"";
    }
    text += rop;
    return QuickFixBundle.message(""negation.broader.scope.text"", text);
  }
  @Override
  @NotNull
  public String getFamilyName() {
    return QuickFixBundle.message(""negation.broader.scope.family"");
  }
  @Override
  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
    if (!myPrefixExpression.isValid() || myPrefixExpression.getOperand() == null) return false;
    PsiElement parent = myPrefixExpression.getParent();
    if (parent instanceof PsiInstanceOfExpression && ((PsiInstanceOfExpression)parent).getOperand() == myPrefixExpression) {
      return true;
    }
    if (!(parent instanceof PsiBinaryExpression)) return false;
    PsiBinaryExpression binaryExpression = (PsiBinaryExpression)parent;
    return binaryExpression.getLOperand() == myPrefixExpression && TypeConversionUtil.isBooleanType(binaryExpression.getType());
  }
  @NotNull
  @Override
  public PsiElement getElementToMakeWritable(@NotNull PsiFile file) {
    return myPrefixExpression;
  }
  @Override
  public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
    if (!isAvailable(project, editor, file)) return;
    PsiExpression operand = myPrefixExpression.getOperand();
    PsiElement unnegated = myPrefixExpression.replace(operand);
    PsiElement parent = unnegated.getParent();
    PsiElementFactory factory = JavaPsiFacade.getInstance(file.getProject()).getElementFactory();
    PsiPrefixExpression negated = (PsiPrefixExpression)factory.createExpressionFromText(""!(xxx)"", parent);
    PsiParenthesizedExpression parentheses = (PsiParenthesizedExpression)negated.getOperand();
    parentheses.getExpression().replace(parent.copy());
    parent.replace(negated);
  }
  @Override
  public boolean startInWriteAction() {
    return true;
  }
}",class,
"  public NegationBroadScopeFix(@NotNull PsiPrefixExpression prefixExpression) {
    myPrefixExpression = prefixExpression;
  }",method,
"  @Override
  @NotNull
  public String getText() {
    PsiExpression operand = myPrefixExpression.getOperand();
    String text = operand == null ? """" : operand.getText() + "" "";
    PsiElement parent = myPrefixExpression.getParent();
    String rop;
    if (parent instanceof PsiInstanceOfExpression) {
      text += PsiKeyword.INSTANCEOF + "" "";
      final PsiTypeElement type = ((PsiInstanceOfExpression)parent).getCheckType();
      rop = type == null ? """" : type.getText();
    }
    else if (parent instanceof PsiBinaryExpression) {
      text += ((PsiBinaryExpression)parent).getOperationSign().getText() + "" "";
      final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();
      rop = rOperand == null ? """" : rOperand.getText();
    }
    else {
      rop = ""<expr>"";
    }
    text += rop;
    return QuickFixBundle.message(""negation.broader.scope.text"", text);
  }",method,
"    if (parent instanceof PsiInstanceOfExpression) {
      text += PsiKeyword.INSTANCEOF + "" "";
      final PsiTypeElement type = ((PsiInstanceOfExpression)parent).getCheckType();
      rop = type == null ? """" : type.getText();
    }",method,
"    else if (parent instanceof PsiBinaryExpression) {
      text += ((PsiBinaryExpression)parent).getOperationSign().getText() + "" "";
      final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();
      rop = rOperand == null ? """" : rOperand.getText();
    }",method,
"  @Override
  @NotNull
  public String getFamilyName() {
    return QuickFixBundle.message(""negation.broader.scope.family"");
  }",method,
"  @Override
  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
    if (!myPrefixExpression.isValid() || myPrefixExpression.getOperand() == null) return false;
    PsiElement parent = myPrefixExpression.getParent();
    if (parent instanceof PsiInstanceOfExpression && ((PsiInstanceOfExpression)parent).getOperand() == myPrefixExpression) {
      return true;
    }
    if (!(parent instanceof PsiBinaryExpression)) return false;
    PsiBinaryExpression binaryExpression = (PsiBinaryExpression)parent;
    return binaryExpression.getLOperand() == myPrefixExpression && TypeConversionUtil.isBooleanType(binaryExpression.getType());
  }",method,
"  @NotNull
  @Override
  public PsiElement getElementToMakeWritable(@NotNull PsiFile file) {
    return myPrefixExpression;
  }",method,
"  @Override
  public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
    if (!isAvailable(project, editor, file)) return;
    PsiExpression operand = myPrefixExpression.getOperand();
    PsiElement unnegated = myPrefixExpression.replace(operand);
    PsiElement parent = unnegated.getParent();
    PsiElementFactory factory = JavaPsiFacade.getInstance(file.getProject()).getElementFactory();
    PsiPrefixExpression negated = (PsiPrefixExpression)factory.createExpressionFromText(""!(xxx)"", parent);
    PsiParenthesizedExpression parentheses = (PsiParenthesizedExpression)negated.getOperand();
    parentheses.getExpression().replace(parent.copy());
    parent.replace(negated);
  }",method,
"  @Override
  public boolean startInWriteAction() {
    return true;
  }",method,
"public class SilentRadioMedium extends AbstractRadioMedium {
  public SilentRadioMedium(Simulation simulation) {
    super(simulation);
  }
  public RadioConnection createConnections(Radio radio) {
    return null;
  }
  public void updateSignalStrengths() {
  }
  public Collection<Element> getConfigXML() {
    return null;
  }
  public boolean setConfigXML(Collection<Element> configXML, boolean visAvailable) {
    return true;
  }
}",class,
"  public SilentRadioMedium(Simulation simulation) {
    super(simulation);
  }",method,
"  public RadioConnection createConnections(Radio radio) {
    return null;
  }",method,
"  public void updateSignalStrengths() {
  }",method,
"  public Collection<Element> getConfigXML() {
    return null;
  }",method,
"  public boolean setConfigXML(Collection<Element> configXML, boolean visAvailable) {
    return true;
  }",method,
"public class CvsChangeListsBuilder {
  @NonNls private static final String INITIALLY_ADDED_ON_BRANCH = ""was initially added on branch"";
  private static class ChangeListKey extends Trinity<String, String, String> {
    public ChangeListKey(final String branch, final String author, final String message) {
      super(branch, author, message);
    }
  }
  private final Map<ChangeListKey, List<CvsChangeList>> myCache = new HashMap<>();
  private long myLastNumber = 0;
  private final String myRootPath;
  private final CvsEnvironment myEnvironment;
  private final Project myProject;
  private final VirtualFile myRootFile;
  public CvsChangeListsBuilder(final String rootPath, final CvsEnvironment environment, final Project project, final VirtualFile rootFile) {
    myRootPath = rootPath;
    myEnvironment = environment;
    myProject = project;
    myRootFile = rootFile;
  }
  public List<CvsChangeList> getVersions() {
    final ArrayList<CvsChangeList> result = new ArrayList<>();
    for (List<CvsChangeList> versions : myCache.values()) {
      result.addAll(versions);
    }
    return result;
  }
  public CvsChangeList addRevision(RevisionWrapper revisionWrapper) {
    final Revision revision = revisionWrapper.getRevision();
    final CvsChangeList version = findOrCreateVersionFor(revision.getMessage(),
                                                         revisionWrapper.getTime(),
                                                         revision.getAuthor(),
                                                         revisionWrapper.getBranch(),
                                                         revisionWrapper.getFile());
    version.addFileRevision(revisionWrapper);
    return version;
  }
  private CvsChangeList findOrCreateVersionFor(final String message, final long date, final String author,
                                               final String branch, final String path) {
    final ChangeListKey key = new ChangeListKey(branch, author, message);
    final List<CvsChangeList> versions = myCache.get(key);
    if (versions != null) {
      for (int i = versions.size() - 1; i >= 0; i--) {
        final CvsChangeList version = versions.get(i);
        if (version.containsDate(date) && !version.containsFile(path)) {
          return version;
        }
      }
    }
    final CvsChangeList result =
      new CvsChangeList(myProject, myEnvironment, myRootFile, myLastNumber, message, date, author, myRootPath);
    myLastNumber += 1;
    if (!myCache.containsKey(key)) {
      myCache.put(key, new ArrayList<>());
    }
    myCache.get(key).add(result);
    return result;
  }
  @Nullable
  public List<RevisionWrapper> revisionWrappersFromLog(final LogInformationWrapper log) {
    final String file = log.getFile();
    if (!CvsChangeList.isAncestor(myRootPath, file)) {
      return null;
    }
    final List<RevisionWrapper> result = new ArrayList<>();
    for (Revision revision : log.getRevisions()) {
      if (revision != null) {
        if (CvsChangeList.DEAD_STATE.equals(revision.getState()) &&
            revision.getMessage().contains(INITIALLY_ADDED_ON_BRANCH)) {
          // ignore dead revision (otherwise it'll get stuck in incoming changes forever - it's considered a deletion and
          // the file is never actually deleted)
          continue;
        }
        final String branchName = getBranchName(revision, log.getSymbolicNames());
        result.add(new RevisionWrapper(file, revision, branchName));
      }
    }
    return result;
  }
  public void add(LogInformationWrapper log) {
    final List<RevisionWrapper> wrappers = revisionWrappersFromLog(log);
    if (wrappers == null) {
      return;
    }
    for (RevisionWrapper wrapper : wrappers) {
      addRevision(wrapper);
    }
  }
  @Nullable
  private static String getBranchName(final Revision revision, final List<SymbolicName> symbolicNames) {
    final CvsRevisionNumber number = new CvsRevisionNumber(revision.getNumber().trim());
    final int[] subRevisions = number.getSubRevisions();
    String branchNumberString = null;
    if (subRevisions != null && subRevisions.length >= 4) {
      final int branchRevNumber = subRevisions [subRevisions.length-2];
      final CvsRevisionNumber branchNumber = number.removeTailVersions(2).addTailVersions(0, branchRevNumber);
      branchNumberString = branchNumber.asString();
    }
    if (branchNumberString == null) {
      final String branches = revision.getBranches();
      if (branches != null && branches.length() > 0) {
        final String[] branchNames = branches.split("";"");
        final CvsRevisionNumber revisionNumber = new CvsRevisionNumber(branchNames [0].trim());
        final int[] branchSubRevisions = revisionNumber.getSubRevisions();
        assert branchSubRevisions != null;
        final int rev = branchSubRevisions [branchSubRevisions.length-1];
        final CvsRevisionNumber branchNumber = revisionNumber.removeTailVersions(1).addTailVersions(0, rev);
        branchNumberString = branchNumber.asString();
      }
    }
    if (branchNumberString != null) {
      for(SymbolicName name: symbolicNames) {
        if (name.getRevision().equals(branchNumberString)) {
          return name.getName();
        }
      }
    }
    return null;
  }
}",class,

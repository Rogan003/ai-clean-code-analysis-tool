code_snippet,type,score
"    public void testCreatePutRequestWithBody() throws Exception {
        TestRequest.PutWithBody request = new TestRequest.PutWithBody();
        assertEquals(request.getMethod(), Method.PUT);
        HttpUriRequest httpRequest = HttpClientStack.createHttpRequest(request, null);
        assertTrue(httpRequest instanceof HttpPut);
    }",method,
"    public void testCreateDeleteRequest() throws Exception {
        TestRequest.Delete request = new TestRequest.Delete();
        assertEquals(request.getMethod(), Method.DELETE);
        HttpUriRequest httpRequest = HttpClientStack.createHttpRequest(request, null);
        assertTrue(httpRequest instanceof HttpDelete);
    }",method,
"    public void testCreateHeadRequest() throws Exception {
        TestRequest.Head request = new TestRequest.Head();
        assertEquals(request.getMethod(), Method.HEAD);
        HttpUriRequest httpRequest = HttpClientStack.createHttpRequest(request, null);
        assertTrue(httpRequest instanceof HttpHead);
    }",method,
"    public void testCreateOptionsRequest() throws Exception {
        TestRequest.Options request = new TestRequest.Options();
        assertEquals(request.getMethod(), Method.OPTIONS);
        HttpUriRequest httpRequest = HttpClientStack.createHttpRequest(request, null);
        assertTrue(httpRequest instanceof HttpOptions);
    }",method,
"    public void testCreateTraceRequest() throws Exception {
        TestRequest.Trace request = new TestRequest.Trace();
        assertEquals(request.getMethod(), Method.TRACE);
        HttpUriRequest httpRequest = HttpClientStack.createHttpRequest(request, null);
        assertTrue(httpRequest instanceof HttpTrace);
    }",method,
"    public void testCreatePatchRequest() throws Exception {
        TestRequest.Patch request = new TestRequest.Patch();
        assertEquals(request.getMethod(), Method.PATCH);
        HttpUriRequest httpRequest = HttpClientStack.createHttpRequest(request, null);
        assertTrue(httpRequest instanceof HttpPatch);
    }",method,
"    public void testCreatePatchRequestWithBody() throws Exception {
        TestRequest.PatchWithBody request = new TestRequest.PatchWithBody();
        assertEquals(request.getMethod(), Method.PATCH);
        HttpUriRequest httpRequest = HttpClientStack.createHttpRequest(request, null);
        assertTrue(httpRequest instanceof HttpPatch);
    }",method,
"public final class ErrorPronePlugin extends BlazeJavaCompilerPlugin {
  private final ScannerSupplier scannerSupplier;
  private final boolean testOnly;
  public ErrorPronePlugin(boolean testOnly) {
    this(testOnly, BuiltInCheckerSuppliers.errorChecks());
  }
  public ErrorPronePlugin(boolean testOnly, ScannerSupplier scannerSupplier) {
    this.testOnly = testOnly;
    this.scannerSupplier = scannerSupplier;
  }
  private ErrorProneAnalyzer errorProneAnalyzer;
  private ErrorProneOptions epOptions;
  public static void setupMessageBundle(Context context) {
    JavacMessages.instance(context).add(""com.google.errorprone.errors"");
  }
  private static final String COMPILING_TEST_ONLY_CODE_ARG = ""-XepCompilingTestOnlyCode"";
  @Override
  public List<String> processArgs(List<String> args) throws InvalidCommandLineException {
    ImmutableList.Builder<String> epArgs = ImmutableList.<String>builder().addAll(args);
    // allow javacopts that reference unknown error-prone checks
    epArgs.add(""-XepIgnoreUnknownCheckNames"");
    if (testOnly()) {
      epArgs.add(COMPILING_TEST_ONLY_CODE_ARG);
    }
    return processEpOptions(epArgs.build())
        // TODO(glorioso): This post-filtering shouldn't be needed except that the bazel dependency
        // on error prone doesn't yet know about -XepCompilingTestOnlyCode.
        // Remove this once the 3p version is recent enough.
        .stream()
        .filter(arg -> !arg.equals(COMPILING_TEST_ONLY_CODE_ARG))
        .collect(ImmutableList.toImmutableList());
  }
  private List<String> processEpOptions(List<String> args) throws InvalidCommandLineException {
    try {
      epOptions = ErrorProneOptions.processArgs(args);
    } catch (InvalidCommandLineOptionException e) {
      throw new InvalidCommandLineException(e.getMessage());
    }
    return Arrays.asList(epOptions.getRemainingArgs());
  }
  @Override
  public void init(Context context, Log log, JavaCompiler compiler) {
    super.init(context, log, compiler);
    setupMessageBundle(context);
    if (epOptions == null) {
      epOptions = ErrorProneOptions.empty();
    }
    errorProneAnalyzer = new ErrorProneAnalyzer(scannerSupplier, epOptions, context);
  }
  @Override
  public void postFlow(Env<AttrContext> env) {
    try {
      errorProneAnalyzer.finished(new TaskEvent(Kind.ANALYZE, env.toplevel, env.enclClass.sym));
    } catch (ErrorProneError e) {
      e.logFatalError(log);
      // let the exception propagate to javac's main, where it will cause the compilation to
      // terminate with Result.ABNORMAL
      throw e;
    }
  }
  @VisibleForTesting
  public boolean testOnly() {
    return testOnly;
  }
}",class,
"  public ErrorPronePlugin(boolean testOnly) {
    this(testOnly, BuiltInCheckerSuppliers.errorChecks());
  }",method,
"  public ErrorPronePlugin(boolean testOnly, ScannerSupplier scannerSupplier) {
    this.testOnly = testOnly;
    this.scannerSupplier = scannerSupplier;
  }",method,
"  public static void setupMessageBundle(Context context) {
    JavacMessages.instance(context).add(""com.google.errorprone.errors"");
  }",method,
"  @Override
  public List<String> processArgs(List<String> args) throws InvalidCommandLineException {
    ImmutableList.Builder<String> epArgs = ImmutableList.<String>builder().addAll(args);
    // allow javacopts that reference unknown error-prone checks
    epArgs.add(""-XepIgnoreUnknownCheckNames"");
    if (testOnly()) {
      epArgs.add(COMPILING_TEST_ONLY_CODE_ARG);
    }
    return processEpOptions(epArgs.build())
        // TODO(glorioso): This post-filtering shouldn't be needed except that the bazel dependency
        // on error prone doesn't yet know about -XepCompilingTestOnlyCode.
        // Remove this once the 3p version is recent enough.
        .stream()
        .filter(arg -> !arg.equals(COMPILING_TEST_ONLY_CODE_ARG))
        .collect(ImmutableList.toImmutableList());
  }",method,
"  private List<String> processEpOptions(List<String> args) throws InvalidCommandLineException {
    try {
      epOptions = ErrorProneOptions.processArgs(args);
    } catch (InvalidCommandLineOptionException e) {
      throw new InvalidCommandLineException(e.getMessage());
    }
    return Arrays.asList(epOptions.getRemainingArgs());
  }",method,
"  @Override
  public void init(Context context, Log log, JavaCompiler compiler) {
    super.init(context, log, compiler);
    setupMessageBundle(context);
    if (epOptions == null) {
      epOptions = ErrorProneOptions.empty();
    }
    errorProneAnalyzer = new ErrorProneAnalyzer(scannerSupplier, epOptions, context);
  }",method,
"    if (epOptions == null) {
      epOptions = ErrorProneOptions.empty();
    }",method,
"  @Override
  public void postFlow(Env<AttrContext> env) {
    try {
      errorProneAnalyzer.finished(new TaskEvent(Kind.ANALYZE, env.toplevel, env.enclClass.sym));
    } catch (ErrorProneError e) {
      e.logFatalError(log);
      // let the exception propagate to javac's main, where it will cause the compilation to
      // terminate with Result.ABNORMAL
      throw e;
    }
  }",method,
"  @VisibleForTesting
  public boolean testOnly() {
    return testOnly;
  }",method,
"public abstract class AbstractRegistryFactory implements RegistryFactory {
    // 日志输出
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);
    // 注册中心获取过程锁
    private static final ReentrantLock LOCK = new ReentrantLock();
    // 注册中心集合 Map<RegistryAddress, Registry>
    private static final Map<String, Registry> REGISTRIES = new ConcurrentHashMap<String, Registry>();
    public static Collection<Registry> getRegistries() {
        return Collections.unmodifiableCollection(REGISTRIES.values());
    }
    // TODO: 2017/8/30 to move somewhere else better
    public static void destroyAll() {
        if (LOGGER.isInfoEnabled()) {
            LOGGER.info(""Close all registries "" + getRegistries());
        }
        // 锁定注册中心关闭过程
        LOCK.lock();
        try {
            for (Registry registry : getRegistries()) {
                try {
                    registry.destroy();
                } catch (Throwable e) {
                    LOGGER.error(e.getMessage(), e);
                }
            }
            REGISTRIES.clear();
        } finally {
            // 释放锁
            LOCK.unlock();
        }
    }
    public Registry getRegistry(URL url) {
        url = url.setPath(RegistryService.class.getName())
                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())
                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);
        String key = url.toServiceString();
        // 锁定注册中心获取过程，保证注册中心单一实例
        LOCK.lock();
        try {
            Registry registry = REGISTRIES.get(key);
            if (registry != null) {
                return registry;
            }
            registry = createRegistry(url);
            if (registry == null) {
                throw new IllegalStateException(""Can not create registry "" + url);
            }
            REGISTRIES.put(key, registry);
            return registry;
        } finally {
            // 释放锁
            LOCK.unlock();
        }
    }
    protected abstract Registry createRegistry(URL url);
}",class,
"    public static Collection<Registry> getRegistries() {
        return Collections.unmodifiableCollection(REGISTRIES.values());
    }",method,
"    public static void destroyAll() {
        if (LOGGER.isInfoEnabled()) {
            LOGGER.info(""Close all registries "" + getRegistries());
        }
        // 锁定注册中心关闭过程
        LOCK.lock();
        try {
            for (Registry registry : getRegistries()) {
                try {
                    registry.destroy();
                } catch (Throwable e) {
                    LOGGER.error(e.getMessage(), e);
                }
            }
            REGISTRIES.clear();
        } finally {
            // 释放锁
            LOCK.unlock();
        }
    }",method,
"    public Registry getRegistry(URL url) {
        url = url.setPath(RegistryService.class.getName())
                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())
                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);
        String key = url.toServiceString();
        // 锁定注册中心获取过程，保证注册中心单一实例
        LOCK.lock();
        try {
            Registry registry = REGISTRIES.get(key);
            if (registry != null) {
                return registry;
            }
            registry = createRegistry(url);
            if (registry == null) {
                throw new IllegalStateException(""Can not create registry "" + url);
            }
            REGISTRIES.put(key, registry);
            return registry;
        } finally {
            // 释放锁
            LOCK.unlock();
        }
    }",method,
"            if (registry != null) {
                return registry;
            }",method,
"            if (registry == null) {
                throw new IllegalStateException(""Can not create registry "" + url);
            }",method,
"  public static Object getAAHintForSwingComponent() {
    UISettings uiSettings = ApplicationManager.getApplication() == null ? null : UISettings.getInstance();
    if (uiSettings != null) {
      AntialiasingType type = uiSettings.getIdeAAType();
      if (type != null) return type.getTextInfo();
    }
    return GREYSCALE.getTextInfo();
  }",method,
"    if (uiSettings != null) {
      AntialiasingType type = uiSettings.getIdeAAType();
      if (type != null) return type.getTextInfo();
    }",method,
"  public static Object getKeyForCurrentScope(boolean inEditor) {
    UISettings uiSettings = ApplicationManager.getApplication() == null ? null : UISettings.getInstance();
    if (uiSettings != null) {
      AntialiasingType type = inEditor ? uiSettings.getEditorAAType() : uiSettings.getIdeAAType();
      if (type != null) return type.myHint;
    }
    return RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
  }",method,
"    if (uiSettings != null) {
      AntialiasingType type = inEditor ? uiSettings.getEditorAAType() : uiSettings.getIdeAAType();
      if (type != null) return type.myHint;
    }",method,
"  AntialiasingType(String name, Object hint, boolean enabled) {
    myName = name;
    myHint = hint;
    isEnabled = enabled;
  }",method,
"  public Object getTextInfo() {
    return isEnabled ? GraphicsUtil.createAATextInfo(myHint) : null;
  }",method,
"  @Override
  public String toString() {
    return myName;
  }",method,
"  ColorBlindness(String key) {
    this.key = key;
  }",method,
"public class OptionalOffsetDateTimeTest {
    private final Environment env = new Environment(""test-optional-offset-date-time"", Jackson.newObjectMapper(),
            Validators.newValidator(), new MetricRegistry(), null);
    private TaskDao dao;
    @Before
    public void setupTests() throws IOException {
        final DataSourceFactory dataSourceFactory = new DataSourceFactory();
        dataSourceFactory.setDriverClass(""org.h2.Driver"");
        dataSourceFactory.setUrl(""jdbc:h2:mem:optional-offset-date-time-"" + System.currentTimeMillis() + ""?user=sa"");
        dataSourceFactory.setInitialSize(1);
        final DBI dbi = new DBIFactory().build(env, dataSourceFactory, ""test"");
        try (Handle h = dbi.open()) {
            h.execute(""CREATE TABLE IF NOT EXISTS tasks ("" +
                    ""id INT PRIMARY KEY, "" +
                    ""assignee VARCHAR(255) NOT NULL, "" +
                    ""start_date TIMESTAMP, "" +
                    ""end_date TIMESTAMP, "" +
                    ""comments VARCHAR(1024) "" +
                    "")"");
        }
        dao = dbi.onDemand(TaskDao.class);
    }
    @Test
    public void testPresent() {
        final OffsetDateTime startDate = OffsetDateTime.now();
        final OffsetDateTime endDate = startDate.plusDays(1L);
        dao.insert(1, Optional.of(""John Hughes""), startDate, Optional.of(endDate), Optional.empty());
        assertThat(dao.findEndDateById(1).get()).isEqualTo(endDate);
    }
    @Test
    public void testAbsent() {
        dao.insert(2, Optional.of(""Kate Johansen""), OffsetDateTime.now(),
                Optional.empty(), Optional.of(""To be done""));
        assertThat(dao.findEndDateById(2).isPresent()).isFalse();
    }
    interface TaskDao {
        @SqlUpdate(""INSERT INTO tasks(id, assignee, start_date, end_date, comments) "" +
                ""VALUES (:id, :assignee, :start_date, :end_date, :comments)"")
        void insert(@Bind(""id"") int id, @Bind(""assignee"") Optional<String> assignee,
                    @Bind(""start_date"") OffsetDateTime startDate, @Bind(""end_date"") Optional<OffsetDateTime> endDate,
                    @Bind(""comments"") Optional<String> comments);
        @SqlQuery(""SELECT end_date FROM tasks WHERE id = :id"")
        @SingleValueResult
        Optional<OffsetDateTime> findEndDateById(@Bind(""id"") int id);
    }
}",class,
"    @Before
    public void setupTests() throws IOException {
        final DataSourceFactory dataSourceFactory = new DataSourceFactory();
        dataSourceFactory.setDriverClass(""org.h2.Driver"");
        dataSourceFactory.setUrl(""jdbc:h2:mem:optional-offset-date-time-"" + System.currentTimeMillis() + ""?user=sa"");
        dataSourceFactory.setInitialSize(1);
        final DBI dbi = new DBIFactory().build(env, dataSourceFactory, ""test"");
        try (Handle h = dbi.open()) {
            h.execute(""CREATE TABLE IF NOT EXISTS tasks ("" +
                    ""id INT PRIMARY KEY, "" +
                    ""assignee VARCHAR(255) NOT NULL, "" +
                    ""start_date TIMESTAMP, "" +
                    ""end_date TIMESTAMP, "" +
                    ""comments VARCHAR(1024) "" +
                    "")"");
        }
        dao = dbi.onDemand(TaskDao.class);
    }",method,
"    @Test
    public void testPresent() {
        final OffsetDateTime startDate = OffsetDateTime.now();
        final OffsetDateTime endDate = startDate.plusDays(1L);
        dao.insert(1, Optional.of(""John Hughes""), startDate, Optional.of(endDate), Optional.empty());
        assertThat(dao.findEndDateById(1).get()).isEqualTo(endDate);
    }",method,
"    @Test
    public void testAbsent() {
        dao.insert(2, Optional.of(""Kate Johansen""), OffsetDateTime.now(),
                Optional.empty(), Optional.of(""To be done""));
        assertThat(dao.findEndDateById(2).isPresent()).isFalse();
    }",method,
"public class ToDate implements Function {
    @Override
    public Object call(Properties bindings, Object[] args) {
        if (args.length == 0) {
            // missing value, can this happen?
            return null;
        }
        Object arg0 = args[0];
        String o1;
        if (arg0 instanceof Date) {
            return arg0;
        } else if (arg0 instanceof Calendar) {
            return ((Calendar) arg0).getTime();
        } else if (arg0 instanceof Long) {
            o1 =  ((Long) arg0).toString(); // treat integers as years
        } else if (arg0 instanceof String) {
            o1 = (String) arg0;
        } else {
            // ignore cell values that aren't strings
            return new EvalError(""Not a String - cannot parse to date"");
        }
        // ""o, boolean month_first (optional)""
        if (args.length == 1 || (args.length == 2 && args[1] instanceof Boolean)) {
            boolean month_first = true;
            if (args.length == 2) {
                month_first = (Boolean) args[1];
            }
            try {
                return CalendarParser.parse( o1, (month_first) ? CalendarParser.MM_DD_YY : CalendarParser.DD_MM_YY);
            } catch (CalendarParserException e) {
                Date d = ParsingUtilities.stringToDate(o1);
                if (d != null) {
                    return d;
                } else {
                    try {
                        return javax.xml.bind.DatatypeConverter.parseDateTime(o1).getTime();
                    } catch (IllegalArgumentException e2) {
                    }
                    // alternate implementation which may be useful on some JVMs?
//                    try {
//                        return javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar(o1).toGregorianCalendar().getTime();
//                    } catch (DatatypeConfigurationException e2) {     
//                    }
                }
                return new EvalError(""Cannot parse to date"");
            }
        }
        // ""o, format1, format2 (optional), ...""
        Locale locale = Locale.getDefault();
        if (args.length>=2) {
            for (int i=1;i<args.length;i++) {
                if (!(args[i] instanceof String)) {
                    // skip formats that aren't strings
                    continue;
                }
                String format  = StringUtils.trim((String) args[i]);
                DateFormat formatter;
                // Attempt to parse first string as a language tag
                if (i == 1) {
                    // Locale possibleLocale = Locale.forLanguageTag(format); // Java 1.7+ only
                    Locale possibleLocale;
                    int c = format.indexOf('_');
                    if (c > 0) {
                        possibleLocale = new Locale(format.substring(0, c),format.substring(c+1));
                    } else {
                        possibleLocale = new Locale(format);
                    }
                    boolean valid = false;
                    for (Locale l : DateFormat.getAvailableLocales()) {
                        if (l.equals(possibleLocale)) {
                            locale = possibleLocale;
                            valid = true;
                            break;
                        }
                    }
                    if (valid) { // If we got a valid locale
                        if (args.length == 2) { // No format strings to try, process using default
                          formatter = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
                          formatter.setLenient(true);
                          GregorianCalendar date = parse(o1, formatter);
                          if (date != null) {
                              return date;
                          } else {
                              return new EvalError(""Unable to parse as date"");
                          }
                        }
                        continue; // Don't try to process locale string as a format string if it was valid
                    }
                }
                try {
                    formatter = new SimpleDateFormat(format,locale);
                } catch (IllegalArgumentException e) {
                    return new EvalError(""Unknown date format"");
                }
                formatter.setLenient(true);
                GregorianCalendar date = parse(o1, formatter);
                if (date != null) {
                    return date;
                }
            }
            return new EvalError(""Unable to parse as date"");
        }
        return null;
    }
    private GregorianCalendar parse(String o1, DateFormat formatter) {
        try {
            Date date = formatter.parse(o1);
            GregorianCalendar c = new GregorianCalendar();
            c.setTime(date);
            return c;
        } catch (java.text.ParseException e) {
            return null;
        }
    }
    @Override
    public void write(JSONWriter writer, Properties options)
    throws JSONException {
        writer.object();
        writer.key(""description""); writer.value(""Returns o converted to a date object, you can hint if the day or the month is listed first, or give an ordered list of possible formats using this syntax: http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"");
        writer.key(""params""); writer.value(""o, boolean month_first / format1, format2, ... (all optional)"");
        writer.key(""returns""); writer.value(""date"");
        writer.endObject();
    }
}",class,
"    @Override
    public Object call(Properties bindings, Object[] args) {
        if (args.length == 0) {
            // missing value, can this happen?
            return null;
        }
        Object arg0 = args[0];
        String o1;
        if (arg0 instanceof Date) {
            return arg0;
        } else if (arg0 instanceof Calendar) {
            return ((Calendar) arg0).getTime();
        } else if (arg0 instanceof Long) {
            o1 =  ((Long) arg0).toString(); // treat integers as years
        } else if (arg0 instanceof String) {
            o1 = (String) arg0;
        } else {
            // ignore cell values that aren't strings
            return new EvalError(""Not a String - cannot parse to date"");
        }
        // ""o, boolean month_first (optional)""
        if (args.length == 1 || (args.length == 2 && args[1] instanceof Boolean)) {
            boolean month_first = true;
            if (args.length == 2) {
                month_first = (Boolean) args[1];
            }
            try {
                return CalendarParser.parse( o1, (month_first) ? CalendarParser.MM_DD_YY : CalendarParser.DD_MM_YY);
            } catch (CalendarParserException e) {
                Date d = ParsingUtilities.stringToDate(o1);
                if (d != null) {
                    return d;
                } else {
                    try {
                        return javax.xml.bind.DatatypeConverter.parseDateTime(o1).getTime();
                    } catch (IllegalArgumentException e2) {
                    }
                    // alternate implementation which may be useful on some JVMs?
//                    try {
//                        return javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar(o1).toGregorianCalendar().getTime();
//                    } catch (DatatypeConfigurationException e2) {     
//                    }
                }
                return new EvalError(""Cannot parse to date"");
            }
        }
        // ""o, format1, format2 (optional), ...""
        Locale locale = Locale.getDefault();
        if (args.length>=2) {
            for (int i=1;i<args.length;i++) {
                if (!(args[i] instanceof String)) {
                    // skip formats that aren't strings
                    continue;
                }
                String format  = StringUtils.trim((String) args[i]);
                DateFormat formatter;
                // Attempt to parse first string as a language tag
                if (i == 1) {
                    // Locale possibleLocale = Locale.forLanguageTag(format); // Java 1.7+ only
                    Locale possibleLocale;
                    int c = format.indexOf('_');
                    if (c > 0) {
                        possibleLocale = new Locale(format.substring(0, c),format.substring(c+1));
                    } else {
                        possibleLocale = new Locale(format);
                    }
                    boolean valid = false;
                    for (Locale l : DateFormat.getAvailableLocales()) {
                        if (l.equals(possibleLocale)) {
                            locale = possibleLocale;
                            valid = true;
                            break;
                        }
                    }
                    if (valid) { // If we got a valid locale
                        if (args.length == 2) { // No format strings to try, process using default
                          formatter = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
                          formatter.setLenient(true);
                          GregorianCalendar date = parse(o1, formatter);
                          if (date != null) {
                              return date;
                          } else {
                              return new EvalError(""Unable to parse as date"");
                          }
                        }
                        continue; // Don't try to process locale string as a format string if it was valid
                    }
                }
                try {
                    formatter = new SimpleDateFormat(format,locale);
                } catch (IllegalArgumentException e) {
                    return new EvalError(""Unknown date format"");
                }
                formatter.setLenient(true);
                GregorianCalendar date = parse(o1, formatter);
                if (date != null) {
                    return date;
                }
            }
            return new EvalError(""Unable to parse as date"");
        }
        return null;
    }",method,
"        if (args.length == 0) {
            // missing value, can this happen?
            return null;
        }",method,
"        if (arg0 instanceof Date) {
            return arg0;
        }",method,
"            if (args.length == 2) {
                month_first = (Boolean) args[1];
            }",method,
"                if (d != null) {
                    return d;
                }",method,
"        if (args.length>=2) {
            for (int i=1;i<args.length;i++) {
                if (!(args[i] instanceof String)) {
                    // skip formats that aren't strings
                    continue;
                }
                String format  = StringUtils.trim((String) args[i]);
                DateFormat formatter;
                // Attempt to parse first string as a language tag
                if (i == 1) {
                    // Locale possibleLocale = Locale.forLanguageTag(format); // Java 1.7+ only
                    Locale possibleLocale;
                    int c = format.indexOf('_');
                    if (c > 0) {
                        possibleLocale = new Locale(format.substring(0, c),format.substring(c+1));
                    } else {
                        possibleLocale = new Locale(format);
                    }
                    boolean valid = false;
                    for (Locale l : DateFormat.getAvailableLocales()) {
                        if (l.equals(possibleLocale)) {
                            locale = possibleLocale;
                            valid = true;
                            break;
                        }
                    }
                    if (valid) { // If we got a valid locale
                        if (args.length == 2) { // No format strings to try, process using default
                          formatter = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
                          formatter.setLenient(true);
                          GregorianCalendar date = parse(o1, formatter);
                          if (date != null) {
                              return date;
                          } else {
                              return new EvalError(""Unable to parse as date"");
                          }
                        }
                        continue; // Don't try to process locale string as a format string if it was valid
                    }
                }
                try {
                    formatter = new SimpleDateFormat(format,locale);
                } catch (IllegalArgumentException e) {
                    return new EvalError(""Unknown date format"");
                }
                formatter.setLenient(true);
                GregorianCalendar date = parse(o1, formatter);
                if (date != null) {
                    return date;
                }
            }
            return new EvalError(""Unable to parse as date"");
        }",method,
"            for (int i=1;i<args.length;i++) {
                if (!(args[i] instanceof String)) {
                    // skip formats that aren't strings
                    continue;
                }
                String format  = StringUtils.trim((String) args[i]);
                DateFormat formatter;
                // Attempt to parse first string as a language tag
                if (i == 1) {
                    // Locale possibleLocale = Locale.forLanguageTag(format); // Java 1.7+ only
                    Locale possibleLocale;
                    int c = format.indexOf('_');
                    if (c > 0) {
                        possibleLocale = new Locale(format.substring(0, c),format.substring(c+1));
                    } else {
                        possibleLocale = new Locale(format);
                    }
                    boolean valid = false;
                    for (Locale l : DateFormat.getAvailableLocales()) {
                        if (l.equals(possibleLocale)) {
                            locale = possibleLocale;
                            valid = true;
                            break;
                        }
                    }
                    if (valid) { // If we got a valid locale
                        if (args.length == 2) { // No format strings to try, process using default
                          formatter = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
                          formatter.setLenient(true);
                          GregorianCalendar date = parse(o1, formatter);
                          if (date != null) {
                              return date;
                          } else {
                              return new EvalError(""Unable to parse as date"");
                          }
                        }
                        continue; // Don't try to process locale string as a format string if it was valid
                    }
                }
                try {
                    formatter = new SimpleDateFormat(format,locale);
                } catch (IllegalArgumentException e) {
                    return new EvalError(""Unknown date format"");
                }
                formatter.setLenient(true);
                GregorianCalendar date = parse(o1, formatter);
                if (date != null) {
                    return date;
                }
            }",method,
"                if (i == 1) {
                    // Locale possibleLocale = Locale.forLanguageTag(format); // Java 1.7+ only
                    Locale possibleLocale;
                    int c = format.indexOf('_');
                    if (c > 0) {
                        possibleLocale = new Locale(format.substring(0, c),format.substring(c+1));
                    } else {
                        possibleLocale = new Locale(format);
                    }
                    boolean valid = false;
                    for (Locale l : DateFormat.getAvailableLocales()) {
                        if (l.equals(possibleLocale)) {
                            locale = possibleLocale;
                            valid = true;
                            break;
                        }
                    }
                    if (valid) { // If we got a valid locale
                        if (args.length == 2) { // No format strings to try, process using default
                          formatter = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
                          formatter.setLenient(true);
                          GregorianCalendar date = parse(o1, formatter);
                          if (date != null) {
                              return date;
                          } else {
                              return new EvalError(""Unable to parse as date"");
                          }
                        }
                        continue; // Don't try to process locale string as a format string if it was valid
                    }
                }",method,
"                    if (c > 0) {
                        possibleLocale = new Locale(format.substring(0, c),format.substring(c+1));
                    }",method,
"                    if (valid) { // If we got a valid locale
                        if (args.length == 2) { // No format strings to try, process using default
                          formatter = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
                          formatter.setLenient(true);
                          GregorianCalendar date = parse(o1, formatter);
                          if (date != null) {
                              return date;
                          } else {
                              return new EvalError(""Unable to parse as date"");
                          }
                        }
                        continue; // Don't try to process locale string as a format string if it was valid
                    }",method,
"                        if (args.length == 2) { // No format strings to try, process using default
                          formatter = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
                          formatter.setLenient(true);
                          GregorianCalendar date = parse(o1, formatter);
                          if (date != null) {
                              return date;
                          } else {
                              return new EvalError(""Unable to parse as date"");
                          }
                        }",method,
"                          if (date != null) {
                              return date;
                          }",method,
"                if (date != null) {
                    return date;
                }",method,
"    private GregorianCalendar parse(String o1, DateFormat formatter) {
        try {
            Date date = formatter.parse(o1);
            GregorianCalendar c = new GregorianCalendar();
            c.setTime(date);
            return c;
        } catch (java.text.ParseException e) {
            return null;
        }
    }",method,
"    @Override
    public void write(JSONWriter writer, Properties options)
    throws JSONException {
        writer.object();
        writer.key(""description""); writer.value(""Returns o converted to a date object, you can hint if the day or the month is listed first, or give an ordered list of possible formats using this syntax: http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"");
        writer.key(""params""); writer.value(""o, boolean month_first / format1, format2, ... (all optional)"");
        writer.key(""returns""); writer.value(""date"");
        writer.endObject();
    }",method,
"public abstract class SNIServerName {
    // the type of the server name
    private final int type;
    // the encoded value of the server name
    private final byte[] encoded;
    // the hex digitals
    private static final char[] HEXES = ""0123456789ABCDEF"".toCharArray();
    protected SNIServerName(int type, byte[] encoded) {
        if (type < 0) {
            throw new IllegalArgumentException(
                ""Server name type cannot be less than zero"");
        } else if (type > 255) {
            throw new IllegalArgumentException(
                ""Server name type cannot be greater than 255"");
        }
        this.type = type;
        if (encoded == null) {
            throw new NullPointerException(
                ""Server name encoded value cannot be null"");
        }
        this.encoded = encoded.clone();
    }
    public final int getType() {
        return type;
    }
    public final byte[] getEncoded() {
        return encoded.clone();
    }
    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (this.getClass() != other.getClass()) {
            return false;
        }
        SNIServerName that = (SNIServerName)other;
        return (this.type == that.type) &&
                    Arrays.equals(this.encoded, that.encoded);
    }
    @Override
    public int hashCode() {
        int result = 17;    // 17/31: prime number to decrease collisions
        result = 31 * result + type;
        result = 31 * result + Arrays.hashCode(encoded);
        return result;
    }
    @Override
    public String toString() {
        if (type == StandardConstants.SNI_HOST_NAME) {
            return ""type=host_name (0), value="" + toHexString(encoded);
        } else {
            return ""type=("" + type + ""), value="" + toHexString(encoded);
        }
    }
    // convert byte array to hex string
    private static String toHexString(byte[] bytes) {
        if (bytes.length == 0) {
            return ""(empty)"";
        }
        StringBuilder sb = new StringBuilder(bytes.length * 3 - 1);
        boolean isInitial = true;
        for (byte b : bytes) {
            if (isInitial) {
                isInitial = false;
            } else {
                sb.append(':');
            }
            int k = b & 0xFF;
            sb.append(HEXES[k >>> 4]);
            sb.append(HEXES[k & 0xF]);
        }
        return sb.toString();
    }
}",class,
"    protected SNIServerName(int type, byte[] encoded) {
        if (type < 0) {
            throw new IllegalArgumentException(
                ""Server name type cannot be less than zero"");
        } else if (type > 255) {
            throw new IllegalArgumentException(
                ""Server name type cannot be greater than 255"");
        }
        this.type = type;
        if (encoded == null) {
            throw new NullPointerException(
                ""Server name encoded value cannot be null"");
        }
        this.encoded = encoded.clone();
    }",method,
"        if (type < 0) {
            throw new IllegalArgumentException(
                ""Server name type cannot be less than zero"");
        }",method,
"        if (encoded == null) {
            throw new NullPointerException(
                ""Server name encoded value cannot be null"");
        }",method,
"    public final int getType() {
        return type;
    }",method,
"    public final byte[] getEncoded() {
        return encoded.clone();
    }",method,
"    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (this.getClass() != other.getClass()) {
            return false;
        }
        SNIServerName that = (SNIServerName)other;
        return (this.type == that.type) &&
                    Arrays.equals(this.encoded, that.encoded);
    }",method,
"        if (this == other) {
            return true;
        }",method,
"    @Override
    public int hashCode() {
        int result = 17;    // 17/31: prime number to decrease collisions
        result = 31 * result + type;
        result = 31 * result + Arrays.hashCode(encoded);
        return result;
    }",method,
"    @Override
    public String toString() {
        if (type == StandardConstants.SNI_HOST_NAME) {
            return ""type=host_name (0), value="" + toHexString(encoded);
        } else {
            return ""type=("" + type + ""), value="" + toHexString(encoded);
        }
    }",method,
"        if (type == StandardConstants.SNI_HOST_NAME) {
            return ""type=host_name (0), value="" + toHexString(encoded);
        }",method,
"    private static String toHexString(byte[] bytes) {
        if (bytes.length == 0) {
            return ""(empty)"";
        }
        StringBuilder sb = new StringBuilder(bytes.length * 3 - 1);
        boolean isInitial = true;
        for (byte b : bytes) {
            if (isInitial) {
                isInitial = false;
            } else {
                sb.append(':');
            }
            int k = b & 0xFF;
            sb.append(HEXES[k >>> 4]);
            sb.append(HEXES[k & 0xF]);
        }
        return sb.toString();
    }",method,
"        if (bytes.length == 0) {
            return ""(empty)"";
        }",method,
"        for (byte b : bytes) {
            if (isInitial) {
                isInitial = false;
            } else {
                sb.append(':');
            }
            int k = b & 0xFF;
            sb.append(HEXES[k >>> 4]);
            sb.append(HEXES[k & 0xF]);
        }",method,
"            if (isInitial) {
                isInitial = false;
            }",method,
"public class ModuleConfig extends AbstractConfig {
    private static final long serialVersionUID = 5508512956753757169L;
    // 模块名称
    private String name;
    // 模块版本
    private String version;
    // 应用负责人
    private String owner;
    // 组织名(BU或部门)
    private String organization;
    // 注册中心
    private List<RegistryConfig> registries;
    // 服务监控
    private MonitorConfig monitor;
    // 是否为缺省
    private Boolean isDefault;
    public ModuleConfig() {
    }
    public ModuleConfig(String name) {
        setName(name);
    }
    @Parameter(key = ""module"", required = true)
    public String getName() {
        return name;
    }
    public void setName(String name) {
        checkName(""name"", name);
        this.name = name;
        if (id == null || id.length() == 0) {
            id = name;
        }
    }
    @Parameter(key = ""module.version"")
    public String getVersion() {
        return version;
    }
    public void setVersion(String version) {
        this.version = version;
    }
    public String getOwner() {
        return owner;
    }
    public void setOwner(String owner) {
        checkName(""owner"", owner);
        this.owner = owner;
    }
    public String getOrganization() {
        return organization;
    }
    public void setOrganization(String organization) {
        checkName(""organization"", organization);
        this.organization = organization;
    }
    public RegistryConfig getRegistry() {
        return registries == null || registries.size() == 0 ? null : registries.get(0);
    }
    public void setRegistry(RegistryConfig registry) {
        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);
        registries.add(registry);
        this.registries = registries;
    }
    public List<RegistryConfig> getRegistries() {
        return registries;
    }
    @SuppressWarnings({""unchecked""})
    public void setRegistries(List<? extends RegistryConfig> registries) {
        this.registries = (List<RegistryConfig>) registries;
    }
    public MonitorConfig getMonitor() {
        return monitor;
    }
    public void setMonitor(String monitor) {
        this.monitor = new MonitorConfig(monitor);
    }
    public void setMonitor(MonitorConfig monitor) {
        this.monitor = monitor;
    }
    public Boolean isDefault() {
        return isDefault;
    }
    public void setDefault(Boolean isDefault) {
        this.isDefault = isDefault;
    }
}",class,
"    public ModuleConfig() {
    }",method,
"    public ModuleConfig(String name) {
        setName(name);
    }",method,
"    @Parameter(key = ""module"", required = true)
    public String getName() {
        return name;
    }",method,
"    public void setName(String name) {
        checkName(""name"", name);
        this.name = name;
        if (id == null || id.length() == 0) {
            id = name;
        }
    }",method,
"    @Parameter(key = ""module.version"")
    public String getVersion() {
        return version;
    }",method,
"    public void setVersion(String version) {
        this.version = version;
    }",method,
"    public String getOwner() {
        return owner;
    }",method,
"    public void setOwner(String owner) {
        checkName(""owner"", owner);
        this.owner = owner;
    }",method,
"    public String getOrganization() {
        return organization;
    }",method,
"    public void setOrganization(String organization) {
        checkName(""organization"", organization);
        this.organization = organization;
    }",method,
"    public RegistryConfig getRegistry() {
        return registries == null || registries.size() == 0 ? null : registries.get(0);
    }",method,
"    public void setRegistry(RegistryConfig registry) {
        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);
        registries.add(registry);
        this.registries = registries;
    }",method,
"    public List<RegistryConfig> getRegistries() {
        return registries;
    }",method,
"    @SuppressWarnings({""unchecked""})
    public void setRegistries(List<? extends RegistryConfig> registries) {
        this.registries = (List<RegistryConfig>) registries;
    }",method,
"    public MonitorConfig getMonitor() {
        return monitor;
    }",method,
"    public void setMonitor(String monitor) {
        this.monitor = new MonitorConfig(monitor);
    }",method,
"    public void setMonitor(MonitorConfig monitor) {
        this.monitor = monitor;
    }",method,
"    public Boolean isDefault() {
        return isDefault;
    }",method,
"    public void setDefault(Boolean isDefault) {
        this.isDefault = isDefault;
    }",method,
"public class MapToStringTester<K, V> extends AbstractMapTester<K, V> {
  public void testToString_minimal() {
    assertNotNull(""toString() should not return null"", getMap().toString());
  }
  @CollectionSize.Require(ZERO)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  public void testToString_size0() {
    assertEquals(""emptyMap.toString should return {}"", ""{}"", getMap().toString());
  }
  @CollectionSize.Require(ONE)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  public void testToString_size1() {
    assertEquals(""size1Map.toString should return {entry}"", ""{"" + e0() + ""}"", getMap().toString());
  }
  @CollectionSize.Require(absent = ZERO)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  @MapFeature.Require(ALLOWS_NULL_KEYS)
  public void testToStringWithNullKey() {
    initMapWithNullKey();
    testToString_formatting();
  }
  @CollectionSize.Require(absent = ZERO)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  @MapFeature.Require(ALLOWS_NULL_VALUES)
  public void testToStringWithNullValue() {
    initMapWithNullValue();
    testToString_formatting();
  }
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  public void testToString_formatting() {
    assertEquals(
        ""map.toString() incorrect"", expectedToString(getMap().entrySet()), getMap().toString());
  }
  private String expectedToString(Set<Entry<K, V>> entries) {
    Map<K, V> reference = new LinkedHashMap<>();
    for (Map.Entry<K, V> entry : entries) {
      reference.put(entry.getKey(), entry.getValue());
    }
    return reference.toString();
  }
}",class,
"  public void testToString_minimal() {
    assertNotNull(""toString() should not return null"", getMap().toString());
  }",method,
"  @CollectionSize.Require(ZERO)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  public void testToString_size0() {
    assertEquals(""emptyMap.toString should return {}"", ""{}"", getMap().toString());
  }",method,
"  @CollectionSize.Require(ONE)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  public void testToString_size1() {
    assertEquals(""size1Map.toString should return {entry}"", ""{"" + e0() + ""}"", getMap().toString());
  }",method,
"  @CollectionSize.Require(absent = ZERO)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  @MapFeature.Require(ALLOWS_NULL_KEYS)
  public void testToStringWithNullKey() {
    initMapWithNullKey();
    testToString_formatting();
  }",method,
"  @CollectionSize.Require(absent = ZERO)
  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  @MapFeature.Require(ALLOWS_NULL_VALUES)
  public void testToStringWithNullValue() {
    initMapWithNullValue();
    testToString_formatting();
  }",method,
"  @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
  public void testToString_formatting() {
    assertEquals(
        ""map.toString() incorrect"", expectedToString(getMap().entrySet()), getMap().toString());
  }",method,
"  private String expectedToString(Set<Entry<K, V>> entries) {
    Map<K, V> reference = new LinkedHashMap<>();
    for (Map.Entry<K, V> entry : entries) {
      reference.put(entry.getKey(), entry.getValue());
    }
    return reference.toString();
  }",method,
"    for (Map.Entry<K, V> entry : entries) {
      reference.put(entry.getKey(), entry.getValue());
    }",method,
"public class XsdNamespaceBuilder extends NanoXmlUtil.IXMLBuilderAdapter implements Comparable<XsdNamespaceBuilder> {
  public static String computeNamespace(final InputStream is) {
    return computeNamespace(new InputStreamReader(is)).getNamespace();
  }
  public static XsdNamespaceBuilder computeNamespace(final Reader reader) {
    try {
      final XsdNamespaceBuilder builder = new XsdNamespaceBuilder();
      NanoXmlUtil.parse(reader, builder);
      HashSet<String> tags = new HashSet<>(builder.getTags());
      tags.removeAll(builder.myReferencedTags);
      builder.getRootTags().addAll(tags);
      return builder;
    }
    finally {
      try {
        if (reader != null) {
          reader.close();
        }
      }
      catch (IOException e) {
        // can never happen
      }
    }
  }
  private String myCurrentTag;
  private int myCurrentDepth;
  private String myNamespace;
  private String myVersion;
  private final List<String> myTags;
  private final Set<String> myReferencedTags = new HashSet<>();
  private final List<String> myRootTags;
  private final List<String> myAttributes = new ArrayList<>();
  @Override
  public void startElement(@NonNls final String name, @NonNls final String nsPrefix, @NonNls final String nsURI, final String systemID, final int lineNr)
      throws Exception {
    if (XmlUtil.XML_SCHEMA_URI.equals(nsURI)) {
      myCurrentTag = name;
    }
    myCurrentDepth++;
  }
  @Override
  public void endElement(String name, String nsPrefix, String nsURI) throws Exception {
    myCurrentDepth--;
    myCurrentTag = null;
  }
  @Override
  public void addAttribute(@NonNls final String key, final String nsPrefix, final String nsURI, final String value, final String type)
      throws Exception {
    if (myCurrentDepth == 1 && ""schema"".equals(myCurrentTag)) {
      if (""targetNamespace"".equals(key)) {
        myNamespace = value;
      }
      else if (""version"".equals(key)) {
        myVersion = value;
      }
    }
    else if (""element"".equals(myCurrentTag)) {
      if (myCurrentDepth < 3 && ""name"".equals(key)) {
        myTags.add(value);
      }
      else if (""ref"".equals(key)) {
        myReferencedTags.add(XmlUtil.getLocalName(value).toString());
      }
    }
  }
  @Override
  public int compareTo(@NotNull XsdNamespaceBuilder o) {
    return Comparing.compare(myNamespace, o.myNamespace);
  }
  public boolean hasTag(@NotNull String tagName) {
    return myTags.contains(tagName);
  }
  public int getRating(@Nullable String tagName, @Nullable String version) {
    int rate = 0;
    if (tagName != null && myTags.contains(tagName)) {
      rate |= 0x02;
    }
    if (version != null && version.equals(myVersion)) {
      rate |= 0x01;
    }
    return rate;
  }
  private XsdNamespaceBuilder() {
    myTags = new ArrayList<>();
    myRootTags = new ArrayList<>();
  }
  XsdNamespaceBuilder(String namespace, String version, List<String> tags, List<String> rootTags) {
    myNamespace = namespace;
    myVersion = version;
    myTags = tags;
    myRootTags = rootTags;
  }
  public String getNamespace() {
    return myNamespace;
  }
  public String getVersion() {
    return myVersion;
  }
  public List<String> getTags() {
    return myTags;
  }
  public List<String> getRootTags() {
    return myRootTags;
  }
  public List<String> getAttributes() {
    return myAttributes;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    XsdNamespaceBuilder builder = (XsdNamespaceBuilder)o;
    if (myNamespace != null ? !myNamespace.equals(builder.myNamespace) : builder.myNamespace != null) return false;
    if (myVersion != null ? !myVersion.equals(builder.myVersion) : builder.myVersion != null) return false;
    if (myTags != null ? !myTags.equals(builder.myTags) : builder.myTags != null) return false;
    return true;
  }
  @Override
  public int hashCode() {
    int result = myNamespace != null ? myNamespace.hashCode() : 0;
    result = 31 * result + (myVersion != null ? myVersion.hashCode() : 0);
    result = 31 * result + (myTags != null ? myTags.hashCode() : 0);
    return result;
  }
}",class,
"  public static String computeNamespace(final InputStream is) {
    return computeNamespace(new InputStreamReader(is)).getNamespace();
  }",method,
"  public static XsdNamespaceBuilder computeNamespace(final Reader reader) {
    try {
      final XsdNamespaceBuilder builder = new XsdNamespaceBuilder();
      NanoXmlUtil.parse(reader, builder);
      HashSet<String> tags = new HashSet<>(builder.getTags());
      tags.removeAll(builder.myReferencedTags);
      builder.getRootTags().addAll(tags);
      return builder;
    }
    finally {
      try {
        if (reader != null) {
          reader.close();
        }
      }
      catch (IOException e) {
        // can never happen
      }
    }
  }",method,
"        if (reader != null) {
          reader.close();
        }",method,
"      catch (IOException e) {
        // can never happen
      }",method,
"  @Override
  public void startElement(@NonNls final String name, @NonNls final String nsPrefix, @NonNls final String nsURI, final String systemID, final int lineNr)
      throws Exception {
    if (XmlUtil.XML_SCHEMA_URI.equals(nsURI)) {
      myCurrentTag = name;
    }
    myCurrentDepth++;
  }",method,

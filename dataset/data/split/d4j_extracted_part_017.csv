code_snippet,type,score
"    public void setUserOauthId(Integer userOauthId) {
        this.userOauthId = userOauthId;
    }",method,
"    public Integer getUserId() {
        return userId;
    }",method,
"    public void setUserId(Integer userId) {
        this.userId = userId;
    }",method,
"    public Integer getOauthId() {
        return oauthId;
    }",method,
"    public void setOauthId(Integer oauthId) {
        this.oauthId = oauthId;
    }",method,
"    public Byte getStatus() {
        return status;
    }",method,
"    public void setStatus(Byte status) {
        this.status = status;
    }",method,
"    public Date getCreateTime() {
        return createTime;
    }",method,
"    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }",method,
"    public byte[] getOpenId() {
        return openId;
    }",method,
"    public void setOpenId(byte[] openId) {
        this.openId = openId;
    }",method,
"    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(getClass().getSimpleName());
        sb.append("" ["");
        sb.append(""Hash = "").append(hashCode());
        sb.append("", userOauthId="").append(userOauthId);
        sb.append("", userId="").append(userId);
        sb.append("", oauthId="").append(oauthId);
        sb.append("", status="").append(status);
        sb.append("", createTime="").append(createTime);
        sb.append("", openId="").append(openId);
        sb.append(""]"");
        return sb.toString();
    }",method,
"    @Override
    public boolean equals(Object that) {
        if (this == that) {
            return true;
        }
        if (that == null) {
            return false;
        }
        if (getClass() != that.getClass()) {
            return false;
        }
        UcenterUserOauth other = (UcenterUserOauth) that;
        return (this.getUserOauthId() == null ? other.getUserOauthId() == null : this.getUserOauthId().equals(other.getUserOauthId()))
            && (this.getUserId() == null ? other.getUserId() == null : this.getUserId().equals(other.getUserId()))
            && (this.getOauthId() == null ? other.getOauthId() == null : this.getOauthId().equals(other.getOauthId()))
            && (this.getStatus() == null ? other.getStatus() == null : this.getStatus().equals(other.getStatus()))
            && (this.getCreateTime() == null ? other.getCreateTime() == null : this.getCreateTime().equals(other.getCreateTime()))
            && (Arrays.equals(this.getOpenId(), other.getOpenId()));
    }",method,
"        if (this == that) {
            return true;
        }",method,
"        if (that == null) {
            return false;
        }",method,
"    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((getUserOauthId() == null) ? 0 : getUserOauthId().hashCode());
        result = prime * result + ((getUserId() == null) ? 0 : getUserId().hashCode());
        result = prime * result + ((getOauthId() == null) ? 0 : getOauthId().hashCode());
        result = prime * result + ((getStatus() == null) ? 0 : getStatus().hashCode());
        result = prime * result + ((getCreateTime() == null) ? 0 : getCreateTime().hashCode());
        result = prime * result + (Arrays.hashCode(getOpenId()));
        return result;
    }",method,
"public class Main_interpolator extends ActionBarActivity implements Main_fragment.OnPlotClickListener {
    @Override
    public void onBackPressed() {
        if (getFragmentManager().getBackStackEntryCount() > 0){
            getFragmentManager().popBackStackImmediate();
            getFragmentManager().beginTransaction().commit();
        } else {
            super.onBackPressed();
        }
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //ActionBar actionbar=getActionBar();
        //actionbar.show();
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.my_toolbar);
        setSupportActionBar(toolbar);
        if (savedInstanceState==null) {
            Main_fragment main_fragment = new Main_fragment();
            getFragmentManager().beginTransaction().add(R.id.fragment, main_fragment, ""main_fragment"")
                    .commit();
        }
    }
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main_interpolator, menu);
        return super.onCreateOptionsMenu(menu);
    }
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        switch (id) {
            case R.id.about:
                Intent about = new Intent(Main_interpolator.this,About.class);
                startActivity(about);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
    @Override
    public void OnPlotClick(InterpolatorPoints interpolatorPoints) {
        try {
            InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(), 0);
        }catch (NullPointerException e){
            Log.d(""Exception"",""Lite"");
        }
        Graph_Fragment graph_fragment = new Graph_Fragment();
        Bundle bundle = new Bundle();
        bundle.putFloat(""x"",interpolatorPoints.x);
        bundle.putFloat(""y"",interpolatorPoints.y);
        bundle.putFloat(""x1"",interpolatorPoints.x1);
        bundle.putFloat(""x2"",interpolatorPoints.x2);
        bundle.putFloat(""y1"",interpolatorPoints.y1);
        bundle.putFloat(""y2"", interpolatorPoints.y2);
        graph_fragment.setArguments(bundle);
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        fragmentTransaction.replace(R.id.fragment, graph_fragment, ""graph_fragmet"");
        fragmentTransaction.addToBackStack(null);
        fragmentTransaction.commit();
    }
}",class,
"    @Override
    public void onBackPressed() {
        if (getFragmentManager().getBackStackEntryCount() > 0){
            getFragmentManager().popBackStackImmediate();
            getFragmentManager().beginTransaction().commit();
        } else {
            super.onBackPressed();
        }
    }",method,
"    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //ActionBar actionbar=getActionBar();
        //actionbar.show();
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.my_toolbar);
        setSupportActionBar(toolbar);
        if (savedInstanceState==null) {
            Main_fragment main_fragment = new Main_fragment();
            getFragmentManager().beginTransaction().add(R.id.fragment, main_fragment, ""main_fragment"")
                    .commit();
        }
    }",method,
"        if (savedInstanceState==null) {
            Main_fragment main_fragment = new Main_fragment();
            getFragmentManager().beginTransaction().add(R.id.fragment, main_fragment, ""main_fragment"")
                    .commit();
        }",method,
"    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main_interpolator, menu);
        return super.onCreateOptionsMenu(menu);
    }",method,
"    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        switch (id) {
            case R.id.about:
                Intent about = new Intent(Main_interpolator.this,About.class);
                startActivity(about);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }",method,
"        switch (id) {
            case R.id.about:
                Intent about = new Intent(Main_interpolator.this,About.class);
                startActivity(about);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }",method,
"    @Override
    public void OnPlotClick(InterpolatorPoints interpolatorPoints) {
        try {
            InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(), 0);
        }catch (NullPointerException e){
            Log.d(""Exception"",""Lite"");
        }
        Graph_Fragment graph_fragment = new Graph_Fragment();
        Bundle bundle = new Bundle();
        bundle.putFloat(""x"",interpolatorPoints.x);
        bundle.putFloat(""y"",interpolatorPoints.y);
        bundle.putFloat(""x1"",interpolatorPoints.x1);
        bundle.putFloat(""x2"",interpolatorPoints.x2);
        bundle.putFloat(""y1"",interpolatorPoints.y1);
        bundle.putFloat(""y2"", interpolatorPoints.y2);
        graph_fragment.setArguments(bundle);
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        fragmentTransaction.replace(R.id.fragment, graph_fragment, ""graph_fragmet"");
        fragmentTransaction.addToBackStack(null);
        fragmentTransaction.commit();
    }",method,
"public class OcamlClean extends AbstractBuildRuleWithDeclaredAndExtraDeps {
  @AddToRuleKey private final OcamlBuildContext ocamlContext;
  private static final Logger LOG = Logger.get(OcamlClean.class);
  public OcamlClean(
      BuildTarget buildTarget,
      ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      OcamlBuildContext ocamlContext) {
    super(buildTarget, projectFilesystem, params);
    this.ocamlContext = ocamlContext;
  }
  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context, BuildableContext buildableContext) {
    ImmutableList.Builder<Step> steps = ImmutableList.builder();
    Path bcDir = ocamlContext.getCompileBytecodeOutputDir();
    Path optDir = ocamlContext.getCompileNativeOutputDir();
    if (Files.exists(bcDir)) {
      buildableContext.recordArtifact(bcDir);
      LOG.debug(""Adding clean step for bytecode output dir %s"", bcDir.toString());
      steps.addAll(
          MakeCleanDirectoryStep.of(
              BuildCellRelativePath.fromCellRelativePath(
                  context.getBuildCellRootPath(), getProjectFilesystem(), bcDir)));
    }
    if (Files.exists(optDir)) {
      buildableContext.recordArtifact(optDir);
      LOG.debug(""Adding clean step for native output dir %s"", optDir.toString());
      steps.addAll(
          MakeCleanDirectoryStep.of(
              BuildCellRelativePath.fromCellRelativePath(
                  context.getBuildCellRootPath(), getProjectFilesystem(), optDir)));
    }
    return steps.build();
  }
  @Nullable
  @Override
  public SourcePath getSourcePathToOutput() {
    return null;
  }
  @Override
  public boolean isCacheable() {
    return false;
  }
}",class,
"  public OcamlClean(
      BuildTarget buildTarget,
      ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      OcamlBuildContext ocamlContext) {
    super(buildTarget, projectFilesystem, params);
    this.ocamlContext = ocamlContext;
  }",method,
"  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context, BuildableContext buildableContext) {
    ImmutableList.Builder<Step> steps = ImmutableList.builder();
    Path bcDir = ocamlContext.getCompileBytecodeOutputDir();
    Path optDir = ocamlContext.getCompileNativeOutputDir();
    if (Files.exists(bcDir)) {
      buildableContext.recordArtifact(bcDir);
      LOG.debug(""Adding clean step for bytecode output dir %s"", bcDir.toString());
      steps.addAll(
          MakeCleanDirectoryStep.of(
              BuildCellRelativePath.fromCellRelativePath(
                  context.getBuildCellRootPath(), getProjectFilesystem(), bcDir)));
    }
    if (Files.exists(optDir)) {
      buildableContext.recordArtifact(optDir);
      LOG.debug(""Adding clean step for native output dir %s"", optDir.toString());
      steps.addAll(
          MakeCleanDirectoryStep.of(
              BuildCellRelativePath.fromCellRelativePath(
                  context.getBuildCellRootPath(), getProjectFilesystem(), optDir)));
    }
    return steps.build();
  }",method,
"  @Nullable
  @Override
  public SourcePath getSourcePathToOutput() {
    return null;
  }",method,
"  @Override
  public boolean isCacheable() {
    return false;
  }",method,
"public class GitCheckAttrParser {
  private static final Logger LOG = Logger.getInstance(GitCheckAttrParser.class);
  private static final String UNSPECIFIED_VALUE = ""unspecified"";
  @NotNull private final Map<String, Collection<GitAttribute>> myAttributes;
  private GitCheckAttrParser(@NotNull List<String> output) {
    myAttributes = new HashMap<>();
    for (String line : output) {
      if (line.isEmpty()) {
        continue;
      }
      List<String> split = StringUtil.split(line, "":"");
      LOG.assertTrue(split.size() == 3, String.format(""Output doesn't match the expected format. Line: %s%nAll output:%n%s"",
                                                      line, StringUtil.join(output, ""\n"")));
      String file = split.get(0).trim();
      String attribute = split.get(1).trim();
      String info = split.get(2).trim();
      GitAttribute attr = GitAttribute.forName(attribute);
      if (attr == null || info.equalsIgnoreCase(UNSPECIFIED_VALUE)) {
        // ignoring attributes that we are not interested in
        continue;
      }
      myAttributes.computeIfAbsent(file, f -> new ArrayList<>()).add(attr);
    }
  }
  @NotNull
  public static GitCheckAttrParser parse(@NotNull List<String> output) {
    return new GitCheckAttrParser(output);
  }
  @NotNull
  public Map<String, Collection<GitAttribute>> getAttributes() {
    return myAttributes;
  }
}",class,
"  @NotNull private final Map<String, Collection<GitAttribute>> myAttributes;
  private GitCheckAttrParser(@NotNull List<String> output) {
    myAttributes = new HashMap<>();
    for (String line : output) {
      if (line.isEmpty()) {
        continue;
      }
      List<String> split = StringUtil.split(line, "":"");
      LOG.assertTrue(split.size() == 3, String.format(""Output doesn't match the expected format. Line: %s%nAll output:%n%s"",
                                                      line, StringUtil.join(output, ""\n"")));
      String file = split.get(0).trim();
      String attribute = split.get(1).trim();
      String info = split.get(2).trim();
      GitAttribute attr = GitAttribute.forName(attribute);
      if (attr == null || info.equalsIgnoreCase(UNSPECIFIED_VALUE)) {
        // ignoring attributes that we are not interested in
        continue;
      }
      myAttributes.computeIfAbsent(file, f -> new ArrayList<>()).add(attr);
    }
  }",method,
"    for (String line : output) {
      if (line.isEmpty()) {
        continue;
      }
      List<String> split = StringUtil.split(line, "":"");
      LOG.assertTrue(split.size() == 3, String.format(""Output doesn't match the expected format. Line: %s%nAll output:%n%s"",
                                                      line, StringUtil.join(output, ""\n"")));
      String file = split.get(0).trim();
      String attribute = split.get(1).trim();
      String info = split.get(2).trim();
      GitAttribute attr = GitAttribute.forName(attribute);
      if (attr == null || info.equalsIgnoreCase(UNSPECIFIED_VALUE)) {
        // ignoring attributes that we are not interested in
        continue;
      }
      myAttributes.computeIfAbsent(file, f -> new ArrayList<>()).add(attr);
    }",method,
"  @NotNull
  public static GitCheckAttrParser parse(@NotNull List<String> output) {
    return new GitCheckAttrParser(output);
  }",method,
"  @NotNull
  public Map<String, Collection<GitAttribute>> getAttributes() {
    return myAttributes;
  }",method,
"import java.util.Map;
class InjectorBuilder {
    private final Stopwatch stopwatch = new Stopwatch();
    private final Errors errors = new Errors();
    private Stage stage;
    private final Initializer initializer = new Initializer();
    private final BindingProcessor bindingProcesor;
    private final InjectionRequestProcessor injectionRequestProcessor;
    private final InjectorShell.Builder shellBuilder = new InjectorShell.Builder();
    private List<InjectorShell> shells;
    InjectorBuilder() {
        injectionRequestProcessor = new InjectionRequestProcessor(errors, initializer);
        bindingProcesor = new BindingProcessor(errors, initializer);
    }
    InjectorBuilder stage(Stage stage) {
        shellBuilder.stage(stage);
        this.stage = stage;
        return this;
    }
    InjectorBuilder addModules(Iterable<? extends Module> modules) {
        shellBuilder.addModules(modules);
        return this;
    }
    Injector build() {
        if (shellBuilder == null) {
            throw new AssertionError(""Already built, builders are not reusable."");
        }
        // Synchronize while we're building up the bindings and other injector state. This ensures that
        // the JIT bindings in the parent injector don't change while we're being built
        synchronized (shellBuilder.lock()) {
            shells = shellBuilder.build(initializer, bindingProcesor, stopwatch, errors);
            stopwatch.resetAndLog(""Injector construction"");
            initializeStatically();
        }
        injectDynamically();
        return primaryInjector();
    }
    private void initializeStatically() {
        bindingProcesor.initializeBindings();
        stopwatch.resetAndLog(""Binding initialization"");
        for (InjectorShell shell : shells) {
            shell.getInjector().index();
        }
        stopwatch.resetAndLog(""Binding indexing"");
        injectionRequestProcessor.process(shells);
        stopwatch.resetAndLog(""Collecting injection requests"");
        bindingProcesor.runCreationListeners();
        stopwatch.resetAndLog(""Binding validation"");
        injectionRequestProcessor.validate();
        stopwatch.resetAndLog(""Static validation"");
        initializer.validateOustandingInjections(errors);
        stopwatch.resetAndLog(""Instance member validation"");
        new LookupProcessor(errors).process(shells);
        for (InjectorShell shell : shells) {
            ((DeferredLookups) shell.getInjector().lookups).initialize(errors);
        }
        stopwatch.resetAndLog(""Provider verification"");
        for (InjectorShell shell : shells) {
            if (!shell.getElements().isEmpty()) {
                throw new AssertionError(""Failed to execute "" + shell.getElements());
            }
        }
        errors.throwCreationExceptionIfErrorsExist();
    }
    private Injector primaryInjector() {
        return shells.get(0).getInjector();
    }
    private void injectDynamically() {
        injectionRequestProcessor.injectMembers();
        stopwatch.resetAndLog(""Static member injection"");
        initializer.injectAll(errors);
        stopwatch.resetAndLog(""Instance injection"");
        errors.throwCreationExceptionIfErrorsExist();
        for (InjectorShell shell : shells) {
            loadEagerSingletons(shell.getInjector(), stage, errors);
        }
        stopwatch.resetAndLog(""Preloading singletons"");
        errors.throwCreationExceptionIfErrorsExist();
    }
    public void loadEagerSingletons(InjectorImpl injector, Stage stage, Errors errors) {
        for (final Binding<?> binding : injector.state.getExplicitBindingsThisLevel().values()) {
            loadEagerSingletons(injector, stage, errors, (BindingImpl<?>)binding);
        }
        for (final Binding<?> binding : injector.jitBindings.values()) {
            loadEagerSingletons(injector, stage, errors, (BindingImpl<?>)binding);
        }
    }
    private void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors, BindingImpl<?> binding) {
        if (binding.getScoping().isEagerSingleton(stage)) {
            try {
                injector.callInContext(new ContextualCallable<Void>() {
                    Dependency<?> dependency = Dependency.get(binding.getKey());
                    @Override
                    public Void call(InternalContext context) {
                        context.setDependency(dependency);
                        Errors errorsForBinding = errors.withSource(dependency);
                        try {
                            binding.getInternalFactory().get(errorsForBinding, context, dependency);
                        } catch (ErrorsException e) {
                            errorsForBinding.merge(e.getErrors());
                        } finally {
                            context.setDependency(null);
                        }
                        return null;
                    }
                });
            } catch (ErrorsException e) {
                throw new AssertionError();
            }
        }
    }
}",class,
"    InjectorBuilder() {
        injectionRequestProcessor = new InjectionRequestProcessor(errors, initializer);
        bindingProcesor = new BindingProcessor(errors, initializer);
    }",method,
"    InjectorBuilder stage(Stage stage) {
        shellBuilder.stage(stage);
        this.stage = stage;
        return this;
    }",method,
"    InjectorBuilder addModules(Iterable<? extends Module> modules) {
        shellBuilder.addModules(modules);
        return this;
    }",method,
"    Injector build() {
        if (shellBuilder == null) {
            throw new AssertionError(""Already built, builders are not reusable."");
        }
        // Synchronize while we're building up the bindings and other injector state. This ensures that
        // the JIT bindings in the parent injector don't change while we're being built
        synchronized (shellBuilder.lock()) {
            shells = shellBuilder.build(initializer, bindingProcesor, stopwatch, errors);
            stopwatch.resetAndLog(""Injector construction"");
            initializeStatically();
        }
        injectDynamically();
        return primaryInjector();
    }",method,
"        if (shellBuilder == null) {
            throw new AssertionError(""Already built, builders are not reusable."");
        }",method,
"    private void initializeStatically() {
        bindingProcesor.initializeBindings();
        stopwatch.resetAndLog(""Binding initialization"");
        for (InjectorShell shell : shells) {
            shell.getInjector().index();
        }
        stopwatch.resetAndLog(""Binding indexing"");
        injectionRequestProcessor.process(shells);
        stopwatch.resetAndLog(""Collecting injection requests"");
        bindingProcesor.runCreationListeners();
        stopwatch.resetAndLog(""Binding validation"");
        injectionRequestProcessor.validate();
        stopwatch.resetAndLog(""Static validation"");
        initializer.validateOustandingInjections(errors);
        stopwatch.resetAndLog(""Instance member validation"");
        new LookupProcessor(errors).process(shells);
        for (InjectorShell shell : shells) {
            ((DeferredLookups) shell.getInjector().lookups).initialize(errors);
        }
        stopwatch.resetAndLog(""Provider verification"");
        for (InjectorShell shell : shells) {
            if (!shell.getElements().isEmpty()) {
                throw new AssertionError(""Failed to execute "" + shell.getElements());
            }
        }
        errors.throwCreationExceptionIfErrorsExist();
    }",method,
"        for (InjectorShell shell : shells) {
            shell.getInjector().index();
        }",method,
"        for (InjectorShell shell : shells) {
            ((DeferredLookups) shell.getInjector().lookups).initialize(errors);
        }",method,
"        for (InjectorShell shell : shells) {
            if (!shell.getElements().isEmpty()) {
                throw new AssertionError(""Failed to execute "" + shell.getElements());
            }
        }",method,
"    private Injector primaryInjector() {
        return shells.get(0).getInjector();
    }",method,
"    private void injectDynamically() {
        injectionRequestProcessor.injectMembers();
        stopwatch.resetAndLog(""Static member injection"");
        initializer.injectAll(errors);
        stopwatch.resetAndLog(""Instance injection"");
        errors.throwCreationExceptionIfErrorsExist();
        for (InjectorShell shell : shells) {
            loadEagerSingletons(shell.getInjector(), stage, errors);
        }
        stopwatch.resetAndLog(""Preloading singletons"");
        errors.throwCreationExceptionIfErrorsExist();
    }",method,
"        for (InjectorShell shell : shells) {
            loadEagerSingletons(shell.getInjector(), stage, errors);
        }",method,
"    public void loadEagerSingletons(InjectorImpl injector, Stage stage, Errors errors) {
        for (final Binding<?> binding : injector.state.getExplicitBindingsThisLevel().values()) {
            loadEagerSingletons(injector, stage, errors, (BindingImpl<?>)binding);
        }
        for (final Binding<?> binding : injector.jitBindings.values()) {
            loadEagerSingletons(injector, stage, errors, (BindingImpl<?>)binding);
        }
    }",method,
"    private void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors, BindingImpl<?> binding) {
        if (binding.getScoping().isEagerSingleton(stage)) {
            try {
                injector.callInContext(new ContextualCallable<Void>() {
                    Dependency<?> dependency = Dependency.get(binding.getKey());
                    @Override
                    public Void call(InternalContext context) {
                        context.setDependency(dependency);
                        Errors errorsForBinding = errors.withSource(dependency);
                        try {
                            binding.getInternalFactory().get(errorsForBinding, context, dependency);
                        } catch (ErrorsException e) {
                            errorsForBinding.merge(e.getErrors());
                        } finally {
                            context.setDependency(null);
                        }
                        return null;
                    }
                });
            } catch (ErrorsException e) {
                throw new AssertionError();
            }
        }
    }",method,
"                injector.callInContext(new ContextualCallable<Void>() {
                    Dependency<?> dependency = Dependency.get(binding.getKey());
                    @Override
                    public Void call(InternalContext context) {
                        context.setDependency(dependency);
                        Errors errorsForBinding = errors.withSource(dependency);
                        try {
                            binding.getInternalFactory().get(errorsForBinding, context, dependency);
                        } catch (ErrorsException e) {
                            errorsForBinding.merge(e.getErrors());
                        } finally {
                            context.setDependency(null);
                        }
                        return null;
                    }
                }",method,
"                    @Override
                    public Void call(InternalContext context) {
                        context.setDependency(dependency);
                        Errors errorsForBinding = errors.withSource(dependency);
                        try {
                            binding.getInternalFactory().get(errorsForBinding, context, dependency);
                        } catch (ErrorsException e) {
                            errorsForBinding.merge(e.getErrors());
                        } finally {
                            context.setDependency(null);
                        }
                        return null;
                    }",method,
"public class IntegerConstant extends Constant
{
    public int u4value;
    public IntegerConstant()
    {
    }
    public IntegerConstant(int value)
    {
        u4value = value;
    }
    public int getValue()
    {
        return u4value;
    }
    public void setValue(int value)
    {
        u4value = value;
    }
    // Implementations for Constant.
    public int getTag()
    {
        return ClassConstants.CONSTANT_Integer;
    }
    public void accept(Clazz clazz, ConstantVisitor constantVisitor)
    {
        constantVisitor.visitIntegerConstant(clazz, this);
    }
}",class,
"    public IntegerConstant()
    {
    }",method,
"    public IntegerConstant(int value)
    {
        u4value = value;
    }",method,
"    public int getValue()
    {
        return u4value;
    }",method,
"    public void setValue(int value)
    {
        u4value = value;
    }",method,
"    public int getTag()
    {
        return ClassConstants.CONSTANT_Integer;
    }",method,
"    public void accept(Clazz clazz, ConstantVisitor constantVisitor)
    {
        constantVisitor.visitIntegerConstant(clazz, this);
    }",method,
"public class DFISimilarityProvider extends AbstractSimilarityProvider {
    // the ""basic models"" of divergence from independence
    private static final Map<String, Independence> INDEPENDENCE_MEASURES;
    static {
        Map<String, Independence> measures = new HashMap<>();
        measures.put(""standardized"", new IndependenceStandardized());
        measures.put(""saturated"", new IndependenceSaturated());
        measures.put(""chisquared"", new IndependenceChiSquared());
        INDEPENDENCE_MEASURES = unmodifiableMap(measures);
    }
    private final DFISimilarity similarity;
    public DFISimilarityProvider(String name, Settings settings, Settings indexSettings) {
        super(name);
        boolean discountOverlaps = settings.getAsBoolean(""discount_overlaps"", true);
        Independence measure = parseIndependence(settings);
        this.similarity = new DFISimilarity(measure);
        this.similarity.setDiscountOverlaps(discountOverlaps);
    }
    private Independence parseIndependence(Settings settings) {
        String name = settings.get(""independence_measure"");
        Independence measure = INDEPENDENCE_MEASURES.get(name);
        if (measure == null) {
            throw new IllegalArgumentException(""Unsupported IndependenceMeasure ["" + name + ""]"");
        }
        return measure;
    }
    @Override
    public Similarity get() {
        return similarity;
    }
}",class,
"    public DFISimilarityProvider(String name, Settings settings, Settings indexSettings) {
        super(name);
        boolean discountOverlaps = settings.getAsBoolean(""discount_overlaps"", true);
        Independence measure = parseIndependence(settings);
        this.similarity = new DFISimilarity(measure);
        this.similarity.setDiscountOverlaps(discountOverlaps);
    }",method,
"    private Independence parseIndependence(Settings settings) {
        String name = settings.get(""independence_measure"");
        Independence measure = INDEPENDENCE_MEASURES.get(name);
        if (measure == null) {
            throw new IllegalArgumentException(""Unsupported IndependenceMeasure ["" + name + ""]"");
        }
        return measure;
    }",method,
"        if (measure == null) {
            throw new IllegalArgumentException(""Unsupported IndependenceMeasure ["" + name + ""]"");
        }",method,
"    @Override
    public Similarity get() {
        return similarity;
    }",method,
"    public static void dumpAsync(Handler handler, final Dump dump, PrintWriter pw,
            final String prefix, long timeout) {
        final StringWriter sw = new StringWriter();
        if (handler.runWithScissors(new Runnable() {
            @Override
            public void run() {
                PrintWriter lpw = new FastPrintWriter(sw);
                dump.dump(lpw, prefix);
                lpw.close();
            }
        }, timeout)) {
            pw.print(sw.toString());
        } else {
            pw.println(""... timed out"");
        }
    }",method,
"        if (handler.runWithScissors(new Runnable() {
            @Override
            public void run() {
                PrintWriter lpw = new FastPrintWriter(sw);
                dump.dump(lpw, prefix);
                lpw.close();
            }
        }",method,
"            @Override
            public void run() {
                PrintWriter lpw = new FastPrintWriter(sw);
                dump.dump(lpw, prefix);
                lpw.close();
            }",method,
"    private static void logMessage(PrintWriter pw, String msg) {
        if (DEBUG) Slog.v(TAG, msg);
        pw.println(msg);
    }",method,
"    public static boolean checkDumpPermission(Context context, String tag, PrintWriter pw) {
        if (context.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
                != PackageManager.PERMISSION_GRANTED) {
            logMessage(pw, ""Permission Denial: can't dump "" + tag + "" from from pid=""
                    + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid()
                    + "" due to missing android.permission.DUMP permission"");
            return false;
        } else {
            return true;
        }
    }",method,
"    public static boolean checkUsageStatsPermission(Context context, String tag, PrintWriter pw) {
        // System internals always get access
        final int uid = Binder.getCallingUid();
        switch (uid) {
            case android.os.Process.ROOT_UID:
            case android.os.Process.SYSTEM_UID:
            case android.os.Process.SHELL_UID:
                return true;
        }
        // Caller always needs to hold permission
        if (context.checkCallingOrSelfPermission(android.Manifest.permission.PACKAGE_USAGE_STATS)
                != PackageManager.PERMISSION_GRANTED) {
            logMessage(pw, ""Permission Denial: can't dump "" + tag + "" from from pid=""
                    + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid()
                    + "" due to missing android.permission.PACKAGE_USAGE_STATS permission"");
            return false;
        }
        // And finally, caller needs to have appops access; this is totally
        // hacky, but it's the easiest way to wire this up without retrofitting
        // Binder.dump() to pass through package names.
        final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
        final String[] pkgs = context.getPackageManager().getPackagesForUid(uid);
        if (pkgs != null) {
            for (String pkg : pkgs) {
                switch (appOps.checkOpNoThrow(AppOpsManager.OP_GET_USAGE_STATS, uid, pkg)) {
                    case AppOpsManager.MODE_ALLOWED:
                        if (DEBUG) Slog.v(TAG, ""Found package "" + pkg + "" with ""
                                + ""android:get_usage_stats allowed"");
                        return true;
                    case AppOpsManager.MODE_DEFAULT:
                        if (DEBUG) Slog.v(TAG, ""Found package "" + pkg + "" with ""
                                + ""android:get_usage_stats default"");
                        return true;
                }
            }
        }
        logMessage(pw, ""Permission Denial: can't dump "" + tag + "" from from pid=""
                + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid()
                + "" due to android:get_usage_stats app-op not allowed"");
        return false;
    }",method,
"        switch (uid) {
            case android.os.Process.ROOT_UID:
            case android.os.Process.SYSTEM_UID:
            case android.os.Process.SHELL_UID:
                return true;
        }",method,
"        if (pkgs != null) {
            for (String pkg : pkgs) {
                switch (appOps.checkOpNoThrow(AppOpsManager.OP_GET_USAGE_STATS, uid, pkg)) {
                    case AppOpsManager.MODE_ALLOWED:
                        if (DEBUG) Slog.v(TAG, ""Found package "" + pkg + "" with ""
                                + ""android:get_usage_stats allowed"");
                        return true;
                    case AppOpsManager.MODE_DEFAULT:
                        if (DEBUG) Slog.v(TAG, ""Found package "" + pkg + "" with ""
                                + ""android:get_usage_stats default"");
                        return true;
                }
            }
        }",method,
"            for (String pkg : pkgs) {
                switch (appOps.checkOpNoThrow(AppOpsManager.OP_GET_USAGE_STATS, uid, pkg)) {
                    case AppOpsManager.MODE_ALLOWED:
                        if (DEBUG) Slog.v(TAG, ""Found package "" + pkg + "" with ""
                                + ""android:get_usage_stats allowed"");
                        return true;
                    case AppOpsManager.MODE_DEFAULT:
                        if (DEBUG) Slog.v(TAG, ""Found package "" + pkg + "" with ""
                                + ""android:get_usage_stats default"");
                        return true;
                }
            }",method,
"    public static boolean checkDumpAndUsageStatsPermission(Context context, String tag,
            PrintWriter pw) {
        return checkDumpPermission(context, tag, pw) && checkUsageStatsPermission(context, tag, pw);
    }",method,
"public class FunctionDeclaration extends BodyDeclaration {
  private String name = null;
  private boolean returnsRetained = false;
  private final ChildLink<Type> returnType = ChildLink.create(Type.class, this);
  private final ChildList<SingleVariableDeclaration> parameters =
      ChildList.create(SingleVariableDeclaration.class, this);
  private final ChildLink<Block> body = ChildLink.create(Block.class, this);
  private String jniSignature = null;
  public FunctionDeclaration(FunctionDeclaration other) {
    super(other);
    name = other.getName();
    returnsRetained = other.returnsRetained();
    returnType.copyFrom(other.getReturnType());
    parameters.copyFrom(other.getParameters());
    body.copyFrom(other.getBody());
    jniSignature = other.jniSignature;
  }
  public FunctionDeclaration(String name, TypeMirror returnType) {
    this.name = name;
    this.returnType.set(Type.newType(returnType));
  }
  @Override
  public Kind getKind() {
    return Kind.FUNCTION_DECLARATION;
  }
  public String getName() {
    return name;
  }
  public boolean returnsRetained() {
    return returnsRetained;
  }
  public void setReturnsRetained(boolean value) {
    returnsRetained = value;
  }
  public Type getReturnType() {
    return returnType.get();
  }
  public SingleVariableDeclaration getParameter(int index) {
    return parameters.get(index);
  }
  public List<SingleVariableDeclaration> getParameters() {
    return parameters;
  }
  public Block getBody() {
    return body.get();
  }
  public void setBody(Block newBody) {
    body.set(newBody);
  }
  public String getJniSignature() {
    return jniSignature;
  }
  public void setJniSignature(String s) {
    this.jniSignature = s;
  }
  @Override
  protected void acceptInner(TreeVisitor visitor) {
    if (visitor.visit(this)) {
      javadoc.accept(visitor);
      annotations.accept(visitor);
      returnType.accept(visitor);
      parameters.accept(visitor);
      body.accept(visitor);
    }
    visitor.endVisit(this);
  }
  @Override
  public FunctionDeclaration copy() {
    return new FunctionDeclaration(this);
  }
  public FunctionDeclaration addParameter(SingleVariableDeclaration param) {
    parameters.add(param);
    return this;
  }
}",class,
"  public FunctionDeclaration(FunctionDeclaration other) {
    super(other);
    name = other.getName();
    returnsRetained = other.returnsRetained();
    returnType.copyFrom(other.getReturnType());
    parameters.copyFrom(other.getParameters());
    body.copyFrom(other.getBody());
    jniSignature = other.jniSignature;
  }",method,
"  public FunctionDeclaration(String name, TypeMirror returnType) {
    this.name = name;
    this.returnType.set(Type.newType(returnType));
  }",method,
"  @Override
  public Kind getKind() {
    return Kind.FUNCTION_DECLARATION;
  }",method,
"  public String getName() {
    return name;
  }",method,
"  public boolean returnsRetained() {
    return returnsRetained;
  }",method,
"  public void setReturnsRetained(boolean value) {
    returnsRetained = value;
  }",method,
"  public Type getReturnType() {
    return returnType.get();
  }",method,
"  public SingleVariableDeclaration getParameter(int index) {
    return parameters.get(index);
  }",method,
"  public List<SingleVariableDeclaration> getParameters() {
    return parameters;
  }",method,
"  public Block getBody() {
    return body.get();
  }",method,
"  public void setBody(Block newBody) {
    body.set(newBody);
  }",method,
"  public String getJniSignature() {
    return jniSignature;
  }",method,
"  public void setJniSignature(String s) {
    this.jniSignature = s;
  }",method,
"  @Override
  protected void acceptInner(TreeVisitor visitor) {
    if (visitor.visit(this)) {
      javadoc.accept(visitor);
      annotations.accept(visitor);
      returnType.accept(visitor);
      parameters.accept(visitor);
      body.accept(visitor);
    }
    visitor.endVisit(this);
  }",method,
"  @Override
  public FunctionDeclaration copy() {
    return new FunctionDeclaration(this);
  }",method,
"  public FunctionDeclaration addParameter(SingleVariableDeclaration param) {
    parameters.add(param);
    return this;
  }",method,
"public class ObserverNodeTest extends AndroidTestCase {
    static class TestObserver  extends ContentObserver {
        public TestObserver() {
            super(new Handler());
        }
    }
    public void testUri() {
        final int myUserHandle = UserHandle.myUserId();
        ObserverNode root = new ObserverNode("""");
        Uri[] uris = new Uri[] {
            Uri.parse(""content://c/a/""),
            Uri.parse(""content://c/""),
            Uri.parse(""content://x/""),
            Uri.parse(""content://c/b/""),
            Uri.parse(""content://c/a/a1/1/""),
            Uri.parse(""content://c/a/a1/2/""),
            Uri.parse(""content://c/b/1/""),
            Uri.parse(""content://c/b/2/""),
        };
        int[] nums = new int[] {4, 7, 1, 4, 2, 2, 3, 3};
        // special case
        root.addObserverLocked(uris[0], new TestObserver().getContentObserver(), false, root,
                0, 0, myUserHandle);
        for(int i = 1; i < uris.length; i++) {
            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), true, root,
                    0, 0, myUserHandle);
        }
        ArrayList<ObserverCall> calls = new ArrayList<ObserverCall>();
        for (int i = nums.length - 1; i >=0; --i) {
            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
            assertEquals(nums[i], calls.size());
            calls.clear();
        }
    }
    public void testUriNotNotify() {
        final int myUserHandle = UserHandle.myUserId();
        ObserverNode root = new ObserverNode("""");
        Uri[] uris = new Uri[] {
            Uri.parse(""content://c/""),
            Uri.parse(""content://x/""),
            Uri.parse(""content://c/a/""),
            Uri.parse(""content://c/b/""),
            Uri.parse(""content://c/a/1/""),
            Uri.parse(""content://c/a/2/""),
            Uri.parse(""content://c/b/1/""),
            Uri.parse(""content://c/b/2/""),
        };
        int[] nums = new int[] {7, 1, 3, 3, 1, 1, 1, 1};
        for(int i = 0; i < uris.length; i++) {
            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), false, root,
                    0, 0, myUserHandle);
        }
        ArrayList<ObserverCall> calls = new ArrayList<ObserverCall>();
        for (int i = uris.length - 1; i >=0; --i) {
            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
            assertEquals(nums[i], calls.size());
            calls.clear();
        }
    }
}",class,
"    static class TestObserver  extends ContentObserver {
        public TestObserver() {
            super(new Handler());
        }
    }",class,
"        public TestObserver() {
            super(new Handler());
        }",method,
"    public void testUri() {
        final int myUserHandle = UserHandle.myUserId();
        ObserverNode root = new ObserverNode("""");
        Uri[] uris = new Uri[] {
            Uri.parse(""content://c/a/""),
            Uri.parse(""content://c/""),
            Uri.parse(""content://x/""),
            Uri.parse(""content://c/b/""),
            Uri.parse(""content://c/a/a1/1/""),
            Uri.parse(""content://c/a/a1/2/""),
            Uri.parse(""content://c/b/1/""),
            Uri.parse(""content://c/b/2/""),
        };
        int[] nums = new int[] {4, 7, 1, 4, 2, 2, 3, 3};
        // special case
        root.addObserverLocked(uris[0], new TestObserver().getContentObserver(), false, root,
                0, 0, myUserHandle);
        for(int i = 1; i < uris.length; i++) {
            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), true, root,
                    0, 0, myUserHandle);
        }
        ArrayList<ObserverCall> calls = new ArrayList<ObserverCall>();
        for (int i = nums.length - 1; i >=0; --i) {
            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
            assertEquals(nums[i], calls.size());
            calls.clear();
        }
    }",method,
"        for(int i = 1; i < uris.length; i++) {
            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), true, root,
                    0, 0, myUserHandle);
        }",method,
"        for (int i = nums.length - 1; i >=0; --i) {
            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
            assertEquals(nums[i], calls.size());
            calls.clear();
        }",method,
"    public void testUriNotNotify() {
        final int myUserHandle = UserHandle.myUserId();
        ObserverNode root = new ObserverNode("""");
        Uri[] uris = new Uri[] {
            Uri.parse(""content://c/""),
            Uri.parse(""content://x/""),
            Uri.parse(""content://c/a/""),
            Uri.parse(""content://c/b/""),
            Uri.parse(""content://c/a/1/""),
            Uri.parse(""content://c/a/2/""),
            Uri.parse(""content://c/b/1/""),
            Uri.parse(""content://c/b/2/""),
        };
        int[] nums = new int[] {7, 1, 3, 3, 1, 1, 1, 1};
        for(int i = 0; i < uris.length; i++) {
            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), false, root,
                    0, 0, myUserHandle);
        }
        ArrayList<ObserverCall> calls = new ArrayList<ObserverCall>();
        for (int i = uris.length - 1; i >=0; --i) {
            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
            assertEquals(nums[i], calls.size());
            calls.clear();
        }
    }",method,
"        for(int i = 0; i < uris.length; i++) {
            root.addObserverLocked(uris[i], new TestObserver().getContentObserver(), false, root,
                    0, 0, myUserHandle);
        }",method,
"        for (int i = uris.length - 1; i >=0; --i) {
            root.collectObserversLocked(uris[i], 0, null, false, 0, myUserHandle, calls);
            assertEquals(nums[i], calls.size());
            calls.clear();
        }",method,
"public class SpdyHeaderBlockZlibDecoderTest {
    // zlib header indicating 32K window size fastest deflate algorithm with SPDY dictionary
    private static final byte[] zlibHeader = {0x78, 0x3f, (byte) 0xe3, (byte) 0xc6, (byte) 0xa7, (byte) 0xc2};
    private static final byte[] zlibSyncFlush = {0x00, 0x00, 0x00, (byte) 0xff, (byte) 0xff};
    private static final int maxHeaderSize = 8192;
    private static final String name = ""name"";
    private static final String value = ""value"";
    private static final byte[] nameBytes = name.getBytes();
    private static final byte[] valueBytes = value.getBytes();
    private SpdyHeaderBlockZlibDecoder decoder;
    private SpdyHeadersFrame frame;
    @Before
    public void setUp() {
        decoder = new SpdyHeaderBlockZlibDecoder(SpdyVersion.SPDY_3_1, maxHeaderSize);
        frame = new DefaultSpdyHeadersFrame(1);
    }
    @After
    public void tearDown() {
        decoder.end();
    }
    @Test
    public void testHeaderBlock() throws Exception {
        ByteBuf headerBlock = Unpooled.buffer(37);
        headerBlock.writeBytes(zlibHeader);
        headerBlock.writeByte(0); // Non-compressed block
        headerBlock.writeByte(0x15); // little-endian length (21)
        headerBlock.writeByte(0x00); // little-endian length (21)
        headerBlock.writeByte(0xea); // one's compliment of length
        headerBlock.writeByte(0xff); // one's compliment of length
        headerBlock.writeInt(1); // number of Name/Value pairs
        headerBlock.writeInt(4); // length of name
        headerBlock.writeBytes(nameBytes);
        headerBlock.writeInt(5); // length of value
        headerBlock.writeBytes(valueBytes);
        headerBlock.writeBytes(zlibSyncFlush);
        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);
        decoder.endHeaderBlock(frame);
        assertFalse(headerBlock.isReadable());
        assertFalse(frame.isInvalid());
        assertEquals(1, frame.headers().names().size());
        assertTrue(frame.headers().contains(name));
        assertEquals(1, frame.headers().getAll(name).size());
        assertEquals(value, frame.headers().get(name));
        headerBlock.release();
    }
    @Test
    public void testHeaderBlockMultipleDecodes() throws Exception {
        ByteBuf headerBlock = Unpooled.buffer(37);
        headerBlock.writeBytes(zlibHeader);
        headerBlock.writeByte(0); // Non-compressed block
        headerBlock.writeByte(0x15); // little-endian length (21)
        headerBlock.writeByte(0x00); // little-endian length (21)
        headerBlock.writeByte(0xea); // one's compliment of length
        headerBlock.writeByte(0xff); // one's compliment of length
        headerBlock.writeInt(1); // number of Name/Value pairs
        headerBlock.writeInt(4); // length of name
        headerBlock.writeBytes(nameBytes);
        headerBlock.writeInt(5); // length of value
        headerBlock.writeBytes(valueBytes);
        headerBlock.writeBytes(zlibSyncFlush);
        int readableBytes = headerBlock.readableBytes();
        for (int i = 0; i < readableBytes; i++) {
            ByteBuf headerBlockSegment = headerBlock.slice(i, 1);
            decoder.decode(ByteBufAllocator.DEFAULT, headerBlockSegment, frame);
            assertFalse(headerBlockSegment.isReadable());
        }
        decoder.endHeaderBlock(frame);
        assertFalse(frame.isInvalid());
        assertEquals(1, frame.headers().names().size());
        assertTrue(frame.headers().contains(name));
        assertEquals(1, frame.headers().getAll(name).size());
        assertEquals(value, frame.headers().get(name));
        headerBlock.release();
    }
    @Test
    public void testLargeHeaderName() throws Exception {
        ByteBuf headerBlock = Unpooled.buffer(8220);
        headerBlock.writeBytes(zlibHeader);
        headerBlock.writeByte(0); // Non-compressed block
        headerBlock.writeByte(0x0c); // little-endian length (8204)
        headerBlock.writeByte(0x20); // little-endian length (8204)
        headerBlock.writeByte(0xf3); // one's compliment of length
        headerBlock.writeByte(0xdf); // one's compliment of length
        headerBlock.writeInt(1); // number of Name/Value pairs
        headerBlock.writeInt(8192); // length of name
        for (int i = 0; i < 8192; i++) {
            headerBlock.writeByte('n');
        }
        headerBlock.writeInt(0); // length of value
        headerBlock.writeBytes(zlibSyncFlush);
        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);
        decoder.endHeaderBlock(frame);
        assertFalse(headerBlock.isReadable());
        assertFalse(frame.isInvalid());
        assertFalse(frame.isTruncated());
        assertEquals(1, frame.headers().names().size());
        headerBlock.release();
    }
    @Test
    public void testLargeHeaderValue() throws Exception {
        ByteBuf headerBlock = Unpooled.buffer(8220);
        headerBlock.writeBytes(zlibHeader);
        headerBlock.writeByte(0); // Non-compressed block
        headerBlock.writeByte(0x0c); // little-endian length (8204)
        headerBlock.writeByte(0x20); // little-endian length (8204)
        headerBlock.writeByte(0xf3); // one's compliment of length
        headerBlock.writeByte(0xdf); // one's compliment of length
        headerBlock.writeInt(1); // number of Name/Value pairs
        headerBlock.writeInt(1); // length of name
        headerBlock.writeByte('n');
        headerBlock.writeInt(8191); // length of value
        for (int i = 0; i < 8191; i++) {
            headerBlock.writeByte('v');
        }
        headerBlock.writeBytes(zlibSyncFlush);
        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);
        decoder.endHeaderBlock(frame);
        assertFalse(headerBlock.isReadable());
        assertFalse(frame.isInvalid());
        assertFalse(frame.isTruncated());
        assertEquals(1, frame.headers().names().size());
        assertEquals(8191, frame.headers().get(""n"").length());
        headerBlock.release();
    }
    @Test(expected = SpdyProtocolException.class)
    public void testHeaderBlockExtraData() throws Exception {
        ByteBuf headerBlock = Unpooled.buffer(37);
        headerBlock.writeBytes(zlibHeader);
        headerBlock.writeByte(0); // Non-compressed block
        headerBlock.writeByte(0x15); // little-endian length (21)
        headerBlock.writeByte(0x00); // little-endian length (21)
        headerBlock.writeByte(0xea); // one's compliment of length
        headerBlock.writeByte(0xff); // one's compliment of length
        headerBlock.writeInt(1); // number of Name/Value pairs
        headerBlock.writeInt(4); // length of name
        headerBlock.writeBytes(nameBytes);
        headerBlock.writeInt(5); // length of value
        headerBlock.writeBytes(valueBytes);
        headerBlock.writeByte(0x19); // adler-32 checksum
        headerBlock.writeByte(0xa5); // adler-32 checksum
        headerBlock.writeByte(0x03); // adler-32 checksum
        headerBlock.writeByte(0xc9); // adler-32 checksum
        headerBlock.writeByte(0); // Data following zlib stream
        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);
        headerBlock.release();
    }
    @Test(expected = SpdyProtocolException.class)
    public void testHeaderBlockInvalidDictionary() throws Exception {
        ByteBuf headerBlock = Unpooled.buffer(7);
        headerBlock.writeByte(0x78);
        headerBlock.writeByte(0x3f);
        headerBlock.writeByte(0x01); // Unknown dictionary
        headerBlock.writeByte(0x02); // Unknown dictionary
        headerBlock.writeByte(0x03); // Unknown dictionary
        headerBlock.writeByte(0x04); // Unknown dictionary
        headerBlock.writeByte(0); // Non-compressed block
        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);
        headerBlock.release();
    }
    @Test(expected = SpdyProtocolException.class)
    public void testHeaderBlockInvalidDeflateBlock() throws Exception {
        ByteBuf headerBlock = Unpooled.buffer(11);
        headerBlock.writeBytes(zlibHeader);
        headerBlock.writeByte(0); // Non-compressed block
        headerBlock.writeByte(0x00); // little-endian length (0)
        headerBlock.writeByte(0x00); // little-endian length (0)
        headerBlock.writeByte(0x00); // invalid one's compliment
        headerBlock.writeByte(0x00); // invalid one's compliment
        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);
        headerBlock.release();
    }
}",class,
"    @Before
    public void setUp() {
        decoder = new SpdyHeaderBlockZlibDecoder(SpdyVersion.SPDY_3_1, maxHeaderSize);
        frame = new DefaultSpdyHeadersFrame(1);
    }",method,

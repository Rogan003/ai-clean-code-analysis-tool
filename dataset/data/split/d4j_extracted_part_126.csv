code_snippet,type,score
"    @Override
    public boolean matchesCriteria(String vendor, NsdServiceInfo nsdServiceInfo) {
        if (!TextUtils.equals(vendor, mVendorInfo.mVendorID)) return false;
        String pdls = MDnsUtils.getString(nsdServiceInfo.getAttributes().get(PDL_ATTRIBUTE));
        boolean hasMobileSupport = TextUtils.equals(ATTRIBUTE_VALUE__TRUE, MDnsUtils.getString(nsdServiceInfo.getAttributes().get(MDNS_ATTRIBUTE__HPLFMOBILEPRINTER)));
        return (((hasMobileSupport || isPrintSupported(MDnsUtils.getString(nsdServiceInfo.getAttributes().get(MDNS_ATTRIBUTE__TY))))
                    &&!TextUtils.isEmpty(pdls))
                && (pdls.contains(PDL__PCL)
                || pdls.contains(PDL__PDF)
                || pdls.contains(PDL__PCLM)
                || pdls.contains(PDL__PWG_RASTER)));
    }",method,
"public class FocusableInTouchModeClickTest extends ActivityInstrumentationTestCase2<LLOfTwoFocusableInTouchMode> {
    public FocusableInTouchModeClickTest() {
        super(""com.android.frameworks.coretests"", LLOfTwoFocusableInTouchMode.class);
    }
    protected void setUp() throws Exception {
        super.setUp();
        setActivityInitialTouchMode(true);
    }
    @MediumTest
    public void testPreconditions() {
        assertTrue(""should start in touch mode"", getActivity().getButton1().isInTouchMode());
        assertTrue(getActivity().getButton1().isFocused());
    }
    @LargeTest
    public void testClickGivesFocusNoClickFired() {
        TouchUtils.clickView(this, getActivity().getButton2());
        assertTrue(""click should give focusable in touch mode focus"",
                getActivity().getButton2().isFocused());
        assertFalse(""getting focus should result in no on click"",
                getActivity().isB2Fired());
        TouchUtils.clickView(this, getActivity().getButton2());
        assertTrue(""subsequent click while focused should fire on click"",
                getActivity().isB2Fired());
    }
    @MediumTest
    public void testTapGivesFocusNoClickFired() {
        TouchUtils.touchAndCancelView(this, getActivity().getButton2());
        assertFalse(""button shouldn't have fired click"", getActivity().isB2Fired());
        assertFalse(""button shouldn't have focus"", getActivity().getButton2().isFocused());
    }
}",class,
"    public FocusableInTouchModeClickTest() {
        super(""com.android.frameworks.coretests"", LLOfTwoFocusableInTouchMode.class);
    }",method,
"    protected void setUp() throws Exception {
        super.setUp();
        setActivityInitialTouchMode(true);
    }",method,
"    @MediumTest
    public void testPreconditions() {
        assertTrue(""should start in touch mode"", getActivity().getButton1().isInTouchMode());
        assertTrue(getActivity().getButton1().isFocused());
    }",method,
"    @LargeTest
    public void testClickGivesFocusNoClickFired() {
        TouchUtils.clickView(this, getActivity().getButton2());
        assertTrue(""click should give focusable in touch mode focus"",
                getActivity().getButton2().isFocused());
        assertFalse(""getting focus should result in no on click"",
                getActivity().isB2Fired());
        TouchUtils.clickView(this, getActivity().getButton2());
        assertTrue(""subsequent click while focused should fire on click"",
                getActivity().isB2Fired());
    }",method,
"    @MediumTest
    public void testTapGivesFocusNoClickFired() {
        TouchUtils.touchAndCancelView(this, getActivity().getButton2());
        assertFalse(""button shouldn't have fired click"", getActivity().isB2Fired());
        assertFalse(""button shouldn't have focus"", getActivity().getButton2().isFocused());
    }",method,
"public class ClassLoaderIds {
    public enum Type {
        SCRIPT,
        TEST_TASK_CLASSPATH
    }
    private static ClassLoaderId of(Type type, String... attributes) {
        return new DefaultClassLoaderId(type, attributes);
    }
    public static ClassLoaderId buildScript(String fileName, String operationId) {
        return of(Type.SCRIPT, fileName, operationId);
    }
    public static ClassLoaderId testTaskClasspath(String testTaskPath) {
        return of(Type.TEST_TASK_CLASSPATH, testTaskPath);
    }
    private static class DefaultClassLoaderId implements ClassLoaderId {
        private final Type type;
        private final String[] attributes;
        public DefaultClassLoaderId(Type type, String[] attributes) {
            this.type = type;
            this.attributes = attributes;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            DefaultClassLoaderId that = (DefaultClassLoaderId) o;
            return type == that.type && Arrays.equals(attributes, that.attributes);
        }
        @Override
        public int hashCode() {
            int result = type.hashCode();
            result = 31 * result + Arrays.hashCode(attributes);
            return result;
        }
        @Override
        public String toString() {
            return ""ClassLoaderId{type="" + type + "", attributes="" + Arrays.toString(attributes) + '}';
        }
    }
}",class,
"    private static class DefaultClassLoaderId implements ClassLoaderId {
        private final Type type;
        private final String[] attributes;
        public DefaultClassLoaderId(Type type, String[] attributes) {
            this.type = type;
            this.attributes = attributes;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            DefaultClassLoaderId that = (DefaultClassLoaderId) o;
            return type == that.type && Arrays.equals(attributes, that.attributes);
        }
        @Override
        public int hashCode() {
            int result = type.hashCode();
            result = 31 * result + Arrays.hashCode(attributes);
            return result;
        }
        @Override
        public String toString() {
            return ""ClassLoaderId{type="" + type + "", attributes="" + Arrays.toString(attributes) + '}';
        }
    }",class,
"    private static ClassLoaderId of(Type type, String... attributes) {
        return new DefaultClassLoaderId(type, attributes);
    }",method,
"    public static ClassLoaderId buildScript(String fileName, String operationId) {
        return of(Type.SCRIPT, fileName, operationId);
    }",method,
"    public static ClassLoaderId testTaskClasspath(String testTaskPath) {
        return of(Type.TEST_TASK_CLASSPATH, testTaskPath);
    }",method,
"        public DefaultClassLoaderId(Type type, String[] attributes) {
            this.type = type;
            this.attributes = attributes;
        }",method,
"        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            DefaultClassLoaderId that = (DefaultClassLoaderId) o;
            return type == that.type && Arrays.equals(attributes, that.attributes);
        }",method,
"            if (this == o) {
                return true;
            }",method,
"        @Override
        public int hashCode() {
            int result = type.hashCode();
            result = 31 * result + Arrays.hashCode(attributes);
            return result;
        }",method,
"        @Override
        public String toString() {
            return ""ClassLoaderId{type="" + type + "", attributes="" + Arrays.toString(attributes) + '}';
        }",method,
"public class RemappingClassBuilder extends DelegatingClassBuilder {
    private final ClassBuilder builder;
    private final Remapper remapper;
    public RemappingClassBuilder(@NotNull ClassBuilder builder, @NotNull Remapper remapper) {
        this.builder = builder;
        this.remapper = remapper;
    }
    @Override
    @NotNull
    protected ClassBuilder getDelegate() {
        return builder;
    }
    @Override
    public void defineClass(
            @Nullable PsiElement origin,
            int version,
            int access,
            @NotNull String name,
            @Nullable String signature,
            @NotNull String superName,
            @NotNull String[] interfaces
    ) {
        super.defineClass(origin, version, access, remapper.mapType(name), remapper.mapSignature(signature, false), remapper.mapType(superName), remapper.mapTypes(interfaces));
    }
    @Override
    @NotNull
    public FieldVisitor newField(
            @NotNull JvmDeclarationOrigin origin,
            int access,
            @NotNull String name,
            @NotNull String desc,
            @Nullable String signature,
            @Nullable Object value
    ) {
        return new RemappingFieldAdapter(
                builder.newField(origin, access, name, remapper.mapDesc(desc), remapper.mapSignature(signature, true), value),
                remapper
        );
    }
    @Override
    @NotNull
    public MethodVisitor newMethod(
            @NotNull JvmDeclarationOrigin origin,
            int access,
            @NotNull String name,
            @NotNull String desc,
            @Nullable String signature,
            @Nullable String[] exceptions
    ) {
        return new RemappingMethodAdapter(
                access, desc,
                builder.newMethod(origin, access, name, remapper.mapMethodDesc(desc), remapper.mapSignature(signature, false), exceptions),
                remapper
        );
    }
    @Override
    @NotNull
    public AnnotationVisitor newAnnotation(@NotNull String desc, boolean visible) {
        return new RemappingAnnotationAdapter(builder.newAnnotation(remapper.mapDesc(desc), visible), remapper);
    }
    @Override
    @NotNull
    public ClassVisitor getVisitor() {
        return new RemappingClassAdapter(builder.getVisitor(), remapper);
    }
}",class,
"    public RemappingClassBuilder(@NotNull ClassBuilder builder, @NotNull Remapper remapper) {
        this.builder = builder;
        this.remapper = remapper;
    }",method,
"    @Override
    @NotNull
    protected ClassBuilder getDelegate() {
        return builder;
    }",method,
"    @Override
    public void defineClass(
            @Nullable PsiElement origin,
            int version,
            int access,
            @NotNull String name,
            @Nullable String signature,
            @NotNull String superName,
            @NotNull String[] interfaces
    ) {
        super.defineClass(origin, version, access, remapper.mapType(name), remapper.mapSignature(signature, false), remapper.mapType(superName), remapper.mapTypes(interfaces));
    }",method,
"    @Override
    @NotNull
    public FieldVisitor newField(
            @NotNull JvmDeclarationOrigin origin,
            int access,
            @NotNull String name,
            @NotNull String desc,
            @Nullable String signature,
            @Nullable Object value
    ) {
        return new RemappingFieldAdapter(
                builder.newField(origin, access, name, remapper.mapDesc(desc), remapper.mapSignature(signature, true), value),
                remapper
        );
    }",method,
"    @Override
    @NotNull
    public MethodVisitor newMethod(
            @NotNull JvmDeclarationOrigin origin,
            int access,
            @NotNull String name,
            @NotNull String desc,
            @Nullable String signature,
            @Nullable String[] exceptions
    ) {
        return new RemappingMethodAdapter(
                access, desc,
                builder.newMethod(origin, access, name, remapper.mapMethodDesc(desc), remapper.mapSignature(signature, false), exceptions),
                remapper
        );
    }",method,
"    @Override
    @NotNull
    public AnnotationVisitor newAnnotation(@NotNull String desc, boolean visible) {
        return new RemappingAnnotationAdapter(builder.newAnnotation(remapper.mapDesc(desc), visible), remapper);
    }",method,
"    @Override
    @NotNull
    public ClassVisitor getVisitor() {
        return new RemappingClassAdapter(builder.getVisitor(), remapper);
    }",method,
"public class Issue943 extends TestCase {
    public void test_for_issue() throws Exception {
        String text = ""{\n"" +
                ""\t\""symbols\"":[\n"" +
                ""\t    {\""id\"":1,\""type\"":\""SCATTER\""},\n"" +
                ""\t    {\""id\"":2,\""type\"":\""BONUS\""}\n"" +
                ""\t]\n"" +
                ""}"";
        JSONObject root = JSON.parseObject(text);
        JSONArray symbols = root.getJSONArray(""symbols"");
        assertNotNull(symbols);
        assertEquals(2, symbols.size());
        assertEquals(1, symbols.getJSONObject(0).get(""id""));
        assertEquals(""SCATTER"", symbols.getJSONObject(0).get(""type""));
        assertEquals(2, symbols.getJSONObject(1).get(""id""));
        assertEquals(""BONUS"", symbols.getJSONObject(1).get(""type""));
        SlotConfig slotConfig = JSON.parseObject(text, SlotConfig.class);
        assertNotNull(slotConfig);
        assertEquals(2, slotConfig.symbols.size());
        assertEquals(1, slotConfig.symbols.get(0).getId());
        assertEquals(SymbolType.SCATTER, slotConfig.symbols.get(0).getType());
        assertEquals(2, slotConfig.symbols.get(1).getId());
        assertEquals(SymbolType.BONUS, slotConfig.symbols.get(1).getType());
    }
    private static class SlotConfig {
        private List<Symbol> symbols;
        public List<Symbol> getSymbols() {
            return symbols;
        }
        public void setSymbols(List<Symbol> symbols) {
            this.symbols = symbols;
        }
    }
    private static class Symbol {
        private int id;
        private SymbolType type;
        public int getId() {
            return id;
        }
        public void setId(int id) {
            this.id = id;
        }
        public SymbolType getType() {
            return type;
        }
        public void setType(SymbolType type) {
            this.type = type;
        }
    }
    enum SymbolType {
        NORMAL, WILD, SCATTER, BONUS
    }
}",class,
"    private static class SlotConfig {
        private List<Symbol> symbols;
        public List<Symbol> getSymbols() {
            return symbols;
        }
        public void setSymbols(List<Symbol> symbols) {
            this.symbols = symbols;
        }
    }",class,
"    private static class Symbol {
        private int id;
        private SymbolType type;
        public int getId() {
            return id;
        }
        public void setId(int id) {
            this.id = id;
        }
        public SymbolType getType() {
            return type;
        }
        public void setType(SymbolType type) {
            this.type = type;
        }
    }",class,
"    public void test_for_issue() throws Exception {
        String text = ""{\n"" +
                ""\t\""symbols\"":[\n"" +
                ""\t    {\""id\"":1,\""type\"":\""SCATTER\""},\n"" +
                ""\t    {\""id\"":2,\""type\"":\""BONUS\""}\n"" +
                ""\t]\n"" +
                ""}"";
        JSONObject root = JSON.parseObject(text);
        JSONArray symbols = root.getJSONArray(""symbols"");
        assertNotNull(symbols);
        assertEquals(2, symbols.size());
        assertEquals(1, symbols.getJSONObject(0).get(""id""));
        assertEquals(""SCATTER"", symbols.getJSONObject(0).get(""type""));
        assertEquals(2, symbols.getJSONObject(1).get(""id""));
        assertEquals(""BONUS"", symbols.getJSONObject(1).get(""type""));
        SlotConfig slotConfig = JSON.parseObject(text, SlotConfig.class);
        assertNotNull(slotConfig);
        assertEquals(2, slotConfig.symbols.size());
        assertEquals(1, slotConfig.symbols.get(0).getId());
        assertEquals(SymbolType.SCATTER, slotConfig.symbols.get(0).getType());
        assertEquals(2, slotConfig.symbols.get(1).getId());
        assertEquals(SymbolType.BONUS, slotConfig.symbols.get(1).getType());
    }",method,
"        public List<Symbol> getSymbols() {
            return symbols;
        }",method,
"        public void setSymbols(List<Symbol> symbols) {
            this.symbols = symbols;
        }",method,
"        public int getId() {
            return id;
        }",method,
"        public void setId(int id) {
            this.id = id;
        }",method,
"        public SymbolType getType() {
            return type;
        }",method,
"        public void setType(SymbolType type) {
            this.type = type;
        }",method,
"final class ImmutableMapKeySet<K, V> extends ImmutableSet.Indexed<K> {
  @Weak private final ImmutableMap<K, V> map;
  ImmutableMapKeySet(ImmutableMap<K, V> map) {
    this.map = map;
  }
  @Override
  public int size() {
    return map.size();
  }
  @Override
  public UnmodifiableIterator<K> iterator() {
    return map.keyIterator();
  }
  @Override
  public Spliterator<K> spliterator() {
    return map.keySpliterator();
  }
  @Override
  public boolean contains(@Nullable Object object) {
    return map.containsKey(object);
  }
  @Override
  K get(int index) {
    return map.entrySet().asList().get(index).getKey();
  }
  @Override
  public void forEach(Consumer<? super K> action) {
    checkNotNull(action);
    map.forEach((k, v) -> action.accept(k));
  }
  @Override
  boolean isPartialView() {
    return true;
  }
  @GwtIncompatible // serialization
  @Override
  Object writeReplace() {
    return new KeySetSerializedForm<K>(map);
  }
  @GwtIncompatible // serialization
  private static class KeySetSerializedForm<K> implements Serializable {
    final ImmutableMap<K, ?> map;
    KeySetSerializedForm(ImmutableMap<K, ?> map) {
      this.map = map;
    }
    Object readResolve() {
      return map.keySet();
    }
    private static final long serialVersionUID = 0;
  }
}",class,
"  private static class KeySetSerializedForm<K> implements Serializable {
    final ImmutableMap<K, ?> map;
    KeySetSerializedForm(ImmutableMap<K, ?> map) {
      this.map = map;
    }
    Object readResolve() {
      return map.keySet();
    }
    private static final long serialVersionUID = 0;
  }",class,
"  @Weak private final ImmutableMap<K, V> map;
  ImmutableMapKeySet(ImmutableMap<K, V> map) {
    this.map = map;
  }",method,
"  @Override
  public int size() {
    return map.size();
  }",method,
"  @Override
  public UnmodifiableIterator<K> iterator() {
    return map.keyIterator();
  }",method,
"  @Override
  public Spliterator<K> spliterator() {
    return map.keySpliterator();
  }",method,
"  @Override
  public boolean contains(@Nullable Object object) {
    return map.containsKey(object);
  }",method,
"  @Override
  K get(int index) {
    return map.entrySet().asList().get(index).getKey();
  }",method,
"  @Override
  public void forEach(Consumer<? super K> action) {
    checkNotNull(action);
    map.forEach((k, v) -> action.accept(k));
  }",method,
"  @Override
  boolean isPartialView() {
    return true;
  }",method,
"  @GwtIncompatible // serialization
  @Override
  Object writeReplace() {
    return new KeySetSerializedForm<K>(map);
  }",method,
"    KeySetSerializedForm(ImmutableMap<K, ?> map) {
      this.map = map;
    }",method,
"    Object readResolve() {
      return map.keySet();
    }",method,
"public class HttpUrlFetcher implements DataFetcher<InputStream> {
  private static final String TAG = ""HttpUrlFetcher"";
  private static final int MAXIMUM_REDIRECTS = 5;
  // Visible for testing.
  static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
      new DefaultHttpUrlConnectionFactory();
  private final GlideUrl glideUrl;
  private final int timeout;
  private final HttpUrlConnectionFactory connectionFactory;
  private HttpURLConnection urlConnection;
  private InputStream stream;
  private volatile boolean isCancelled;
  public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
    this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
  }
  // Visible for testing.
  HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
    this.glideUrl = glideUrl;
    this.timeout = timeout;
    this.connectionFactory = connectionFactory;
  }
  @Override
  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    long startTime = LogTime.getLogTime();
    final InputStream result;
    try {
      result = loadDataWithRedirects(glideUrl.toURL(), 0 , null ,
          glideUrl.getHeaders());
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Failed to load data for url"", e);
      }
      callback.onLoadFailed(e);
      return;
    }
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
      Log.v(TAG, ""Finished http url fetcher fetch in "" + LogTime.getElapsedMillis(startTime)
          + "" ms and loaded "" + result);
    }
    callback.onDataReady(result);
  }
  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
      Map<String, String> headers) throws IOException {
    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new HttpException(""Too many (> "" + MAXIMUM_REDIRECTS + "") redirects!"");
    } else {
      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
      try {
        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
          throw new HttpException(""In re-direct loop"");
        }
      } catch (URISyntaxException e) {
        // Do nothing, this is best effort.
      }
    }
    urlConnection = connectionFactory.build(url);
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);
    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
    urlConnection.setInstanceFollowRedirects(false);
    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.
    stream = urlConnection.getInputStream();
    if (isCancelled) {
      return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) {
      return getStreamForSuccessfulRequest(urlConnection);
    } else if (statusCode / 100 == 3) {
      String redirectUrlString = urlConnection.getHeaderField(""Location"");
      if (TextUtils.isEmpty(redirectUrlString)) {
        throw new HttpException(""Received empty or null redirect url"");
      }
      URL redirectUrl = new URL(url, redirectUrlString);
      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
      // to disconnecting the url connection below. See #2352.
      cleanup();
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else if (statusCode == -1) {
      throw new HttpException(statusCode);
    } else {
      throw new HttpException(urlConnection.getResponseMessage(), statusCode);
    }
  }
  private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
      throws IOException {
    if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
      int contentLength = urlConnection.getContentLength();
      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
    } else {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Got non empty content encoding: "" + urlConnection.getContentEncoding());
      }
      stream = urlConnection.getInputStream();
    }
    return stream;
  }
  @Override
  public void cleanup() {
    if (stream != null) {
      try {
        stream.close();
      } catch (IOException e) {
        // Ignore
      }
    }
    if (urlConnection != null) {
      urlConnection.disconnect();
    }
    urlConnection = null;
  }
  @Override
  public void cancel() {
    // TODO: we should consider disconnecting the url connection here, but we can't do so
    // directly because cancel is often called on the main thread.
    isCancelled = true;
  }
  @NonNull
  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }
  @NonNull
  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }
  interface HttpUrlConnectionFactory {
    HttpURLConnection build(URL url) throws IOException;
  }
  private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
    @Synthetic
    DefaultHttpUrlConnectionFactory() { }
    @Override
    public HttpURLConnection build(URL url) throws IOException {
      return (HttpURLConnection) url.openConnection();
    }
  }
}",class,
"  private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
    @Synthetic
    DefaultHttpUrlConnectionFactory() { }
    @Override
    public HttpURLConnection build(URL url) throws IOException {
      return (HttpURLConnection) url.openConnection();
    }
  }",class,
"  public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
    this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
  }",method,
"  HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
    this.glideUrl = glideUrl;
    this.timeout = timeout;
    this.connectionFactory = connectionFactory;
  }",method,
"  @Override
  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    long startTime = LogTime.getLogTime();
    final InputStream result;
    try {
      result = loadDataWithRedirects(glideUrl.toURL(), 0 , null ,
          glideUrl.getHeaders());
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Failed to load data for url"", e);
      }
      callback.onLoadFailed(e);
      return;
    }
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
      Log.v(TAG, ""Finished http url fetcher fetch in "" + LogTime.getElapsedMillis(startTime)
          + "" ms and loaded "" + result);
    }
    callback.onDataReady(result);
  }",method,
"  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
      Map<String, String> headers) throws IOException {
    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new HttpException(""Too many (> "" + MAXIMUM_REDIRECTS + "") redirects!"");
    } else {
      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
      try {
        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
          throw new HttpException(""In re-direct loop"");
        }
      } catch (URISyntaxException e) {
        // Do nothing, this is best effort.
      }
    }
    urlConnection = connectionFactory.build(url);
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);
    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
    urlConnection.setInstanceFollowRedirects(false);
    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.
    stream = urlConnection.getInputStream();
    if (isCancelled) {
      return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) {
      return getStreamForSuccessfulRequest(urlConnection);
    } else if (statusCode / 100 == 3) {
      String redirectUrlString = urlConnection.getHeaderField(""Location"");
      if (TextUtils.isEmpty(redirectUrlString)) {
        throw new HttpException(""Received empty or null redirect url"");
      }
      URL redirectUrl = new URL(url, redirectUrlString);
      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
      // to disconnecting the url connection below. See #2352.
      cleanup();
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else if (statusCode == -1) {
      throw new HttpException(statusCode);
    } else {
      throw new HttpException(urlConnection.getResponseMessage(), statusCode);
    }
  }",method,
"    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new HttpException(""Too many (> "" + MAXIMUM_REDIRECTS + "") redirects!"");
    }",method,
"    if (isCancelled) {
      return null;
    }",method,
"    if (statusCode / 100 == 2) {
      return getStreamForSuccessfulRequest(urlConnection);
    }",method,
"  private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
      throws IOException {
    if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
      int contentLength = urlConnection.getContentLength();
      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
    } else {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Got non empty content encoding: "" + urlConnection.getContentEncoding());
      }
      stream = urlConnection.getInputStream();
    }
    return stream;
  }",method,
"  @Override
  public void cleanup() {
    if (stream != null) {
      try {
        stream.close();
      } catch (IOException e) {
        // Ignore
      }
    }
    if (urlConnection != null) {
      urlConnection.disconnect();
    }
    urlConnection = null;
  }",method,
"    if (stream != null) {
      try {
        stream.close();
      } catch (IOException e) {
        // Ignore
      }
    }",method,
"    if (urlConnection != null) {
      urlConnection.disconnect();
    }",method,
"  @Override
  public void cancel() {
    // TODO: we should consider disconnecting the url connection here, but we can't do so
    // directly because cancel is often called on the main thread.
    isCancelled = true;
  }",method,
"  @NonNull
  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }",method,
"  @NonNull
  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }",method,
"    @Synthetic
    DefaultHttpUrlConnectionFactory() { }",method,
"    @Override
    public HttpURLConnection build(URL url) throws IOException {
      return (HttpURLConnection) url.openConnection();
    }",method,
"public class LocalFileMetadata
        implements ConnectorMetadata
{
    public static final String PRESTO_LOGS_SCHEMA = ""logs"";
    public static final ColumnMetadata SERVER_ADDRESS_COLUMN = new ColumnMetadata(""server_address"", createUnboundedVarcharType());
    private static final List<String> SCHEMA_NAMES = ImmutableList.of(PRESTO_LOGS_SCHEMA);
    private final LocalFileTables localFileTables;
    @Inject
    public LocalFileMetadata(LocalFileTables localFileTables)
    {
        this.localFileTables = requireNonNull(localFileTables, ""localFileTables is null"");
    }
    @Override
    public List<String> listSchemaNames(ConnectorSession session)
    {
        return SCHEMA_NAMES;
    }
    @Override
    public ConnectorTableHandle getTableHandle(ConnectorSession session, SchemaTableName tableName)
    {
        requireNonNull(tableName, ""tableName is null"");
        return localFileTables.getTable(tableName);
    }
    @Override
    public ConnectorTableMetadata getTableMetadata(ConnectorSession session, ConnectorTableHandle table)
    {
        LocalFileTableHandle tableHandle = (LocalFileTableHandle) table;
        return new ConnectorTableMetadata(tableHandle.getSchemaTableName(), localFileTables.getColumns(tableHandle));
    }
    @Override
    public List<SchemaTableName> listTables(ConnectorSession session, String schemaNameOrNull)
    {
        return localFileTables.getTables();
    }
    @Override
    public List<ConnectorTableLayoutResult> getTableLayouts(ConnectorSession session, ConnectorTableHandle table, Constraint<ColumnHandle> constraint, Optional<Set<ColumnHandle>> desiredColumns)
    {
        LocalFileTableHandle tableHandle = (LocalFileTableHandle) table;
        ConnectorTableLayout layout = new ConnectorTableLayout(new LocalFileTableLayoutHandle(tableHandle, constraint.getSummary()));
        return ImmutableList.of(new ConnectorTableLayoutResult(layout, constraint.getSummary()));
    }
    @Override
    public ConnectorTableLayout getTableLayout(ConnectorSession session, ConnectorTableLayoutHandle handle)
    {
        LocalFileTableLayoutHandle layout = (LocalFileTableLayoutHandle) handle;
        return new ConnectorTableLayout(layout);
    }
    @Override
    public Map<String, ColumnHandle> getColumnHandles(ConnectorSession session, ConnectorTableHandle table)
    {
        LocalFileTableHandle tableHandle = (LocalFileTableHandle) table;
        return getColumnHandles(tableHandle);
    }
    private Map<String, ColumnHandle> getColumnHandles(LocalFileTableHandle tableHandle)
    {
        ImmutableMap.Builder<String, ColumnHandle> columnHandles = ImmutableMap.builder();
        int index = 0;
        for (ColumnMetadata column : localFileTables.getColumns(tableHandle)) {
            int ordinalPosition;
            if (column.getName().equals(SERVER_ADDRESS_COLUMN_NAME)) {
                ordinalPosition = SERVER_ADDRESS_ORDINAL_POSITION;
            }
            else {
                ordinalPosition = index;
                index++;
            }
            columnHandles.put(column.getName(), new LocalFileColumnHandle(column.getName(), column.getType(), ordinalPosition));
        }
        return columnHandles.build();
    }
    @Override
    public ColumnMetadata getColumnMetadata(ConnectorSession session, ConnectorTableHandle tableHandle, ColumnHandle columnHandle)
    {
        return ((LocalFileColumnHandle) columnHandle).toColumnMetadata();
    }
    @Override
    public Map<SchemaTableName, List<ColumnMetadata>> listTableColumns(ConnectorSession session, SchemaTablePrefix prefix)
    {
        requireNonNull(prefix, ""prefix is null"");
        ImmutableMap.Builder<SchemaTableName, List<ColumnMetadata>> columns = ImmutableMap.builder();
        for (SchemaTableName tableName : listTables(session, prefix)) {
            LocalFileTableHandle tableHandle = localFileTables.getTable(tableName);
            if (tableHandle != null) {
                columns.put(tableName, localFileTables.getColumns(tableHandle));
            }
        }
        return columns.build();
    }
    @Override
    public List<SchemaTableName> listViews(ConnectorSession session, String schemaNameOrNull)
    {
        return emptyList();
    }
    @Override
    public Map<SchemaTableName, ConnectorViewDefinition> getViews(ConnectorSession session, SchemaTablePrefix prefix)
    {
        return emptyMap();
    }
    private List<SchemaTableName> listTables(ConnectorSession session, SchemaTablePrefix prefix)
    {
        if (prefix.getSchemaName() == null) {
            return listTables(session, prefix.getSchemaName());
        }
        return ImmutableList.of(new SchemaTableName(prefix.getSchemaName(), prefix.getTableName()));
    }
}",class,
"    @Inject
    public LocalFileMetadata(LocalFileTables localFileTables)
    {
        this.localFileTables = requireNonNull(localFileTables, ""localFileTables is null"");
    }",method,
"    @Override
    public List<String> listSchemaNames(ConnectorSession session)
    {
        return SCHEMA_NAMES;
    }",method,
"    @Override
    public ConnectorTableHandle getTableHandle(ConnectorSession session, SchemaTableName tableName)
    {
        requireNonNull(tableName, ""tableName is null"");
        return localFileTables.getTable(tableName);
    }",method,
"    @Override
    public ConnectorTableMetadata getTableMetadata(ConnectorSession session, ConnectorTableHandle table)
    {
        LocalFileTableHandle tableHandle = (LocalFileTableHandle) table;
        return new ConnectorTableMetadata(tableHandle.getSchemaTableName(), localFileTables.getColumns(tableHandle));
    }",method,
"    @Override
    public List<SchemaTableName> listTables(ConnectorSession session, String schemaNameOrNull)
    {
        return localFileTables.getTables();
    }",method,
"    @Override
    public List<ConnectorTableLayoutResult> getTableLayouts(ConnectorSession session, ConnectorTableHandle table, Constraint<ColumnHandle> constraint, Optional<Set<ColumnHandle>> desiredColumns)
    {
        LocalFileTableHandle tableHandle = (LocalFileTableHandle) table;
        ConnectorTableLayout layout = new ConnectorTableLayout(new LocalFileTableLayoutHandle(tableHandle, constraint.getSummary()));
        return ImmutableList.of(new ConnectorTableLayoutResult(layout, constraint.getSummary()));
    }",method,
"    @Override
    public ConnectorTableLayout getTableLayout(ConnectorSession session, ConnectorTableLayoutHandle handle)
    {
        LocalFileTableLayoutHandle layout = (LocalFileTableLayoutHandle) handle;
        return new ConnectorTableLayout(layout);
    }",method,
"    @Override
    public Map<String, ColumnHandle> getColumnHandles(ConnectorSession session, ConnectorTableHandle table)
    {
        LocalFileTableHandle tableHandle = (LocalFileTableHandle) table;
        return getColumnHandles(tableHandle);
    }",method,
"    private Map<String, ColumnHandle> getColumnHandles(LocalFileTableHandle tableHandle)
    {
        ImmutableMap.Builder<String, ColumnHandle> columnHandles = ImmutableMap.builder();
        int index = 0;
        for (ColumnMetadata column : localFileTables.getColumns(tableHandle)) {
            int ordinalPosition;
            if (column.getName().equals(SERVER_ADDRESS_COLUMN_NAME)) {
                ordinalPosition = SERVER_ADDRESS_ORDINAL_POSITION;
            }
            else {
                ordinalPosition = index;
                index++;
            }
            columnHandles.put(column.getName(), new LocalFileColumnHandle(column.getName(), column.getType(), ordinalPosition));
        }
        return columnHandles.build();
    }",method,
"    @Override
    public ColumnMetadata getColumnMetadata(ConnectorSession session, ConnectorTableHandle tableHandle, ColumnHandle columnHandle)
    {
        return ((LocalFileColumnHandle) columnHandle).toColumnMetadata();
    }",method,
"    @Override
    public Map<SchemaTableName, List<ColumnMetadata>> listTableColumns(ConnectorSession session, SchemaTablePrefix prefix)
    {
        requireNonNull(prefix, ""prefix is null"");
        ImmutableMap.Builder<SchemaTableName, List<ColumnMetadata>> columns = ImmutableMap.builder();
        for (SchemaTableName tableName : listTables(session, prefix)) {
            LocalFileTableHandle tableHandle = localFileTables.getTable(tableName);
            if (tableHandle != null) {
                columns.put(tableName, localFileTables.getColumns(tableHandle));
            }
        }
        return columns.build();
    }",method,
"            if (tableHandle != null) {
                columns.put(tableName, localFileTables.getColumns(tableHandle));
            }",method,
"    @Override
    public List<SchemaTableName> listViews(ConnectorSession session, String schemaNameOrNull)
    {
        return emptyList();
    }",method,
"    @Override
    public Map<SchemaTableName, ConnectorViewDefinition> getViews(ConnectorSession session, SchemaTablePrefix prefix)
    {
        return emptyMap();
    }",method,
"    private List<SchemaTableName> listTables(ConnectorSession session, SchemaTablePrefix prefix)
    {
        if (prefix.getSchemaName() == null) {
            return listTables(session, prefix.getSchemaName());
        }
        return ImmutableList.of(new SchemaTableName(prefix.getSchemaName(), prefix.getTableName()));
    }",method,
"public class DiffManagerTest {
  @Test
  public void testAdditionalTools() {
    DiffManagerImpl diffManager = new DiffManagerImpl();
    MyDiffTool tool = new MyDiffTool();
    diffManager.registerDiffTool(tool);
    MyDiffRequest request = new MyDiffRequest();
    request.addContent();
    request.addContent();
    request.addContent();
    request.addContent();
    assertTrue(diffManager.getDiffTool().canShow(request));
    assertEquals(1, tool.myCanShowCount);
    diffManager.getDiffTool().show(request);
    assertEquals(2, tool.myCanShowCount);
    assertEquals(1, tool.myShowCount);
  }
  private static class MyDiffTool implements DiffTool {
    public int myCanShowCount = 0;
    public int myShowCount = 0;
    @Override
    public boolean canShow(DiffRequest request) {
      myCanShowCount++;
      return canShowImpl(request);
    }
    @Override
    public DiffViewer createComponent(String title, DiffRequest request, Window window, @NotNull Disposable parentDisposable) {
      return null;
    }
    private static boolean canShowImpl(DiffRequest request) {
      return request.getContents().length == 4;
    }
    @Override
    public void show(DiffRequest request) {
      assertTrue(canShowImpl(request));
      myShowCount++;
    }
  }
  private static class MyDiffRequest extends DiffRequest {
    private final List<String> myContentTitles = new ArrayList<>();
    private final List<DiffContent> myDiffContents = new ArrayList<>();
    public MyDiffRequest() {
      super(null);
    }
    @Override
    public String getWindowTitle() {
      return ""title"";
    }
    @Override
    public String[] getContentTitles() {
      return ArrayUtil.toStringArray(myContentTitles);
    }
    @NotNull
    @Override
    public DiffContent[] getContents() {
      return myDiffContents.toArray(new DiffContent[myDiffContents.size()]);
    }
    public void addContent(DiffContent content, String title) {
      myDiffContents.add(content);
      myContentTitles.add(title);
    }
    public void addContent() {
      Project project = EasyMock.createMock(Project.class);
      addContent(new BinaryContent(project, ArrayUtil.EMPTY_BYTE_ARRAY, null, FileTypes.UNKNOWN, null), """");
    }
  }
}",class,
"  private static class MyDiffTool implements DiffTool {
    public int myCanShowCount = 0;
    public int myShowCount = 0;
    @Override
    public boolean canShow(DiffRequest request) {
      myCanShowCount++;
      return canShowImpl(request);
    }
    @Override
    public DiffViewer createComponent(String title, DiffRequest request, Window window, @NotNull Disposable parentDisposable) {
      return null;
    }
    private static boolean canShowImpl(DiffRequest request) {
      return request.getContents().length == 4;
    }
    @Override
    public void show(DiffRequest request) {
      assertTrue(canShowImpl(request));
      myShowCount++;
    }
  }",class,
"  private static class MyDiffRequest extends DiffRequest {
    private final List<String> myContentTitles = new ArrayList<>();
    private final List<DiffContent> myDiffContents = new ArrayList<>();
    public MyDiffRequest() {
      super(null);
    }
    @Override
    public String getWindowTitle() {
      return ""title"";
    }
    @Override
    public String[] getContentTitles() {
      return ArrayUtil.toStringArray(myContentTitles);
    }
    @NotNull
    @Override
    public DiffContent[] getContents() {
      return myDiffContents.toArray(new DiffContent[myDiffContents.size()]);
    }
    public void addContent(DiffContent content, String title) {
      myDiffContents.add(content);
      myContentTitles.add(title);
    }
    public void addContent() {
      Project project = EasyMock.createMock(Project.class);
      addContent(new BinaryContent(project, ArrayUtil.EMPTY_BYTE_ARRAY, null, FileTypes.UNKNOWN, null), """");
    }
  }",class,
"  @Test
  public void testAdditionalTools() {
    DiffManagerImpl diffManager = new DiffManagerImpl();
    MyDiffTool tool = new MyDiffTool();
    diffManager.registerDiffTool(tool);
    MyDiffRequest request = new MyDiffRequest();
    request.addContent();
    request.addContent();
    request.addContent();
    request.addContent();
    assertTrue(diffManager.getDiffTool().canShow(request));
    assertEquals(1, tool.myCanShowCount);
    diffManager.getDiffTool().show(request);
    assertEquals(2, tool.myCanShowCount);
    assertEquals(1, tool.myShowCount);
  }",method,
"    @Override
    public boolean canShow(DiffRequest request) {
      myCanShowCount++;
      return canShowImpl(request);
    }",method,
"    @Override
    public DiffViewer createComponent(String title, DiffRequest request, Window window, @NotNull Disposable parentDisposable) {
      return null;
    }",method,
"    private static boolean canShowImpl(DiffRequest request) {
      return request.getContents().length == 4;
    }",method,
"    @Override
    public void show(DiffRequest request) {
      assertTrue(canShowImpl(request));
      myShowCount++;
    }",method,
"    public MyDiffRequest() {
      super(null);
    }",method,
"    @Override
    public String getWindowTitle() {
      return ""title"";
    }",method,
"    @Override
    public String[] getContentTitles() {
      return ArrayUtil.toStringArray(myContentTitles);
    }",method,
"    @NotNull
    @Override
    public DiffContent[] getContents() {
      return myDiffContents.toArray(new DiffContent[myDiffContents.size()]);
    }",method,
"    public void addContent(DiffContent content, String title) {
      myDiffContents.add(content);
      myContentTitles.add(title);
    }",method,
"    public void addContent() {
      Project project = EasyMock.createMock(Project.class);
      addContent(new BinaryContent(project, ArrayUtil.EMPTY_BYTE_ARRAY, null, FileTypes.UNKNOWN, null), """");
    }",method,
"public class ShaderProgramManager {
	// ===========================================================
	// Constants
	// ===========================================================
	// ===========================================================
	// Fields
	// ===========================================================
	private final ArrayList<ShaderProgram> mShaderProgramsManaged = new ArrayList<ShaderProgram>();
	// ===========================================================
	// Constructors
	// ===========================================================
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	// ===========================================================
	// Methods
	// ===========================================================
	public synchronized void onCreate() {
		this.loadShaderProgram(PositionColorTextureCoordinatesShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesUniformColorShaderProgram.getInstance());
		this.loadShaderProgram(PositionColorShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesTextureSelectShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesPositionInterpolationTextureSelectShaderProgram.getInstance());
	}
	public synchronized void onDestroy() {
		final ArrayList<ShaderProgram> managedShaderPrograms = this.mShaderProgramsManaged;
		for(int i = managedShaderPrograms.size() - 1; i >= 0; i--) {
			managedShaderPrograms.get(i).setCompiled(false);
		}
		this.mShaderProgramsManaged.clear();
	}
	public synchronized void loadShaderProgram(final ShaderProgram pShaderProgram) {
		if(pShaderProgram == null) {
			throw new IllegalArgumentException(""pShaderProgram must not be null!"");
		}
		if(pShaderProgram.isCompiled()) {
			Debug.w(""Loading an already compiled "" + ShaderProgram.class.getSimpleName() + "": '"" + pShaderProgram.getClass().getSimpleName() + ""'. '"" + pShaderProgram.getClass().getSimpleName() + ""' will be recompiled."");
			pShaderProgram.setCompiled(false);
		}
		if(this.mShaderProgramsManaged.contains(pShaderProgram)) {
			Debug.w(""Loading an already loaded "" + ShaderProgram.class.getSimpleName() + "": '"" + pShaderProgram.getClass().getSimpleName() + ""'."");
		} else {
			this.mShaderProgramsManaged.add(pShaderProgram);
		}
	}
	public void loadShaderPrograms(final ShaderProgram ... pShaderPrograms) {
		for(int i = pShaderPrograms.length - 1; i >= 0; i--) {
			this.loadShaderProgram(pShaderPrograms[i]);
		}
	}
	public synchronized void onReload() {
		final ArrayList<ShaderProgram> managedShaderPrograms = this.mShaderProgramsManaged;
		for(int i = managedShaderPrograms.size() - 1; i >= 0; i--) {
			managedShaderPrograms.get(i).setCompiled(false);
		}
	}
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"public class ShaderProgramCompileException extends ShaderProgramException {
	// ===========================================================
	// Constants
	// ===========================================================
	private static final long serialVersionUID = 8284346688949370359L;
	// ===========================================================
	// Fields
	// ===========================================================
	// ===========================================================
	// Constructors
	// ===========================================================
	public ShaderProgramCompileException(final String pMessage, final String pSource) {
		super(""Reason: "" + pMessage + ""\nSource:\n##########################\n"" + pSource + ""\n##########################"");
	}
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	// ===========================================================
	// Methods
	// ===========================================================
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	public synchronized void onCreate() {
		this.loadShaderProgram(PositionColorTextureCoordinatesShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesUniformColorShaderProgram.getInstance());
		this.loadShaderProgram(PositionColorShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesTextureSelectShaderProgram.getInstance());
		this.loadShaderProgram(PositionTextureCoordinatesPositionInterpolationTextureSelectShaderProgram.getInstance());
	}",method,
"	public synchronized void onDestroy() {
		final ArrayList<ShaderProgram> managedShaderPrograms = this.mShaderProgramsManaged;
		for(int i = managedShaderPrograms.size() - 1; i >= 0; i--) {
			managedShaderPrograms.get(i).setCompiled(false);
		}
		this.mShaderProgramsManaged.clear();
	}",method,
"	public synchronized void loadShaderProgram(final ShaderProgram pShaderProgram) {
		if(pShaderProgram == null) {
			throw new IllegalArgumentException(""pShaderProgram must not be null!"");
		}
		if(pShaderProgram.isCompiled()) {
			Debug.w(""Loading an already compiled "" + ShaderProgram.class.getSimpleName() + "": '"" + pShaderProgram.getClass().getSimpleName() + ""'. '"" + pShaderProgram.getClass().getSimpleName() + ""' will be recompiled."");
			pShaderProgram.setCompiled(false);
		}
		if(this.mShaderProgramsManaged.contains(pShaderProgram)) {
			Debug.w(""Loading an already loaded "" + ShaderProgram.class.getSimpleName() + "": '"" + pShaderProgram.getClass().getSimpleName() + ""'."");
		} else {
			this.mShaderProgramsManaged.add(pShaderProgram);
		}
	}",method,

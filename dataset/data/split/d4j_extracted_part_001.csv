code_snippet,type,original_score,new_score
"public class ErrorsTag extends AbstractHtmlElementBodyTag implements BodyTag {
	public static final String MESSAGES_ATTRIBUTE = ""messages"";
	public static final String SPAN_TAG = ""span"";
	private String element = SPAN_TAG;
	private String delimiter = ""<br/>"";
	private Object oldMessages;
	private boolean errorMessagesWereExposed;
	public void setElement(String element) {
		Assert.hasText(element, ""'element' cannot be null or blank"");
		this.element = element;
	}
	public String getElement() {
		return this.element;
	}
	public void setDelimiter(String delimiter) {
		this.delimiter = delimiter;
	}
	public String getDelimiter() {
		return this.delimiter;
	}
	@Override
	protected String autogenerateId() throws JspException {
		String path = getPropertyPath();
		if ("""".equals(path) || ""*"".equals(path)) {
			path = (String) this.pageContext.getAttribute(
					FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE);
		}
		return StringUtils.deleteAny(path, ""[]"") + "".errors"";
	}
	@Override
	protected String getName() throws JspException {
		return null;
	}
	@Override
	protected boolean shouldRender() throws JspException {
		try {
			return getBindStatus().isError();
		}
		catch (IllegalStateException ex) {
			// Neither BindingResult nor target object available.
			return false;
		}
	}
	@Override
	protected void renderDefaultContent(TagWriter tagWriter) throws JspException {
		tagWriter.startTag(getElement());
		writeDefaultAttributes(tagWriter);
		String delimiter = ObjectUtils.getDisplayString(evaluate(""delimiter"", getDelimiter()));
		String[] errorMessages = getBindStatus().getErrorMessages();
		for (int i = 0; i < errorMessages.length; i++) {
			String errorMessage = errorMessages[i];
			if (i > 0) {
				tagWriter.appendValue(delimiter);
			}
			tagWriter.appendValue(getDisplayString(errorMessage));
		}
		tagWriter.endTag();
	}
	@Override
	protected void exposeAttributes() throws JspException {
		List<String> errorMessages = new ArrayList<>();
		errorMessages.addAll(Arrays.asList(getBindStatus().getErrorMessages()));
		this.oldMessages = this.pageContext.getAttribute(MESSAGES_ATTRIBUTE, PageContext.PAGE_SCOPE);
		this.pageContext.setAttribute(MESSAGES_ATTRIBUTE, errorMessages, PageContext.PAGE_SCOPE);
		this.errorMessagesWereExposed = true;
	}
	@Override
	protected void removeAttributes() {
		if (this.errorMessagesWereExposed) {
			if (this.oldMessages != null) {
				this.pageContext.setAttribute(MESSAGES_ATTRIBUTE, this.oldMessages, PageContext.PAGE_SCOPE);
				this.oldMessages = null;
			}
			else {
				this.pageContext.removeAttribute(MESSAGES_ATTRIBUTE, PageContext.PAGE_SCOPE);
			}
		}
	}
}",class,changes_recommended
"	public void setElement(String element) {
		Assert.hasText(element, ""'element' cannot be null or blank"");
		this.element = element;
	}",method,good
"	public String getElement() {
		return this.element;
	}",method,good
"	public void setDelimiter(String delimiter) {
		this.delimiter = delimiter;
	}",method,good
"	public String getDelimiter() {
		return this.delimiter;
	}",method,good
"	@Override
	protected String autogenerateId() throws JspException {
		String path = getPropertyPath();
		if ("""".equals(path) || ""*"".equals(path)) {
			path = (String) this.pageContext.getAttribute(
					FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE);
		}
		return StringUtils.deleteAny(path, ""[]"") + "".errors"";
	}",method,good
"	@Override
	protected String getName() throws JspException {
		return null;
	}",method,good
"	@Override
	protected boolean shouldRender() throws JspException {
		try {
			return getBindStatus().isError();
		}
		catch (IllegalStateException ex) {
			// Neither BindingResult nor target object available.
			return false;
		}
	}",method,good
"		catch (IllegalStateException ex) {
			// Neither BindingResult nor target object available.
			return false;
		}",method,good
"	@Override
	protected void renderDefaultContent(TagWriter tagWriter) throws JspException {
		tagWriter.startTag(getElement());
		writeDefaultAttributes(tagWriter);
		String delimiter = ObjectUtils.getDisplayString(evaluate(""delimiter"", getDelimiter()));
		String[] errorMessages = getBindStatus().getErrorMessages();
		for (int i = 0; i < errorMessages.length; i++) {
			String errorMessage = errorMessages[i];
			if (i > 0) {
				tagWriter.appendValue(delimiter);
			}
			tagWriter.appendValue(getDisplayString(errorMessage));
		}
		tagWriter.endTag();
	}",method,good
"		for (int i = 0; i < errorMessages.length; i++) {
			String errorMessage = errorMessages[i];
			if (i > 0) {
				tagWriter.appendValue(delimiter);
			}
			tagWriter.appendValue(getDisplayString(errorMessage));
		}",method,good
"			if (i > 0) {
				tagWriter.appendValue(delimiter);
			}",method,good
"	@Override
	protected void exposeAttributes() throws JspException {
		List<String> errorMessages = new ArrayList<>();
		errorMessages.addAll(Arrays.asList(getBindStatus().getErrorMessages()));
		this.oldMessages = this.pageContext.getAttribute(MESSAGES_ATTRIBUTE, PageContext.PAGE_SCOPE);
		this.pageContext.setAttribute(MESSAGES_ATTRIBUTE, errorMessages, PageContext.PAGE_SCOPE);
		this.errorMessagesWereExposed = true;
	}",method,good
"	@Override
	protected void removeAttributes() {
		if (this.errorMessagesWereExposed) {
			if (this.oldMessages != null) {
				this.pageContext.setAttribute(MESSAGES_ATTRIBUTE, this.oldMessages, PageContext.PAGE_SCOPE);
				this.oldMessages = null;
			}
			else {
				this.pageContext.removeAttribute(MESSAGES_ATTRIBUTE, PageContext.PAGE_SCOPE);
			}
		}
	}",method,good
"		if (this.errorMessagesWereExposed) {
			if (this.oldMessages != null) {
				this.pageContext.setAttribute(MESSAGES_ATTRIBUTE, this.oldMessages, PageContext.PAGE_SCOPE);
				this.oldMessages = null;
			}
			else {
				this.pageContext.removeAttribute(MESSAGES_ATTRIBUTE, PageContext.PAGE_SCOPE);
			}
		}",method,good
"			if (this.oldMessages != null) {
				this.pageContext.setAttribute(MESSAGES_ATTRIBUTE, this.oldMessages, PageContext.PAGE_SCOPE);
				this.oldMessages = null;
			}",method,good
"public class UnwrapElseBranchAction extends PsiElementBaseIntentionAction {
  private static final Logger LOG = Logger.getInstance(UnwrapElseBranchAction.class);
  @Override
  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {
    PsiElement parent = element.getParent();
    if (parent instanceof PsiIfStatement) {
      PsiIfStatement ifStatement = (PsiIfStatement)parent;
      PsiStatement elseBranch = ifStatement.getElseBranch();
      PsiElement grandParent = ifStatement.getParent();
      if (elseBranch != null && grandParent != null) {
        if (!(grandParent instanceof PsiCodeBlock)) {
          PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);
          PsiCodeBlock codeBlock = factory.createCodeBlockFromText(""{"" + ifStatement.getText() + ""}"", ifStatement);
          codeBlock = (PsiCodeBlock)ifStatement.replace(codeBlock);
          ifStatement = (PsiIfStatement)codeBlock.getStatements()[0];
          elseBranch = ifStatement.getElseBranch();
          LOG.assertTrue(elseBranch != null);
        }
        InvertIfConditionAction.addAfter(ifStatement, elseBranch);
        elseBranch.delete();
      }
    }
  }
  @Override
  public boolean isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) {
    if (element instanceof PsiKeyword && ((PsiKeyword)element).getTokenType() == JavaTokenType.ELSE_KEYWORD) {
      PsiElement parent = element.getParent();
      if (parent instanceof PsiIfStatement) {
        PsiIfStatement ifStatement = (PsiIfStatement)parent;
        PsiStatement elseBranch = ifStatement.getElseBranch();
        if (elseBranch != null) {
          PsiStatement thenBranch = ifStatement.getThenBranch();
          boolean thenCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(thenBranch);
          boolean elseCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(elseBranch);
          if (!thenCompletesNormally ||
              elseCompletesNormally ||
              !nextStatementMayBecomeUnreachable(ifStatement)) {
            if (thenCompletesNormally) {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch.changes.semantics""));
            }
            else {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch""));
            }
            return true;
          }
        }
      }
    }
    return false;
  }
  private static boolean nextStatementMayBecomeUnreachable(PsiStatement statement) {
    PsiStatement nextStatement = PsiTreeUtil.getNextSiblingOfType(statement, PsiStatement.class);
    if (nextStatement != null) {
      return !(nextStatement instanceof PsiSwitchLabelStatement);
    }
    PsiElement parent = statement.getParent();
    if (parent instanceof PsiIfStatement) {
      PsiIfStatement ifStatement = (PsiIfStatement)parent;
      PsiStatement thenBranch = ifStatement.getThenBranch();
      PsiStatement elseBranch = ifStatement.getElseBranch();
      if (thenBranch == statement && ControlFlowUtils.statementMayCompleteNormally(elseBranch) ||
          elseBranch == statement && ControlFlowUtils.statementMayCompleteNormally(thenBranch)) {
        return false;
      }
      return nextStatementMayBecomeUnreachable(ifStatement);
    }
    if (parent instanceof PsiLabeledStatement) {
      return nextStatementMayBecomeUnreachable((PsiLabeledStatement)parent);
    }
    if (parent instanceof PsiCodeBlock) {
      PsiStatement parentStatement = ObjectUtils.tryCast(parent.getParent(), PsiStatement.class);
      if (parentStatement instanceof PsiBlockStatement ||
          parentStatement instanceof PsiSynchronizedStatement ||
          parentStatement instanceof PsiTryStatement || // TODO handle try-catch more accurately
          parentStatement instanceof PsiSwitchStatement) {
        return nextStatementMayBecomeUnreachable(parentStatement);
      }
    }
    return false;
  }
  @Nls
  @NotNull
  @Override
  public String getFamilyName() {
    return CodeInsightBundle.message(""intention.unwrap.else.branch"");
  }
}",class,changes_recommended
"  @Override
  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {
    PsiElement parent = element.getParent();
    if (parent instanceof PsiIfStatement) {
      PsiIfStatement ifStatement = (PsiIfStatement)parent;
      PsiStatement elseBranch = ifStatement.getElseBranch();
      PsiElement grandParent = ifStatement.getParent();
      if (elseBranch != null && grandParent != null) {
        if (!(grandParent instanceof PsiCodeBlock)) {
          PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);
          PsiCodeBlock codeBlock = factory.createCodeBlockFromText(""{"" + ifStatement.getText() + ""}"", ifStatement);
          codeBlock = (PsiCodeBlock)ifStatement.replace(codeBlock);
          ifStatement = (PsiIfStatement)codeBlock.getStatements()[0];
          elseBranch = ifStatement.getElseBranch();
          LOG.assertTrue(elseBranch != null);
        }
        InvertIfConditionAction.addAfter(ifStatement, elseBranch);
        elseBranch.delete();
      }
    }
  }",method,good
"    if (parent instanceof PsiIfStatement) {
      PsiIfStatement ifStatement = (PsiIfStatement)parent;
      PsiStatement elseBranch = ifStatement.getElseBranch();
      PsiElement grandParent = ifStatement.getParent();
      if (elseBranch != null && grandParent != null) {
        if (!(grandParent instanceof PsiCodeBlock)) {
          PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);
          PsiCodeBlock codeBlock = factory.createCodeBlockFromText(""{"" + ifStatement.getText() + ""}"", ifStatement);
          codeBlock = (PsiCodeBlock)ifStatement.replace(codeBlock);
          ifStatement = (PsiIfStatement)codeBlock.getStatements()[0];
          elseBranch = ifStatement.getElseBranch();
          LOG.assertTrue(elseBranch != null);
        }
        InvertIfConditionAction.addAfter(ifStatement, elseBranch);
        elseBranch.delete();
      }
    }",method,good
"      if (elseBranch != null && grandParent != null) {
        if (!(grandParent instanceof PsiCodeBlock)) {
          PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);
          PsiCodeBlock codeBlock = factory.createCodeBlockFromText(""{"" + ifStatement.getText() + ""}"", ifStatement);
          codeBlock = (PsiCodeBlock)ifStatement.replace(codeBlock);
          ifStatement = (PsiIfStatement)codeBlock.getStatements()[0];
          elseBranch = ifStatement.getElseBranch();
          LOG.assertTrue(elseBranch != null);
        }
        InvertIfConditionAction.addAfter(ifStatement, elseBranch);
        elseBranch.delete();
      }",method,good
"  @Override
  public boolean isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) {
    if (element instanceof PsiKeyword && ((PsiKeyword)element).getTokenType() == JavaTokenType.ELSE_KEYWORD) {
      PsiElement parent = element.getParent();
      if (parent instanceof PsiIfStatement) {
        PsiIfStatement ifStatement = (PsiIfStatement)parent;
        PsiStatement elseBranch = ifStatement.getElseBranch();
        if (elseBranch != null) {
          PsiStatement thenBranch = ifStatement.getThenBranch();
          boolean thenCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(thenBranch);
          boolean elseCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(elseBranch);
          if (!thenCompletesNormally ||
              elseCompletesNormally ||
              !nextStatementMayBecomeUnreachable(ifStatement)) {
            if (thenCompletesNormally) {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch.changes.semantics""));
            }
            else {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch""));
            }
            return true;
          }
        }
      }
    }
    return false;
  }",method,good
"      if (parent instanceof PsiIfStatement) {
        PsiIfStatement ifStatement = (PsiIfStatement)parent;
        PsiStatement elseBranch = ifStatement.getElseBranch();
        if (elseBranch != null) {
          PsiStatement thenBranch = ifStatement.getThenBranch();
          boolean thenCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(thenBranch);
          boolean elseCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(elseBranch);
          if (!thenCompletesNormally ||
              elseCompletesNormally ||
              !nextStatementMayBecomeUnreachable(ifStatement)) {
            if (thenCompletesNormally) {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch.changes.semantics""));
            }
            else {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch""));
            }
            return true;
          }
        }
      }",method,good
"        if (elseBranch != null) {
          PsiStatement thenBranch = ifStatement.getThenBranch();
          boolean thenCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(thenBranch);
          boolean elseCompletesNormally = ControlFlowUtils.statementMayCompleteNormally(elseBranch);
          if (!thenCompletesNormally ||
              elseCompletesNormally ||
              !nextStatementMayBecomeUnreachable(ifStatement)) {
            if (thenCompletesNormally) {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch.changes.semantics""));
            }
            else {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch""));
            }
            return true;
          }
        }",method,good
"            if (thenCompletesNormally) {
              setText(CodeInsightBundle.message(""intention.unwrap.else.branch.changes.semantics""));
            }",method,good
"  private static boolean nextStatementMayBecomeUnreachable(PsiStatement statement) {
    PsiStatement nextStatement = PsiTreeUtil.getNextSiblingOfType(statement, PsiStatement.class);
    if (nextStatement != null) {
      return !(nextStatement instanceof PsiSwitchLabelStatement);
    }
    PsiElement parent = statement.getParent();
    if (parent instanceof PsiIfStatement) {
      PsiIfStatement ifStatement = (PsiIfStatement)parent;
      PsiStatement thenBranch = ifStatement.getThenBranch();
      PsiStatement elseBranch = ifStatement.getElseBranch();
      if (thenBranch == statement && ControlFlowUtils.statementMayCompleteNormally(elseBranch) ||
          elseBranch == statement && ControlFlowUtils.statementMayCompleteNormally(thenBranch)) {
        return false;
      }
      return nextStatementMayBecomeUnreachable(ifStatement);
    }
    if (parent instanceof PsiLabeledStatement) {
      return nextStatementMayBecomeUnreachable((PsiLabeledStatement)parent);
    }
    if (parent instanceof PsiCodeBlock) {
      PsiStatement parentStatement = ObjectUtils.tryCast(parent.getParent(), PsiStatement.class);
      if (parentStatement instanceof PsiBlockStatement ||
          parentStatement instanceof PsiSynchronizedStatement ||
          parentStatement instanceof PsiTryStatement || // TODO handle try-catch more accurately
          parentStatement instanceof PsiSwitchStatement) {
        return nextStatementMayBecomeUnreachable(parentStatement);
      }
    }
    return false;
  }",method,good
"    if (nextStatement != null) {
      return !(nextStatement instanceof PsiSwitchLabelStatement);
    }",method,good
"    if (parent instanceof PsiIfStatement) {
      PsiIfStatement ifStatement = (PsiIfStatement)parent;
      PsiStatement thenBranch = ifStatement.getThenBranch();
      PsiStatement elseBranch = ifStatement.getElseBranch();
      if (thenBranch == statement && ControlFlowUtils.statementMayCompleteNormally(elseBranch) ||
          elseBranch == statement && ControlFlowUtils.statementMayCompleteNormally(thenBranch)) {
        return false;
      }
      return nextStatementMayBecomeUnreachable(ifStatement);
    }",method,good
"    if (parent instanceof PsiLabeledStatement) {
      return nextStatementMayBecomeUnreachable((PsiLabeledStatement)parent);
    }",method,good
"    if (parent instanceof PsiCodeBlock) {
      PsiStatement parentStatement = ObjectUtils.tryCast(parent.getParent(), PsiStatement.class);
      if (parentStatement instanceof PsiBlockStatement ||
          parentStatement instanceof PsiSynchronizedStatement ||
          parentStatement instanceof PsiTryStatement || // TODO handle try-catch more accurately
          parentStatement instanceof PsiSwitchStatement) {
        return nextStatementMayBecomeUnreachable(parentStatement);
      }
    }",method,good
"      if (parentStatement instanceof PsiBlockStatement ||
          parentStatement instanceof PsiSynchronizedStatement ||
          parentStatement instanceof PsiTryStatement || // TODO handle try-catch more accurately
          parentStatement instanceof PsiSwitchStatement) {
        return nextStatementMayBecomeUnreachable(parentStatement);
      }",method,good
"  @Nls
  @NotNull
  @Override
  public String getFamilyName() {
    return CodeInsightBundle.message(""intention.unwrap.else.branch"");
  }",method,good
"public class CallableSelectorTest {
    @Test
    public void testCallableProcToIfaceMatchIsNotOrderSensitive() throws Exception {
        final Ruby runtime = Ruby.newInstance();
        final Method list1 = java.io.File.class.getMethod(""listFiles"", java.io.FileFilter.class);
        final Method list2 = java.io.File.class.getMethod(""listFiles"", java.io.FilenameFilter.class);
        HashMap cache;
        JavaMethod[] methods;
        Binding binding = new Binding(new Frame(), null, new BacktraceElement());
        JavaMethod result; IRubyObject[] args;
        // arity 1 :
        BlockBody body1 = new NullBlockBody() {
            // @Override public Arity arity() { return Arity.ONE_ARGUMENT; }
            @Override
            public Signature getSignature() { return Signature.ONE_ARGUMENT; }
        };
        RubyProc dummyProc = RubyProc.newProc(runtime, new Block(body1, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] { // ""reverse"" method order
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list1), result);
        // arity 2 :
        BlockBody body2 = new NullBlockBody() {
            // @Override public Arity arity() { return Arity.TWO_ARGUMENTS; }
            @Override
            public Signature getSignature() { return Signature.TWO_ARGUMENTS; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body2, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] { // ""reverse"" method order
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list2), result);
        // arity -1 :
        BlockBody body_1 = new NullBlockBody() { // arity -1
            // @Override public Arity arity() { return Arity.OPTIONAL; }
            @Override
            public Signature getSignature() { return Signature.OPTIONAL; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body_1, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        // arity -3 :
        BlockBody body_3 = new NullBlockBody() { // arity -3
            // @Override public Arity arity() { return Arity.TWO_REQUIRED; }
            @Override
            public Signature getSignature() { return Signature.TWO_REQUIRED; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body_3, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        // arity -2 :
        BlockBody body_2 = new NullBlockBody() { // arity -2 (arg1, *rest) should prefer (single)
            // @Override public Arity arity() { return Arity.ONE_REQUIRED; }
            @Override
            public Signature getSignature() { return Signature.ONE_REQUIRED; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body_2, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
    }
}",class,changes_required
"    @Test
    public void testCallableProcToIfaceMatchIsNotOrderSensitive() throws Exception {
        final Ruby runtime = Ruby.newInstance();
        final Method list1 = java.io.File.class.getMethod(""listFiles"", java.io.FileFilter.class);
        final Method list2 = java.io.File.class.getMethod(""listFiles"", java.io.FilenameFilter.class);
        HashMap cache;
        JavaMethod[] methods;
        Binding binding = new Binding(new Frame(), null, new BacktraceElement());
        JavaMethod result; IRubyObject[] args;
        // arity 1 :
        BlockBody body1 = new NullBlockBody() {
            // @Override public Arity arity() { return Arity.ONE_ARGUMENT; }
            @Override
            public Signature getSignature() { return Signature.ONE_ARGUMENT; }
        };
        RubyProc dummyProc = RubyProc.newProc(runtime, new Block(body1, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] { // ""reverse"" method order
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list1), result);
        // arity 2 :
        BlockBody body2 = new NullBlockBody() {
            // @Override public Arity arity() { return Arity.TWO_ARGUMENTS; }
            @Override
            public Signature getSignature() { return Signature.TWO_ARGUMENTS; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body2, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] { // ""reverse"" method order
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        args = new IRubyObject[] { dummyProc };
        result = (JavaMethod)CallableSelector.matchingCallableArityN(runtime, cache, methods, args);
        assertEquals(new JavaMethod(runtime, list2), result);
        // arity -1 :
        BlockBody body_1 = new NullBlockBody() { // arity -1
            // @Override public Arity arity() { return Arity.OPTIONAL; }
            @Override
            public Signature getSignature() { return Signature.OPTIONAL; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body_1, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        // arity -3 :
        BlockBody body_3 = new NullBlockBody() { // arity -3
            // @Override public Arity arity() { return Arity.TWO_REQUIRED; }
            @Override
            public Signature getSignature() { return Signature.TWO_REQUIRED; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body_3, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list2), result);
        // arity -2 :
        BlockBody body_2 = new NullBlockBody() { // arity -2 (arg1, *rest) should prefer (single)
            // @Override public Arity arity() { return Arity.ONE_REQUIRED; }
            @Override
            public Signature getSignature() { return Signature.ONE_REQUIRED; }
        };
        dummyProc = RubyProc.newProc(runtime, new Block(body_2, binding), Block.Type.PROC);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list1), new JavaMethod(runtime, list2)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
        cache = new HashMap<>();
        methods = new JavaMethod[] {
            new JavaMethod(runtime, list2), new JavaMethod(runtime, list1)
        };
        result = (JavaMethod)CallableSelector.matchingCallableArityOne(runtime, cache, methods, dummyProc);
        assertEquals(new JavaMethod(runtime, list1), result);
    }",method,changes_required
"            @Override
            public Signature getSignature() { return Signature.ONE_ARGUMENT; }",method,good
"            @Override
            public Signature getSignature() { return Signature.TWO_ARGUMENTS; }",method,good
"            @Override
            public Signature getSignature() { return Signature.OPTIONAL; }",method,good
"            @Override
            public Signature getSignature() { return Signature.TWO_REQUIRED; }",method,good
"            @Override
            public Signature getSignature() { return Signature.ONE_REQUIRED; }",method,good
"public class SemServiceImpl extends SemService{
  private final ConcurrentMap<PsiElement, SemCacheChunk> myCache = ContainerUtil.createConcurrentWeakKeySoftValueMap();
  private volatile  MultiMap<SemKey, NullableFunction<PsiElement, Collection<? extends SemElement>>> myProducers;
  private final Project myProject;
  private boolean myBulkChange = false;
  private final AtomicInteger myCreatingSem = new AtomicInteger(0);
  public SemServiceImpl(Project project, PsiManager psiManager) {
    myProject = project;
    final MessageBusConnection connection = project.getMessageBus().connect();
    connection.subscribe(PsiModificationTracker.TOPIC, new PsiModificationTracker.Listener() {
      @Override
      public void modificationCountChanged() {
        if (!isInsideAtomicChange()) {
          clearCache();
        }
      }
    });
    ((PsiManagerEx)psiManager).registerRunnableToRunOnChange(() -> {
      if (!isInsideAtomicChange()) {
        clearCache();
      }
    });
    LowMemoryWatcher.register(() -> {
      if (myCreatingSem.get() == 0) {
        clearCache();
      }
      //System.out.println(""SemService cache flushed"");
    }, project);
  }
  private MultiMap<SemKey, NullableFunction<PsiElement, Collection<? extends SemElement>>> collectProducers() {
    final MultiMap<SemKey, NullableFunction<PsiElement, Collection<? extends SemElement>>> map = MultiMap.createSmart();
    final SemRegistrar registrar = new SemRegistrar() {
      @Override
      public <T extends SemElement, V extends PsiElement> void registerSemElementProvider(SemKey<T> key,
                                                                                          final ElementPattern<? extends V> place,
                                                                                          final NullableFunction<V, T> provider) {
        map.putValue(key, element -> {
          if (place.accepts(element)) {
            return Collections.singleton(provider.fun((V)element));
          }
          return null;
        });
      }
      @Override
      public <T extends SemElement, V extends PsiElement> void registerRepeatableSemElementProvider(SemKey<T> key,
                                                                                                    ElementPattern<? extends V> place,
                                                                                                    NullableFunction<V, Collection<T>> provider) {
        map.putValue(key, element -> {
          if (place.accepts(element)) {
            return provider.fun((V)element);
          }
          return null;
        });
      }
    };
    for (SemContributorEP contributor : myProject.getExtensions(SemContributor.EP_NAME)) {
      contributor.registerSemProviders(myProject.getPicoContainer(), registrar);
    }
    return map;
  }
  @Override
  public void clearCache() {
    myCache.clear();
  }
  @Override
  public void performAtomicChange(@NotNull Runnable change) {
    ApplicationManager.getApplication().assertWriteAccessAllowed();
    final boolean oldValue = myBulkChange;
    myBulkChange = true;
    try {
      change.run();
    }
    finally {
      myBulkChange = oldValue;
      if (!oldValue) {
        clearCache();
      }
    }
  }
  @Override
  public boolean isInsideAtomicChange() {
    return myBulkChange;
  }
  @Override
  @Nullable
  public <T extends SemElement> List<T> getSemElements(final SemKey<T> key, @NotNull final PsiElement psi) {
    List<T> cached = _getCachedSemElements(key, true, psi);
    if (cached != null) {
      return cached;
    }
    ensureInitialized();
    RecursionGuard.StackStamp stamp = RecursionManager.createGuard(""semService"").markStack();
    LinkedHashSet<T> result = new LinkedHashSet<>();
    final Map<SemKey, List<SemElement>> map = new THashMap<>();
    for (final SemKey each : key.getInheritors()) {
      List<SemElement> list = createSemElements(each, psi);
      map.put(each, list);
      result.addAll((List<T>)list);
    }
    if (stamp.mayCacheNow()) {
      final SemCacheChunk persistent = getOrCreateChunk(psi);
      for (SemKey semKey : map.keySet()) {
        persistent.putSemElements(semKey, map.get(semKey));
      }
    }
    return new ArrayList<>(result);
  }
  private void ensureInitialized() {
    if (myProducers == null) {
      myProducers = collectProducers();
    }
  }
  @NotNull
  private List<SemElement> createSemElements(SemKey key, PsiElement psi) {
    List<SemElement> result = null;
    Collection<NullableFunction<PsiElement, Collection<? extends SemElement>>> functions = myProducers.get(key);
    if (!functions.isEmpty()) {
      for (final NullableFunction<PsiElement, Collection<? extends SemElement>> producer : functions) {
        myCreatingSem.incrementAndGet();
        try {
          final Collection<? extends SemElement> elements = producer.fun(psi);
          if (elements != null) {
            if (result == null) result = new SmartList<>();
            ContainerUtil.addAllNotNull(result, elements);
          }
        }
        finally {
          myCreatingSem.decrementAndGet();
        }
      }
    }
    return result == null ? Collections.emptyList() : Collections.unmodifiableList(result);
  }
  @Override
  @Nullable
  public <T extends SemElement> List<T> getCachedSemElements(SemKey<T> key, @NotNull PsiElement psi) {
    return _getCachedSemElements(key, false, psi);
  }
  @Nullable
  private <T extends SemElement> List<T> _getCachedSemElements(SemKey<T> key, boolean paranoid, final PsiElement element) {
    final SemCacheChunk chunk = obtainChunk(element);
    if (chunk == null) return null;
    List<T> singleList = null;
    LinkedHashSet<T> result = null;
    final List<SemKey> inheritors = key.getInheritors();
    //noinspection ForLoopReplaceableByForEach
    for (int i = 0; i < inheritors.size(); i++) {
      List<T> cached = (List<T>)chunk.getSemElements(inheritors.get(i));
      if (cached == null && paranoid) {
        return null;
      }
      if (cached != null && cached != Collections.<T>emptyList()) {
        if (singleList == null) {
          singleList = cached;
          continue;
        }
        if (result == null) {
          result = new LinkedHashSet<>(singleList);
        }
        result.addAll(cached);
      }
    }
    if (result == null) {
      if (singleList != null) {
        return singleList;
      }
      return Collections.emptyList();
    }
    return new ArrayList<>(result);
  }
  @Nullable
  private SemCacheChunk obtainChunk(@Nullable PsiElement root) {
    return myCache.get(root);
  }
  @Override
  public <T extends SemElement> void setCachedSemElement(SemKey<T> key, @NotNull PsiElement psi, @Nullable T semElement) {
    getOrCreateChunk(psi).putSemElements(key, ContainerUtil.createMaybeSingletonList(semElement));
  }
  @Override
  public void clearCachedSemElements(@NotNull PsiElement psi) {
    myCache.remove(psi);
  }
  private SemCacheChunk getOrCreateChunk(final PsiElement element) {
    SemCacheChunk chunk = obtainChunk(element);
    if (chunk == null) {
      chunk = ConcurrencyUtil.cacheOrGet(myCache, element, new SemCacheChunk());
    }
    return chunk;
  }
  private static class SemCacheChunk {
    private final ConcurrentIntObjectMap<List<SemElement>> map = ContainerUtil.createConcurrentIntObjectMap();
    public List<SemElement> getSemElements(SemKey<?> key) {
      return map.get(key.getUniqueId());
    }
    public void putSemElements(SemKey<?> key, List<SemElement> elements) {
      map.put(key.getUniqueId(), elements);
    }
    @Override
    public int hashCode() {
      return 0; // ConcurrentWeakKeySoftValueHashMap.SoftValue requires hashCode, and this is faster than identityHashCode
    }
  }
}",class,changes_required
"  private static class SemCacheChunk {
    private final ConcurrentIntObjectMap<List<SemElement>> map = ContainerUtil.createConcurrentIntObjectMap();
    public List<SemElement> getSemElements(SemKey<?> key) {
      return map.get(key.getUniqueId());
    }
    public void putSemElements(SemKey<?> key, List<SemElement> elements) {
      map.put(key.getUniqueId(), elements);
    }
    @Override
    public int hashCode() {
      return 0; // ConcurrentWeakKeySoftValueHashMap.SoftValue requires hashCode, and this is faster than identityHashCode
    }
  }",class,good
"  public SemServiceImpl(Project project, PsiManager psiManager) {
    myProject = project;
    final MessageBusConnection connection = project.getMessageBus().connect();
    connection.subscribe(PsiModificationTracker.TOPIC, new PsiModificationTracker.Listener() {
      @Override
      public void modificationCountChanged() {
        if (!isInsideAtomicChange()) {
          clearCache();
        }
      }
    });
    ((PsiManagerEx)psiManager).registerRunnableToRunOnChange(() -> {
      if (!isInsideAtomicChange()) {
        clearCache();
      }
    });
    LowMemoryWatcher.register(() -> {
      if (myCreatingSem.get() == 0) {
        clearCache();
      }
      //System.out.println(""SemService cache flushed"");
    }, project);
  }",method,good
"    connection.subscribe(PsiModificationTracker.TOPIC, new PsiModificationTracker.Listener() {
      @Override
      public void modificationCountChanged() {
        if (!isInsideAtomicChange()) {
          clearCache();
        }
      }
    }",method,good
"      @Override
      public void modificationCountChanged() {
        if (!isInsideAtomicChange()) {
          clearCache();
        }
      }",method,good
"  private MultiMap<SemKey, NullableFunction<PsiElement, Collection<? extends SemElement>>> collectProducers() {
    final MultiMap<SemKey, NullableFunction<PsiElement, Collection<? extends SemElement>>> map = MultiMap.createSmart();
    final SemRegistrar registrar = new SemRegistrar() {
      @Override
      public <T extends SemElement, V extends PsiElement> void registerSemElementProvider(SemKey<T> key,
                                                                                          final ElementPattern<? extends V> place,
                                                                                          final NullableFunction<V, T> provider) {
        map.putValue(key, element -> {
          if (place.accepts(element)) {
            return Collections.singleton(provider.fun((V)element));
          }
          return null;
        });
      }
      @Override
      public <T extends SemElement, V extends PsiElement> void registerRepeatableSemElementProvider(SemKey<T> key,
                                                                                                    ElementPattern<? extends V> place,
                                                                                                    NullableFunction<V, Collection<T>> provider) {
        map.putValue(key, element -> {
          if (place.accepts(element)) {
            return provider.fun((V)element);
          }
          return null;
        });
      }
    };
    for (SemContributorEP contributor : myProject.getExtensions(SemContributor.EP_NAME)) {
      contributor.registerSemProviders(myProject.getPicoContainer(), registrar);
    }
    return map;
  }",method,changes_required
"      @Override
      public <T extends SemElement, V extends PsiElement> void registerSemElementProvider(SemKey<T> key,
                                                                                          final ElementPattern<? extends V> place,
                                                                                          final NullableFunction<V, T> provider) {
        map.putValue(key, element -> {
          if (place.accepts(element)) {
            return Collections.singleton(provider.fun((V)element));
          }
          return null;
        });
      }",method,changes_recommended
"      @Override
      public <T extends SemElement, V extends PsiElement> void registerRepeatableSemElementProvider(SemKey<T> key,
                                                                                                    ElementPattern<? extends V> place,
                                                                                                    NullableFunction<V, Collection<T>> provider) {
        map.putValue(key, element -> {
          if (place.accepts(element)) {
            return provider.fun((V)element);
          }
          return null;
        });
      }",method,changes_recommended
"  @Override
  public void clearCache() {
    myCache.clear();
  }",method,good
"  @Override
  public void performAtomicChange(@NotNull Runnable change) {
    ApplicationManager.getApplication().assertWriteAccessAllowed();
    final boolean oldValue = myBulkChange;
    myBulkChange = true;
    try {
      change.run();
    }
    finally {
      myBulkChange = oldValue;
      if (!oldValue) {
        clearCache();
      }
    }
  }",method,good
"      if (!oldValue) {
        clearCache();
      }",method,good
"  @Override
  public boolean isInsideAtomicChange() {
    return myBulkChange;
  }",method,good
"  @Override
  @Nullable
  public <T extends SemElement> List<T> getSemElements(final SemKey<T> key, @NotNull final PsiElement psi) {
    List<T> cached = _getCachedSemElements(key, true, psi);
    if (cached != null) {
      return cached;
    }
    ensureInitialized();
    RecursionGuard.StackStamp stamp = RecursionManager.createGuard(""semService"").markStack();
    LinkedHashSet<T> result = new LinkedHashSet<>();
    final Map<SemKey, List<SemElement>> map = new THashMap<>();
    for (final SemKey each : key.getInheritors()) {
      List<SemElement> list = createSemElements(each, psi);
      map.put(each, list);
      result.addAll((List<T>)list);
    }
    if (stamp.mayCacheNow()) {
      final SemCacheChunk persistent = getOrCreateChunk(psi);
      for (SemKey semKey : map.keySet()) {
        persistent.putSemElements(semKey, map.get(semKey));
      }
    }
    return new ArrayList<>(result);
  }",method,good
"    if (cached != null) {
      return cached;
    }",method,good
"  private void ensureInitialized() {
    if (myProducers == null) {
      myProducers = collectProducers();
    }
  }",method,good
"    if (myProducers == null) {
      myProducers = collectProducers();
    }",method,good
"  @NotNull
  private List<SemElement> createSemElements(SemKey key, PsiElement psi) {
    List<SemElement> result = null;
    Collection<NullableFunction<PsiElement, Collection<? extends SemElement>>> functions = myProducers.get(key);
    if (!functions.isEmpty()) {
      for (final NullableFunction<PsiElement, Collection<? extends SemElement>> producer : functions) {
        myCreatingSem.incrementAndGet();
        try {
          final Collection<? extends SemElement> elements = producer.fun(psi);
          if (elements != null) {
            if (result == null) result = new SmartList<>();
            ContainerUtil.addAllNotNull(result, elements);
          }
        }
        finally {
          myCreatingSem.decrementAndGet();
        }
      }
    }
    return result == null ? Collections.emptyList() : Collections.unmodifiableList(result);
  }",method,good
"      for (final NullableFunction<PsiElement, Collection<? extends SemElement>> producer : functions) {
        myCreatingSem.incrementAndGet();
        try {
          final Collection<? extends SemElement> elements = producer.fun(psi);
          if (elements != null) {
            if (result == null) result = new SmartList<>();
            ContainerUtil.addAllNotNull(result, elements);
          }
        }
        finally {
          myCreatingSem.decrementAndGet();
        }
      }",method,good
"          if (elements != null) {
            if (result == null) result = new SmartList<>();
            ContainerUtil.addAllNotNull(result, elements);
          }",method,good
"  @Override
  @Nullable
  public <T extends SemElement> List<T> getCachedSemElements(SemKey<T> key, @NotNull PsiElement psi) {
    return _getCachedSemElements(key, false, psi);
  }",method,good
"  @Nullable
  private <T extends SemElement> List<T> _getCachedSemElements(SemKey<T> key, boolean paranoid, final PsiElement element) {
    final SemCacheChunk chunk = obtainChunk(element);
    if (chunk == null) return null;
    List<T> singleList = null;
    LinkedHashSet<T> result = null;
    final List<SemKey> inheritors = key.getInheritors();
    //noinspection ForLoopReplaceableByForEach
    for (int i = 0; i < inheritors.size(); i++) {
      List<T> cached = (List<T>)chunk.getSemElements(inheritors.get(i));
      if (cached == null && paranoid) {
        return null;
      }
      if (cached != null && cached != Collections.<T>emptyList()) {
        if (singleList == null) {
          singleList = cached;
          continue;
        }
        if (result == null) {
          result = new LinkedHashSet<>(singleList);
        }
        result.addAll(cached);
      }
    }
    if (result == null) {
      if (singleList != null) {
        return singleList;
      }
      return Collections.emptyList();
    }
    return new ArrayList<>(result);
  }",method,good
"      if (cached == null && paranoid) {
        return null;
      }",method,good
"        if (singleList == null) {
          singleList = cached;
          continue;
        }",method,good
"        if (result == null) {
          result = new LinkedHashSet<>(singleList);
        }",method,good
"    if (result == null) {
      if (singleList != null) {
        return singleList;
      }
      return Collections.emptyList();
    }",method,good
"      if (singleList != null) {
        return singleList;
      }",method,good
"  @Nullable
  private SemCacheChunk obtainChunk(@Nullable PsiElement root) {
    return myCache.get(root);
  }",method,good
"  @Override
  public <T extends SemElement> void setCachedSemElement(SemKey<T> key, @NotNull PsiElement psi, @Nullable T semElement) {
    getOrCreateChunk(psi).putSemElements(key, ContainerUtil.createMaybeSingletonList(semElement));
  }",method,good
"  @Override
  public void clearCachedSemElements(@NotNull PsiElement psi) {
    myCache.remove(psi);
  }",method,good
"  private SemCacheChunk getOrCreateChunk(final PsiElement element) {
    SemCacheChunk chunk = obtainChunk(element);
    if (chunk == null) {
      chunk = ConcurrencyUtil.cacheOrGet(myCache, element, new SemCacheChunk());
    }
    return chunk;
  }",method,good
"    if (chunk == null) {
      chunk = ConcurrencyUtil.cacheOrGet(myCache, element, new SemCacheChunk());
    }",method,good
"    public List<SemElement> getSemElements(SemKey<?> key) {
      return map.get(key.getUniqueId());
    }",method,good
"    public void putSemElements(SemKey<?> key, List<SemElement> elements) {
      map.put(key.getUniqueId(), elements);
    }",method,good
"    @Override
    public int hashCode() {
      return 0; // ConcurrentWeakKeySoftValueHashMap.SoftValue requires hashCode, and this is faster than identityHashCode
    }",method,good
"public class RestoreSnapshotRequestBuilder extends MasterNodeOperationRequestBuilder<RestoreSnapshotRequest, RestoreSnapshotResponse, RestoreSnapshotRequestBuilder> {
    public RestoreSnapshotRequestBuilder(ElasticsearchClient client, RestoreSnapshotAction action) {
        super(client, action, new RestoreSnapshotRequest());
    }
    public RestoreSnapshotRequestBuilder(ElasticsearchClient client, RestoreSnapshotAction action, String repository, String name) {
        super(client, action, new RestoreSnapshotRequest(repository, name));
    }
    public RestoreSnapshotRequestBuilder setSnapshot(String snapshot) {
        request.snapshot(snapshot);
        return this;
    }
    public RestoreSnapshotRequestBuilder setRepository(String repository) {
        request.repository(repository);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIndices(String... indices) {
        request.indices(indices);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIndicesOptions(IndicesOptions indicesOptions) {
        request.indicesOptions(indicesOptions);
        return this;
    }
    public RestoreSnapshotRequestBuilder setRenamePattern(String renamePattern) {
        request.renamePattern(renamePattern);
        return this;
    }
    public RestoreSnapshotRequestBuilder setRenameReplacement(String renameReplacement) {
        request.renameReplacement(renameReplacement);
        return this;
    }
    public RestoreSnapshotRequestBuilder setSettings(Settings settings) {
        request.settings(settings);
        return this;
    }
    public RestoreSnapshotRequestBuilder setSettings(Settings.Builder settings) {
        request.settings(settings);
        return this;
    }
    public RestoreSnapshotRequestBuilder setSettings(String source, XContentType xContentType) {
        request.settings(source, xContentType);
        return this;
    }
    public RestoreSnapshotRequestBuilder setSettings(Map<String, Object> source) {
        request.settings(source);
        return this;
    }
    public RestoreSnapshotRequestBuilder setWaitForCompletion(boolean waitForCompletion) {
        request.waitForCompletion(waitForCompletion);
        return this;
    }
    public RestoreSnapshotRequestBuilder setRestoreGlobalState(boolean restoreGlobalState) {
        request.includeGlobalState(restoreGlobalState);
        return this;
    }
    public RestoreSnapshotRequestBuilder setPartial(boolean partial) {
        request.partial(partial);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIncludeAliases(boolean restoreAliases) {
        request.includeAliases(restoreAliases);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIndexSettings(Settings settings) {
        request.indexSettings(settings);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIndexSettings(Settings.Builder settings) {
        request.indexSettings(settings);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIndexSettings(String source, XContentType xContentType) {
        request.indexSettings(source, xContentType);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIndexSettings(Map<String, Object> source) {
        request.indexSettings(source);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIgnoreIndexSettings(String... ignoreIndexSettings) {
        request.ignoreIndexSettings(ignoreIndexSettings);
        return this;
    }
    public RestoreSnapshotRequestBuilder setIgnoreIndexSettings(List<String> ignoreIndexSettings) {
        request.ignoreIndexSettings(ignoreIndexSettings);
        return this;
    }
}",class,changes_recommended
"    public RestoreSnapshotRequestBuilder(ElasticsearchClient client, RestoreSnapshotAction action) {
        super(client, action, new RestoreSnapshotRequest());
    }",method,good
"    public RestoreSnapshotRequestBuilder(ElasticsearchClient client, RestoreSnapshotAction action, String repository, String name) {
        super(client, action, new RestoreSnapshotRequest(repository, name));
    }",method,good
"    public RestoreSnapshotRequestBuilder setSnapshot(String snapshot) {
        request.snapshot(snapshot);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setRepository(String repository) {
        request.repository(repository);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIndices(String... indices) {
        request.indices(indices);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIndicesOptions(IndicesOptions indicesOptions) {
        request.indicesOptions(indicesOptions);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setRenamePattern(String renamePattern) {
        request.renamePattern(renamePattern);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setRenameReplacement(String renameReplacement) {
        request.renameReplacement(renameReplacement);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setSettings(Settings settings) {
        request.settings(settings);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setSettings(Settings.Builder settings) {
        request.settings(settings);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setSettings(String source, XContentType xContentType) {
        request.settings(source, xContentType);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setSettings(Map<String, Object> source) {
        request.settings(source);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setWaitForCompletion(boolean waitForCompletion) {
        request.waitForCompletion(waitForCompletion);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setRestoreGlobalState(boolean restoreGlobalState) {
        request.includeGlobalState(restoreGlobalState);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setPartial(boolean partial) {
        request.partial(partial);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIncludeAliases(boolean restoreAliases) {
        request.includeAliases(restoreAliases);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIndexSettings(Settings settings) {
        request.indexSettings(settings);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIndexSettings(Settings.Builder settings) {
        request.indexSettings(settings);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIndexSettings(String source, XContentType xContentType) {
        request.indexSettings(source, xContentType);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIndexSettings(Map<String, Object> source) {
        request.indexSettings(source);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIgnoreIndexSettings(String... ignoreIndexSettings) {
        request.ignoreIndexSettings(ignoreIndexSettings);
        return this;
    }",method,good
"    public RestoreSnapshotRequestBuilder setIgnoreIndexSettings(List<String> ignoreIndexSettings) {
        request.ignoreIndexSettings(ignoreIndexSettings);
        return this;
    }",method,good
"public class SQLiteAsyncQuery extends SQLiteProgram {
    private static final String TAG = ""WCDB.SQLiteAsyncQuery"";
    private final int mResultColumns;
    public SQLiteAsyncQuery(SQLiteDatabase db, String query, Object[] bindArgs,
            CancellationSignal cancellationSignal) {
        super(db, query, bindArgs, cancellationSignal);
        mResultColumns = getColumnNames().length;
    }
    void acquire() {
        if (mPreparedStatement == null) {
            acquirePreparedStatement();
            mPreparedStatement.bindArguments(getBindArgs());
        }
    }
    void release() {
        releasePreparedStatement();
    }
    int fillRows(ChunkedCursorWindow window, int startPos, int count) {
        // Ensure prepared statement is acquired.
        acquire();
        // Check whether number of columns has been set.
        if (window.getNumColumns() != mResultColumns) {
            window.setNumColumns(mResultColumns);
        }
        try {
            return nativeFillRows(mPreparedStatement.getPtr(), window.mWindowPtr, startPos, count);
        } catch (SQLiteDatabaseCorruptException e) {
            onCorruption();
            throw e;
        } catch (SQLiteException e) {
            Log.e(TAG, ""Got exception on fillRows: "" + e.getMessage() + "", SQL: "" + getSql());
            throw e;
        }
    }
    int getCount() {
        // Ensure prepared statement is acquired.
        acquire();
        try {
            return nativeCount(mPreparedStatement.getPtr());
        } catch (SQLiteDatabaseCorruptException e) {
            onCorruption();
            throw e;
        } catch (SQLiteException e) {
            Log.e(TAG, ""Got exception on getCount: "" + e.getMessage() + "", SQL: "" + getSql());
            throw e;
        }
    }
    void reset() {
        if (mPreparedStatement != null)
            mPreparedStatement.reset(false);
    }
    private static native int nativeFillRows(long statementPtr, long windowPtr, int startPos, int count);
    private static native int nativeCount(long statementPtr);
}",class,changes_recommended
"public class SQLiteBindOrColumnIndexOutOfRangeException extends SQLiteException {
    public SQLiteBindOrColumnIndexOutOfRangeException() {}
    public SQLiteBindOrColumnIndexOutOfRangeException(String error) {
        super(error);
    }
}",class,good
"public class SQLiteBlobTooBigException extends SQLiteException {
    public SQLiteBlobTooBigException() {}
    public SQLiteBlobTooBigException(String error) {
        super(error);
    }
}",class,good
"public class SQLiteCantOpenDatabaseException extends SQLiteException {
    public SQLiteCantOpenDatabaseException() {}
    public SQLiteCantOpenDatabaseException(String error) {
        super(error);
    }
}",class,good
"    public SQLiteAsyncQuery(SQLiteDatabase db, String query, Object[] bindArgs,
            CancellationSignal cancellationSignal) {
        super(db, query, bindArgs, cancellationSignal);
        mResultColumns = getColumnNames().length;
    }",method,good
"    void acquire() {
        if (mPreparedStatement == null) {
            acquirePreparedStatement();
            mPreparedStatement.bindArguments(getBindArgs());
        }
    }",method,good

code_snippet,type,score
"    public void sendMessage(Message msg, int delay) {
        try {
            syncLatch.await();
            if (delay <= 0) {
                handler.sendMessage(msg);
            } else {
                handler.sendMessageDelayed(msg, delay);
            }
        } catch (Exception e) {
            FileLog.e(e);
        }
    }",method,
"            if (delay <= 0) {
                handler.sendMessage(msg);
            }",method,
"    public void cancelRunnable(Runnable runnable) {
        try {
            syncLatch.await();
            handler.removeCallbacks(runnable);
        } catch (Exception e) {
            FileLog.e(e);
        }
    }",method,
"    public void postRunnable(Runnable runnable) {
        postRunnable(runnable, 0);
    }",method,
"    public void postRunnable(Runnable runnable, long delay) {
        try {
            syncLatch.await();
            if (delay <= 0) {
                handler.post(runnable);
            } else {
                handler.postDelayed(runnable, delay);
            }
        } catch (Exception e) {
            FileLog.e(e);
        }
    }",method,
"            if (delay <= 0) {
                handler.post(runnable);
            }",method,
"    public void cleanupQueue() {
        try {
            syncLatch.await();
            handler.removeCallbacksAndMessages(null);
        } catch (Exception e) {
            FileLog.e(e);
        }
    }",method,
"    public void handleMessage(Message inputMessage) {
    }",method,
"    @Override
    public void run() {
        Looper.prepare();
        handler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                DispatchQueue.this.handleMessage(msg);
            }
        };
        syncLatch.countDown();
        Looper.loop();
    }",method,
"            @Override
            public void handleMessage(Message msg) {
                DispatchQueue.this.handleMessage(msg);
            }",method,
"public class QuestionableNameInspectionBase extends BaseInspection {
  public QuestionableNameInspectionBase() {
    parseString(nameString, nameList);
  }
  @NonNls public String nameString = ""aa,abc,bad,bar,bar2,baz,baz1,baz2,"" +
                                     ""baz3,bb,blah,bogus,bool,cc,dd,defau1t,dummy,dummy2,ee,fa1se,"" +
                                     ""ff,foo,foo1,foo2,foo3,foobar,four,fred,fred1,fred2,gg,hh,hello,"" +
                                     ""hello1,hello2,hello3,ii,nu11,one,silly,silly2,string,two,that,"" +
                                     ""then,three,whi1e,var"";List<String> nameList = new ArrayList<>(32);
  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""questionable.name.display.name"");
  }
  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(
      ""questionable.name.problem.descriptor"");
  }
  @Override
  public void readSettings(@NotNull Element element) throws InvalidDataException {
    super.readSettings(element);
    parseString(nameString, nameList);
  }
  @Override
  public void writeSettings(@NotNull Element element) throws WriteExternalException {
    nameString = formatString(nameList);
    super.writeSettings(element);
  }
  @Override
  protected boolean buildQuickFixesOnlyForOnTheFlyErrors() {
    return true;
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new QuestionableNameVisitor();
  }
  private class QuestionableNameVisitor extends BaseInspectionVisitor {
    private final Set<String> nameSet = new HashSet<>(nameList);
    @Override
    public void visitVariable(@NotNull PsiVariable variable) {
      final String name = variable.getName();
      if (nameSet.contains(name)) {
        registerVariableError(variable);
      }
    }
    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      final String name = method.getName();
      if (nameSet.contains(name)) {
        registerMethodError(method);
      }
    }
    @Override
    public void visitClass(@NotNull PsiClass aClass) {
      final String name = aClass.getName();
      if (nameSet.contains(name)) {
        registerClassError(aClass);
      }
    }
  }
}",class,
"  private class QuestionableNameVisitor extends BaseInspectionVisitor {
    private final Set<String> nameSet = new HashSet<>(nameList);
    @Override
    public void visitVariable(@NotNull PsiVariable variable) {
      final String name = variable.getName();
      if (nameSet.contains(name)) {
        registerVariableError(variable);
      }
    }
    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      final String name = method.getName();
      if (nameSet.contains(name)) {
        registerMethodError(method);
      }
    }
    @Override
    public void visitClass(@NotNull PsiClass aClass) {
      final String name = aClass.getName();
      if (nameSet.contains(name)) {
        registerClassError(aClass);
      }
    }
  }",class,
"  public QuestionableNameInspectionBase() {
    parseString(nameString, nameList);
  }",method,
"  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""questionable.name.display.name"");
  }",method,
"  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(
      ""questionable.name.problem.descriptor"");
  }",method,
"  @Override
  public void readSettings(@NotNull Element element) throws InvalidDataException {
    super.readSettings(element);
    parseString(nameString, nameList);
  }",method,
"  @Override
  public void writeSettings(@NotNull Element element) throws WriteExternalException {
    nameString = formatString(nameList);
    super.writeSettings(element);
  }",method,
"  @Override
  protected boolean buildQuickFixesOnlyForOnTheFlyErrors() {
    return true;
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new QuestionableNameVisitor();
  }",method,
"    @Override
    public void visitVariable(@NotNull PsiVariable variable) {
      final String name = variable.getName();
      if (nameSet.contains(name)) {
        registerVariableError(variable);
      }
    }",method,
"    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      final String name = method.getName();
      if (nameSet.contains(name)) {
        registerMethodError(method);
      }
    }",method,
"    @Override
    public void visitClass(@NotNull PsiClass aClass) {
      final String name = aClass.getName();
      if (nameSet.contains(name)) {
        registerClassError(aClass);
      }
    }",method,
"public class NodesHotThreadsRequest extends BaseNodesRequest<NodesHotThreadsRequest> {
    int threads = 3;
    String type = ""cpu"";
    TimeValue interval = new TimeValue(500, TimeUnit.MILLISECONDS);
    int snapshots = 10;
    boolean ignoreIdleThreads = true;
    // for serialization
    public NodesHotThreadsRequest() {
    }
    public NodesHotThreadsRequest(String... nodesIds) {
        super(nodesIds);
    }
    public int threads() {
        return this.threads;
    }
    public NodesHotThreadsRequest threads(int threads) {
        this.threads = threads;
        return this;
    }
    public boolean ignoreIdleThreads() {
        return this.ignoreIdleThreads;
    }
    public NodesHotThreadsRequest ignoreIdleThreads(boolean ignoreIdleThreads) {
        this.ignoreIdleThreads = ignoreIdleThreads;
        return this;
    }
    public NodesHotThreadsRequest type(String type) {
        this.type = type;
        return this;
    }
    public String type() {
        return this.type;
    }
    public NodesHotThreadsRequest interval(TimeValue interval) {
        this.interval = interval;
        return this;
    }
    public TimeValue interval() {
        return this.interval;
    }
    public int snapshots() {
        return this.snapshots;
    }
    public NodesHotThreadsRequest snapshots(int snapshots) {
        this.snapshots = snapshots;
        return this;
    }
    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        threads = in.readInt();
        ignoreIdleThreads = in.readBoolean();
        type = in.readString();
        interval = new TimeValue(in);
        snapshots = in.readInt();
    }
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeInt(threads);
        out.writeBoolean(ignoreIdleThreads);
        out.writeString(type);
        interval.writeTo(out);
        out.writeInt(snapshots);
    }
}",class,
"    public NodesHotThreadsRequest() {
    }",method,
"    public NodesHotThreadsRequest(String... nodesIds) {
        super(nodesIds);
    }",method,
"    public int threads() {
        return this.threads;
    }",method,
"    public NodesHotThreadsRequest threads(int threads) {
        this.threads = threads;
        return this;
    }",method,
"    public boolean ignoreIdleThreads() {
        return this.ignoreIdleThreads;
    }",method,
"    public NodesHotThreadsRequest ignoreIdleThreads(boolean ignoreIdleThreads) {
        this.ignoreIdleThreads = ignoreIdleThreads;
        return this;
    }",method,
"    public NodesHotThreadsRequest type(String type) {
        this.type = type;
        return this;
    }",method,
"    public String type() {
        return this.type;
    }",method,
"    public NodesHotThreadsRequest interval(TimeValue interval) {
        this.interval = interval;
        return this;
    }",method,
"    public TimeValue interval() {
        return this.interval;
    }",method,
"    public int snapshots() {
        return this.snapshots;
    }",method,
"    public NodesHotThreadsRequest snapshots(int snapshots) {
        this.snapshots = snapshots;
        return this;
    }",method,
"    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        threads = in.readInt();
        ignoreIdleThreads = in.readBoolean();
        type = in.readString();
        interval = new TimeValue(in);
        snapshots = in.readInt();
    }",method,
"    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeInt(threads);
        out.writeBoolean(ignoreIdleThreads);
        out.writeString(type);
        interval.writeTo(out);
        out.writeInt(snapshots);
    }",method,
"public class WeakPropertyChangeAdapter
  implements PropertyChangeListener
{
  private final WeakReference myRef;
  public WeakPropertyChangeAdapter(PropertyChangeListener l) {
    myRef = new WeakReference(l);
  }
  @Override
  public void propertyChange(PropertyChangeEvent e) {
    PropertyChangeListener l = (PropertyChangeListener)myRef.get();
    if (l != null) {
      l.propertyChange(e);
    }
  }
}",class,
"public class ClsFormatException extends Exception {
  public ClsFormatException() { }
  public ClsFormatException(String message) {
    super(message);
  }
  public ClsFormatException(String message, Throwable cause) {
    super(message, cause);
  }
}",class,
"  public WeakPropertyChangeAdapter(PropertyChangeListener l) {
    myRef = new WeakReference(l);
  }",method,
"  @Override
  public void propertyChange(PropertyChangeEvent e) {
    PropertyChangeListener l = (PropertyChangeListener)myRef.get();
    if (l != null) {
      l.propertyChange(e);
    }
  }",method,
"    if (l != null) {
      l.propertyChange(e);
    }",method,
  public ClsFormatException() { },method,
"  public ClsFormatException(String message) {
    super(message);
  }",method,
"  public ClsFormatException(String message, Throwable cause) {
    super(message, cause);
  }",method,
"public final class WorkProcessor<T>
    implements EventProcessor
{
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
    private final RingBuffer<T> ringBuffer;
    private final SequenceBarrier sequenceBarrier;
    private final WorkHandler<? super T> workHandler;
    private final ExceptionHandler<? super T> exceptionHandler;
    private final Sequence workSequence;
    private final EventReleaser eventReleaser = new EventReleaser()
    {
        @Override
        public void release()
        {
            sequence.set(Long.MAX_VALUE);
        }
    };
    private final TimeoutHandler timeoutHandler;
    public WorkProcessor(
        final RingBuffer<T> ringBuffer,
        final SequenceBarrier sequenceBarrier,
        final WorkHandler<? super T> workHandler,
        final ExceptionHandler<? super T> exceptionHandler,
        final Sequence workSequence)
    {
        this.ringBuffer = ringBuffer;
        this.sequenceBarrier = sequenceBarrier;
        this.workHandler = workHandler;
        this.exceptionHandler = exceptionHandler;
        this.workSequence = workSequence;
        if (this.workHandler instanceof EventReleaseAware)
        {
            ((EventReleaseAware) this.workHandler).setEventReleaser(eventReleaser);
        }
        timeoutHandler = (workHandler instanceof TimeoutHandler) ? (TimeoutHandler) workHandler : null;
    }
    @Override
    public Sequence getSequence()
    {
        return sequence;
    }
    @Override
    public void halt()
    {
        running.set(false);
        sequenceBarrier.alert();
    }
    @Override
    public boolean isRunning()
    {
        return running.get();
    }
    @Override
    public void run()
    {
        if (!running.compareAndSet(false, true))
        {
            throw new IllegalStateException(""Thread is already running"");
        }
        sequenceBarrier.clearAlert();
        notifyStart();
        boolean processedSequence = true;
        long cachedAvailableSequence = Long.MIN_VALUE;
        long nextSequence = sequence.get();
        T event = null;
        while (true)
        {
            try
            {
                // if previous sequence was processed - fetch the next sequence and set
                // that we have successfully processed the previous sequence
                // typically, this will be true
                // this prevents the sequence getting too far forward if an exception
                // is thrown from the WorkHandler
                if (processedSequence)
                {
                    processedSequence = false;
                    do
                    {
                        nextSequence = workSequence.get() + 1L;
                        sequence.set(nextSequence - 1L);
                    }
                    while (!workSequence.compareAndSet(nextSequence - 1L, nextSequence));
                }
                if (cachedAvailableSequence >= nextSequence)
                {
                    event = ringBuffer.get(nextSequence);
                    workHandler.onEvent(event);
                    processedSequence = true;
                }
                else
                {
                    cachedAvailableSequence = sequenceBarrier.waitFor(nextSequence);
                }
            }
            catch (final TimeoutException e)
            {
                notifyTimeout(sequence.get());
            }
            catch (final AlertException ex)
            {
                if (!running.get())
                {
                    break;
                }
            }
            catch (final Throwable ex)
            {
                // handle, mark as processed, unless the exception handler threw an exception
                exceptionHandler.handleEventException(ex, nextSequence, event);
                processedSequence = true;
            }
        }
        notifyShutdown();
        running.set(false);
    }
    private void notifyTimeout(final long availableSequence)
    {
        try
        {
            if (timeoutHandler != null)
            {
                timeoutHandler.onTimeout(availableSequence);
            }
        }
        catch (Throwable e)
        {
            exceptionHandler.handleEventException(e, availableSequence, null);
        }
    }
    private void notifyStart()
    {
        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware) workHandler).onStart();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnStartException(ex);
            }
        }
    }
    private void notifyShutdown()
    {
        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware) workHandler).onShutdown();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnShutdownException(ex);
            }
        }
    }
}",class,
"public final class YieldingWaitStrategy implements WaitStrategy
{
    private static final int SPIN_TRIES = 100;
    @Override
    public long waitFor(
        final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
        throws AlertException, InterruptedException
    {
        long availableSequence;
        int counter = SPIN_TRIES;
        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            counter = applyWaitMethod(barrier, counter);
        }
        return availableSequence;
    }
    @Override
    public void signalAllWhenBlocking()
    {
    }
    private int applyWaitMethod(final SequenceBarrier barrier, int counter)
        throws AlertException
    {
        barrier.checkAlert();
        if (0 == counter)
        {
            Thread.yield();
        }
        else
        {
            --counter;
        }
        return counter;
    }
}",class,
"        @Override
        public void release()
        {
            sequence.set(Long.MAX_VALUE);
        }",method,
"    public WorkProcessor(
        final RingBuffer<T> ringBuffer,
        final SequenceBarrier sequenceBarrier,
        final WorkHandler<? super T> workHandler,
        final ExceptionHandler<? super T> exceptionHandler,
        final Sequence workSequence)
    {
        this.ringBuffer = ringBuffer;
        this.sequenceBarrier = sequenceBarrier;
        this.workHandler = workHandler;
        this.exceptionHandler = exceptionHandler;
        this.workSequence = workSequence;
        if (this.workHandler instanceof EventReleaseAware)
        {
            ((EventReleaseAware) this.workHandler).setEventReleaser(eventReleaser);
        }
        timeoutHandler = (workHandler instanceof TimeoutHandler) ? (TimeoutHandler) workHandler : null;
    }",method,
"        if (this.workHandler instanceof EventReleaseAware)
        {
            ((EventReleaseAware) this.workHandler).setEventReleaser(eventReleaser);
        }",method,
"    @Override
    public Sequence getSequence()
    {
        return sequence;
    }",method,
"    @Override
    public void halt()
    {
        running.set(false);
        sequenceBarrier.alert();
    }",method,
"    @Override
    public boolean isRunning()
    {
        return running.get();
    }",method,
"    @Override
    public void run()
    {
        if (!running.compareAndSet(false, true))
        {
            throw new IllegalStateException(""Thread is already running"");
        }
        sequenceBarrier.clearAlert();
        notifyStart();
        boolean processedSequence = true;
        long cachedAvailableSequence = Long.MIN_VALUE;
        long nextSequence = sequence.get();
        T event = null;
        while (true)
        {
            try
            {
                // if previous sequence was processed - fetch the next sequence and set
                // that we have successfully processed the previous sequence
                // typically, this will be true
                // this prevents the sequence getting too far forward if an exception
                // is thrown from the WorkHandler
                if (processedSequence)
                {
                    processedSequence = false;
                    do
                    {
                        nextSequence = workSequence.get() + 1L;
                        sequence.set(nextSequence - 1L);
                    }
                    while (!workSequence.compareAndSet(nextSequence - 1L, nextSequence));
                }
                if (cachedAvailableSequence >= nextSequence)
                {
                    event = ringBuffer.get(nextSequence);
                    workHandler.onEvent(event);
                    processedSequence = true;
                }
                else
                {
                    cachedAvailableSequence = sequenceBarrier.waitFor(nextSequence);
                }
            }
            catch (final TimeoutException e)
            {
                notifyTimeout(sequence.get());
            }
            catch (final AlertException ex)
            {
                if (!running.get())
                {
                    break;
                }
            }
            catch (final Throwable ex)
            {
                // handle, mark as processed, unless the exception handler threw an exception
                exceptionHandler.handleEventException(ex, nextSequence, event);
                processedSequence = true;
            }
        }
        notifyShutdown();
        running.set(false);
    }",method,
"        while (true)
        {
            try
            {
                // if previous sequence was processed - fetch the next sequence and set
                // that we have successfully processed the previous sequence
                // typically, this will be true
                // this prevents the sequence getting too far forward if an exception
                // is thrown from the WorkHandler
                if (processedSequence)
                {
                    processedSequence = false;
                    do
                    {
                        nextSequence = workSequence.get() + 1L;
                        sequence.set(nextSequence - 1L);
                    }
                    while (!workSequence.compareAndSet(nextSequence - 1L, nextSequence));
                }
                if (cachedAvailableSequence >= nextSequence)
                {
                    event = ringBuffer.get(nextSequence);
                    workHandler.onEvent(event);
                    processedSequence = true;
                }
                else
                {
                    cachedAvailableSequence = sequenceBarrier.waitFor(nextSequence);
                }
            }
            catch (final TimeoutException e)
            {
                notifyTimeout(sequence.get());
            }
            catch (final AlertException ex)
            {
                if (!running.get())
                {
                    break;
                }
            }
            catch (final Throwable ex)
            {
                // handle, mark as processed, unless the exception handler threw an exception
                exceptionHandler.handleEventException(ex, nextSequence, event);
                processedSequence = true;
            }
        }",method,
"                if (processedSequence)
                {
                    processedSequence = false;
                    do
                    {
                        nextSequence = workSequence.get() + 1L;
                        sequence.set(nextSequence - 1L);
                    }
                    while (!workSequence.compareAndSet(nextSequence - 1L, nextSequence));
                }",method,
"                if (cachedAvailableSequence >= nextSequence)
                {
                    event = ringBuffer.get(nextSequence);
                    workHandler.onEvent(event);
                    processedSequence = true;
                }",method,
"            catch (final TimeoutException e)
            {
                notifyTimeout(sequence.get());
            }",method,
"            catch (final AlertException ex)
            {
                if (!running.get())
                {
                    break;
                }
            }",method,
"            catch (final Throwable ex)
            {
                // handle, mark as processed, unless the exception handler threw an exception
                exceptionHandler.handleEventException(ex, nextSequence, event);
                processedSequence = true;
            }",method,
"    private void notifyTimeout(final long availableSequence)
    {
        try
        {
            if (timeoutHandler != null)
            {
                timeoutHandler.onTimeout(availableSequence);
            }
        }
        catch (Throwable e)
        {
            exceptionHandler.handleEventException(e, availableSequence, null);
        }
    }",method,
"            if (timeoutHandler != null)
            {
                timeoutHandler.onTimeout(availableSequence);
            }",method,
"        catch (Throwable e)
        {
            exceptionHandler.handleEventException(e, availableSequence, null);
        }",method,
"    private void notifyStart()
    {
        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware) workHandler).onStart();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnStartException(ex);
            }
        }
    }",method,
"        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware) workHandler).onStart();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnStartException(ex);
            }
        }",method,
"            catch (final Throwable ex)
            {
                exceptionHandler.handleOnStartException(ex);
            }",method,
"    private void notifyShutdown()
    {
        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware) workHandler).onShutdown();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnShutdownException(ex);
            }
        }
    }",method,
"        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware) workHandler).onShutdown();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnShutdownException(ex);
            }
        }",method,
"            catch (final Throwable ex)
            {
                exceptionHandler.handleOnShutdownException(ex);
            }",method,
"    @Override
    public long waitFor(
        final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
        throws AlertException, InterruptedException
    {
        long availableSequence;
        int counter = SPIN_TRIES;
        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            counter = applyWaitMethod(barrier, counter);
        }
        return availableSequence;
    }",method,
"    @Override
    public void signalAllWhenBlocking()
    {
    }",method,
"    private int applyWaitMethod(final SequenceBarrier barrier, int counter)
        throws AlertException
    {
        barrier.checkAlert();
        if (0 == counter)
        {
            Thread.yield();
        }
        else
        {
            --counter;
        }
        return counter;
    }",method,
"        if (0 == counter)
        {
            Thread.yield();
        }",method,
"public abstract class KotlinUnwrapRemoveBase extends AbstractUnwrapper<KotlinUnwrapRemoveBase.Context> {
    private final String key;
    protected KotlinUnwrapRemoveBase(@NotNull String key) {
        super("""");
        this.key = key;
    }
    @Override
    public String getDescription(PsiElement e) {
        assert e instanceof KtElement;
        return KotlinBundle.message(key, ElementSelectionUtilsKt.getExpressionShortText((KtElement) e));
    }
    protected boolean canExtractExpression(@NotNull KtExpression expression, @NotNull KtElement parent) {
        if (expression instanceof KtBlockExpression) {
            KtBlockExpression block = (KtBlockExpression) expression;
            return block.getStatements().size() <= 1 || parent instanceof KtBlockExpression;
        }
        return true;
    }
    protected static class Context extends AbstractUnwrapper.AbstractContext {
        @Override
        protected boolean isWhiteSpace(PsiElement element) {
            return element instanceof PsiWhiteSpace;
        }
        public void extractFromBlock(@NotNull KtBlockExpression block, @NotNull KtElement from) throws IncorrectOperationException {
            List<KtExpression> expressions = block.getStatements();
            if (!expressions.isEmpty()) {
                extract(expressions.get(0), expressions.get(expressions.size() - 1), from);
            }
        }
        public void extractFromExpression(@NotNull KtExpression expression, @NotNull KtElement from) throws IncorrectOperationException {
            if (expression instanceof KtBlockExpression) {
                extractFromBlock((KtBlockExpression) expression, from);
            }
            else {
                extract(expression, expression, from);
            }
        }
        public void replace(@NotNull KtElement originalElement, @NotNull KtElement newElement) {
            if (myIsEffective) {
                originalElement.replace(newElement);
            }
        }
    }
    @Override
    protected Context createContext() {
        return new Context();
    }
}",class,
"    protected static class Context extends AbstractUnwrapper.AbstractContext {
        @Override
        protected boolean isWhiteSpace(PsiElement element) {
            return element instanceof PsiWhiteSpace;
        }
        public void extractFromBlock(@NotNull KtBlockExpression block, @NotNull KtElement from) throws IncorrectOperationException {
            List<KtExpression> expressions = block.getStatements();
            if (!expressions.isEmpty()) {
                extract(expressions.get(0), expressions.get(expressions.size() - 1), from);
            }
        }
        public void extractFromExpression(@NotNull KtExpression expression, @NotNull KtElement from) throws IncorrectOperationException {
            if (expression instanceof KtBlockExpression) {
                extractFromBlock((KtBlockExpression) expression, from);
            }
            else {
                extract(expression, expression, from);
            }
        }
        public void replace(@NotNull KtElement originalElement, @NotNull KtElement newElement) {
            if (myIsEffective) {
                originalElement.replace(newElement);
            }
        }
    }",class,
"    protected KotlinUnwrapRemoveBase(@NotNull String key) {
        super("""");
        this.key = key;
    }",method,
"    @Override
    public String getDescription(PsiElement e) {
        assert e instanceof KtElement;
        return KotlinBundle.message(key, ElementSelectionUtilsKt.getExpressionShortText((KtElement) e));
    }",method,
"    protected boolean canExtractExpression(@NotNull KtExpression expression, @NotNull KtElement parent) {
        if (expression instanceof KtBlockExpression) {
            KtBlockExpression block = (KtBlockExpression) expression;
            return block.getStatements().size() <= 1 || parent instanceof KtBlockExpression;
        }
        return true;
    }",method,
"        if (expression instanceof KtBlockExpression) {
            KtBlockExpression block = (KtBlockExpression) expression;
            return block.getStatements().size() <= 1 || parent instanceof KtBlockExpression;
        }",method,
"        @Override
        protected boolean isWhiteSpace(PsiElement element) {
            return element instanceof PsiWhiteSpace;
        }",method,
"        public void extractFromBlock(@NotNull KtBlockExpression block, @NotNull KtElement from) throws IncorrectOperationException {
            List<KtExpression> expressions = block.getStatements();
            if (!expressions.isEmpty()) {
                extract(expressions.get(0), expressions.get(expressions.size() - 1), from);
            }
        }",method,
"        public void extractFromExpression(@NotNull KtExpression expression, @NotNull KtElement from) throws IncorrectOperationException {
            if (expression instanceof KtBlockExpression) {
                extractFromBlock((KtBlockExpression) expression, from);
            }
            else {
                extract(expression, expression, from);
            }
        }",method,
"            if (expression instanceof KtBlockExpression) {
                extractFromBlock((KtBlockExpression) expression, from);
            }",method,
"        public void replace(@NotNull KtElement originalElement, @NotNull KtElement newElement) {
            if (myIsEffective) {
                originalElement.replace(newElement);
            }
        }",method,
"            if (myIsEffective) {
                originalElement.replace(newElement);
            }",method,
"    @Override
    protected Context createContext() {
        return new Context();
    }",method,
"public class HttpContentCompressor extends HttpContentEncoder {
    private final int compressionLevel;
    private final int windowBits;
    private final int memLevel;
    private ChannelHandlerContext ctx;
    public HttpContentCompressor() {
        this(6);
    }
    public HttpContentCompressor(int compressionLevel) {
        this(compressionLevel, 15, 8);
    }
    public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel) {
        if (compressionLevel < 0 || compressionLevel > 9) {
            throw new IllegalArgumentException(
                    ""compressionLevel: "" + compressionLevel +
                    "" (expected: 0-9)"");
        }
        if (windowBits < 9 || windowBits > 15) {
            throw new IllegalArgumentException(
                    ""windowBits: "" + windowBits + "" (expected: 9-15)"");
        }
        if (memLevel < 1 || memLevel > 9) {
            throw new IllegalArgumentException(
                    ""memLevel: "" + memLevel + "" (expected: 1-9)"");
        }
        this.compressionLevel = compressionLevel;
        this.windowBits = windowBits;
        this.memLevel = memLevel;
    }
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        this.ctx = ctx;
    }
    @Override
    protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
        String contentEncoding = headers.headers().get(HttpHeaderNames.CONTENT_ENCODING);
        if (contentEncoding != null) {
            // Content-Encoding was set, either as something specific or as the IDENTITY encoding
            // Therefore, we should NOT encode here
            return null;
        }
        ZlibWrapper wrapper = determineWrapper(acceptEncoding);
        if (wrapper == null) {
            return null;
        }
        String targetContentEncoding;
        switch (wrapper) {
        case GZIP:
            targetContentEncoding = ""gzip"";
            break;
        case ZLIB:
            targetContentEncoding = ""deflate"";
            break;
        default:
            throw new Error();
        }
        return new Result(
                targetContentEncoding,
                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),
                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(
                        wrapper, compressionLevel, windowBits, memLevel)));
    }
    @SuppressWarnings(""FloatingPointEquality"")
    protected ZlibWrapper determineWrapper(String acceptEncoding) {
        float starQ = -1.0f;
        float gzipQ = -1.0f;
        float deflateQ = -1.0f;
        for (String encoding : acceptEncoding.split("","")) {
            float q = 1.0f;
            int equalsPos = encoding.indexOf('=');
            if (equalsPos != -1) {
                try {
                    q = Float.parseFloat(encoding.substring(equalsPos + 1));
                } catch (NumberFormatException e) {
                    // Ignore encoding
                    q = 0.0f;
                }
            }
            if (encoding.contains(""*"")) {
                starQ = q;
            } else if (encoding.contains(""gzip"") && q > gzipQ) {
                gzipQ = q;
            } else if (encoding.contains(""deflate"") && q > deflateQ) {
                deflateQ = q;
            }
        }
        if (gzipQ > 0.0f || deflateQ > 0.0f) {
            if (gzipQ >= deflateQ) {
                return ZlibWrapper.GZIP;
            } else {
                return ZlibWrapper.ZLIB;
            }
        }
        if (starQ > 0.0f) {
            if (gzipQ == -1.0f) {
                return ZlibWrapper.GZIP;
            }
            if (deflateQ == -1.0f) {
                return ZlibWrapper.ZLIB;
            }
        }
        return null;
    }
}",class,
"    public HttpContentCompressor() {
        this(6);
    }",method,
"    public HttpContentCompressor(int compressionLevel) {
        this(compressionLevel, 15, 8);
    }",method,
"    public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel) {
        if (compressionLevel < 0 || compressionLevel > 9) {
            throw new IllegalArgumentException(
                    ""compressionLevel: "" + compressionLevel +
                    "" (expected: 0-9)"");
        }
        if (windowBits < 9 || windowBits > 15) {
            throw new IllegalArgumentException(
                    ""windowBits: "" + windowBits + "" (expected: 9-15)"");
        }
        if (memLevel < 1 || memLevel > 9) {
            throw new IllegalArgumentException(
                    ""memLevel: "" + memLevel + "" (expected: 1-9)"");
        }
        this.compressionLevel = compressionLevel;
        this.windowBits = windowBits;
        this.memLevel = memLevel;
    }",method,
"        if (compressionLevel < 0 || compressionLevel > 9) {
            throw new IllegalArgumentException(
                    ""compressionLevel: "" + compressionLevel +
                    "" (expected: 0-9)"");
        }",method,
"        if (windowBits < 9 || windowBits > 15) {
            throw new IllegalArgumentException(
                    ""windowBits: "" + windowBits + "" (expected: 9-15)"");
        }",method,
"        if (memLevel < 1 || memLevel > 9) {
            throw new IllegalArgumentException(
                    ""memLevel: "" + memLevel + "" (expected: 1-9)"");
        }",method,
"    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        this.ctx = ctx;
    }",method,
"    @Override
    protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
        String contentEncoding = headers.headers().get(HttpHeaderNames.CONTENT_ENCODING);
        if (contentEncoding != null) {
            // Content-Encoding was set, either as something specific or as the IDENTITY encoding
            // Therefore, we should NOT encode here
            return null;
        }
        ZlibWrapper wrapper = determineWrapper(acceptEncoding);
        if (wrapper == null) {
            return null;
        }
        String targetContentEncoding;
        switch (wrapper) {
        case GZIP:
            targetContentEncoding = ""gzip"";
            break;
        case ZLIB:
            targetContentEncoding = ""deflate"";
            break;
        default:
            throw new Error();
        }
        return new Result(
                targetContentEncoding,
                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),
                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(
                        wrapper, compressionLevel, windowBits, memLevel)));
    }",method,
"        if (contentEncoding != null) {
            // Content-Encoding was set, either as something specific or as the IDENTITY encoding
            // Therefore, we should NOT encode here
            return null;
        }",method,
"        if (wrapper == null) {
            return null;
        }",method,
"        switch (wrapper) {
        case GZIP:
            targetContentEncoding = ""gzip"";
            break;
        case ZLIB:
            targetContentEncoding = ""deflate"";
            break;
        default:
            throw new Error();
        }",method,
"    @SuppressWarnings(""FloatingPointEquality"")
    protected ZlibWrapper determineWrapper(String acceptEncoding) {
        float starQ = -1.0f;
        float gzipQ = -1.0f;
        float deflateQ = -1.0f;
        for (String encoding : acceptEncoding.split("","")) {
            float q = 1.0f;
            int equalsPos = encoding.indexOf('=');
            if (equalsPos != -1) {
                try {
                    q = Float.parseFloat(encoding.substring(equalsPos + 1));
                } catch (NumberFormatException e) {
                    // Ignore encoding
                    q = 0.0f;
                }
            }
            if (encoding.contains(""*"")) {
                starQ = q;
            } else if (encoding.contains(""gzip"") && q > gzipQ) {
                gzipQ = q;
            } else if (encoding.contains(""deflate"") && q > deflateQ) {
                deflateQ = q;
            }
        }
        if (gzipQ > 0.0f || deflateQ > 0.0f) {
            if (gzipQ >= deflateQ) {
                return ZlibWrapper.GZIP;
            } else {
                return ZlibWrapper.ZLIB;
            }
        }
        if (starQ > 0.0f) {
            if (gzipQ == -1.0f) {
                return ZlibWrapper.GZIP;
            }
            if (deflateQ == -1.0f) {
                return ZlibWrapper.ZLIB;
            }
        }
        return null;
    }",method,
"            if (equalsPos != -1) {
                try {
                    q = Float.parseFloat(encoding.substring(equalsPos + 1));
                } catch (NumberFormatException e) {
                    // Ignore encoding
                    q = 0.0f;
                }
            }",method,
"        if (gzipQ > 0.0f || deflateQ > 0.0f) {
            if (gzipQ >= deflateQ) {
                return ZlibWrapper.GZIP;
            } else {
                return ZlibWrapper.ZLIB;
            }
        }",method,

code_snippet,type,score
"    public CodeSigner(CertPath signerCertPath, Timestamp timestamp) {
        if (signerCertPath == null) {
            throw new NullPointerException();
        }
        this.signerCertPath = signerCertPath;
        this.timestamp = timestamp;
    }",method,
"        if (signerCertPath == null) {
            throw new NullPointerException();
        }",method,
"    public CertPath getSignerCertPath() {
        return signerCertPath;
    }",method,
"    public Timestamp getTimestamp() {
        return timestamp;
    }",method,
"    public int hashCode() {
        if (myhash == -1) {
            if (timestamp == null) {
                myhash = signerCertPath.hashCode();
            } else {
                myhash = signerCertPath.hashCode() + timestamp.hashCode();
            }
        }
        return myhash;
    }",method,
"        if (myhash == -1) {
            if (timestamp == null) {
                myhash = signerCertPath.hashCode();
            } else {
                myhash = signerCertPath.hashCode() + timestamp.hashCode();
            }
        }",method,
"            if (timestamp == null) {
                myhash = signerCertPath.hashCode();
            }",method,
"    public boolean equals(Object obj) {
        if (obj == null || (!(obj instanceof CodeSigner))) {
            return false;
        }
        CodeSigner that = (CodeSigner)obj;
        if (this == that) {
            return true;
        }
        Timestamp thatTimestamp = that.getTimestamp();
        if (timestamp == null) {
            if (thatTimestamp != null) {
                return false;
            }
        } else {
            if (thatTimestamp == null ||
                (! timestamp.equals(thatTimestamp))) {
                return false;
            }
        }
        return signerCertPath.equals(that.getSignerCertPath());
    }",method,
"        if (this == that) {
            return true;
        }",method,
"        if (timestamp == null) {
            if (thatTimestamp != null) {
                return false;
            }
        }",method,
"            if (thatTimestamp != null) {
                return false;
            }",method,
"    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(""("");
        sb.append(""Signer: "" + signerCertPath.getCertificates().get(0));
        if (timestamp != null) {
            sb.append(""timestamp: "" + timestamp);
        }
        sb.append("")"");
        return sb.toString();
    }",method,
"        if (timestamp != null) {
            sb.append(""timestamp: "" + timestamp);
        }",method,
"    private void readObject(ObjectInputStream ois)
        throws IOException, ClassNotFoundException {
     ois.defaultReadObject();
     myhash = -1;
    }",method,
"public class BuildOperationQueueFailure extends GradleException {
    public BuildOperationQueueFailure(String message) {
        super(message);
    }
    public BuildOperationQueueFailure(String message, Throwable cause) {
        super(message, cause);
    }
}",class,
"    public BuildOperationQueueFailure(String message) {
        super(message);
    }",method,
"    public BuildOperationQueueFailure(String message, Throwable cause) {
        super(message, cause);
    }",method,
"public class ClassPathFactoryBeanDefinitionScannerTests {
	private static final String BASE_PACKAGE = FactoryMethodComponent.class.getPackage().getName();
	@Test
	public void testSingletonScopedFactoryMethod() {
		GenericApplicationContext context = new GenericApplicationContext();
		ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(context);
		context.getBeanFactory().registerScope(""request"", new SimpleMapScope());
		scanner.scan(BASE_PACKAGE);
		context.registerBeanDefinition(""clientBean"", new RootBeanDefinition(QualifiedClientBean.class));
		context.refresh();
		FactoryMethodComponent fmc = context.getBean(""factoryMethodComponent"", FactoryMethodComponent.class);
		assertFalse(fmc.getClass().getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR));
		TestBean tb = (TestBean) context.getBean(""publicInstance""); //2
		assertEquals(""publicInstance"", tb.getName());
		TestBean tb2 = (TestBean) context.getBean(""publicInstance""); //2
		assertEquals(""publicInstance"", tb2.getName());
		assertSame(tb2, tb);
		tb = (TestBean) context.getBean(""protectedInstance""); //3
		assertEquals(""protectedInstance"", tb.getName());
		assertSame(tb, context.getBean(""protectedInstance""));
		assertEquals(""0"", tb.getCountry());
		tb2 = context.getBean(""protectedInstance"", TestBean.class); //3
		assertEquals(""protectedInstance"", tb2.getName());
		assertSame(tb2, tb);
		tb = context.getBean(""privateInstance"", TestBean.class); //4
		assertEquals(""privateInstance"", tb.getName());
		assertEquals(1, tb.getAge());
		tb2 = context.getBean(""privateInstance"", TestBean.class); //4
		assertEquals(2, tb2.getAge());
		assertNotSame(tb2, tb);
		Object bean = context.getBean(""requestScopedInstance""); //5
		assertTrue(AopUtils.isCglibProxy(bean));
		assertTrue(bean instanceof ScopedObject);
		QualifiedClientBean clientBean = context.getBean(""clientBean"", QualifiedClientBean.class);
		assertSame(context.getBean(""publicInstance""), clientBean.testBean);
		assertSame(context.getBean(""dependencyBean""), clientBean.dependencyBean);
		assertSame(context, clientBean.applicationContext);
	}
	public static class QualifiedClientBean {
		@Autowired @Qualifier(""public"")
		public TestBean testBean;
		@Autowired
		public DependencyBean dependencyBean;
		@Autowired
		AbstractApplicationContext applicationContext;
	}
}",class,
"	public static class QualifiedClientBean {
		@Autowired @Qualifier(""public"")
		public TestBean testBean;
		@Autowired
		public DependencyBean dependencyBean;
		@Autowired
		AbstractApplicationContext applicationContext;
	}",class,
"	@Test
	public void testSingletonScopedFactoryMethod() {
		GenericApplicationContext context = new GenericApplicationContext();
		ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(context);
		context.getBeanFactory().registerScope(""request"", new SimpleMapScope());
		scanner.scan(BASE_PACKAGE);
		context.registerBeanDefinition(""clientBean"", new RootBeanDefinition(QualifiedClientBean.class));
		context.refresh();
		FactoryMethodComponent fmc = context.getBean(""factoryMethodComponent"", FactoryMethodComponent.class);
		assertFalse(fmc.getClass().getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR));
		TestBean tb = (TestBean) context.getBean(""publicInstance""); //2
		assertEquals(""publicInstance"", tb.getName());
		TestBean tb2 = (TestBean) context.getBean(""publicInstance""); //2
		assertEquals(""publicInstance"", tb2.getName());
		assertSame(tb2, tb);
		tb = (TestBean) context.getBean(""protectedInstance""); //3
		assertEquals(""protectedInstance"", tb.getName());
		assertSame(tb, context.getBean(""protectedInstance""));
		assertEquals(""0"", tb.getCountry());
		tb2 = context.getBean(""protectedInstance"", TestBean.class); //3
		assertEquals(""protectedInstance"", tb2.getName());
		assertSame(tb2, tb);
		tb = context.getBean(""privateInstance"", TestBean.class); //4
		assertEquals(""privateInstance"", tb.getName());
		assertEquals(1, tb.getAge());
		tb2 = context.getBean(""privateInstance"", TestBean.class); //4
		assertEquals(2, tb2.getAge());
		assertNotSame(tb2, tb);
		Object bean = context.getBean(""requestScopedInstance""); //5
		assertTrue(AopUtils.isCglibProxy(bean));
		assertTrue(bean instanceof ScopedObject);
		QualifiedClientBean clientBean = context.getBean(""clientBean"", QualifiedClientBean.class);
		assertSame(context.getBean(""publicInstance""), clientBean.testBean);
		assertSame(context.getBean(""dependencyBean""), clientBean.dependencyBean);
		assertSame(context, clientBean.applicationContext);
	}",method,
"public class RenameProjectCommand extends Command {
    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        try {
            String name = request.getParameter(""name"");
            ProjectMetadata pm = getProjectMetadata(request);
            pm.setName(name);
            respond(response, ""{ \""code\"" : \""ok\"" }"");
        } catch (Exception e) {
            respondException(response, e);
        }
    }
}",class,
"    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        try {
            String name = request.getParameter(""name"");
            ProjectMetadata pm = getProjectMetadata(request);
            pm.setName(name);
            respond(response, ""{ \""code\"" : \""ok\"" }"");
        } catch (Exception e) {
            respondException(response, e);
        }
    }",method,
"public class IdeaProjectModelModifier extends JavaProjectModelModifier {
  private static final Logger LOG = Logger.getInstance(IdeaProjectModelModifier.class);
  private final Project myProject;
  public IdeaProjectModelModifier(Project project) {
    myProject = project;
  }
  @Override
  public Promise<Void> addModuleDependency(@NotNull Module from, @NotNull Module to, @NotNull DependencyScope scope, boolean exported) {
    ModuleRootModificationUtil.addDependency(from, to, scope, exported);
    return Promises.resolvedPromise(null);
  }
  @Override
  public Promise<Void> addLibraryDependency(@NotNull Module from, @NotNull Library library, @NotNull DependencyScope scope, boolean exported) {
    OrderEntryUtil.addLibraryToRoots(from, library, scope, exported);
    return Promises.resolvedPromise(null);
  }
  @Override
  public Promise<Void> addExternalLibraryDependency(@NotNull final Collection<Module> modules,
                                                    @NotNull final ExternalLibraryDescriptor descriptor,
                                                    @NotNull final DependencyScope scope) {
    List<String> defaultRoots = descriptor.getLibraryClassesRoots();
    List<String> classesRoots;
    Module firstModule = ContainerUtil.getFirstItem(modules);
    if (!defaultRoots.isEmpty()) {
      LOG.assertTrue(firstModule != null);
      classesRoots = new LocateLibraryDialog(firstModule, defaultRoots, descriptor.getPresentableName()).showAndGetResult();
    }
    else {
      String version = descriptor.getMinVersion();
      String mavenCoordinates = descriptor.getLibraryGroupId() + "":"" +
                                descriptor.getLibraryArtifactId() +
                                (version != null ? "":"" + version : """");
      RepositoryAttachDialog dialog = new RepositoryAttachDialog(myProject, mavenCoordinates, RepositoryAttachDialog.Mode.DOWNLOAD);
      if (!dialog.showAndGet()) {
        return Promises.rejectedPromise();
      }
      RepositoryLibraryProperties libraryProperties = new RepositoryLibraryProperties(dialog.getCoordinateText(), true);
      Collection<OrderRoot> roots =
        JarRepositoryManager.loadDependenciesModal(myProject, libraryProperties, dialog.getAttachSources(), dialog.getAttachJavaDoc(), null, null);
      if (roots.isEmpty()) {
        Messages.showErrorDialog(myProject, descriptor.getPresentableName() + "" was not loaded."", ""Failed to Download Library"");
        return Promises.rejectedPromise();
      }
      classesRoots = roots.stream()
        .filter(root -> root.getType() == OrderRootType.CLASSES)
        .map(root -> PathUtil.getLocalPath(root.getFile()))
        .collect(Collectors.toList());
    }
    if (!classesRoots.isEmpty()) {
      String libraryName = classesRoots.size() > 1 ? descriptor.getPresentableName() : null;
      final List<String> urls = OrderEntryFix.refreshAndConvertToUrls(classesRoots);
      if (modules.size() == 1) {
        ModuleRootModificationUtil.addModuleLibrary(firstModule, libraryName, urls, Collections.emptyList(), scope);
      }
      else {
        new WriteAction() {
          protected void run(@NotNull Result result) {
            Library library =
              LibraryUtil.createLibrary(LibraryTablesRegistrar.getInstance().getLibraryTable(myProject), descriptor.getPresentableName());
            Library.ModifiableModel model = library.getModifiableModel();
            for (String url : urls) {
              model.addRoot(url, OrderRootType.CLASSES);
            }
            model.commit();
            for (Module module : modules) {
              ModuleRootModificationUtil.addDependency(module, library, scope, false);
            }
          }
        }.execute();
      }
    }
    return Promises.resolvedPromise(null);
  }
  @Override
  public Promise<Void> changeLanguageLevel(@NotNull Module module, @NotNull LanguageLevel level) {
    final LanguageLevel moduleLevel = LanguageLevelModuleExtensionImpl.getInstance(module).getLanguageLevel();
    if (moduleLevel != null && JavaSdkUtil.isLanguageLevelAcceptable(myProject, module, level)) {
      final ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();
      rootModel.getModuleExtension(LanguageLevelModuleExtension.class).setLanguageLevel(level);
      rootModel.commit();
    }
    else {
      LanguageLevelProjectExtension.getInstance(myProject).setLanguageLevel(level);
      ProjectRootManagerEx.getInstanceEx(myProject).makeRootsChange(EmptyRunnable.INSTANCE, false, true);
    }
    return Promises.resolvedPromise(null);
  }
}",class,
"  public IdeaProjectModelModifier(Project project) {
    myProject = project;
  }",method,
"  @Override
  public Promise<Void> addModuleDependency(@NotNull Module from, @NotNull Module to, @NotNull DependencyScope scope, boolean exported) {
    ModuleRootModificationUtil.addDependency(from, to, scope, exported);
    return Promises.resolvedPromise(null);
  }",method,
"  @Override
  public Promise<Void> addLibraryDependency(@NotNull Module from, @NotNull Library library, @NotNull DependencyScope scope, boolean exported) {
    OrderEntryUtil.addLibraryToRoots(from, library, scope, exported);
    return Promises.resolvedPromise(null);
  }",method,
"  @Override
  public Promise<Void> addExternalLibraryDependency(@NotNull final Collection<Module> modules,
                                                    @NotNull final ExternalLibraryDescriptor descriptor,
                                                    @NotNull final DependencyScope scope) {
    List<String> defaultRoots = descriptor.getLibraryClassesRoots();
    List<String> classesRoots;
    Module firstModule = ContainerUtil.getFirstItem(modules);
    if (!defaultRoots.isEmpty()) {
      LOG.assertTrue(firstModule != null);
      classesRoots = new LocateLibraryDialog(firstModule, defaultRoots, descriptor.getPresentableName()).showAndGetResult();
    }
    else {
      String version = descriptor.getMinVersion();
      String mavenCoordinates = descriptor.getLibraryGroupId() + "":"" +
                                descriptor.getLibraryArtifactId() +
                                (version != null ? "":"" + version : """");
      RepositoryAttachDialog dialog = new RepositoryAttachDialog(myProject, mavenCoordinates, RepositoryAttachDialog.Mode.DOWNLOAD);
      if (!dialog.showAndGet()) {
        return Promises.rejectedPromise();
      }
      RepositoryLibraryProperties libraryProperties = new RepositoryLibraryProperties(dialog.getCoordinateText(), true);
      Collection<OrderRoot> roots =
        JarRepositoryManager.loadDependenciesModal(myProject, libraryProperties, dialog.getAttachSources(), dialog.getAttachJavaDoc(), null, null);
      if (roots.isEmpty()) {
        Messages.showErrorDialog(myProject, descriptor.getPresentableName() + "" was not loaded."", ""Failed to Download Library"");
        return Promises.rejectedPromise();
      }
      classesRoots = roots.stream()
        .filter(root -> root.getType() == OrderRootType.CLASSES)
        .map(root -> PathUtil.getLocalPath(root.getFile()))
        .collect(Collectors.toList());
    }
    if (!classesRoots.isEmpty()) {
      String libraryName = classesRoots.size() > 1 ? descriptor.getPresentableName() : null;
      final List<String> urls = OrderEntryFix.refreshAndConvertToUrls(classesRoots);
      if (modules.size() == 1) {
        ModuleRootModificationUtil.addModuleLibrary(firstModule, libraryName, urls, Collections.emptyList(), scope);
      }
      else {
        new WriteAction() {
          protected void run(@NotNull Result result) {
            Library library =
              LibraryUtil.createLibrary(LibraryTablesRegistrar.getInstance().getLibraryTable(myProject), descriptor.getPresentableName());
            Library.ModifiableModel model = library.getModifiableModel();
            for (String url : urls) {
              model.addRoot(url, OrderRootType.CLASSES);
            }
            model.commit();
            for (Module module : modules) {
              ModuleRootModificationUtil.addDependency(module, library, scope, false);
            }
          }
        }.execute();
      }
    }
    return Promises.resolvedPromise(null);
  }",method,
"        new WriteAction() {
          protected void run(@NotNull Result result) {
            Library library =
              LibraryUtil.createLibrary(LibraryTablesRegistrar.getInstance().getLibraryTable(myProject), descriptor.getPresentableName());
            Library.ModifiableModel model = library.getModifiableModel();
            for (String url : urls) {
              model.addRoot(url, OrderRootType.CLASSES);
            }
            model.commit();
            for (Module module : modules) {
              ModuleRootModificationUtil.addDependency(module, library, scope, false);
            }
          }
        }",method,
"          protected void run(@NotNull Result result) {
            Library library =
              LibraryUtil.createLibrary(LibraryTablesRegistrar.getInstance().getLibraryTable(myProject), descriptor.getPresentableName());
            Library.ModifiableModel model = library.getModifiableModel();
            for (String url : urls) {
              model.addRoot(url, OrderRootType.CLASSES);
            }
            model.commit();
            for (Module module : modules) {
              ModuleRootModificationUtil.addDependency(module, library, scope, false);
            }
          }",method,
"            for (String url : urls) {
              model.addRoot(url, OrderRootType.CLASSES);
            }",method,
"            for (Module module : modules) {
              ModuleRootModificationUtil.addDependency(module, library, scope, false);
            }",method,
"  @Override
  public Promise<Void> changeLanguageLevel(@NotNull Module module, @NotNull LanguageLevel level) {
    final LanguageLevel moduleLevel = LanguageLevelModuleExtensionImpl.getInstance(module).getLanguageLevel();
    if (moduleLevel != null && JavaSdkUtil.isLanguageLevelAcceptable(myProject, module, level)) {
      final ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();
      rootModel.getModuleExtension(LanguageLevelModuleExtension.class).setLanguageLevel(level);
      rootModel.commit();
    }
    else {
      LanguageLevelProjectExtension.getInstance(myProject).setLanguageLevel(level);
      ProjectRootManagerEx.getInstanceEx(myProject).makeRootsChange(EmptyRunnable.INSTANCE, false, true);
    }
    return Promises.resolvedPromise(null);
  }",method,
"public class StreamsMetadata {
    public final static StreamsMetadata NOT_AVAILABLE = new StreamsMetadata(new HostInfo(""unavailable"", -1),
                                                                            Collections.<String>emptySet(),
                                                                            Collections.<TopicPartition>emptySet());
    private final HostInfo hostInfo;
    private final Set<String> stateStoreNames;
    private final Set<TopicPartition> topicPartitions;
    public StreamsMetadata(final HostInfo hostInfo,
                           final Set<String> stateStoreNames,
                           final Set<TopicPartition> topicPartitions) {
        this.hostInfo = hostInfo;
        this.stateStoreNames = stateStoreNames;
        this.topicPartitions = topicPartitions;
    }
    public HostInfo hostInfo() {
        return hostInfo;
    }
    public Set<String> stateStoreNames() {
        return stateStoreNames;
    }
    public Set<TopicPartition> topicPartitions() {
        return topicPartitions;
    }
    public String host() {
        return hostInfo.host();
    }
    public int port() {
        return hostInfo.port();
    }
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final StreamsMetadata that = (StreamsMetadata) o;
        if (!hostInfo.equals(that.hostInfo)) return false;
        if (!stateStoreNames.equals(that.stateStoreNames)) return false;
        return topicPartitions.equals(that.topicPartitions);
    }
    @Override
    public int hashCode() {
        int result = hostInfo.hashCode();
        result = 31 * result + stateStoreNames.hashCode();
        result = 31 * result + topicPartitions.hashCode();
        return result;
    }
    @Override
    public String toString() {
        return ""StreamsMetadata{"" +
                ""hostInfo="" + hostInfo +
                "", stateStoreNames="" + stateStoreNames +
                "", topicPartitions="" + topicPartitions +
                '}';
    }
}",class,
"    public StreamsMetadata(final HostInfo hostInfo,
                           final Set<String> stateStoreNames,
                           final Set<TopicPartition> topicPartitions) {
        this.hostInfo = hostInfo;
        this.stateStoreNames = stateStoreNames;
        this.topicPartitions = topicPartitions;
    }",method,
"    public HostInfo hostInfo() {
        return hostInfo;
    }",method,
"    public Set<String> stateStoreNames() {
        return stateStoreNames;
    }",method,
"    public Set<TopicPartition> topicPartitions() {
        return topicPartitions;
    }",method,
"    public String host() {
        return hostInfo.host();
    }",method,
"    public int port() {
        return hostInfo.port();
    }",method,
"    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final StreamsMetadata that = (StreamsMetadata) o;
        if (!hostInfo.equals(that.hostInfo)) return false;
        if (!stateStoreNames.equals(that.stateStoreNames)) return false;
        return topicPartitions.equals(that.topicPartitions);
    }",method,
"    @Override
    public int hashCode() {
        int result = hostInfo.hashCode();
        result = 31 * result + stateStoreNames.hashCode();
        result = 31 * result + topicPartitions.hashCode();
        return result;
    }",method,
"    @Override
    public String toString() {
        return ""StreamsMetadata{"" +
                ""hostInfo="" + hostInfo +
                "", stateStoreNames="" + stateStoreNames +
                "", topicPartitions="" + topicPartitions +
                '}';
    }",method,
"public class ImmutableAuthor implements Serializable {
  protected final int id;
  protected final String username;
  protected final String password;
  protected final String email;
  protected final String bio;
  protected final Section favouriteSection;
  public ImmutableAuthor(int id, String username, String password, String email, String bio, Section section) {
    this.id = id;
    this.username = username;
    this.password = password;
    this.email = email;
    this.bio = bio;
    this.favouriteSection = section;
  }
  public int getId() {
    return id;
  }
  public String getUsername() {
    return username;
  }
  public String getPassword() {
    return password;
  }
  public String getEmail() {
    return email;
  }
  public String getBio() {
    return bio;
  }
  public Section getFavouriteSection() {
    return favouriteSection;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Author)) return false;
    Author author = (Author) o;
    if (id != author.id) return false;
    if (bio != null ? !bio.equals(author.bio) : author.bio != null) return false;
    if (email != null ? !email.equals(author.email) : author.email != null) return false;
    if (password != null ? !password.equals(author.password) : author.password != null) return false;
    if (username != null ? !username.equals(author.username) : author.username != null) return false;
    if (favouriteSection != null ? !favouriteSection.equals(author.favouriteSection) : author.favouriteSection != null)
      return false;
    return true;
  }
  @Override
  public int hashCode() {
    int result;
    result = id;
    result = 31 * result + (username != null ? username.hashCode() : 0);
    result = 31 * result + (password != null ? password.hashCode() : 0);
    result = 31 * result + (email != null ? email.hashCode() : 0);
    result = 31 * result + (bio != null ? bio.hashCode() : 0);
    result = 31 * result + (favouriteSection != null ? favouriteSection.hashCode() : 0);
    return result;
  }
  @Override
  public String toString() {
    return id + "" "" + username + "" "" + password + "" "" + email;
  }
}",class,
"  public ImmutableAuthor(int id, String username, String password, String email, String bio, Section section) {
    this.id = id;
    this.username = username;
    this.password = password;
    this.email = email;
    this.bio = bio;
    this.favouriteSection = section;
  }",method,
"  public int getId() {
    return id;
  }",method,
"  public String getUsername() {
    return username;
  }",method,
"  public String getPassword() {
    return password;
  }",method,
"  public String getEmail() {
    return email;
  }",method,
"  public String getBio() {
    return bio;
  }",method,
"  public Section getFavouriteSection() {
    return favouriteSection;
  }",method,
"  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Author)) return false;
    Author author = (Author) o;
    if (id != author.id) return false;
    if (bio != null ? !bio.equals(author.bio) : author.bio != null) return false;
    if (email != null ? !email.equals(author.email) : author.email != null) return false;
    if (password != null ? !password.equals(author.password) : author.password != null) return false;
    if (username != null ? !username.equals(author.username) : author.username != null) return false;
    if (favouriteSection != null ? !favouriteSection.equals(author.favouriteSection) : author.favouriteSection != null)
      return false;
    return true;
  }",method,
"  @Override
  public int hashCode() {
    int result;
    result = id;
    result = 31 * result + (username != null ? username.hashCode() : 0);
    result = 31 * result + (password != null ? password.hashCode() : 0);
    result = 31 * result + (email != null ? email.hashCode() : 0);
    result = 31 * result + (bio != null ? bio.hashCode() : 0);
    result = 31 * result + (favouriteSection != null ? favouriteSection.hashCode() : 0);
    return result;
  }",method,
"  @Override
  public String toString() {
    return id + "" "" + username + "" "" + password + "" "" + email;
  }",method,
"public final class SpeedSearchUtil {
  private SpeedSearchUtil() {
  }
  public static void applySpeedSearchHighlighting(@NotNull JComponent speedSearchEnabledComponent,
                                                  @NotNull SimpleColoredComponent coloredComponent,
                                                  boolean mainTextOnly,
                                                  boolean selected) {
    SpeedSearchSupply speedSearch = SpeedSearchSupply.getSupply(speedSearchEnabledComponent);
    // The bad thing is that SpeedSearch model is decoupled from UI presentation so we don't know the real matched text.
    // Our best guess is to get string from the ColoredComponent. We can only provide main-text-only option.
    Iterable<TextRange> ranges = speedSearch == null ? null : speedSearch.matchingFragments(coloredComponent.getCharSequence(mainTextOnly).toString());
    Iterator<TextRange> rangesIterator = ranges != null ? ranges.iterator() : null;
    if (rangesIterator == null || !rangesIterator.hasNext()) return;
    Color bg = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();
    SimpleColoredComponent.ColoredIterator coloredIterator = coloredComponent.iterator();
    TextRange range = rangesIterator.next();
    main: while (coloredIterator.hasNext()) {
      coloredIterator.next();
      int offset = coloredIterator.getOffset();
      int endOffset = coloredIterator.getEndOffset();
      if (!range.intersectsStrict(offset, endOffset)) continue;
      SimpleTextAttributes attributes = coloredIterator.getTextAttributes();
      SimpleTextAttributes highlighted = new SimpleTextAttributes(bg, attributes.getFgColor(), null, attributes.getStyle() | SimpleTextAttributes.STYLE_SEARCH_MATCH);
      do {
        if (range.getStartOffset() > offset) {
          offset = coloredIterator.split(range.getStartOffset() - offset, attributes);
        }
        if (range.getEndOffset() <= endOffset) {
          offset = coloredIterator.split(range.getEndOffset() - offset, highlighted);
          if (rangesIterator.hasNext()) {
            range = rangesIterator.next();
          }
          else {
            break main;
          }
        }
        else {
          coloredIterator.split(endOffset - offset, highlighted);
          continue main;
        }
      }
      while (range.intersectsStrict(offset, endOffset));
    }
  }
  public static void appendFragmentsForSpeedSearch(@NotNull JComponent speedSearchEnabledComponent,
                                                   @NotNull String text,
                                                   @NotNull SimpleTextAttributes attributes,
                                                   boolean selected,
                                                   @NotNull SimpleColoredComponent simpleColoredComponent) {
    final SpeedSearchSupply speedSearch = SpeedSearchSupply.getSupply(speedSearchEnabledComponent);
    if (speedSearch != null) {
      final Iterable<TextRange> fragments = speedSearch.matchingFragments(text);
      if (fragments != null) {
        final Color fg = attributes.getFgColor();
        final Color bg = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();
        final int style = attributes.getStyle();
        final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);
        final SimpleTextAttributes highlighted = new SimpleTextAttributes(bg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);
        appendColoredFragments(simpleColoredComponent, text, fragments, plain, highlighted);
        return;
      }
    }
    simpleColoredComponent.append(text, attributes);
  }
  public static void appendColoredFragmentForMatcher(@NotNull String text,
                                                     SimpleColoredComponent component,
                                                     @NotNull final SimpleTextAttributes attributes,
                                                     @Nullable Matcher matcher,
                                                     Color selectedBg,
                                                     boolean selected) {
    if (!(matcher instanceof MinusculeMatcher) || (Registry.is(""ide.highlight.match.in.selected.only"") && !selected)) {
      component.append(text, attributes);
      return;
    }
    final Iterable<TextRange> iterable = ((MinusculeMatcher)matcher).matchingFragments(text);
    if (iterable != null) {
      final Color fg = attributes.getFgColor();
      final int style = attributes.getStyle();
      final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);
      final SimpleTextAttributes highlighted = new SimpleTextAttributes(selectedBg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);
      appendColoredFragments(component, text, iterable, plain, highlighted);
    }
    else {
      component.append(text, attributes);
    }
  }
  public static void appendColoredFragments(final SimpleColoredComponent simpleColoredComponent,
                                            final String text,
                                            Iterable<TextRange> colored,
                                            final SimpleTextAttributes plain, final SimpleTextAttributes highlighted) {
    final List<Pair<String, Integer>> searchTerms = new ArrayList<>();
    for (TextRange fragment : colored) {
      searchTerms.add(Pair.create(fragment.substring(text), fragment.getStartOffset()));
    }
    int lastOffset = 0;
    for (Pair<String, Integer> pair : searchTerms) {
      if (pair.second > lastOffset) {
        simpleColoredComponent.append(text.substring(lastOffset, pair.second), plain);
      }
      simpleColoredComponent.append(text.substring(pair.second, pair.second + pair.first.length()), highlighted);
      lastOffset = pair.second + pair.first.length();
    }
    if (lastOffset < text.length()) {
      simpleColoredComponent.append(text.substring(lastOffset), plain);
    }
  }
}",class,
"  private SpeedSearchUtil() {
  }",method,
"  public static void applySpeedSearchHighlighting(@NotNull JComponent speedSearchEnabledComponent,
                                                  @NotNull SimpleColoredComponent coloredComponent,
                                                  boolean mainTextOnly,
                                                  boolean selected) {
    SpeedSearchSupply speedSearch = SpeedSearchSupply.getSupply(speedSearchEnabledComponent);
    // The bad thing is that SpeedSearch model is decoupled from UI presentation so we don't know the real matched text.
    // Our best guess is to get string from the ColoredComponent. We can only provide main-text-only option.
    Iterable<TextRange> ranges = speedSearch == null ? null : speedSearch.matchingFragments(coloredComponent.getCharSequence(mainTextOnly).toString());
    Iterator<TextRange> rangesIterator = ranges != null ? ranges.iterator() : null;
    if (rangesIterator == null || !rangesIterator.hasNext()) return;
    Color bg = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();
    SimpleColoredComponent.ColoredIterator coloredIterator = coloredComponent.iterator();
    TextRange range = rangesIterator.next();
    main: while (coloredIterator.hasNext()) {
      coloredIterator.next();
      int offset = coloredIterator.getOffset();
      int endOffset = coloredIterator.getEndOffset();
      if (!range.intersectsStrict(offset, endOffset)) continue;
      SimpleTextAttributes attributes = coloredIterator.getTextAttributes();
      SimpleTextAttributes highlighted = new SimpleTextAttributes(bg, attributes.getFgColor(), null, attributes.getStyle() | SimpleTextAttributes.STYLE_SEARCH_MATCH);
      do {
        if (range.getStartOffset() > offset) {
          offset = coloredIterator.split(range.getStartOffset() - offset, attributes);
        }
        if (range.getEndOffset() <= endOffset) {
          offset = coloredIterator.split(range.getEndOffset() - offset, highlighted);
          if (rangesIterator.hasNext()) {
            range = rangesIterator.next();
          }
          else {
            break main;
          }
        }
        else {
          coloredIterator.split(endOffset - offset, highlighted);
          continue main;
        }
      }
      while (range.intersectsStrict(offset, endOffset));
    }
  }",method,
"  public static void appendFragmentsForSpeedSearch(@NotNull JComponent speedSearchEnabledComponent,
                                                   @NotNull String text,
                                                   @NotNull SimpleTextAttributes attributes,
                                                   boolean selected,
                                                   @NotNull SimpleColoredComponent simpleColoredComponent) {
    final SpeedSearchSupply speedSearch = SpeedSearchSupply.getSupply(speedSearchEnabledComponent);
    if (speedSearch != null) {
      final Iterable<TextRange> fragments = speedSearch.matchingFragments(text);
      if (fragments != null) {
        final Color fg = attributes.getFgColor();
        final Color bg = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();
        final int style = attributes.getStyle();
        final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);
        final SimpleTextAttributes highlighted = new SimpleTextAttributes(bg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);
        appendColoredFragments(simpleColoredComponent, text, fragments, plain, highlighted);
        return;
      }
    }
    simpleColoredComponent.append(text, attributes);
  }",method,
"    if (speedSearch != null) {
      final Iterable<TextRange> fragments = speedSearch.matchingFragments(text);
      if (fragments != null) {
        final Color fg = attributes.getFgColor();
        final Color bg = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();
        final int style = attributes.getStyle();
        final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);
        final SimpleTextAttributes highlighted = new SimpleTextAttributes(bg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);
        appendColoredFragments(simpleColoredComponent, text, fragments, plain, highlighted);
        return;
      }
    }",method,
"      if (fragments != null) {
        final Color fg = attributes.getFgColor();
        final Color bg = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();
        final int style = attributes.getStyle();
        final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);
        final SimpleTextAttributes highlighted = new SimpleTextAttributes(bg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);
        appendColoredFragments(simpleColoredComponent, text, fragments, plain, highlighted);
        return;
      }",method,
"  public static void appendColoredFragmentForMatcher(@NotNull String text,
                                                     SimpleColoredComponent component,
                                                     @NotNull final SimpleTextAttributes attributes,
                                                     @Nullable Matcher matcher,
                                                     Color selectedBg,
                                                     boolean selected) {
    if (!(matcher instanceof MinusculeMatcher) || (Registry.is(""ide.highlight.match.in.selected.only"") && !selected)) {
      component.append(text, attributes);
      return;
    }
    final Iterable<TextRange> iterable = ((MinusculeMatcher)matcher).matchingFragments(text);
    if (iterable != null) {
      final Color fg = attributes.getFgColor();
      final int style = attributes.getStyle();
      final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);
      final SimpleTextAttributes highlighted = new SimpleTextAttributes(selectedBg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);
      appendColoredFragments(component, text, iterable, plain, highlighted);
    }
    else {
      component.append(text, attributes);
    }
  }",method,
"    if (iterable != null) {
      final Color fg = attributes.getFgColor();
      final int style = attributes.getStyle();
      final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);
      final SimpleTextAttributes highlighted = new SimpleTextAttributes(selectedBg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);
      appendColoredFragments(component, text, iterable, plain, highlighted);
    }",method,
"  public static void appendColoredFragments(final SimpleColoredComponent simpleColoredComponent,
                                            final String text,
                                            Iterable<TextRange> colored,
                                            final SimpleTextAttributes plain, final SimpleTextAttributes highlighted) {
    final List<Pair<String, Integer>> searchTerms = new ArrayList<>();
    for (TextRange fragment : colored) {
      searchTerms.add(Pair.create(fragment.substring(text), fragment.getStartOffset()));
    }
    int lastOffset = 0;
    for (Pair<String, Integer> pair : searchTerms) {
      if (pair.second > lastOffset) {
        simpleColoredComponent.append(text.substring(lastOffset, pair.second), plain);
      }
      simpleColoredComponent.append(text.substring(pair.second, pair.second + pair.first.length()), highlighted);
      lastOffset = pair.second + pair.first.length();
    }
    if (lastOffset < text.length()) {
      simpleColoredComponent.append(text.substring(lastOffset), plain);
    }
  }",method,
"    for (TextRange fragment : colored) {
      searchTerms.add(Pair.create(fragment.substring(text), fragment.getStartOffset()));
    }",method,
"    for (Pair<String, Integer> pair : searchTerms) {
      if (pair.second > lastOffset) {
        simpleColoredComponent.append(text.substring(lastOffset, pair.second), plain);
      }
      simpleColoredComponent.append(text.substring(pair.second, pair.second + pair.first.length()), highlighted);
      lastOffset = pair.second + pair.first.length();
    }",method,
"      if (pair.second > lastOffset) {
        simpleColoredComponent.append(text.substring(lastOffset, pair.second), plain);
      }",method,
"public class LocalFileDependencyBackedArtifactSet implements ResolvedArtifactSet {
    private final LocalFileDependencyMetadata dependencyMetadata;
    private final Spec<? super ComponentIdentifier> componentFilter;
    private final VariantSelector selector;
    private final ArtifactTypeRegistry artifactTypeRegistry;
    public LocalFileDependencyBackedArtifactSet(LocalFileDependencyMetadata dependencyMetadata, Spec<? super ComponentIdentifier> componentFilter, VariantSelector selector, ArtifactTypeRegistry artifactTypeRegistry) {
        this.dependencyMetadata = dependencyMetadata;
        this.componentFilter = componentFilter;
        this.selector = selector;
        this.artifactTypeRegistry = artifactTypeRegistry;
    }
    @Override
    public Completion startVisit(BuildOperationQueue<RunnableBuildOperation> actions, AsyncArtifactListener listener) {
        if (!listener.includeFileDependencies()) {
            return EMPTY_RESULT;
        }
        ComponentIdentifier componentIdentifier = dependencyMetadata.getComponentId();
        if (componentIdentifier != null && !componentFilter.isSatisfiedBy(componentIdentifier)) {
            return EMPTY_RESULT;
        }
        Set<File> files;
        try {
            files = dependencyMetadata.getFiles().getFiles();
        } catch (Throwable throwable) {
            return new BrokenResolvedArtifactSet(throwable);
        }
        List<ResolvedArtifactSet> selectedArtifacts = Lists.newArrayListWithCapacity(files.size());
        for (File file : files) {
            ComponentArtifactIdentifier artifactIdentifier;
            if (componentIdentifier == null) {
                artifactIdentifier = new OpaqueComponentArtifactIdentifier(file);
                if (!componentFilter.isSatisfiedBy(artifactIdentifier.getComponentIdentifier())) {
                    continue;
                }
            } else {
                artifactIdentifier = new ComponentFileArtifactIdentifier(componentIdentifier, file.getName());
            }
            AttributeContainerInternal variantAttributes = artifactTypeRegistry.mapAttributesFor(file);
            SingletonFileResolvedVariant variant = new SingletonFileResolvedVariant(file, artifactIdentifier, variantAttributes, dependencyMetadata);
            selectedArtifacts.add(selector.select(variant));
        }
        return CompositeResolvedArtifactSet.of(selectedArtifacts).startVisit(actions, listener);
    }
    @Override
    public void collectBuildDependencies(BuildDependenciesVisitor visitor) {
        visitor.visitDependency(dependencyMetadata.getFiles().getBuildDependencies());
    }
    private static class SingletonFileResolvedVariant implements ResolvedVariant, ResolvedArtifactSet, Completion, ResolvedVariantSet {
        private final File file;
        private final ComponentArtifactIdentifier artifactIdentifier;
        private final AttributeContainerInternal variantAttributes;
        private final LocalFileDependencyMetadata dependencyMetadata;
        SingletonFileResolvedVariant(File file, ComponentArtifactIdentifier artifactIdentifier, AttributeContainerInternal variantAttributes, LocalFileDependencyMetadata dependencyMetadata) {
            this.file = file;
            this.artifactIdentifier = artifactIdentifier;
            this.variantAttributes = variantAttributes;
            this.dependencyMetadata = dependencyMetadata;
        }
        @Override
        public String toString() {
            return asDescribable().getDisplayName();
        }
        @Override
        public ResolvedArtifactSet getArtifacts() {
            return this;
        }
        @Override
        public DisplayName asDescribable() {
            return Describables.of(artifactIdentifier);
        }
        @Override
        public Set<ResolvedVariant> getVariants() {
            return Collections.<ResolvedVariant>singleton(this);
        }
        @Override
        public AttributesSchemaInternal getSchema() {
            return EmptySchema.INSTANCE;
        }
        @Override
        public Completion startVisit(BuildOperationQueue<RunnableBuildOperation> actions, AsyncArtifactListener listener) {
            if (listener.includeFileDependencies()) {
                listener.fileAvailable(file);
                return this;
            }
            return EMPTY_RESULT;
        }
        @Override
        public void visit(ArtifactVisitor visitor) {
            visitor.visitFile(artifactIdentifier, variantAttributes, file);
        }
        @Override
        public void collectBuildDependencies(BuildDependenciesVisitor visitor) {
            visitor.visitDependency(dependencyMetadata.getFiles().getBuildDependencies());
        }
        @Override
        public AttributeContainerInternal getAttributes() {
            return variantAttributes;
        }
    }
}",class,
"    private static class SingletonFileResolvedVariant implements ResolvedVariant, ResolvedArtifactSet, Completion, ResolvedVariantSet {
        private final File file;
        private final ComponentArtifactIdentifier artifactIdentifier;
        private final AttributeContainerInternal variantAttributes;
        private final LocalFileDependencyMetadata dependencyMetadata;
        SingletonFileResolvedVariant(File file, ComponentArtifactIdentifier artifactIdentifier, AttributeContainerInternal variantAttributes, LocalFileDependencyMetadata dependencyMetadata) {
            this.file = file;
            this.artifactIdentifier = artifactIdentifier;
            this.variantAttributes = variantAttributes;
            this.dependencyMetadata = dependencyMetadata;
        }
        @Override
        public String toString() {
            return asDescribable().getDisplayName();
        }
        @Override
        public ResolvedArtifactSet getArtifacts() {
            return this;
        }
        @Override
        public DisplayName asDescribable() {
            return Describables.of(artifactIdentifier);
        }
        @Override
        public Set<ResolvedVariant> getVariants() {
            return Collections.<ResolvedVariant>singleton(this);
        }
        @Override
        public AttributesSchemaInternal getSchema() {
            return EmptySchema.INSTANCE;
        }
        @Override
        public Completion startVisit(BuildOperationQueue<RunnableBuildOperation> actions, AsyncArtifactListener listener) {
            if (listener.includeFileDependencies()) {
                listener.fileAvailable(file);
                return this;
            }
            return EMPTY_RESULT;
        }
        @Override
        public void visit(ArtifactVisitor visitor) {
            visitor.visitFile(artifactIdentifier, variantAttributes, file);
        }
        @Override
        public void collectBuildDependencies(BuildDependenciesVisitor visitor) {
            visitor.visitDependency(dependencyMetadata.getFiles().getBuildDependencies());
        }
        @Override
        public AttributeContainerInternal getAttributes() {
            return variantAttributes;
        }
    }",class,
"    public LocalFileDependencyBackedArtifactSet(LocalFileDependencyMetadata dependencyMetadata, Spec<? super ComponentIdentifier> componentFilter, VariantSelector selector, ArtifactTypeRegistry artifactTypeRegistry) {
        this.dependencyMetadata = dependencyMetadata;
        this.componentFilter = componentFilter;
        this.selector = selector;
        this.artifactTypeRegistry = artifactTypeRegistry;
    }",method,
"    @Override
    public Completion startVisit(BuildOperationQueue<RunnableBuildOperation> actions, AsyncArtifactListener listener) {
        if (!listener.includeFileDependencies()) {
            return EMPTY_RESULT;
        }
        ComponentIdentifier componentIdentifier = dependencyMetadata.getComponentId();
        if (componentIdentifier != null && !componentFilter.isSatisfiedBy(componentIdentifier)) {
            return EMPTY_RESULT;
        }
        Set<File> files;
        try {
            files = dependencyMetadata.getFiles().getFiles();
        } catch (Throwable throwable) {
            return new BrokenResolvedArtifactSet(throwable);
        }
        List<ResolvedArtifactSet> selectedArtifacts = Lists.newArrayListWithCapacity(files.size());
        for (File file : files) {
            ComponentArtifactIdentifier artifactIdentifier;
            if (componentIdentifier == null) {
                artifactIdentifier = new OpaqueComponentArtifactIdentifier(file);
                if (!componentFilter.isSatisfiedBy(artifactIdentifier.getComponentIdentifier())) {
                    continue;
                }
            } else {
                artifactIdentifier = new ComponentFileArtifactIdentifier(componentIdentifier, file.getName());
            }
            AttributeContainerInternal variantAttributes = artifactTypeRegistry.mapAttributesFor(file);
            SingletonFileResolvedVariant variant = new SingletonFileResolvedVariant(file, artifactIdentifier, variantAttributes, dependencyMetadata);
            selectedArtifacts.add(selector.select(variant));
        }
        return CompositeResolvedArtifactSet.of(selectedArtifacts).startVisit(actions, listener);
    }",method,
"        for (File file : files) {
            ComponentArtifactIdentifier artifactIdentifier;
            if (componentIdentifier == null) {
                artifactIdentifier = new OpaqueComponentArtifactIdentifier(file);
                if (!componentFilter.isSatisfiedBy(artifactIdentifier.getComponentIdentifier())) {
                    continue;
                }
            } else {
                artifactIdentifier = new ComponentFileArtifactIdentifier(componentIdentifier, file.getName());
            }
            AttributeContainerInternal variantAttributes = artifactTypeRegistry.mapAttributesFor(file);
            SingletonFileResolvedVariant variant = new SingletonFileResolvedVariant(file, artifactIdentifier, variantAttributes, dependencyMetadata);
            selectedArtifacts.add(selector.select(variant));
        }",method,
"            if (componentIdentifier == null) {
                artifactIdentifier = new OpaqueComponentArtifactIdentifier(file);
                if (!componentFilter.isSatisfiedBy(artifactIdentifier.getComponentIdentifier())) {
                    continue;
                }
            }",method,
"    @Override
    public void collectBuildDependencies(BuildDependenciesVisitor visitor) {
        visitor.visitDependency(dependencyMetadata.getFiles().getBuildDependencies());
    }",method,
"        SingletonFileResolvedVariant(File file, ComponentArtifactIdentifier artifactIdentifier, AttributeContainerInternal variantAttributes, LocalFileDependencyMetadata dependencyMetadata) {
            this.file = file;
            this.artifactIdentifier = artifactIdentifier;
            this.variantAttributes = variantAttributes;
            this.dependencyMetadata = dependencyMetadata;
        }",method,
"        @Override
        public String toString() {
            return asDescribable().getDisplayName();
        }",method,
"        @Override
        public ResolvedArtifactSet getArtifacts() {
            return this;
        }",method,
"        @Override
        public DisplayName asDescribable() {
            return Describables.of(artifactIdentifier);
        }",method,
"        @Override
        public Set<ResolvedVariant> getVariants() {
            return Collections.<ResolvedVariant>singleton(this);
        }",method,
"        @Override
        public AttributesSchemaInternal getSchema() {
            return EmptySchema.INSTANCE;
        }",method,
"        @Override
        public Completion startVisit(BuildOperationQueue<RunnableBuildOperation> actions, AsyncArtifactListener listener) {
            if (listener.includeFileDependencies()) {
                listener.fileAvailable(file);
                return this;
            }
            return EMPTY_RESULT;
        }",method,
"        @Override
        public void visit(ArtifactVisitor visitor) {
            visitor.visitFile(artifactIdentifier, variantAttributes, file);
        }",method,
"        @Override
        public void collectBuildDependencies(BuildDependenciesVisitor visitor) {
            visitor.visitDependency(dependencyMetadata.getFiles().getBuildDependencies());
        }",method,
"        @Override
        public AttributeContainerInternal getAttributes() {
            return variantAttributes;
        }",method,
"public class Table<R, C, V> {
    private Map<R, Map<C, V>> table = new HashMap<>();
    public V put(R row, C column, V value) {
        Map<C, V> columns = table.get(row);
        if (columns == null) {
            columns = new HashMap<>();
            table.put(row, columns);
        }
        return columns.put(column, value);
    }
    public V get(R row, C column) {
        Map<C, V> columns = table.get(row);
        if (columns == null)
            return null;
        return columns.get(column);
    }
    public Map<C, V> remove(R row) {
        return table.remove(row);
    }
    public V remove(R row, C column) {
        Map<C, V> columns = table.get(row);
        if (columns == null)
            return null;
        V value = columns.remove(column);
        if (columns.isEmpty())
            table.remove(row);
        return value;
    }
    public Map<C, V> row(R row) {
        Map<C, V> columns = table.get(row);
        if (columns == null)
            return Collections.emptyMap();
        return Collections.unmodifiableMap(columns);
    }
}",class,
"    public V put(R row, C column, V value) {
        Map<C, V> columns = table.get(row);
        if (columns == null) {
            columns = new HashMap<>();
            table.put(row, columns);
        }
        return columns.put(column, value);
    }",method,
"        if (columns == null) {
            columns = new HashMap<>();
            table.put(row, columns);
        }",method,
"    public V get(R row, C column) {
        Map<C, V> columns = table.get(row);
        if (columns == null)
            return null;
        return columns.get(column);
    }",method,
"    public Map<C, V> remove(R row) {
        return table.remove(row);
    }",method,
"    public V remove(R row, C column) {
        Map<C, V> columns = table.get(row);
        if (columns == null)
            return null;
        V value = columns.remove(column);
        if (columns.isEmpty())
            table.remove(row);
        return value;
    }",method,
"    public Map<C, V> row(R row) {
        Map<C, V> columns = table.get(row);
        if (columns == null)
            return Collections.emptyMap();
        return Collections.unmodifiableMap(columns);
    }",method,
"public class NewsEventTextTest extends InstrumentationTestCase {
    private NewsListAdapter adapter;
    private TextView text;
    private User actor;
    private Repository repo;
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        actor = User.builder().login(""user"").build();
        repo = Repository.builder().name(""user/repo"").build();
        Context context = getInstrumentation().getTargetContext();
        adapter = new NewsListAdapter(LayoutInflater.from(context),
                new AvatarLoader(context));
    }
    private GitHubEvent createEvent(GitHubEventType type, GitHubPayload payload) {
        return GitHubEvent.builder()
                .createdAt(new Date())
                .type(type)
                .payload(payload)
                .actor(actor)
                .repo(repo)
                .build();
    }
    private void verify(String expected) {
        CharSequence actual = text.getText();
        assertNotNull(actual);
        assertEquals(expected, actual.toString());
    }
    private void updateView(GitHubEvent event) {
        adapter.setItems(new Object[] { event });
        View view = adapter.getView(0, null, null);
        assertNotNull(view);
        text = (TextView) view.findViewById(id.tv_event);
        assertNotNull(text);
    }
    @UiThreadTest
    public void testCommitCommentEvent() {
        GitHubEvent event = createEvent(GitHubEventType.CommitCommentEvent,
                CommitCommentPayload.builder().build());
        updateView(event);
        verify(""user commented on user/repo"");
    }
    @UiThreadTest
    public void testCreateRepositoryEvent() {
        CreatePayload payload = CreatePayload.builder()
                .refType(""repository"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.CreateEvent, payload);
        updateView(event);
        verify(""user created repository repo"");
    }
    @UiThreadTest
    public void testCreateBranchEvent() {
        CreatePayload payload = CreatePayload.builder()
                .refType(""branch"")
                .ref(""b1"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.CreateEvent, payload);
        updateView(event);
        verify(""user created branch b1 at user/repo"");
    }
    @UiThreadTest
    public void testDelete() {
        DeletePayload payload = DeletePayload.builder()
                .refType(""branch"")
                .ref(""b1"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.DeleteEvent, payload);
        updateView(event);
        verify(""user deleted branch b1 at user/repo"");
    }
    @UiThreadTest
    public void testFollow() {
        User target = User.builder()
                .login(""user2"")
                .build();
        FollowPayload payload = FollowPayload.builder()
                .target(target)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.FollowEvent, payload);
        updateView(event);
        verify(""user started following user2"");
    }
    @UiThreadTest
    public void testGist() {
        Gist gist = Gist.builder()
                .id(""1"")
                .build();
        GistPayload payload = GistPayload.builder()
                .action(""create"")
                .gist(gist)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.GistEvent, payload);
        updateView(event);
        verify(""user created Gist 1"");
    }
    @UiThreadTest
    public void testWiki() {
        GitHubEvent event = createEvent(GitHubEventType.GollumEvent, null);
        updateView(event);
        verify(""user updated the wiki in user/repo"");
    }
    @UiThreadTest
    public void testIssueComment() {
        Issue issue = Issue.builder()
                .number(5)
                .build();
        IssueCommentPayload payload = IssueCommentPayload.builder()
                .issue(issue)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.IssueCommentEvent, payload);
        updateView(event);
        verify(""user commented on issue 5 on user/repo"");
    }
    @UiThreadTest
    public void testIssue() {
        Issue issue = Issue.builder()
                .number(8)
                .build();
        IssuesPayload payload = IssuesPayload.builder()
                .action(""closed"")
                .issue(issue)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.IssuesEvent, payload);
        updateView(event);
        verify(""user closed issue 8 on user/repo"");
    }
    @UiThreadTest
    public void testAddMember() {
        User user = User.builder()
                .login(""person"")
                .build();
        MemberPayload payload = MemberPayload.builder()
                .member(user)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.MemberEvent, payload);
        updateView(event);
        verify(""user added person as a collaborator to user/repo"");
    }
    @UiThreadTest
    public void testOpenSourced() {
        GitHubEvent event = createEvent(GitHubEventType.PublicEvent, null);
        updateView(event);
        verify(""user open sourced repository user/repo"");
    }
    @UiThreadTest
    public void testWatch() {
        GitHubEvent event = createEvent(GitHubEventType.WatchEvent, null);
        updateView(event);
        verify(""user starred user/repo"");
    }
    @UiThreadTest
    public void testPullRequest() {
        PullRequestPayload payload = PullRequestPayload.builder()
                .number(30)
                .action(""merged"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.PullRequestEvent, payload);
        updateView(event);
        verify(""user merged pull request 30 on user/repo"");
    }
    @UiThreadTest
    public void testPush() {
        PushPayload payload = PushPayload.builder()
                .ref(""refs/heads/master"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.PushEvent, payload);
        updateView(event);
        verify(""user pushed to master at user/repo"");
    }
    @UiThreadTest
    public void testTeamAdd() {
        Team team = Team.builder()
                .name(""t1"")
                .build();
        Repository repo = Repository.builder()
                .name(""r2"")
                .build();
        TeamAddPayload payload = TeamAddPayload.builder()
                .repository(repo)
                .team(team)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.TeamAddEvent, payload);
        updateView(event);
        verify(""user added r2 to team t1"");
    }
}",class,
"    @Override
    protected void setUp() throws Exception {
        super.setUp();
        actor = User.builder().login(""user"").build();
        repo = Repository.builder().name(""user/repo"").build();
        Context context = getInstrumentation().getTargetContext();
        adapter = new NewsListAdapter(LayoutInflater.from(context),
                new AvatarLoader(context));
    }",method,
"    private GitHubEvent createEvent(GitHubEventType type, GitHubPayload payload) {
        return GitHubEvent.builder()
                .createdAt(new Date())
                .type(type)
                .payload(payload)
                .actor(actor)
                .repo(repo)
                .build();
    }",method,
"    private void verify(String expected) {
        CharSequence actual = text.getText();
        assertNotNull(actual);
        assertEquals(expected, actual.toString());
    }",method,
"    private void updateView(GitHubEvent event) {
        adapter.setItems(new Object[] { event });
        View view = adapter.getView(0, null, null);
        assertNotNull(view);
        text = (TextView) view.findViewById(id.tv_event);
        assertNotNull(text);
    }",method,
"    @UiThreadTest
    public void testCommitCommentEvent() {
        GitHubEvent event = createEvent(GitHubEventType.CommitCommentEvent,
                CommitCommentPayload.builder().build());
        updateView(event);
        verify(""user commented on user/repo"");
    }",method,
"    @UiThreadTest
    public void testCreateRepositoryEvent() {
        CreatePayload payload = CreatePayload.builder()
                .refType(""repository"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.CreateEvent, payload);
        updateView(event);
        verify(""user created repository repo"");
    }",method,
"    @UiThreadTest
    public void testCreateBranchEvent() {
        CreatePayload payload = CreatePayload.builder()
                .refType(""branch"")
                .ref(""b1"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.CreateEvent, payload);
        updateView(event);
        verify(""user created branch b1 at user/repo"");
    }",method,
"    @UiThreadTest
    public void testDelete() {
        DeletePayload payload = DeletePayload.builder()
                .refType(""branch"")
                .ref(""b1"")
                .build();
        GitHubEvent event = createEvent(GitHubEventType.DeleteEvent, payload);
        updateView(event);
        verify(""user deleted branch b1 at user/repo"");
    }",method,
"    @UiThreadTest
    public void testFollow() {
        User target = User.builder()
                .login(""user2"")
                .build();
        FollowPayload payload = FollowPayload.builder()
                .target(target)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.FollowEvent, payload);
        updateView(event);
        verify(""user started following user2"");
    }",method,
"    @UiThreadTest
    public void testGist() {
        Gist gist = Gist.builder()
                .id(""1"")
                .build();
        GistPayload payload = GistPayload.builder()
                .action(""create"")
                .gist(gist)
                .build();
        GitHubEvent event = createEvent(GitHubEventType.GistEvent, payload);
        updateView(event);
        verify(""user created Gist 1"");
    }",method,
"    @UiThreadTest
    public void testWiki() {
        GitHubEvent event = createEvent(GitHubEventType.GollumEvent, null);
        updateView(event);
        verify(""user updated the wiki in user/repo"");
    }",method,

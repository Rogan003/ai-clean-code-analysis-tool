code_snippet,type,score
"    public TextHit(int charIndex, boolean leadingEdge) {
        this.charIndex = charIndex;
        this.leadingEdge = leadingEdge;
    }",method,
"    public int getCharIndex() {
        return charIndex;
    }",method,
"    public boolean isLeadingEdge() {
        return leadingEdge;
    }",method,
"public class DevToolsSettingsTests {
	@Rule
	public TemporaryFolder temporaryFolder = new TemporaryFolder();
	private static final String ROOT = DevToolsSettingsTests.class.getPackage().getName()
			.replace('.', '/') + ""/"";
	@Test
	public void includePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings
				.load(ROOT + ""spring-devtools-include.properties"");
		assertThat(settings.isRestartInclude(new URL(""file://test/a""))).isTrue();
		assertThat(settings.isRestartInclude(new URL(""file://test/b""))).isTrue();
		assertThat(settings.isRestartInclude(new URL(""file://test/c""))).isFalse();
	}
	@Test
	public void excludePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings
				.load(ROOT + ""spring-devtools-exclude.properties"");
		assertThat(settings.isRestartExclude(new URL(""file://test/a""))).isTrue();
		assertThat(settings.isRestartExclude(new URL(""file://test/b""))).isTrue();
		assertThat(settings.isRestartExclude(new URL(""file://test/c""))).isFalse();
	}
	@Test
	public void defaultIncludePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings.get();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-autoconfigure"")))
				.isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-actuator""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-starter""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-starter-some-thing"")))
				.isTrue();
	}
	private URL makeUrl(String name) throws IOException {
		File file = this.temporaryFolder.newFolder();
		file = new File(file, name);
		file = new File(file, ""target"");
		file = new File(file, ""classes"");
		file.mkdirs();
		return file.toURI().toURL();
	}
}",class,
"	@Test
	public void includePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings
				.load(ROOT + ""spring-devtools-include.properties"");
		assertThat(settings.isRestartInclude(new URL(""file://test/a""))).isTrue();
		assertThat(settings.isRestartInclude(new URL(""file://test/b""))).isTrue();
		assertThat(settings.isRestartInclude(new URL(""file://test/c""))).isFalse();
	}
	@Test
	public void excludePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings
				.load(ROOT + ""spring-devtools-exclude.properties"");
		assertThat(settings.isRestartExclude(new URL(""file://test/a""))).isTrue();
		assertThat(settings.isRestartExclude(new URL(""file://test/b""))).isTrue();
		assertThat(settings.isRestartExclude(new URL(""file://test/c""))).isFalse();
	}",method,
"	@Test
	public void excludePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings
				.load(ROOT + ""spring-devtools-exclude.properties"");
		assertThat(settings.isRestartExclude(new URL(""file://test/a""))).isTrue();
		assertThat(settings.isRestartExclude(new URL(""file://test/b""))).isTrue();
		assertThat(settings.isRestartExclude(new URL(""file://test/c""))).isFalse();
	}
	@Test
	public void defaultIncludePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings.get();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-autoconfigure"")))
				.isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-actuator""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-starter""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-starter-some-thing"")))
				.isTrue();
	}",method,
"	@Test
	public void defaultIncludePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings.get();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-autoconfigure"")))
				.isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-actuator""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-starter""))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(""spring-boot-starter-some-thing"")))
				.isTrue();
	}",method,
"	private URL makeUrl(String name) throws IOException {
		File file = this.temporaryFolder.newFolder();
		file = new File(file, name);
		file = new File(file, ""target"");
		file = new File(file, ""classes"");
		file.mkdirs();
		return file.toURI().toURL();
	}",method,
"important field in this class to control the access for reader/writer.
   */
  private Set<Object> globalMutex = new HashSet<>();
  private ReadLock readerLock = new ReadLock();
  private WriteLock writerLock = new WriteLock();
  @Override
  public Lock readLock() {
    return readerLock;
  }",class,
"  private class ReadLock implements Lock {
    @Override
    public void lock() {
      synchronized (readerMutex) {
        currentReaderCount++;
        if (currentReaderCount == 1) {
          acquireForReaders();
        }
      }
    }
    private void acquireForReaders() {
      // Try to get the globalMutex lock for the first reader
      synchronized (globalMutex) {
        // If the no one get the lock or the lock is locked by reader, just set the reference
        // to the globalMutex to indicate that the lock is locked by Reader.
        while (doesWriterOwnThisLock()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex in acquireForReaders"", e);
            Thread.currentThread().interrupt();
          }
        }
        globalMutex.add(this);
      }
    }
    @Override
    public void unlock() {
      synchronized (readerMutex) {
        currentReaderCount--;
        // Release the lock only when it is the last reader, it is ensure that the lock is released
        // when all reader is completely.
        if (currentReaderCount == 0) {
          synchronized (globalMutex) {
            // Notify the waiter, mostly the writer
            globalMutex.remove(this);
            globalMutex.notifyAll();
          }
        }
      }
    }
    @Override
    public void lockInterruptibly() throws InterruptedException {
      throw new UnsupportedOperationException();
    }
    @Override
    public boolean tryLock() {
      throw new UnsupportedOperationException();
    }
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
      throw new UnsupportedOperationException();
    }
    @Override
    public Condition newCondition() {
      throw new UnsupportedOperationException();
    }
  }",class,
"  private class WriteLock implements Lock {
    @Override
    public void lock() {
      synchronized (globalMutex) {
        // Wait until the lock is free.
        while (!isLockFree()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex to begin writing"", e);
            Thread.currentThread().interrupt();
          }
        }
        // When the lock is free, acquire it by placing an entry in globalMutex
        globalMutex.add(this);
      }
    }
    @Override
    public void unlock() {
      synchronized (globalMutex) {
        globalMutex.remove(this);
        // Notify the waiter, other writer or reader
        globalMutex.notifyAll();
      }
    }
    @Override
    public void lockInterruptibly() throws InterruptedException {
      throw new UnsupportedOperationException();
    }
    @Override
    public boolean tryLock() {
      throw new UnsupportedOperationException();
    }
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
      throw new UnsupportedOperationException();
    }
    @Override
    public Condition newCondition() {
      throw new UnsupportedOperationException();
    }
  }",class,
"  @Override
  public Lock readLock() {
    return readerLock;
  }",method,
"  @Override
  public Lock writeLock() {
    return writerLock;
  }",method,
"  private boolean doesWriterOwnThisLock() {
    return globalMutex.contains(writerLock);
  }",method,
"  private boolean isLockFree() {
    return globalMutex.isEmpty();
  }",method,
"    @Override
    public void lock() {
      synchronized (readerMutex) {
        currentReaderCount++;
        if (currentReaderCount == 1) {
          acquireForReaders();
        }
      }
    }",method,
"      synchronized (readerMutex) {
        currentReaderCount++;
        if (currentReaderCount == 1) {
          acquireForReaders();
        }
      }",method,
"        if (currentReaderCount == 1) {
          acquireForReaders();
        }",method,
"    private void acquireForReaders() {
      // Try to get the globalMutex lock for the first reader
      synchronized (globalMutex) {
        // If the no one get the lock or the lock is locked by reader, just set the reference
        // to the globalMutex to indicate that the lock is locked by Reader.
        while (doesWriterOwnThisLock()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex in acquireForReaders"", e);
            Thread.currentThread().interrupt();
          }
        }
        globalMutex.add(this);
      }
    }",method,
"      synchronized (globalMutex) {
        // If the no one get the lock or the lock is locked by reader, just set the reference
        // to the globalMutex to indicate that the lock is locked by Reader.
        while (doesWriterOwnThisLock()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex in acquireForReaders"", e);
            Thread.currentThread().interrupt();
          }
        }
        globalMutex.add(this);
      }",method,
"    @Override
    public void unlock() {
      synchronized (readerMutex) {
        currentReaderCount--;
        // Release the lock only when it is the last reader, it is ensure that the lock is released
        // when all reader is completely.
        if (currentReaderCount == 0) {
          synchronized (globalMutex) {
            // Notify the waiter, mostly the writer
            globalMutex.remove(this);
            globalMutex.notifyAll();
          }
        }
      }
    }",method,
"      synchronized (readerMutex) {
        currentReaderCount--;
        // Release the lock only when it is the last reader, it is ensure that the lock is released
        // when all reader is completely.
        if (currentReaderCount == 0) {
          synchronized (globalMutex) {
            // Notify the waiter, mostly the writer
            globalMutex.remove(this);
            globalMutex.notifyAll();
          }
        }
      }",method,
"        if (currentReaderCount == 0) {
          synchronized (globalMutex) {
            // Notify the waiter, mostly the writer
            globalMutex.remove(this);
            globalMutex.notifyAll();
          }
        }",method,
"          synchronized (globalMutex) {
            // Notify the waiter, mostly the writer
            globalMutex.remove(this);
            globalMutex.notifyAll();
          }",method,
"    @Override
    public void lockInterruptibly() throws InterruptedException {
      throw new UnsupportedOperationException();
    }",method,
"    @Override
    public boolean tryLock() {
      throw new UnsupportedOperationException();
    }",method,
"    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
      throw new UnsupportedOperationException();
    }",method,
"    @Override
    public Condition newCondition() {
      throw new UnsupportedOperationException();
    }",method,
"    @Override
    public void lock() {
      synchronized (globalMutex) {
        // Wait until the lock is free.
        while (!isLockFree()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex to begin writing"", e);
            Thread.currentThread().interrupt();
          }
        }
        // When the lock is free, acquire it by placing an entry in globalMutex
        globalMutex.add(this);
      }
    }",method,
"      synchronized (globalMutex) {
        // Wait until the lock is free.
        while (!isLockFree()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex to begin writing"", e);
            Thread.currentThread().interrupt();
          }
        }
        // When the lock is free, acquire it by placing an entry in globalMutex
        globalMutex.add(this);
      }",method,
"    @Override
    public void unlock() {
      synchronized (globalMutex) {
        globalMutex.remove(this);
        // Notify the waiter, other writer or reader
        globalMutex.notifyAll();
      }
    }",method,
"      synchronized (globalMutex) {
        globalMutex.remove(this);
        // Notify the waiter, other writer or reader
        globalMutex.notifyAll();
      }",method,
"    @Override
    public void lockInterruptibly() throws InterruptedException {
      throw new UnsupportedOperationException();
    }",method,
"    @Override
    public boolean tryLock() {
      throw new UnsupportedOperationException();
    }",method,
"    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
      throw new UnsupportedOperationException();
    }",method,
"    @Override
    public Condition newCondition() {
      throw new UnsupportedOperationException();
    }",method,
"public class CurrentWeather {
    private String mIcon;
    private long mTime;
    private double mTemperature;
    private double mHumdity;
    private double mPrecipChance;
    private String mSummary;
    private String mTimeZone;
    public String getTimeZone() {
        return mTimeZone;
    }
    public void setTimeZone(String timeZone) {
        mTimeZone = timeZone;
    }
    public String getIcon() {
        return mIcon;
    }
    public void setIcon(String icon) {
        mIcon = icon;
    }
    public int getIconId(){
        int iconId = R.drawable.clear_day;
        if (mIcon.equals(""clear-day"")) {
            iconId = R.drawable.clear_day;
        }
        else if (mIcon.equals(""clear-night"")) {
            iconId = R.drawable.clear_night;
        }
        else if (mIcon.equals(""rain"")) {
            iconId = R.drawable.rain;
        }
        else if (mIcon.equals(""snow"")) {
            iconId = R.drawable.snow;
        }
        else if (mIcon.equals(""sleet"")) {
            iconId = R.drawable.sleet;
        }
        else if (mIcon.equals(""wind"")) {
            iconId = R.drawable.wind;
        }
        else if (mIcon.equals(""fog"")) {
            iconId = R.drawable.fog;
        }
        else if (mIcon.equals(""cloudy"")) {
            iconId = R.drawable.cloudy;
        }
        else if (mIcon.equals(""partly-cloudy-day"")) {
            iconId = R.drawable.partly_cloudy;
        }
        else if (mIcon.equals(""partly-cloudy-night"")) {
            iconId = R.drawable.cloudy_night;
        }
        return iconId;
    }
    public long getTime() {
        return mTime;
    }
    public String getFormattedTime(){
        SimpleDateFormat formatter = new SimpleDateFormat(""h:mm a"");
        formatter.setTimeZone(TimeZone.getTimeZone(getTimeZone()));
        Date dateTime = new Date(getTime() * 1000);
        String timeString = formatter.format(dateTime);
        return timeString;
    }
    public void setTime(long time) {
        mTime = time;
    }
    public int getTemperature() {
        return (int) Math.round(mTemperature);
    }
    public void setTemperature(double temprature) {
        mTemperature = temprature;
    }
    public double getHumdity() {
        return mHumdity;
    }
    public void setHumdity(double humdity) {
        mHumdity = humdity;
    }
    public int getPrecipChance() {
        double precipPercentage = mPrecipChance * 100;
        return (int)Math.round(precipPercentage);
    }
    public void setPrecipChance(double precipChance) {
        mPrecipChance = precipChance;
    }
    public String getSummary() {
        return mSummary;
    }
    public void setSummary(String summary) {
        mSummary = summary;
    }
}",class,
"    public String getTimeZone() {
        return mTimeZone;
    }",method,
"    public void setTimeZone(String timeZone) {
        mTimeZone = timeZone;
    }",method,
"    public String getIcon() {
        return mIcon;
    }",method,
"    public void setIcon(String icon) {
        mIcon = icon;
    }",method,
"    public int getIconId(){
        int iconId = R.drawable.clear_day;
        if (mIcon.equals(""clear-day"")) {
            iconId = R.drawable.clear_day;
        }
        else if (mIcon.equals(""clear-night"")) {
            iconId = R.drawable.clear_night;
        }
        else if (mIcon.equals(""rain"")) {
            iconId = R.drawable.rain;
        }
        else if (mIcon.equals(""snow"")) {
            iconId = R.drawable.snow;
        }
        else if (mIcon.equals(""sleet"")) {
            iconId = R.drawable.sleet;
        }
        else if (mIcon.equals(""wind"")) {
            iconId = R.drawable.wind;
        }
        else if (mIcon.equals(""fog"")) {
            iconId = R.drawable.fog;
        }
        else if (mIcon.equals(""cloudy"")) {
            iconId = R.drawable.cloudy;
        }
        else if (mIcon.equals(""partly-cloudy-day"")) {
            iconId = R.drawable.partly_cloudy;
        }
        else if (mIcon.equals(""partly-cloudy-night"")) {
            iconId = R.drawable.cloudy_night;
        }
        return iconId;
    }",method,
"    public long getTime() {
        return mTime;
    }",method,
"    public String getFormattedTime(){
        SimpleDateFormat formatter = new SimpleDateFormat(""h:mm a"");
        formatter.setTimeZone(TimeZone.getTimeZone(getTimeZone()));
        Date dateTime = new Date(getTime() * 1000);
        String timeString = formatter.format(dateTime);
        return timeString;
    }",method,
"    public void setTime(long time) {
        mTime = time;
    }",method,
"    public int getTemperature() {
        return (int) Math.round(mTemperature);
    }",method,
"    public void setTemperature(double temprature) {
        mTemperature = temprature;
    }",method,
"    public double getHumdity() {
        return mHumdity;
    }",method,
"    public void setHumdity(double humdity) {
        mHumdity = humdity;
    }",method,
"    public int getPrecipChance() {
        double precipPercentage = mPrecipChance * 100;
        return (int)Math.round(precipPercentage);
    }",method,
"    public void setPrecipChance(double precipChance) {
        mPrecipChance = precipChance;
    }",method,
"    public String getSummary() {
        return mSummary;
    }",method,
"    public void setSummary(String summary) {
        mSummary = summary;
    }",method,
"public class Foo implements Serializable {
  private long field1;
  private Bar field2;
  private boolean field3;
  public Foo() {
    super();
  }
  public Foo(long field1, Bar field2, boolean field3) {
    super();
    this.field1 = field1;
    this.field2 = field2;
    this.field3 = field3;
  }
  public long getField1() {
    return field1;
  }
  public void setField1(long field1) {
    this.field1 = field1;
  }
  public Bar getField2() {
    return field2;
  }
  public void setField2(Bar field2) {
    this.field2 = field2;
  }
  public boolean isField3() {
    return field3;
  }
  public void setField3(boolean field3) {
    this.field3 = field3;
  }
}",class,
"  public Foo() {
    super();
  }",method,
"  public Foo(long field1, Bar field2, boolean field3) {
    super();
    this.field1 = field1;
    this.field2 = field2;
    this.field3 = field3;
  }",method,
"  public long getField1() {
    return field1;
  }",method,
"  public void setField1(long field1) {
    this.field1 = field1;
  }",method,
"  public Bar getField2() {
    return field2;
  }",method,
"  public void setField2(Bar field2) {
    this.field2 = field2;
  }",method,
"  public boolean isField3() {
    return field3;
  }",method,
"  public void setField3(boolean field3) {
    this.field3 = field3;
  }",method,
"public class HeaderAnnotator implements Annotator {
  private final HeaderParserRepository myRepository;
  public HeaderAnnotator(@NotNull HeaderParserRepository repository) {
    myRepository = repository;
  }
  @Override
  public void annotate(@NotNull PsiElement psiElement, @NotNull AnnotationHolder holder) {
    if (psiElement instanceof Header) {
      Header header = (Header)psiElement;
      String name = header.getName();
      if (!isValidName(name)) {
        holder.createAnnotation(HighlightSeverity.ERROR, header.getNameElement().getTextRange(), ManifestBundle.message(""header.name.invalid""));
      }
      else {
        HeaderParser headerParser = myRepository.getHeaderParser(name);
        if (headerParser != null) {
          headerParser.annotate(header, holder);
        }
      }
    }
  }
  private static boolean isValidName(String name) {
    for (int i = 0; i < name.length(); i++) {
      char c = name.charAt(i);
      if (!(c == '-' || c == '_' || Character.isLetterOrDigit(c))) {
        return false;
      }
    }
    return true;
  }
}",class,
"  public HeaderAnnotator(@NotNull HeaderParserRepository repository) {
    myRepository = repository;
  }",method,
"  @Override
  public void annotate(@NotNull PsiElement psiElement, @NotNull AnnotationHolder holder) {
    if (psiElement instanceof Header) {
      Header header = (Header)psiElement;
      String name = header.getName();
      if (!isValidName(name)) {
        holder.createAnnotation(HighlightSeverity.ERROR, header.getNameElement().getTextRange(), ManifestBundle.message(""header.name.invalid""));
      }
      else {
        HeaderParser headerParser = myRepository.getHeaderParser(name);
        if (headerParser != null) {
          headerParser.annotate(header, holder);
        }
      }
    }
  }",method,
"    if (psiElement instanceof Header) {
      Header header = (Header)psiElement;
      String name = header.getName();
      if (!isValidName(name)) {
        holder.createAnnotation(HighlightSeverity.ERROR, header.getNameElement().getTextRange(), ManifestBundle.message(""header.name.invalid""));
      }
      else {
        HeaderParser headerParser = myRepository.getHeaderParser(name);
        if (headerParser != null) {
          headerParser.annotate(header, holder);
        }
      }
    }",method,
"        if (headerParser != null) {
          headerParser.annotate(header, holder);
        }",method,
"  private static boolean isValidName(String name) {
    for (int i = 0; i < name.length(); i++) {
      char c = name.charAt(i);
      if (!(c == '-' || c == '_' || Character.isLetterOrDigit(c))) {
        return false;
      }
    }
    return true;
  }",method,
"public class VisibilityErrorEvent implements BuildEventWithConfiguration {
  BuildConfiguration configuration;
  Label label;
  String errorMessage;
  public VisibilityErrorEvent(BuildConfiguration configuration, Label label, String errorMessage) {
    this.configuration = configuration;
    this.label = label;
    this.errorMessage = errorMessage;
  }
  @Override
  public BuildEventId getEventId() {
    return BuildEventId.targetCompleted(label, configuration.getEventId());
  }
  @Override
  public Collection<BuildEventId> getChildrenEvents() {
    return ImmutableList.<BuildEventId>of();
  }
  @Override
  public BuildEventStreamProtos.BuildEvent asStreamProto(BuildEventConverters converters) {
    return GenericBuildEvent.protoChaining(this)
        .setAborted(
            BuildEventStreamProtos.Aborted.newBuilder()
                .setReason(BuildEventStreamProtos.Aborted.AbortReason.ANALYSIS_FAILURE)
                .setDescription(errorMessage)
                .build())
        .build();
  }
  @Override
  public Collection<BuildEvent> getConfigurations() {
    return ImmutableList.<BuildEvent>of(configuration);
  }
}",class,
"  public VisibilityErrorEvent(BuildConfiguration configuration, Label label, String errorMessage) {
    this.configuration = configuration;
    this.label = label;
    this.errorMessage = errorMessage;
  }",method,
"  @Override
  public BuildEventId getEventId() {
    return BuildEventId.targetCompleted(label, configuration.getEventId());
  }",method,
"  @Override
  public Collection<BuildEventId> getChildrenEvents() {
    return ImmutableList.<BuildEventId>of();
  }",method,
"  @Override
  public BuildEventStreamProtos.BuildEvent asStreamProto(BuildEventConverters converters) {
    return GenericBuildEvent.protoChaining(this)
        .setAborted(
            BuildEventStreamProtos.Aborted.newBuilder()
                .setReason(BuildEventStreamProtos.Aborted.AbortReason.ANALYSIS_FAILURE)
                .setDescription(errorMessage)
                .build())
        .build();
  }",method,
"  @Override
  public Collection<BuildEvent> getConfigurations() {
    return ImmutableList.<BuildEvent>of(configuration);
  }",method,
"public class TextFieldWithHistoryWithBrowseButton extends ComponentWithBrowseButton<TextFieldWithHistory> {
  public TextFieldWithHistoryWithBrowseButton() {
    super(new TextFieldWithHistory(), null);
  }
  @Override
  public void addBrowseFolderListener(@Nullable String title,
                                      @Nullable String description,
                                      @Nullable Project project,
                                      FileChooserDescriptor fileChooserDescriptor,
                                      TextComponentAccessor<TextFieldWithHistory> accessor) {
    super.addBrowseFolderListener(title, description, project, fileChooserDescriptor, accessor);
    FileChooserFactory.getInstance().installFileCompletion(getChildComponent().getTextEditor(), fileChooserDescriptor, false, project);
  }
  public void addBrowseFolderListener(@Nullable String title,
                                      @Nullable String description,
                                      @Nullable Project project,
                                      FileChooserDescriptor fileChooserDescriptor,
                                      TextComponentAccessor<TextFieldWithHistory> accessor,
                                      boolean autoRemoveOnHide) {
    addBrowseFolderListener(title, description, project, fileChooserDescriptor, accessor);
    FileChooserFactory.getInstance().installFileCompletion(getChildComponent().getTextEditor(), fileChooserDescriptor, false, project);
  }
  public String getText() {
    return getChildComponent().getText();
  }
  public void setText(@NotNull String text) {
    getChildComponent().setText(text);
  }
  public void setTextAndAddToHistory(@NotNull String text) {
    getChildComponent().setTextAndAddToHistory(text);
  }
}",class,
"  public TextFieldWithHistoryWithBrowseButton() {
    super(new TextFieldWithHistory(), null);
  }",method,
"  @Override
  public void addBrowseFolderListener(@Nullable String title,
                                      @Nullable String description,
                                      @Nullable Project project,
                                      FileChooserDescriptor fileChooserDescriptor,
                                      TextComponentAccessor<TextFieldWithHistory> accessor) {
    super.addBrowseFolderListener(title, description, project, fileChooserDescriptor, accessor);
    FileChooserFactory.getInstance().installFileCompletion(getChildComponent().getTextEditor(), fileChooserDescriptor, false, project);
  }",method,
"  public void addBrowseFolderListener(@Nullable String title,
                                      @Nullable String description,
                                      @Nullable Project project,
                                      FileChooserDescriptor fileChooserDescriptor,
                                      TextComponentAccessor<TextFieldWithHistory> accessor,
                                      boolean autoRemoveOnHide) {
    addBrowseFolderListener(title, description, project, fileChooserDescriptor, accessor);
    FileChooserFactory.getInstance().installFileCompletion(getChildComponent().getTextEditor(), fileChooserDescriptor, false, project);
  }",method,
"  public String getText() {
    return getChildComponent().getText();
  }",method,
"  public void setText(@NotNull String text) {
    getChildComponent().setText(text);
  }",method,
"  public void setTextAndAddToHistory(@NotNull String text) {
    getChildComponent().setTextAndAddToHistory(text);
  }",method,
"public class btDbvtAabbMm extends BulletBase {
	private long swigCPtr;
	protected btDbvtAabbMm(final String className, long cPtr, boolean cMemoryOwn) {
		super(className, cPtr, cMemoryOwn);
		swigCPtr = cPtr;
	}
	public btDbvtAabbMm(long cPtr, boolean cMemoryOwn) {
		this(""btDbvtAabbMm"", cPtr, cMemoryOwn);
		construct();
	}
	@Override
	protected void reset(long cPtr, boolean cMemoryOwn) {
		if (!destroyed)
			destroy();
		super.reset(swigCPtr = cPtr, cMemoryOwn);
	}
	public static long getCPtr(btDbvtAabbMm obj) {
		return (obj == null) ? 0 : obj.swigCPtr;
	}
	@Override
	protected void finalize() throws Throwable {
		if (!destroyed)
			destroy();
		super.finalize();
	}
  @Override protected synchronized void delete() {
		if (swigCPtr != 0) {
			if (swigCMemOwn) {
				swigCMemOwn = false;
				CollisionJNI.delete_btDbvtAabbMm(swigCPtr);
			}
			swigCPtr = 0;
		}
		super.delete();
	}
	private final static btDbvtAabbMm temp = new btDbvtAabbMm(0, false);
	public static btDbvtAabbMm internalTemp(long cPtr, boolean own) {
		temp.reset(cPtr, own);
		return temp;
	}
	private static btDbvtAabbMm[] argumentInstances = new btDbvtAabbMm[] {new btDbvtAabbMm(0, false),
		new btDbvtAabbMm(0, false), new btDbvtAabbMm(0, false), new btDbvtAabbMm(0, false)};
	private static int argumentIndex = -1;
	protected static btDbvtAabbMm obtainForArgument(final long swigCPtr, boolean owner) {
		btDbvtAabbMm instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];
		instance.reset(swigCPtr, owner);
		return instance;
	}
  public Vector3 Center() {
	return CollisionJNI.btDbvtAabbMm_Center(swigCPtr, this);
}
  public Vector3 Lengths() {
	return CollisionJNI.btDbvtAabbMm_Lengths(swigCPtr, this);
}
  public Vector3 Extents() {
	return CollisionJNI.btDbvtAabbMm_Extents(swigCPtr, this);
}
  public Vector3 Mins() {
	return CollisionJNI.btDbvtAabbMm_Mins(swigCPtr, this);
}
  public Vector3 Maxs() {
	return CollisionJNI.btDbvtAabbMm_Maxs(swigCPtr, this);
}
  public static btDbvtAabbMm FromCE(Vector3 c, Vector3 e) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromCE(c, e), true);
  }
  public static btDbvtAabbMm FromCR(Vector3 c, float r) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromCR(c, r), true);
  }
  public static btDbvtAabbMm FromMM(Vector3 mi, Vector3 mx) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromMM(mi, mx), true);
  }
  public static btDbvtAabbMm FromPoints(btVector3 pts, int n) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromPoints__SWIG_0(btVector3.getCPtr(pts), pts, n), true);
  }
  public static btDbvtAabbMm FromPoints(SWIGTYPE_p_p_btVector3 ppts, int n) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromPoints__SWIG_1(SWIGTYPE_p_p_btVector3.getCPtr(ppts), n), true);
  }
  public void Expand(Vector3 e) {
    CollisionJNI.btDbvtAabbMm_Expand(swigCPtr, this, e);
  }
  public void SignedExpand(Vector3 e) {
    CollisionJNI.btDbvtAabbMm_SignedExpand(swigCPtr, this, e);
  }
  public boolean Contain(btDbvtAabbMm a) {
    return CollisionJNI.btDbvtAabbMm_Contain(swigCPtr, this, btDbvtAabbMm.getCPtr(a), a);
  }
  public int Classify(Vector3 n, float o, int s) {
    return CollisionJNI.btDbvtAabbMm_Classify(swigCPtr, this, n, o, s);
  }
  public float ProjectMinimum(Vector3 v, long signs) {
    return CollisionJNI.btDbvtAabbMm_ProjectMinimum(swigCPtr, this, v, signs);
  }
  public Vector3 tMins() {
	return CollisionJNI.btDbvtAabbMm_tMins(swigCPtr, this);
}
  public Vector3 tMaxs() {
	return CollisionJNI.btDbvtAabbMm_tMaxs(swigCPtr, this);
}
  public btDbvtAabbMm() {
    this(CollisionJNI.new_btDbvtAabbMm(), true);
  }
}",class,
"	protected btDbvtAabbMm(final String className, long cPtr, boolean cMemoryOwn) {
		super(className, cPtr, cMemoryOwn);
		swigCPtr = cPtr;
	}",method,
"	public btDbvtAabbMm(long cPtr, boolean cMemoryOwn) {
		this(""btDbvtAabbMm"", cPtr, cMemoryOwn);
		construct();
	}",method,
"	@Override
	protected void reset(long cPtr, boolean cMemoryOwn) {
		if (!destroyed)
			destroy();
		super.reset(swigCPtr = cPtr, cMemoryOwn);
	}",method,
"	public static long getCPtr(btDbvtAabbMm obj) {
		return (obj == null) ? 0 : obj.swigCPtr;
	}",method,
"	@Override
	protected void finalize() throws Throwable {
		if (!destroyed)
			destroy();
		super.finalize();
	}",method,
"  @Override protected synchronized void delete() {
		if (swigCPtr != 0) {
			if (swigCMemOwn) {
				swigCMemOwn = false;
				CollisionJNI.delete_btDbvtAabbMm(swigCPtr);
			}
			swigCPtr = 0;
		}",method,
"			if (swigCMemOwn) {
				swigCMemOwn = false;
				CollisionJNI.delete_btDbvtAabbMm(swigCPtr);
			}",method,
"	public static btDbvtAabbMm internalTemp(long cPtr, boolean own) {
		temp.reset(cPtr, own);
		return temp;
	}",method,
"	protected static btDbvtAabbMm obtainForArgument(final long swigCPtr, boolean owner) {
		btDbvtAabbMm instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];
		instance.reset(swigCPtr, owner);
		return instance;
	}",method,
"  public Vector3 Center() {
	return CollisionJNI.btDbvtAabbMm_Center(swigCPtr, this);
}",method,
"  public Vector3 Lengths() {
	return CollisionJNI.btDbvtAabbMm_Lengths(swigCPtr, this);
}",method,
"  public Vector3 Extents() {
	return CollisionJNI.btDbvtAabbMm_Extents(swigCPtr, this);
}",method,
"  public Vector3 Mins() {
	return CollisionJNI.btDbvtAabbMm_Mins(swigCPtr, this);
}",method,
"  public Vector3 Maxs() {
	return CollisionJNI.btDbvtAabbMm_Maxs(swigCPtr, this);
}",method,
"  public static btDbvtAabbMm FromCE(Vector3 c, Vector3 e) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromCE(c, e), true);
  }",method,
"  public static btDbvtAabbMm FromCR(Vector3 c, float r) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromCR(c, r), true);
  }",method,
"  public static btDbvtAabbMm FromMM(Vector3 mi, Vector3 mx) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromMM(mi, mx), true);
  }",method,
"  public static btDbvtAabbMm FromPoints(btVector3 pts, int n) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromPoints__SWIG_0(btVector3.getCPtr(pts), pts, n), true);
  }",method,
"  public static btDbvtAabbMm FromPoints(SWIGTYPE_p_p_btVector3 ppts, int n) {
    return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromPoints__SWIG_1(SWIGTYPE_p_p_btVector3.getCPtr(ppts), n), true);
  }",method,

code_snippet,type,score
"      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }",method,
"      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }",method,
"    @Override
    public boolean satisfiedBy(@NotNull PsiElement element) {
      if (element instanceof GrMethodCallExpression) {
        final GrMethodCallExpression expression = (GrMethodCallExpression)element;
//        final PsiElement parent = expression.getParent();
//        if (parent instanceof GrAssignmentExpression) return false;
//        if (parent instanceof GrArgumentList) return false;
//        if (parent instanceof GrReturnStatement) return false;
//        if (!(parent instanceof GrCodeBlock || parent instanceof GrIfStatement|| parent instanceof GrCaseSection)) return false;
        final GrExpression invokedExpression = expression.getInvokedExpression();
        if (invokedExpression instanceof GrReferenceExpression) {
          GrReferenceExpression referenceExpression = (GrReferenceExpression)invokedExpression;
          if (""each"".equals(referenceExpression.getReferenceName())) {
            final GrArgumentList argumentList = expression.getArgumentList();
            if (PsiImplUtil.hasExpressionArguments(argumentList)) return false;
            if (PsiImplUtil.hasNamedArguments(argumentList)) return false;
            final GrClosableBlock[] closureArguments = expression.getClosureArguments();
            if (closureArguments.length != 1) return false;
            final GrParameter[] parameters = closureArguments[0].getParameterList().getParameters();
            if (parameters.length > 1) return false;
            return true;
          }
        }
      }
      return false;
    }",method,
"      if (element instanceof GrMethodCallExpression) {
        final GrMethodCallExpression expression = (GrMethodCallExpression)element;
//        final PsiElement parent = expression.getParent();
//        if (parent instanceof GrAssignmentExpression) return false;
//        if (parent instanceof GrArgumentList) return false;
//        if (parent instanceof GrReturnStatement) return false;
//        if (!(parent instanceof GrCodeBlock || parent instanceof GrIfStatement|| parent instanceof GrCaseSection)) return false;
        final GrExpression invokedExpression = expression.getInvokedExpression();
        if (invokedExpression instanceof GrReferenceExpression) {
          GrReferenceExpression referenceExpression = (GrReferenceExpression)invokedExpression;
          if (""each"".equals(referenceExpression.getReferenceName())) {
            final GrArgumentList argumentList = expression.getArgumentList();
            if (PsiImplUtil.hasExpressionArguments(argumentList)) return false;
            if (PsiImplUtil.hasNamedArguments(argumentList)) return false;
            final GrClosableBlock[] closureArguments = expression.getClosureArguments();
            if (closureArguments.length != 1) return false;
            final GrParameter[] parameters = closureArguments[0].getParameterList().getParameters();
            if (parameters.length > 1) return false;
            return true;
          }
        }
      }",method,
"        if (invokedExpression instanceof GrReferenceExpression) {
          GrReferenceExpression referenceExpression = (GrReferenceExpression)invokedExpression;
          if (""each"".equals(referenceExpression.getReferenceName())) {
            final GrArgumentList argumentList = expression.getArgumentList();
            if (PsiImplUtil.hasExpressionArguments(argumentList)) return false;
            if (PsiImplUtil.hasNamedArguments(argumentList)) return false;
            final GrClosableBlock[] closureArguments = expression.getClosureArguments();
            if (closureArguments.length != 1) return false;
            final GrParameter[] parameters = closureArguments[0].getParameterList().getParameters();
            if (parameters.length > 1) return false;
            return true;
          }
        }",method,
"  class NodeImpl<NodeId> implements Node<NodeId> {
    @NotNull private final NodeId myNodeId;
    private final boolean myRemoved;
    public NodeImpl(@NotNull NodeId nodeId, boolean removed) {
      myNodeId = nodeId;
      myRemoved = removed;
    }
    @NotNull
    @Override
    public NodeId getNodeId() {
      return myNodeId;
    }
    @Override
    public boolean removed() {
      return myRemoved;
    }
  }",class,
"  class EdgeImpl<NodeId> implements Edge<NodeId> {
    @Nullable private final NodeId myUpNodeId;
    @Nullable private final NodeId myDownNodeId;
    @Nullable private final NodeId myTargetId;
    private final boolean myRemoved;
    public EdgeImpl(@Nullable NodeId upNodeId, @Nullable NodeId downNodeId, @Nullable NodeId targetId, boolean removed) {
      myUpNodeId = upNodeId;
      myDownNodeId = downNodeId;
      myTargetId = targetId;
      myRemoved = removed;
    }
    @Nullable
    @Override
    public NodeId upNodeId() {
      return myUpNodeId;
    }
    @Nullable
    @Override
    public NodeId downNodeId() {
      return myDownNodeId;
    }
    @Nullable
    @Override
    public NodeId targetId() {
      return myTargetId;
    }
    @Override
    public boolean removed() {
      return myRemoved;
    }
  }",class,
"  class GraphChangesImpl<NodeId> implements GraphChanges<NodeId> {
    private final Collection<Node<NodeId>> myChangedNodes;
    private final Collection<Edge<NodeId>> myChangedEdges;
    public GraphChangesImpl(Collection<Node<NodeId>> changedNodes, Collection<Edge<NodeId>> changedEdges) {
      myChangedNodes = changedNodes;
      myChangedEdges = changedEdges;
    }
    @NotNull
    @Override
    public Collection<Node<NodeId>> getChangedNodes() {
      return myChangedNodes;
    }
    @NotNull
    @Override
    public Collection<Edge<NodeId>> getChangedEdges() {
      return myChangedEdges;
    }
  }",class,
"    public NodeImpl(@NotNull NodeId nodeId, boolean removed) {
      myNodeId = nodeId;
      myRemoved = removed;
    }",method,
"    @NotNull
    @Override
    public NodeId getNodeId() {
      return myNodeId;
    }",method,
"    @Override
    public boolean removed() {
      return myRemoved;
    }",method,
"    public EdgeImpl(@Nullable NodeId upNodeId, @Nullable NodeId downNodeId, @Nullable NodeId targetId, boolean removed) {
      myUpNodeId = upNodeId;
      myDownNodeId = downNodeId;
      myTargetId = targetId;
      myRemoved = removed;
    }",method,
"    @Nullable
    @Override
    public NodeId upNodeId() {
      return myUpNodeId;
    }",method,
"    @Nullable
    @Override
    public NodeId downNodeId() {
      return myDownNodeId;
    }",method,
"    @Nullable
    @Override
    public NodeId targetId() {
      return myTargetId;
    }",method,
"    @Override
    public boolean removed() {
      return myRemoved;
    }",method,
"    public GraphChangesImpl(Collection<Node<NodeId>> changedNodes, Collection<Edge<NodeId>> changedEdges) {
      myChangedNodes = changedNodes;
      myChangedEdges = changedEdges;
    }",method,
"    @NotNull
    @Override
    public Collection<Node<NodeId>> getChangedNodes() {
      return myChangedNodes;
    }",method,
"    @NotNull
    @Override
    public Collection<Edge<NodeId>> getChangedEdges() {
      return myChangedEdges;
    }",method,
"public class APODContentProvider extends ContentProvider {
  private APODSQLiteOpenHelper mOpenHelper;
  @Override
  public boolean onCreate() {
    mOpenHelper = new APODSQLiteOpenHelper(getContext());
    return true;
  }
  @Override
  public Cursor query(
      Uri uri,
      String[] projection,
      String selection,
      String[] selectionArgs,
      String sortOrder) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    Cursor cursor = db.query(
        APODContract.TABLE_NAME,
        projection,
        selection,
        selectionArgs,
        null ,
        null ,
        sortOrder,
        null );
    cursor.setNotificationUri(getContext().getContentResolver(), APODContract.CONTENT_URI);
    return cursor;
  }
  @Override
  public String getType(Uri uri) {
    return null;
  }
  @Override
  public Uri insert(Uri uri, ContentValues values) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    long id = db.insert(APODContract.TABLE_NAME, null , values);
    notifyChange();
    return uri.buildUpon().appendEncodedPath(String.valueOf(id)).build();
  }
  @Override
  public int delete(Uri uri, String selection, String[] selectionArgs) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    int count = db.delete(APODContract.TABLE_NAME, selection, selectionArgs);
    notifyChange();
    return count;
  }
  @Override
  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    int count = db.update(APODContract.TABLE_NAME, values, selection, selectionArgs);
    notifyChange();
    return count;
  }
  @Override
  public ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations)
      throws OperationApplicationException {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      ContentProviderResult[] results = super.applyBatch(operations);
      db.setTransactionSuccessful();
      return results;
    } finally {
      db.endTransaction();
      notifyChange();
    }
  }
  private void notifyChange() {
    getContext().getContentResolver().notifyChange(APODContract.CONTENT_URI, null );
  }
  private static class APODSQLiteOpenHelper extends SQLiteOpenHelper {
    private static final String DB_NAME = ""apod.db"";
    private static final int DB_VERSION = 2;
    public APODSQLiteOpenHelper(Context context) {
      super(context, DB_NAME, null , DB_VERSION);
    }
    @Override
    public void onCreate(SQLiteDatabase db) {
      db.execSQL(
          ""CREATE TABLE "" + APODContract.TABLE_NAME + "" ("" +
              APODContract.Columns._ID + "" INTEGER PRIMARY KEY AUTOINCREMENT, "" +
              APODContract.Columns.TITLE + "" TEXT, "" +
              APODContract.Columns.DESCRIPTION_IMAGE_URL + "" TEXT, "" +
              APODContract.Columns.DESCRIPTION_TEXT + "" TEXT, "" +
              APODContract.Columns.LARGE_IMAGE_URL + "" TEXT "" +
              "")"");
    }
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
      drop(db);
      onCreate(db);
    }
    private void drop(SQLiteDatabase db) {
      db.execSQL(""DROP TABLE "" + APODContract.TABLE_NAME);
    }
  }
}",class,
"  private static class APODSQLiteOpenHelper extends SQLiteOpenHelper {
    private static final String DB_NAME = ""apod.db"";
    private static final int DB_VERSION = 2;
    public APODSQLiteOpenHelper(Context context) {
      super(context, DB_NAME, null , DB_VERSION);
    }
    @Override
    public void onCreate(SQLiteDatabase db) {
      db.execSQL(
          ""CREATE TABLE "" + APODContract.TABLE_NAME + "" ("" +
              APODContract.Columns._ID + "" INTEGER PRIMARY KEY AUTOINCREMENT, "" +
              APODContract.Columns.TITLE + "" TEXT, "" +
              APODContract.Columns.DESCRIPTION_IMAGE_URL + "" TEXT, "" +
              APODContract.Columns.DESCRIPTION_TEXT + "" TEXT, "" +
              APODContract.Columns.LARGE_IMAGE_URL + "" TEXT "" +
              "")"");
    }
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
      drop(db);
      onCreate(db);
    }
    private void drop(SQLiteDatabase db) {
      db.execSQL(""DROP TABLE "" + APODContract.TABLE_NAME);
    }
  }",class,
"  @Override
  public boolean onCreate() {
    mOpenHelper = new APODSQLiteOpenHelper(getContext());
    return true;
  }",method,
"  @Override
  public Cursor query(
      Uri uri,
      String[] projection,
      String selection,
      String[] selectionArgs,
      String sortOrder) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    Cursor cursor = db.query(
        APODContract.TABLE_NAME,
        projection,
        selection,
        selectionArgs,
        null ,
        null ,
        sortOrder,
        null );
    cursor.setNotificationUri(getContext().getContentResolver(), APODContract.CONTENT_URI);
    return cursor;
  }",method,
"  @Override
  public String getType(Uri uri) {
    return null;
  }",method,
"  @Override
  public Uri insert(Uri uri, ContentValues values) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    long id = db.insert(APODContract.TABLE_NAME, null , values);
    notifyChange();
    return uri.buildUpon().appendEncodedPath(String.valueOf(id)).build();
  }",method,
"  @Override
  public int delete(Uri uri, String selection, String[] selectionArgs) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    int count = db.delete(APODContract.TABLE_NAME, selection, selectionArgs);
    notifyChange();
    return count;
  }",method,
"  @Override
  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    int count = db.update(APODContract.TABLE_NAME, values, selection, selectionArgs);
    notifyChange();
    return count;
  }",method,
"  @Override
  public ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations)
      throws OperationApplicationException {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      ContentProviderResult[] results = super.applyBatch(operations);
      db.setTransactionSuccessful();
      return results;
    } finally {
      db.endTransaction();
      notifyChange();
    }
  }",method,
"  private void notifyChange() {
    getContext().getContentResolver().notifyChange(APODContract.CONTENT_URI, null );
  }",method,
"    public APODSQLiteOpenHelper(Context context) {
      super(context, DB_NAME, null , DB_VERSION);
    }",method,
"    @Override
    public void onCreate(SQLiteDatabase db) {
      db.execSQL(
          ""CREATE TABLE "" + APODContract.TABLE_NAME + "" ("" +
              APODContract.Columns._ID + "" INTEGER PRIMARY KEY AUTOINCREMENT, "" +
              APODContract.Columns.TITLE + "" TEXT, "" +
              APODContract.Columns.DESCRIPTION_IMAGE_URL + "" TEXT, "" +
              APODContract.Columns.DESCRIPTION_TEXT + "" TEXT, "" +
              APODContract.Columns.LARGE_IMAGE_URL + "" TEXT "" +
              "")"");
    }",method,
"    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
      drop(db);
      onCreate(db);
    }",method,
"    private void drop(SQLiteDatabase db) {
      db.execSQL(""DROP TABLE "" + APODContract.TABLE_NAME);
    }",method,
"public class GrAnonymousClassDefinitionImpl extends GrTypeDefinitionImpl implements GrAnonymousClassDefinition {
  private SoftReference<PsiClassType> myCachedBaseType;
  public GrAnonymousClassDefinitionImpl(@NotNull ASTNode node) {
    super(node);
  }
  public GrAnonymousClassDefinitionImpl(GrTypeDefinitionStub stub) {
    this(stub, GroovyElementTypes.ANONYMOUS_CLASS_DEFINITION);
  }
  public GrAnonymousClassDefinitionImpl(GrTypeDefinitionStub stub, final GrStubElementType nodeType) {
    super(stub, nodeType);
  }
  @Override
  @NotNull
  public GrCodeReferenceElement getBaseClassReferenceGroovy() {
    GrTypeDefinitionStub stub = getStub();
    if (stub != null) {
      GrCodeReferenceElement reference = stub.getBaseClassReference();
      assert reference != null;
      return reference;
    }
    return findNotNullChildByClass(GrCodeReferenceElement.class); //not null because of definition =)
  }
  @Override
  public boolean hasModifierProperty(@NonNls @NotNull String name) {
    return PsiModifier.FINAL.equals(name);
  }
  @Override
  @Nullable
  public GrArgumentList getArgumentListGroovy() {
    //noinspection ConstantConditions
    return findChildByClass(GrArgumentList.class); //not null because of definition
  }
  @Override
  public boolean isInQualifiedNew() {
    return false;
  }
  @Override
  @NotNull
  public PsiJavaCodeReferenceElement getBaseClassReference() {
    return JavaPsiFacade.getElementFactory(getProject()).createReferenceElementByType(getBaseClassType());
  }
  @Override
  @NotNull
  public PsiClassType getBaseClassType() {
    PsiClassType type = SoftReference.dereference(myCachedBaseType);
    if (type != null && type.isValid()) return type;
    type = new GrClassReferenceType(getBaseClassReferenceGroovy());
    myCachedBaseType = new SoftReference<>(type);
    return type;
  }
  @Override
  @Nullable
  public PsiExpressionList getArgumentList() {
    return null;
  }
  @Nullable
  private PsiClass getBaseClass() {
    return getBaseClassType().resolve();
  }
  @NotNull
  @Override
  public PsiElement getNameIdentifierGroovy() {
    //noinspection ConstantConditions
    return getBaseClassReferenceGroovy().getReferenceNameElement();
  }
  @Override
  public boolean processDeclarations(@NotNull PsiScopeProcessor processor,
                                     @NotNull ResolveState state,
                                     @Nullable PsiElement lastParent,
                                     @NotNull PsiElement place) {
    if (lastParent instanceof GrArgumentList) return true;
    GrCodeReferenceElement refElement = getBaseClassReferenceGroovy();
    if (refElement == place || refElement == lastParent) return true;
    return super.processDeclarations(processor, state, lastParent, place);
  }
  @Override
  public boolean isAnonymous() {
    return true;
  }
  @Override
  public PsiClass getSuperClass() {
    final PsiClass psiClass = getBaseClass();
    if (psiClass != null && !psiClass.isInterface()) return psiClass;
    return JavaPsiFacade.getInstance(getProject()).findClass(CommonClassNames.JAVA_LANG_OBJECT, getResolveScope());
  }
  @Override
  public PsiClass getContainingClass() {
    return null;
  }
  @NotNull
  @Override
  public PsiClassType[] getExtendsListTypes(boolean includeSynthetic) {
    return PsiClassType.EMPTY_ARRAY;
  }
  @Override
  public GrExtendsClause getExtendsClause() {
    return null;
  }
  @Override
  public GrImplementsClause getImplementsClause() {
    return null;
  }
  @NotNull
  @Override
  public PsiClassType[] getImplementsListTypes(boolean includeSynthetic) {
    return PsiClassType.EMPTY_ARRAY;
  }
  @NotNull
  @Override
  public PsiClassType[] getSuperTypes(boolean includeSynthetic) {
    PsiClassType baseClassType = getBaseClassType();
    PsiClass baseClass = baseClassType.resolve();
    if (baseClass == null || !baseClass.isInterface()) {
      return new PsiClassType[]{baseClassType};
    }
    else {
      PsiClassType objectType = PsiType.getJavaLangObject(getManager(), getResolveScope());
      return new PsiClassType[]{objectType, baseClassType};
    }
  }
  @Override
  public String toString() {
    return ""Anonymous class"";
  }
  @Override
  public void subtreeChanged() {
    super.subtreeChanged();
    myCachedBaseType = null;
  }
  @Override
  protected Object clone() {
    final Object o = super.clone();
    ((GrAnonymousClassDefinitionImpl)o).myCachedBaseType = null;
    return o;
  }
  @Override
  public String getQualifiedName() {
    return null;
  }
  @Override
  public String getName() {
    return null;
  }
  @Override
  public PsiIdentifier getNameIdentifier() {
    return null;
  }
  @Override
  public void accept(GroovyElementVisitor visitor) {
    visitor.visitAnonymousClassDefinition(this);
  }
}",class,
"  public GrAnonymousClassDefinitionImpl(@NotNull ASTNode node) {
    super(node);
  }",method,
"  public GrAnonymousClassDefinitionImpl(GrTypeDefinitionStub stub) {
    this(stub, GroovyElementTypes.ANONYMOUS_CLASS_DEFINITION);
  }",method,
"  public GrAnonymousClassDefinitionImpl(GrTypeDefinitionStub stub, final GrStubElementType nodeType) {
    super(stub, nodeType);
  }",method,
"  @Override
  @NotNull
  public GrCodeReferenceElement getBaseClassReferenceGroovy() {
    GrTypeDefinitionStub stub = getStub();
    if (stub != null) {
      GrCodeReferenceElement reference = stub.getBaseClassReference();
      assert reference != null;
      return reference;
    }
    return findNotNullChildByClass(GrCodeReferenceElement.class); //not null because of definition =)
  }",method,
"    if (stub != null) {
      GrCodeReferenceElement reference = stub.getBaseClassReference();
      assert reference != null;
      return reference;
    }",method,
"  @Override
  public boolean hasModifierProperty(@NonNls @NotNull String name) {
    return PsiModifier.FINAL.equals(name);
  }",method,
"  @Override
  @Nullable
  public GrArgumentList getArgumentListGroovy() {
    //noinspection ConstantConditions
    return findChildByClass(GrArgumentList.class); //not null because of definition
  }",method,
"  @Override
  public boolean isInQualifiedNew() {
    return false;
  }",method,
"  @Override
  @NotNull
  public PsiJavaCodeReferenceElement getBaseClassReference() {
    return JavaPsiFacade.getElementFactory(getProject()).createReferenceElementByType(getBaseClassType());
  }",method,
"  @Override
  @NotNull
  public PsiClassType getBaseClassType() {
    PsiClassType type = SoftReference.dereference(myCachedBaseType);
    if (type != null && type.isValid()) return type;
    type = new GrClassReferenceType(getBaseClassReferenceGroovy());
    myCachedBaseType = new SoftReference<>(type);
    return type;
  }",method,
"  @Override
  @Nullable
  public PsiExpressionList getArgumentList() {
    return null;
  }",method,
"  @Nullable
  private PsiClass getBaseClass() {
    return getBaseClassType().resolve();
  }",method,
"  @NotNull
  @Override
  public PsiElement getNameIdentifierGroovy() {
    //noinspection ConstantConditions
    return getBaseClassReferenceGroovy().getReferenceNameElement();
  }",method,
"  @Override
  public boolean processDeclarations(@NotNull PsiScopeProcessor processor,
                                     @NotNull ResolveState state,
                                     @Nullable PsiElement lastParent,
                                     @NotNull PsiElement place) {
    if (lastParent instanceof GrArgumentList) return true;
    GrCodeReferenceElement refElement = getBaseClassReferenceGroovy();
    if (refElement == place || refElement == lastParent) return true;
    return super.processDeclarations(processor, state, lastParent, place);
  }",method,
"  @Override
  public boolean isAnonymous() {
    return true;
  }",method,
"  @Override
  public PsiClass getSuperClass() {
    final PsiClass psiClass = getBaseClass();
    if (psiClass != null && !psiClass.isInterface()) return psiClass;
    return JavaPsiFacade.getInstance(getProject()).findClass(CommonClassNames.JAVA_LANG_OBJECT, getResolveScope());
  }",method,
"  @Override
  public PsiClass getContainingClass() {
    return null;
  }",method,
"  @NotNull
  @Override
  public PsiClassType[] getExtendsListTypes(boolean includeSynthetic) {
    return PsiClassType.EMPTY_ARRAY;
  }",method,
"  @Override
  public GrExtendsClause getExtendsClause() {
    return null;
  }",method,
"  @Override
  public GrImplementsClause getImplementsClause() {
    return null;
  }",method,
"  @NotNull
  @Override
  public PsiClassType[] getImplementsListTypes(boolean includeSynthetic) {
    return PsiClassType.EMPTY_ARRAY;
  }",method,
"  @NotNull
  @Override
  public PsiClassType[] getSuperTypes(boolean includeSynthetic) {
    PsiClassType baseClassType = getBaseClassType();
    PsiClass baseClass = baseClassType.resolve();
    if (baseClass == null || !baseClass.isInterface()) {
      return new PsiClassType[]{baseClassType};
    }
    else {
      PsiClassType objectType = PsiType.getJavaLangObject(getManager(), getResolveScope());
      return new PsiClassType[]{objectType, baseClassType};
    }
  }",method,
"  @Override
  public String toString() {
    return ""Anonymous class"";
  }",method,
"  @Override
  public void subtreeChanged() {
    super.subtreeChanged();
    myCachedBaseType = null;
  }",method,
"  @Override
  protected Object clone() {
    final Object o = super.clone();
    ((GrAnonymousClassDefinitionImpl)o).myCachedBaseType = null;
    return o;
  }",method,
"  @Override
  public String getQualifiedName() {
    return null;
  }",method,
"  @Override
  public String getName() {
    return null;
  }",method,
"  @Override
  public PsiIdentifier getNameIdentifier() {
    return null;
  }",method,
"  @Override
  public void accept(GroovyElementVisitor visitor) {
    visitor.visitAnonymousClassDefinition(this);
  }",method,
"public class MaybeDelayOtherTest {
    @Test
    public void justWithOnNext() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.just(1)
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onNext(1);
        assertFalse(pp.hasSubscribers());
        ts.assertResult(1);
    }
    @Test
    public void justWithOnComplete() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.just(1)
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onComplete();
        assertFalse(pp.hasSubscribers());
        ts.assertResult(1);
    }
    @Test
    public void justWithOnError() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.just(1)
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onError(new TestException(""Other""));
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Other"");
    }
    @Test
    public void emptyWithOnNext() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>empty()
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onNext(1);
        assertFalse(pp.hasSubscribers());
        ts.assertResult();
    }
    @Test
    public void emptyWithOnComplete() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>empty()
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onComplete();
        assertFalse(pp.hasSubscribers());
        ts.assertResult();
    }
    @Test
    public void emptyWithOnError() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>empty()
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onError(new TestException(""Other""));
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Other"");
    }
    @Test
    public void errorWithOnNext() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>error(new TestException(""Main""))
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onNext(1);
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Main"");
    }
    @Test
    public void errorWithOnComplete() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>error(new TestException(""Main""))
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onComplete();
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Main"");
    }
    @Test
    public void errorWithOnError() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>error(new TestException(""Main""))
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onError(new TestException(""Other""));
        assertFalse(pp.hasSubscribers());
        ts.assertFailure(CompositeException.class);
        List<Throwable> list = TestHelper.compositeList(ts.errors().get(0));
        assertEquals(2, list.size());
        TestHelper.assertError(list, 0, TestException.class, ""Main"");
        TestHelper.assertError(list, 1, TestException.class, ""Other"");
    }
    @Test
    public void withCompletableDispose() {
        TestHelper.checkDisposed(Completable.complete().andThen(Maybe.just(1)));
    }
    @Test
    public void withCompletableDoubleOnSubscribe() {
        TestHelper.checkDoubleOnSubscribeCompletableToMaybe(new Function<Completable, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Completable c) throws Exception {
                return c.andThen(Maybe.just(1));
            }
        });
    }
    @Test
    public void withOtherPublisherDispose() {
        TestHelper.checkDisposed(Maybe.just(1).delay(Flowable.just(1)));
    }
}",class,
"    @Test
    public void justWithOnNext() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.just(1)
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onNext(1);
        assertFalse(pp.hasSubscribers());
        ts.assertResult(1);
    }",method,
"    @Test
    public void justWithOnComplete() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.just(1)
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onComplete();
        assertFalse(pp.hasSubscribers());
        ts.assertResult(1);
    }",method,
"    @Test
    public void justWithOnError() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.just(1)
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onError(new TestException(""Other""));
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Other"");
    }",method,
"    @Test
    public void emptyWithOnNext() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>empty()
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onNext(1);
        assertFalse(pp.hasSubscribers());
        ts.assertResult();
    }",method,
"    @Test
    public void emptyWithOnComplete() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>empty()
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onComplete();
        assertFalse(pp.hasSubscribers());
        ts.assertResult();
    }",method,
"    @Test
    public void emptyWithOnError() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>empty()
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onError(new TestException(""Other""));
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Other"");
    }",method,
"    @Test
    public void errorWithOnNext() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>error(new TestException(""Main""))
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onNext(1);
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Main"");
    }",method,
"    @Test
    public void errorWithOnComplete() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>error(new TestException(""Main""))
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onComplete();
        assertFalse(pp.hasSubscribers());
        ts.assertFailureAndMessage(TestException.class, ""Main"");
    }",method,
"    @Test
    public void errorWithOnError() {
        PublishProcessor<Object> pp = PublishProcessor.create();
        TestObserver<Integer> ts = Maybe.<Integer>error(new TestException(""Main""))
        .delay(pp).test();
        ts.assertEmpty();
        assertTrue(pp.hasSubscribers());
        pp.onError(new TestException(""Other""));
        assertFalse(pp.hasSubscribers());
        ts.assertFailure(CompositeException.class);
        List<Throwable> list = TestHelper.compositeList(ts.errors().get(0));
        assertEquals(2, list.size());
        TestHelper.assertError(list, 0, TestException.class, ""Main"");
        TestHelper.assertError(list, 1, TestException.class, ""Other"");
    }",method,
"    @Test
    public void withCompletableDispose() {
        TestHelper.checkDisposed(Completable.complete().andThen(Maybe.just(1)));
    }",method,
"    @Test
    public void withCompletableDoubleOnSubscribe() {
        TestHelper.checkDoubleOnSubscribeCompletableToMaybe(new Function<Completable, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Completable c) throws Exception {
                return c.andThen(Maybe.just(1));
            }
        });
    }",method,
"        TestHelper.checkDoubleOnSubscribeCompletableToMaybe(new Function<Completable, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Completable c) throws Exception {
                return c.andThen(Maybe.just(1));
            }
        }",method,
"            @Override
            public MaybeSource<Integer> apply(Completable c) throws Exception {
                return c.andThen(Maybe.just(1));
            }",method,
"    @Test
    public void withOtherPublisherDispose() {
        TestHelper.checkDisposed(Maybe.just(1).delay(Flowable.just(1)));
    }",method,
"public abstract class HystrixMetricsPublisher {
    // TODO should this have cacheKey functionality like HystrixProperties does?
    // I think we do otherwise dynamically provided owner and properties won't work
    // a custom override would need the caching strategy for properties/publisher/owner etc to be in sync
    public HystrixMetricsPublisherCommand getMetricsPublisherForCommand(HystrixCommandKey commandKey, HystrixCommandGroupKey commandGroupKey, HystrixCommandMetrics metrics, HystrixCircuitBreaker circuitBreaker, HystrixCommandProperties properties) {
        return new HystrixMetricsPublisherCommandDefault(commandKey, commandGroupKey, metrics, circuitBreaker, properties);
    }
    public HystrixMetricsPublisherThreadPool getMetricsPublisherForThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties) {
        return new HystrixMetricsPublisherThreadPoolDefault(threadPoolKey, metrics, properties);
    }
    public HystrixMetricsPublisherCollapser getMetricsPublisherForCollapser(HystrixCollapserKey collapserKey, HystrixCollapserMetrics metrics, HystrixCollapserProperties properties) {
        return new HystrixMetricsPublisherCollapserDefault(collapserKey, metrics, properties);
    }
}",class,
"    public HystrixMetricsPublisherCommand getMetricsPublisherForCommand(HystrixCommandKey commandKey, HystrixCommandGroupKey commandGroupKey, HystrixCommandMetrics metrics, HystrixCircuitBreaker circuitBreaker, HystrixCommandProperties properties) {
        return new HystrixMetricsPublisherCommandDefault(commandKey, commandGroupKey, metrics, circuitBreaker, properties);
    }",method,
"    public HystrixMetricsPublisherThreadPool getMetricsPublisherForThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties) {
        return new HystrixMetricsPublisherThreadPoolDefault(threadPoolKey, metrics, properties);
    }",method,
"    public HystrixMetricsPublisherCollapser getMetricsPublisherForCollapser(HystrixCollapserKey collapserKey, HystrixCollapserMetrics metrics, HystrixCollapserProperties properties) {
        return new HystrixMetricsPublisherCollapserDefault(collapserKey, metrics, properties);
    }",method,
"@Order(Ordered.LOWEST_PRECEDENCE - 20)
class OnJndiCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context,
			AnnotatedTypeMetadata metadata) {
		AnnotationAttributes annotationAttributes = AnnotationAttributes.fromMap(
				metadata.getAnnotationAttributes(ConditionalOnJndi.class.getName()));
		String[] locations = annotationAttributes.getStringArray(""value"");
		try {
			return getMatchOutcome(locations);
		}
		catch (NoClassDefFoundError ex) {
			return ConditionOutcome
					.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class)
							.because(""JNDI class not found""));
		}
	}
	private ConditionOutcome getMatchOutcome(String[] locations) {
		if (!isJndiAvailable()) {
			return ConditionOutcome
					.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class)
							.notAvailable(""JNDI environment""));
		}
		if (locations.length == 0) {
			return ConditionOutcome.match(ConditionMessage
					.forCondition(ConditionalOnJndi.class).available(""JNDI environment""));
		}
		JndiLocator locator = getJndiLocator(locations);
		String location = locator.lookupFirstLocation();
		String details = ""("" + StringUtils.arrayToCommaDelimitedString(locations) + "")"";
		if (location != null) {
			return ConditionOutcome
					.match(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
							.foundExactly(""\"""" + location + ""\""""));
		}
		return ConditionOutcome
				.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
						.didNotFind(""any matching JNDI location"").atAll());
	}
	protected boolean isJndiAvailable() {
		return JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable();
	}
	protected JndiLocator getJndiLocator(String[] locations) {
		return new JndiLocator(locations);
	}
	protected static class JndiLocator extends JndiLocatorSupport {
		private String[] locations;
		public JndiLocator(String[] locations) {
			this.locations = locations;
		}
		public String lookupFirstLocation() {
			for (String location : this.locations) {
				try {
					lookup(location);
					return location;
				}
				catch (NamingException ex) {
					// Swallow and continue
				}
			}
			return null;
		}
	}
}",class,
"							.because(""JNDI class not found""));
		}
	}
	private ConditionOutcome getMatchOutcome(String[] locations) {
		if (!isJndiAvailable()) {
			return ConditionOutcome
					.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class)
							.notAvailable(""JNDI environment""));
		}
		if (locations.length == 0) {
			return ConditionOutcome.match(ConditionMessage
					.forCondition(ConditionalOnJndi.class).available(""JNDI environment""));
		}
		JndiLocator locator = getJndiLocator(locations);
		String location = locator.lookupFirstLocation();
		String details = ""("" + StringUtils.arrayToCommaDelimitedString(locations) + "")"";
		if (location != null) {
			return ConditionOutcome
					.match(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
							.foundExactly(""\"""" + location + ""\""""));
		}
		return ConditionOutcome
				.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
						.didNotFind(""any matching JNDI location"").atAll());
	}",class,
"	protected static class JndiLocator extends JndiLocatorSupport {
		private String[] locations;
		public JndiLocator(String[] locations) {
			this.locations = locations;
		}
		public String lookupFirstLocation() {
			for (String location : this.locations) {
				try {
					lookup(location);
					return location;
				}
				catch (NamingException ex) {
					// Swallow and continue
				}
			}
			return null;
		}
	}",class,
"	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context,
			AnnotatedTypeMetadata metadata) {
		AnnotationAttributes annotationAttributes = AnnotationAttributes.fromMap(
				metadata.getAnnotationAttributes(ConditionalOnJndi.class.getName()));
		String[] locations = annotationAttributes.getStringArray(""value"");
		try {
			return getMatchOutcome(locations);
		}
		catch (NoClassDefFoundError ex) {
			return ConditionOutcome
					.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class)
							.because(""JNDI class not found""));
		}
	}",method,
"		catch (NoClassDefFoundError ex) {
			return ConditionOutcome
					.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class)
							.because(""JNDI class not found""));
		}",method,
"	private ConditionOutcome getMatchOutcome(String[] locations) {
		if (!isJndiAvailable()) {
			return ConditionOutcome
					.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class)
							.notAvailable(""JNDI environment""));
		}
		if (locations.length == 0) {
			return ConditionOutcome.match(ConditionMessage
					.forCondition(ConditionalOnJndi.class).available(""JNDI environment""));
		}
		JndiLocator locator = getJndiLocator(locations);
		String location = locator.lookupFirstLocation();
		String details = ""("" + StringUtils.arrayToCommaDelimitedString(locations) + "")"";
		if (location != null) {
			return ConditionOutcome
					.match(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
							.foundExactly(""\"""" + location + ""\""""));
		}
		return ConditionOutcome
				.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
						.didNotFind(""any matching JNDI location"").atAll());
	}",method,
"		if (locations.length == 0) {
			return ConditionOutcome.match(ConditionMessage
					.forCondition(ConditionalOnJndi.class).available(""JNDI environment""));
		}",method,
"		if (location != null) {
			return ConditionOutcome
					.match(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
							.foundExactly(""\"""" + location + ""\""""));
		}",method,
"	protected boolean isJndiAvailable() {
		return JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable();
	}",method,
"	protected JndiLocator getJndiLocator(String[] locations) {
		return new JndiLocator(locations);
	}",method,
"		public JndiLocator(String[] locations) {
			this.locations = locations;
		}",method,
"		public String lookupFirstLocation() {
			for (String location : this.locations) {
				try {
					lookup(location);
					return location;
				}
				catch (NamingException ex) {
					// Swallow and continue
				}
			}
			return null;
		}",method,
"			for (String location : this.locations) {
				try {
					lookup(location);
					return location;
				}
				catch (NamingException ex) {
					// Swallow and continue
				}
			}",method,
"				catch (NamingException ex) {
					// Swallow and continue
				}",method,
"public class ReindexFromRemoteWhitelistTests extends ESTestCase {
    public void testLocalRequestWithoutWhitelist() {
        checkRemoteWhitelist(buildRemoteWhitelist(emptyList()), null);
    }
    public void testLocalRequestWithWhitelist() {
        checkRemoteWhitelist(buildRemoteWhitelist(randomWhitelist()), null);
    }
    private RemoteInfo newRemoteInfo(String host, int port) {
        return new RemoteInfo(randomAlphaOfLength(5), host, port, new BytesArray(""test""), null, null, emptyMap(),
                RemoteInfo.DEFAULT_SOCKET_TIMEOUT, RemoteInfo.DEFAULT_CONNECT_TIMEOUT);
    }
    public void testWhitelistedRemote() {
        List<String> whitelist = randomWhitelist();
        String[] inList = whitelist.iterator().next().split("":"");
        String host = inList[0];
        int port = Integer.valueOf(inList[1]);
        checkRemoteWhitelist(buildRemoteWhitelist(whitelist), newRemoteInfo(host, port));
    }
    public void testWhitelistedByPrefix() {
        checkRemoteWhitelist(buildRemoteWhitelist(singletonList(""*.example.com:9200"")),
                new RemoteInfo(randomAlphaOfLength(5), ""es.example.com"", 9200, new BytesArray(""test""), null, null, emptyMap(),
                        RemoteInfo.DEFAULT_SOCKET_TIMEOUT, RemoteInfo.DEFAULT_CONNECT_TIMEOUT));
        checkRemoteWhitelist(buildRemoteWhitelist(singletonList(""*.example.com:9200"")),
                newRemoteInfo(""6e134134a1.us-east-1.aws.example.com"", 9200));
    }
    public void testWhitelistedBySuffix() {
        checkRemoteWhitelist(buildRemoteWhitelist(singletonList(""es.example.com:*"")), newRemoteInfo(""es.example.com"", 9200));
    }
    public void testWhitelistedByInfix() {
        checkRemoteWhitelist(buildRemoteWhitelist(singletonList(""es*.example.com:9200"")), newRemoteInfo(""es1.example.com"", 9200));
    }
    public void testLoopbackInWhitelistRemote() throws UnknownHostException {
        List<String> whitelist = randomWhitelist();
        whitelist.add(""127.0.0.1:*"");
        checkRemoteWhitelist(buildRemoteWhitelist(whitelist), newRemoteInfo(""127.0.0.1"", 9200));
    }
    public void testUnwhitelistedRemote() {
        int port = between(1, Integer.MAX_VALUE);
        List<String> whitelist = randomBoolean() ? randomWhitelist() : emptyList();
        Exception e = expectThrows(IllegalArgumentException.class,
                () -> checkRemoteWhitelist(buildRemoteWhitelist(whitelist), newRemoteInfo(""not in list"", port)));
        assertEquals(""[not in list:"" + port + ""] not whitelisted in reindex.remote.whitelist"", e.getMessage());
    }
    public void testRejectMatchAll() {
        assertMatchesTooMuch(singletonList(""*""));
        assertMatchesTooMuch(singletonList(""**""));
        assertMatchesTooMuch(singletonList(""***""));
        assertMatchesTooMuch(Arrays.asList(""realstuff"", ""*""));
        assertMatchesTooMuch(Arrays.asList(""*"", ""realstuff""));
        List<String> random = randomWhitelist();
        random.add(""*"");
        assertMatchesTooMuch(random);
    }
    private void assertMatchesTooMuch(List<String> whitelist) {
        Exception e = expectThrows(IllegalArgumentException.class, () -> buildRemoteWhitelist(whitelist));
        assertEquals(""Refusing to start because whitelist "" + whitelist + "" accepts all addresses. ""
                + ""This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs ""
                + ""for them."", e.getMessage());
    }
    private List<String> randomWhitelist() {
        int size = between(1, 100);
        List<String> whitelist = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            whitelist.add(randomAlphaOfLength(5) + ':' + between(1, Integer.MAX_VALUE));
        }
        return whitelist;
    }
}",class,
"    public void testLocalRequestWithoutWhitelist() {
        checkRemoteWhitelist(buildRemoteWhitelist(emptyList()), null);
    }",method,
"    public void testLocalRequestWithWhitelist() {
        checkRemoteWhitelist(buildRemoteWhitelist(randomWhitelist()), null);
    }",method,
"    private RemoteInfo newRemoteInfo(String host, int port) {
        return new RemoteInfo(randomAlphaOfLength(5), host, port, new BytesArray(""test""), null, null, emptyMap(),
                RemoteInfo.DEFAULT_SOCKET_TIMEOUT, RemoteInfo.DEFAULT_CONNECT_TIMEOUT);
    }",method,
"    public void testWhitelistedRemote() {
        List<String> whitelist = randomWhitelist();
        String[] inList = whitelist.iterator().next().split("":"");
        String host = inList[0];
        int port = Integer.valueOf(inList[1]);
        checkRemoteWhitelist(buildRemoteWhitelist(whitelist), newRemoteInfo(host, port));
    }",method,

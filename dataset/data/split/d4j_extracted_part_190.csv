code_snippet,type,score
"	public Vertex<VertexWeight,EdgeWeight> getRoot()
	{
		return root;
	}",method,
"	public Set<Vertex<VertexWeight,EdgeWeight>> getVertices()
	{
		return vertices;
	}",method,
"	public Set<Edge<VertexWeight,EdgeWeight>> getEdges()
	{
		return edges;
	}",method,
"	public void clear()
	{
		counter = 0;
		root = null;
		vertices.clear();
		edges.clear();
	}",method,
"	public void addVertex(Vertex<VertexWeight,EdgeWeight> v)
	{
		if (vertices.size() == 0)
		{
			root = v;
		}
		v.id = counter++;
		vertices.add(v);
	}",method,
"	public void removeVertex(Vertex<VertexWeight,EdgeWeight> v)
	{
		vertices.remove(v);
		if (v == root)
		{
			Iterator<Vertex<VertexWeight,EdgeWeight>> i = vertices.iterator();
			root = i.hasNext() ? i.next() : null;
		}
        Set<Edge<VertexWeight,EdgeWeight>> s = v.getEmanatingEdges();
		if (s != null)
		{
            for (Edge<VertexWeight, EdgeWeight> e : s)
			{
				Vertex<VertexWeight, EdgeWeight> h = e.getHead();
				h.removeIncidentEdge(e);
				h.removePredecessor(v);
				edges.remove(e);
			}
		}
		s = v.getIncidentEdges();
		if (s != null)
		{
            for (Edge<VertexWeight, EdgeWeight> e : s)
			{
				Vertex<VertexWeight, EdgeWeight> t = e.getTail();
				t.removeEmanatingEdge(e);
				t.removeSuccessor(v);
				edges.remove(e);
			}
		}
		normalize();
	}",method,
"		if (v == root)
		{
			Iterator<Vertex<VertexWeight,EdgeWeight>> i = vertices.iterator();
			root = i.hasNext() ? i.next() : null;
		}",method,
"		if (s != null)
		{
            for (Edge<VertexWeight, EdgeWeight> e : s)
			{
				Vertex<VertexWeight, EdgeWeight> h = e.getHead();
				h.removeIncidentEdge(e);
				h.removePredecessor(v);
				edges.remove(e);
			}
		}",method,
"            for (Edge<VertexWeight, EdgeWeight> e : s)
			{
				Vertex<VertexWeight, EdgeWeight> h = e.getHead();
				h.removeIncidentEdge(e);
				h.removePredecessor(v);
				edges.remove(e);
			}",method,
"		if (s != null)
		{
            for (Edge<VertexWeight, EdgeWeight> e : s)
			{
				Vertex<VertexWeight, EdgeWeight> t = e.getTail();
				t.removeEmanatingEdge(e);
				t.removeSuccessor(v);
				edges.remove(e);
			}
		}",method,
"            for (Edge<VertexWeight, EdgeWeight> e : s)
			{
				Vertex<VertexWeight, EdgeWeight> t = e.getTail();
				t.removeEmanatingEdge(e);
				t.removeSuccessor(v);
				edges.remove(e);
			}",method,
"	public void addEdge(Edge<VertexWeight,EdgeWeight> e)
	{
		edges.add(e);
	}",method,
"	public void normalize()
	{
		counter = 0;
		for (Vertex<VertexWeight, EdgeWeight> name : vertices)
        {
			name.id = counter++;
		}
	}",method,
"		for (Vertex<VertexWeight, EdgeWeight> name : vertices)
        {
			name.id = counter++;
		}",method,
"public class CompositeChangeListFilteringStrategy implements ChangeListFilteringStrategy {
  private final TreeMap<CommittedChangesFilterKey, ChangeListFilteringStrategy> myDelegates;
  private boolean myInSetBase;
  public CompositeChangeListFilteringStrategy() {
    myDelegates = new TreeMap<>();
    myInSetBase = false;
  }
  public JComponent getFilterUI() {
    return null;
  }
  @Override
  public CommittedChangesFilterKey getKey() {
    throw new UnsupportedOperationException();
  }
  public void setFilterBase(final List<CommittedChangeList> changeLists) {
    setFilterBaseImpl(changeLists, true);
  }
  private List<CommittedChangeList> setFilterBaseImpl(final List<CommittedChangeList> changeLists, final boolean setFirst) {
    if (myInSetBase) {
      return changeLists;
    }
    myInSetBase = true;
    List<CommittedChangeList> list = new ArrayList<>(changeLists);
    boolean callSetFilterBase = setFirst;
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      if (callSetFilterBase) {
        delegate.setFilterBase(list);
      }
      callSetFilterBase = true;
      list = delegate.filterChangeLists(list);
    }
    myInSetBase = false;
    return list;
  }
  public void addChangeListener(final ChangeListener listener) {
    // not used
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.addChangeListener(listener);
    }
  }
  public void removeChangeListener(final ChangeListener listener) {
    // not used
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.removeChangeListener(listener);
    }
  }
  public void resetFilterBase() {
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.resetFilterBase();
    }
  }
  public void appendFilterBase(final List<CommittedChangeList> changeLists) {
    List<CommittedChangeList> list = new ArrayList<>(changeLists);
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.appendFilterBase(list);
      list = delegate.filterChangeLists(list);
    }
  }
  @NotNull
  public List<CommittedChangeList> filterChangeLists(final List<CommittedChangeList> changeLists) {
    return setFilterBaseImpl(changeLists, false);
  }
  public void addStrategy(final CommittedChangesFilterKey key, final ChangeListFilteringStrategy strategy) {
    myDelegates.put(key, strategy);
  }
  public ChangeListFilteringStrategy removeStrategy(final CommittedChangesFilterKey key) {
    return myDelegates.remove(key);
  }
}",class,
"  public CompositeChangeListFilteringStrategy() {
    myDelegates = new TreeMap<>();
    myInSetBase = false;
  }",method,
"  public JComponent getFilterUI() {
    return null;
  }",method,
"  @Override
  public CommittedChangesFilterKey getKey() {
    throw new UnsupportedOperationException();
  }",method,
"  public void setFilterBase(final List<CommittedChangeList> changeLists) {
    setFilterBaseImpl(changeLists, true);
  }",method,
"  private List<CommittedChangeList> setFilterBaseImpl(final List<CommittedChangeList> changeLists, final boolean setFirst) {
    if (myInSetBase) {
      return changeLists;
    }
    myInSetBase = true;
    List<CommittedChangeList> list = new ArrayList<>(changeLists);
    boolean callSetFilterBase = setFirst;
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      if (callSetFilterBase) {
        delegate.setFilterBase(list);
      }
      callSetFilterBase = true;
      list = delegate.filterChangeLists(list);
    }
    myInSetBase = false;
    return list;
  }",method,
"    if (myInSetBase) {
      return changeLists;
    }",method,
"      if (callSetFilterBase) {
        delegate.setFilterBase(list);
      }",method,
"  public void addChangeListener(final ChangeListener listener) {
    // not used
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.addChangeListener(listener);
    }
  }",method,
"  public void removeChangeListener(final ChangeListener listener) {
    // not used
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.removeChangeListener(listener);
    }
  }",method,
"  public void resetFilterBase() {
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.resetFilterBase();
    }
  }",method,
"  public void appendFilterBase(final List<CommittedChangeList> changeLists) {
    List<CommittedChangeList> list = new ArrayList<>(changeLists);
    for (final ChangeListFilteringStrategy delegate : myDelegates.values()) {
      delegate.appendFilterBase(list);
      list = delegate.filterChangeLists(list);
    }
  }",method,
"  @NotNull
  public List<CommittedChangeList> filterChangeLists(final List<CommittedChangeList> changeLists) {
    return setFilterBaseImpl(changeLists, false);
  }",method,
"  public void addStrategy(final CommittedChangesFilterKey key, final ChangeListFilteringStrategy strategy) {
    myDelegates.put(key, strategy);
  }",method,
"  public ChangeListFilteringStrategy removeStrategy(final CommittedChangesFilterKey key) {
    return myDelegates.remove(key);
  }",method,
"public class DefaultClassLoaderScope extends AbstractClassLoaderScope {
    public static final String STRICT_MODE_PROPERTY = ""org.gradle.classloaderscope.strict"";
    private final ClassLoaderScope parent;
    private boolean locked;
    private ClassPath export = ClassPath.EMPTY;
    private List<ClassLoader> exportLoaders; // if not null, is not empty
    private ClassPath local = ClassPath.EMPTY;
    private List<ClassLoader> ownLoaders;
    // If these are not null, we are pessimistic (loaders asked for before locking)
    private MultiParentClassLoader exportingClassLoader;
    private MultiParentClassLoader localClassLoader;
    // What is actually exposed
    private ClassLoader effectiveLocalClassLoader;
    private ClassLoader effectiveExportClassLoader;
    public DefaultClassLoaderScope(ClassLoaderScopeIdentifier id, ClassLoaderScope parent, ClassLoaderCache classLoaderCache) {
        super(id, classLoaderCache);
        this.parent = parent;
    }
    private ClassLoader buildLockedLoader(ClassLoaderId id, ClassPath classPath) {
        if (classPath.isEmpty()) {
            return parent.getExportClassLoader();
        }
        return loader(id, classPath);
    }
    private ClassLoader buildLockedLoader(ClassLoaderId id, ClassLoader additional, ClassPath classPath) {
        if (classPath.isEmpty()) {
            return additional;
        }
        return new CachingClassLoader(new MultiParentClassLoader(additional, loader(id, classPath)));
    }
    private ClassLoader buildLockedLoader(ClassLoaderId id, ClassPath classPath, List<ClassLoader> loaders) {
        if (loaders != null) {
            return new CachingClassLoader(buildMultiLoader(id, classPath, loaders));
        }
        return buildLockedLoader(id, classPath);
    }
    private MultiParentClassLoader buildMultiLoader(ClassLoaderId id, ClassPath classPath, List<ClassLoader> loaders) {
        int numParents = 1;
        if (loaders != null) {
            numParents += loaders.size();
        }
        if (!classPath.isEmpty()) {
            numParents += 1;
        }
        List<ClassLoader> parents = new ArrayList<ClassLoader>(numParents);
        parents.add(parent.getExportClassLoader());
        if (loaders != null) {
            parents.addAll(loaders);
        }
        if (!classPath.isEmpty()) {
            parents.add(loader(id, classPath));
        }
        return new MultiParentClassLoader(parents);
    }
    private void buildEffectiveLoaders() {
        if (effectiveLocalClassLoader == null) {
            boolean hasExports = !export.isEmpty() || exportLoaders != null;
            boolean hasLocals = !local.isEmpty();
            if (locked) {
                if (hasExports && hasLocals) {
                    effectiveExportClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), effectiveExportClassLoader, local);
                } else if (hasLocals) {
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), local);
                    effectiveExportClassLoader = parent.getExportClassLoader();
                } else if (hasExports) {
                    classLoaderCache.remove(id.localId());
                    effectiveLocalClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveExportClassLoader = effectiveLocalClassLoader;
                } else {
                    classLoaderCache.remove(id.localId());
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = parent.getExportClassLoader();
                    effectiveExportClassLoader = parent.getExportClassLoader();
                }
            } else { // creating before locking, have to create the most flexible setup
                if (Boolean.getBoolean(STRICT_MODE_PROPERTY)) {
                    throw new IllegalStateException(""Attempt to define scope class loader before scope is locked"");
                }
                exportingClassLoader = buildMultiLoader(id.exportId(), export, exportLoaders);
                effectiveExportClassLoader = new CachingClassLoader(exportingClassLoader);
                localClassLoader = new MultiParentClassLoader(effectiveExportClassLoader, loader(id.localId(), local));
                effectiveLocalClassLoader = new CachingClassLoader(localClassLoader);
            }
            export = null;
            exportLoaders = null;
            local = null;
        }
    }
    @Override
    public ClassLoader getExportClassLoader() {
        buildEffectiveLoaders();
        return effectiveExportClassLoader;
    }
    @Override
    public ClassLoader getLocalClassLoader() {
        buildEffectiveLoaders();
        return effectiveLocalClassLoader;
    }
    @Override
    public ClassLoaderScope getParent() {
        return parent;
    }
    @Override
    public boolean defines(Class<?> clazz) {
        if (ownLoaders != null) {
            for (ClassLoader ownLoader : ownLoaders) {
                if (ownLoader.equals(clazz.getClassLoader())) {
                    return true;
                }
            }
        }
        return false;
    }
    private ClassLoader loader(ClassLoaderId id, ClassPath classPath) {
        ClassLoader classLoader = classLoaderCache.get(id, classPath, parent.getExportClassLoader(), null);
        if (ownLoaders == null) {
            ownLoaders = new ArrayList<ClassLoader>();
        }
        ownLoaders.add(classLoader);
        return classLoader;
    }
    @Override
    public ClassLoaderScope local(ClassPath classPath) {
        if (classPath.isEmpty()) {
            return this;
        }
        assertNotLocked();
        if (localClassLoader != null) {
            ClassLoader loader = loader(id.localId(), classPath);
            localClassLoader.addParent(loader);
        } else {
            local = local.plus(classPath);
        }
        return this;
    }
    @Override
    public ClassLoaderScope export(ClassPath classPath) {
        if (classPath.isEmpty()) {
            return this;
        }
        assertNotLocked();
        if (exportingClassLoader != null) {
            exportingClassLoader.addParent(loader(id.exportId(), classPath));
        } else {
            export = export.plus(classPath);
        }
        return this;
    }
    @Override
    public ClassLoaderScope export(ClassLoader classLoader) {
        assertNotLocked();
        if (exportingClassLoader != null) {
            exportingClassLoader.addParent(classLoader);
        } else {
            if (exportLoaders == null) {
                exportLoaders = new ArrayList<ClassLoader>(1);
            }
            exportLoaders.add(classLoader);
        }
        return this;
    }
    private void assertNotLocked() {
        if (locked) {
            throw new IllegalStateException(""class loader scope is locked"");
        }
    }
    @Override
    public ClassLoaderScope lock() {
        locked = true;
        return this;
    }
    @Override
    public boolean isLocked() {
        return locked;
    }
}",class,
"                    throw new IllegalStateException(""Attempt to define scope class loader before scope is locked"");
                }
                exportingClassLoader = buildMultiLoader(id.exportId(), export, exportLoaders);
                effectiveExportClassLoader = new CachingClassLoader(exportingClassLoader);
                localClassLoader = new MultiParentClassLoader(effectiveExportClassLoader, loader(id.localId(), local));
                effectiveLocalClassLoader = new CachingClassLoader(localClassLoader);
            }
            export = null;
            exportLoaders = null;
            local = null;
        }
    }
    @Override
    public ClassLoader getExportClassLoader() {
        buildEffectiveLoaders();
        return effectiveExportClassLoader;
    }",class,
"            throw new IllegalStateException(""class loader scope is locked"");
        }
    }
    @Override
    public ClassLoaderScope lock() {
        locked = true;
        return this;
    }",class,
"    public DefaultClassLoaderScope(ClassLoaderScopeIdentifier id, ClassLoaderScope parent, ClassLoaderCache classLoaderCache) {
        super(id, classLoaderCache);
        this.parent = parent;
    }",method,
"    private ClassLoader buildLockedLoader(ClassLoaderId id, ClassPath classPath) {
        if (classPath.isEmpty()) {
            return parent.getExportClassLoader();
        }
        return loader(id, classPath);
    }",method,
"    private ClassLoader buildLockedLoader(ClassLoaderId id, ClassLoader additional, ClassPath classPath) {
        if (classPath.isEmpty()) {
            return additional;
        }
        return new CachingClassLoader(new MultiParentClassLoader(additional, loader(id, classPath)));
    }",method,
"    private ClassLoader buildLockedLoader(ClassLoaderId id, ClassPath classPath, List<ClassLoader> loaders) {
        if (loaders != null) {
            return new CachingClassLoader(buildMultiLoader(id, classPath, loaders));
        }
        return buildLockedLoader(id, classPath);
    }",method,
"        if (loaders != null) {
            return new CachingClassLoader(buildMultiLoader(id, classPath, loaders));
        }",method,
"    private MultiParentClassLoader buildMultiLoader(ClassLoaderId id, ClassPath classPath, List<ClassLoader> loaders) {
        int numParents = 1;
        if (loaders != null) {
            numParents += loaders.size();
        }
        if (!classPath.isEmpty()) {
            numParents += 1;
        }
        List<ClassLoader> parents = new ArrayList<ClassLoader>(numParents);
        parents.add(parent.getExportClassLoader());
        if (loaders != null) {
            parents.addAll(loaders);
        }
        if (!classPath.isEmpty()) {
            parents.add(loader(id, classPath));
        }
        return new MultiParentClassLoader(parents);
    }",method,
"        if (loaders != null) {
            numParents += loaders.size();
        }",method,
"        if (loaders != null) {
            parents.addAll(loaders);
        }",method,
"    private void buildEffectiveLoaders() {
        if (effectiveLocalClassLoader == null) {
            boolean hasExports = !export.isEmpty() || exportLoaders != null;
            boolean hasLocals = !local.isEmpty();
            if (locked) {
                if (hasExports && hasLocals) {
                    effectiveExportClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), effectiveExportClassLoader, local);
                } else if (hasLocals) {
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), local);
                    effectiveExportClassLoader = parent.getExportClassLoader();
                } else if (hasExports) {
                    classLoaderCache.remove(id.localId());
                    effectiveLocalClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveExportClassLoader = effectiveLocalClassLoader;
                } else {
                    classLoaderCache.remove(id.localId());
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = parent.getExportClassLoader();
                    effectiveExportClassLoader = parent.getExportClassLoader();
                }
            } else { // creating before locking, have to create the most flexible setup
                if (Boolean.getBoolean(STRICT_MODE_PROPERTY)) {
                    throw new IllegalStateException(""Attempt to define scope class loader before scope is locked"");
                }
                exportingClassLoader = buildMultiLoader(id.exportId(), export, exportLoaders);
                effectiveExportClassLoader = new CachingClassLoader(exportingClassLoader);
                localClassLoader = new MultiParentClassLoader(effectiveExportClassLoader, loader(id.localId(), local));
                effectiveLocalClassLoader = new CachingClassLoader(localClassLoader);
            }
            export = null;
            exportLoaders = null;
            local = null;
        }
    }",method,
"        if (effectiveLocalClassLoader == null) {
            boolean hasExports = !export.isEmpty() || exportLoaders != null;
            boolean hasLocals = !local.isEmpty();
            if (locked) {
                if (hasExports && hasLocals) {
                    effectiveExportClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), effectiveExportClassLoader, local);
                } else if (hasLocals) {
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), local);
                    effectiveExportClassLoader = parent.getExportClassLoader();
                } else if (hasExports) {
                    classLoaderCache.remove(id.localId());
                    effectiveLocalClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveExportClassLoader = effectiveLocalClassLoader;
                } else {
                    classLoaderCache.remove(id.localId());
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = parent.getExportClassLoader();
                    effectiveExportClassLoader = parent.getExportClassLoader();
                }
            } else { // creating before locking, have to create the most flexible setup
                if (Boolean.getBoolean(STRICT_MODE_PROPERTY)) {
                    throw new IllegalStateException(""Attempt to define scope class loader before scope is locked"");
                }
                exportingClassLoader = buildMultiLoader(id.exportId(), export, exportLoaders);
                effectiveExportClassLoader = new CachingClassLoader(exportingClassLoader);
                localClassLoader = new MultiParentClassLoader(effectiveExportClassLoader, loader(id.localId(), local));
                effectiveLocalClassLoader = new CachingClassLoader(localClassLoader);
            }
            export = null;
            exportLoaders = null;
            local = null;
        }",method,
"            if (locked) {
                if (hasExports && hasLocals) {
                    effectiveExportClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), effectiveExportClassLoader, local);
                } else if (hasLocals) {
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), local);
                    effectiveExportClassLoader = parent.getExportClassLoader();
                } else if (hasExports) {
                    classLoaderCache.remove(id.localId());
                    effectiveLocalClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveExportClassLoader = effectiveLocalClassLoader;
                } else {
                    classLoaderCache.remove(id.localId());
                    classLoaderCache.remove(id.exportId());
                    effectiveLocalClassLoader = parent.getExportClassLoader();
                    effectiveExportClassLoader = parent.getExportClassLoader();
                }
            }",method,
"                if (hasExports && hasLocals) {
                    effectiveExportClassLoader = buildLockedLoader(id.exportId(), export, exportLoaders);
                    effectiveLocalClassLoader = buildLockedLoader(id.localId(), effectiveExportClassLoader, local);
                }",method,
"    @Override
    public ClassLoader getExportClassLoader() {
        buildEffectiveLoaders();
        return effectiveExportClassLoader;
    }",method,
"    @Override
    public ClassLoader getLocalClassLoader() {
        buildEffectiveLoaders();
        return effectiveLocalClassLoader;
    }",method,
"    @Override
    public ClassLoaderScope getParent() {
        return parent;
    }",method,
"    @Override
    public boolean defines(Class<?> clazz) {
        if (ownLoaders != null) {
            for (ClassLoader ownLoader : ownLoaders) {
                if (ownLoader.equals(clazz.getClassLoader())) {
                    return true;
                }
            }
        }
        return false;
    }",method,
"        if (ownLoaders != null) {
            for (ClassLoader ownLoader : ownLoaders) {
                if (ownLoader.equals(clazz.getClassLoader())) {
                    return true;
                }
            }
        }",method,
"            for (ClassLoader ownLoader : ownLoaders) {
                if (ownLoader.equals(clazz.getClassLoader())) {
                    return true;
                }
            }",method,
"    private ClassLoader loader(ClassLoaderId id, ClassPath classPath) {
        ClassLoader classLoader = classLoaderCache.get(id, classPath, parent.getExportClassLoader(), null);
        if (ownLoaders == null) {
            ownLoaders = new ArrayList<ClassLoader>();
        }
        ownLoaders.add(classLoader);
        return classLoader;
    }",method,
"        if (ownLoaders == null) {
            ownLoaders = new ArrayList<ClassLoader>();
        }",method,
"    @Override
    public ClassLoaderScope local(ClassPath classPath) {
        if (classPath.isEmpty()) {
            return this;
        }
        assertNotLocked();
        if (localClassLoader != null) {
            ClassLoader loader = loader(id.localId(), classPath);
            localClassLoader.addParent(loader);
        } else {
            local = local.plus(classPath);
        }
        return this;
    }",method,
"        if (localClassLoader != null) {
            ClassLoader loader = loader(id.localId(), classPath);
            localClassLoader.addParent(loader);
        }",method,
"    @Override
    public ClassLoaderScope export(ClassPath classPath) {
        if (classPath.isEmpty()) {
            return this;
        }
        assertNotLocked();
        if (exportingClassLoader != null) {
            exportingClassLoader.addParent(loader(id.exportId(), classPath));
        } else {
            export = export.plus(classPath);
        }
        return this;
    }",method,
"        if (exportingClassLoader != null) {
            exportingClassLoader.addParent(loader(id.exportId(), classPath));
        }",method,
"    @Override
    public ClassLoaderScope export(ClassLoader classLoader) {
        assertNotLocked();
        if (exportingClassLoader != null) {
            exportingClassLoader.addParent(classLoader);
        } else {
            if (exportLoaders == null) {
                exportLoaders = new ArrayList<ClassLoader>(1);
            }
            exportLoaders.add(classLoader);
        }
        return this;
    }",method,
"        if (exportingClassLoader != null) {
            exportingClassLoader.addParent(classLoader);
        }",method,
"            if (exportLoaders == null) {
                exportLoaders = new ArrayList<ClassLoader>(1);
            }",method,
"    private void assertNotLocked() {
        if (locked) {
            throw new IllegalStateException(""class loader scope is locked"");
        }
    }",method,
"        if (locked) {
            throw new IllegalStateException(""class loader scope is locked"");
        }",method,
"    @Override
    public ClassLoaderScope lock() {
        locked = true;
        return this;
    }",method,
"    @Override
    public boolean isLocked() {
        return locked;
    }",method,
"public class Demo2 extends Activity {
    ViewGroup mSceneRoot;
    static Scene mCurrentScene;
    boolean mFirstTime = true;
    Scene mSearchScreen, mResultsScreen;
    TransitionManager mTransitionManager = null;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.search_screen);
        View container = findViewById(R.id.container);
        mSceneRoot = (ViewGroup) container.getParent();
    }
    public void sendMessage(View view) {
        if (mFirstTime) {
            mFirstTime = false;
            // Non-resource approach of creating scenes
//        mSearchScreen = new Scene(this, mSceneRoot, R.layout.search_screen);
//        mResultsScreen = new Scene(this, mSceneRoot, R.layout.results_screen);
            try {
                mSearchScreen = Scene.getSceneForLayout(mSceneRoot, R.layout.search_screen, this);
                mResultsScreen = Scene.getSceneForLayout(mSceneRoot, R.layout.search_screen, this);
            } catch (Exception e) {
                System.out.println(""Problem loading scene resource: "" + e);
            }
            TransitionSet transition = new TransitionSet();
            transition.addTransition(new Fade().addTarget(R.id.resultsText).
                    addTarget(R.id.resultsList)).
                    addTransition(new ChangeBounds().addTarget(R.id.searchContainer)).
                    addTransition(new Recolor().addTarget(R.id.container));
            mTransitionManager = new TransitionManager();
            mTransitionManager.setTransition(mSearchScreen, transition);
            mTransitionManager.setTransition(mResultsScreen, transition);
        }
        if (mCurrentScene == mResultsScreen) {
            mTransitionManager.transitionTo(mSearchScreen);
            mCurrentScene = mSearchScreen;
        } else {
            mTransitionManager.transitionTo(mResultsScreen);
            mCurrentScene = mResultsScreen;
        }
    }
}",class,
"    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.search_screen);
        View container = findViewById(R.id.container);
        mSceneRoot = (ViewGroup) container.getParent();
    }",method,
"    public void sendMessage(View view) {
        if (mFirstTime) {
            mFirstTime = false;
            // Non-resource approach of creating scenes
//        mSearchScreen = new Scene(this, mSceneRoot, R.layout.search_screen);
//        mResultsScreen = new Scene(this, mSceneRoot, R.layout.results_screen);
            try {
                mSearchScreen = Scene.getSceneForLayout(mSceneRoot, R.layout.search_screen, this);
                mResultsScreen = Scene.getSceneForLayout(mSceneRoot, R.layout.search_screen, this);
            } catch (Exception e) {
                System.out.println(""Problem loading scene resource: "" + e);
            }
            TransitionSet transition = new TransitionSet();
            transition.addTransition(new Fade().addTarget(R.id.resultsText).
                    addTarget(R.id.resultsList)).
                    addTransition(new ChangeBounds().addTarget(R.id.searchContainer)).
                    addTransition(new Recolor().addTarget(R.id.container));
            mTransitionManager = new TransitionManager();
            mTransitionManager.setTransition(mSearchScreen, transition);
            mTransitionManager.setTransition(mResultsScreen, transition);
        }
        if (mCurrentScene == mResultsScreen) {
            mTransitionManager.transitionTo(mSearchScreen);
            mCurrentScene = mSearchScreen;
        } else {
            mTransitionManager.transitionTo(mResultsScreen);
            mCurrentScene = mResultsScreen;
        }
    }",method,
"        if (mFirstTime) {
            mFirstTime = false;
            // Non-resource approach of creating scenes
//        mSearchScreen = new Scene(this, mSceneRoot, R.layout.search_screen);
//        mResultsScreen = new Scene(this, mSceneRoot, R.layout.results_screen);
            try {
                mSearchScreen = Scene.getSceneForLayout(mSceneRoot, R.layout.search_screen, this);
                mResultsScreen = Scene.getSceneForLayout(mSceneRoot, R.layout.search_screen, this);
            } catch (Exception e) {
                System.out.println(""Problem loading scene resource: "" + e);
            }
            TransitionSet transition = new TransitionSet();
            transition.addTransition(new Fade().addTarget(R.id.resultsText).
                    addTarget(R.id.resultsList)).
                    addTransition(new ChangeBounds().addTarget(R.id.searchContainer)).
                    addTransition(new Recolor().addTarget(R.id.container));
            mTransitionManager = new TransitionManager();
            mTransitionManager.setTransition(mSearchScreen, transition);
            mTransitionManager.setTransition(mResultsScreen, transition);
        }",method,
"        if (mCurrentScene == mResultsScreen) {
            mTransitionManager.transitionTo(mSearchScreen);
            mCurrentScene = mSearchScreen;
        }",method,
"public class PublishToMavenRepositoryHook extends AbstractPublishToMaven {
    private MavenArtifactRepository repository;
    public MavenArtifactRepository getRepository() {
        return repository;
    }
    public void setRepository(MavenArtifactRepository repository) {
        this.repository = repository;
    }
    @TaskAction
    public void publish() {
        MavenPublicationInternal publicationInternal = getPublicationInternal();
        if (publicationInternal == null) {
            throw new InvalidUserDataException(""The 'publication' property is required"");
        }
        MavenArtifactRepository repository = getRepository();
        if (repository == null) {
            throw new InvalidUserDataException(""The 'repository' property is required"");
        }
        doPublish(publicationInternal, repository);
    }
    private void doPublish(final MavenPublicationInternal publication,
                           final MavenArtifactRepository repository) {
        new PublishOperation(publication, repository.getName()) {
            @Override
            protected void publish() throws Exception {
                try {
                    MavenPublisher remotePublisher = new MavenRemotePublisher(
                            getLoggingManagerFactory(),
                            getMavenRepositoryLocator(),
                            getTemporaryDirFactory(),
                            getRepositoryTransportFactory());
                    MavenPublisher staticLockingPublisher = new StaticLockingMavenPublisher(
                            remotePublisher);
                    MavenPublisher validatingPublisher = new ValidatingMavenPublisher(
                            staticLockingPublisher);
                    validatingPublisher.publish(publication.asNormalisedPublication(), repository);
                } catch (Throwable e) {
                    String message = e.getMessage();
                    if (message.contains(""Could not write to resource"") &&
                            !publication.getVersion().endsWith(""SNAPSHOT"")) {
                        throw new GradleException(""无法deploy release版本，请通过mtl平台打包发布"",e);
                    }
                    if (message.contains(""status code 400"") &&
                            !publication.getVersion().endsWith(""SNAPSHOT"")) {
                        throw new GradleException(""您发布的版本 "" +
                                                          publication.getVersion() +
                                                          "" 在仓库里已经存在"",e);
                    }
                    if (message.contains(""status code 413"")) {
                        throw new GradleException(""您发布超过200M，无法上传"",e);
                    }
                    throw e;
                }
            }
        }.run();
    }
    @Inject
    protected RepositoryTransportFactory getRepositoryTransportFactory() {
        throw new UnsupportedOperationException();
    }
}",class,
"    public MavenArtifactRepository getRepository() {
        return repository;
    }",method,
"    public void setRepository(MavenArtifactRepository repository) {
        this.repository = repository;
    }",method,
"    @TaskAction
    public void publish() {
        MavenPublicationInternal publicationInternal = getPublicationInternal();
        if (publicationInternal == null) {
            throw new InvalidUserDataException(""The 'publication' property is required"");
        }
        MavenArtifactRepository repository = getRepository();
        if (repository == null) {
            throw new InvalidUserDataException(""The 'repository' property is required"");
        }
        doPublish(publicationInternal, repository);
    }",method,
"        if (publicationInternal == null) {
            throw new InvalidUserDataException(""The 'publication' property is required"");
        }",method,
"        if (repository == null) {
            throw new InvalidUserDataException(""The 'repository' property is required"");
        }",method,
"    private void doPublish(final MavenPublicationInternal publication,
                           final MavenArtifactRepository repository) {
        new PublishOperation(publication, repository.getName()) {
            @Override
            protected void publish() throws Exception {
                try {
                    MavenPublisher remotePublisher = new MavenRemotePublisher(
                            getLoggingManagerFactory(),
                            getMavenRepositoryLocator(),
                            getTemporaryDirFactory(),
                            getRepositoryTransportFactory());
                    MavenPublisher staticLockingPublisher = new StaticLockingMavenPublisher(
                            remotePublisher);
                    MavenPublisher validatingPublisher = new ValidatingMavenPublisher(
                            staticLockingPublisher);
                    validatingPublisher.publish(publication.asNormalisedPublication(), repository);
                } catch (Throwable e) {
                    String message = e.getMessage();
                    if (message.contains(""Could not write to resource"") &&
                            !publication.getVersion().endsWith(""SNAPSHOT"")) {
                        throw new GradleException(""无法deploy release版本，请通过mtl平台打包发布"",e);
                    }
                    if (message.contains(""status code 400"") &&
                            !publication.getVersion().endsWith(""SNAPSHOT"")) {
                        throw new GradleException(""您发布的版本 "" +
                                                          publication.getVersion() +
                                                          "" 在仓库里已经存在"",e);
                    }
                    if (message.contains(""status code 413"")) {
                        throw new GradleException(""您发布超过200M，无法上传"",e);
                    }
                    throw e;
                }
            }
        }.run();
    }",method,
"            @Override
            protected void publish() throws Exception {
                try {
                    MavenPublisher remotePublisher = new MavenRemotePublisher(
                            getLoggingManagerFactory(),
                            getMavenRepositoryLocator(),
                            getTemporaryDirFactory(),
                            getRepositoryTransportFactory());
                    MavenPublisher staticLockingPublisher = new StaticLockingMavenPublisher(
                            remotePublisher);
                    MavenPublisher validatingPublisher = new ValidatingMavenPublisher(
                            staticLockingPublisher);
                    validatingPublisher.publish(publication.asNormalisedPublication(), repository);
                } catch (Throwable e) {
                    String message = e.getMessage();
                    if (message.contains(""Could not write to resource"") &&
                            !publication.getVersion().endsWith(""SNAPSHOT"")) {
                        throw new GradleException(""无法deploy release版本，请通过mtl平台打包发布"",e);
                    }
                    if (message.contains(""status code 400"") &&
                            !publication.getVersion().endsWith(""SNAPSHOT"")) {
                        throw new GradleException(""您发布的版本 "" +
                                                          publication.getVersion() +
                                                          "" 在仓库里已经存在"",e);
                    }
                    if (message.contains(""status code 413"")) {
                        throw new GradleException(""您发布超过200M，无法上传"",e);
                    }
                    throw e;
                }
            }",method,
"    @Inject
    protected RepositoryTransportFactory getRepositoryTransportFactory() {
        throw new UnsupportedOperationException();
    }",method,
"import java.util.Set;
class AssistedConstructor<T> {
    private final Constructor<T> constructor;
    private final ParameterListKey assistedParameters;
    private final List<Parameter> allParameters;
    @SuppressWarnings(""unchecked"")
    AssistedConstructor(Constructor<T> constructor, List<TypeLiteral<?>> parameterTypes) {
        this.constructor = constructor;
        Annotation[][] annotations = constructor.getParameterAnnotations();
        List<Type> typeList = new ArrayList<>();
        allParameters = new ArrayList<>(parameterTypes.size());
        // categorize params as @Assisted or @Injected
        for (int i = 0; i < parameterTypes.size(); i++) {
            Parameter parameter = new Parameter(parameterTypes.get(i).getType(), annotations[i]);
            allParameters.add(parameter);
            if (parameter.isProvidedByFactory()) {
                typeList.add(parameter.getType());
            }
        }
        this.assistedParameters = new ParameterListKey(typeList);
    }
    public ParameterListKey getAssistedParameters() {
        return assistedParameters;
    }
    public List<Parameter> getAllParameters() {
        return allParameters;
    }
    public Set<Class<?>> getDeclaredExceptions() {
        return new HashSet<>(Arrays.asList(constructor.getExceptionTypes()));
    }
    public T newInstance(Object[] args) throws Throwable {
        try {
            return constructor.newInstance(args);
        } catch (InvocationTargetException e) {
            throw e.getCause();
        }
    }
    @Override
    public String toString() {
        return constructor.toString();
    }
}",class,
"    @SuppressWarnings(""unchecked"")
    AssistedConstructor(Constructor<T> constructor, List<TypeLiteral<?>> parameterTypes) {
        this.constructor = constructor;
        Annotation[][] annotations = constructor.getParameterAnnotations();
        List<Type> typeList = new ArrayList<>();
        allParameters = new ArrayList<>(parameterTypes.size());
        // categorize params as @Assisted or @Injected
        for (int i = 0; i < parameterTypes.size(); i++) {
            Parameter parameter = new Parameter(parameterTypes.get(i).getType(), annotations[i]);
            allParameters.add(parameter);
            if (parameter.isProvidedByFactory()) {
                typeList.add(parameter.getType());
            }
        }
        this.assistedParameters = new ParameterListKey(typeList);
    }",method,
"    public ParameterListKey getAssistedParameters() {
        return assistedParameters;
    }",method,
"    public List<Parameter> getAllParameters() {
        return allParameters;
    }",method,
"    public Set<Class<?>> getDeclaredExceptions() {
        return new HashSet<>(Arrays.asList(constructor.getExceptionTypes()));
    }",method,
"    public T newInstance(Object[] args) throws Throwable {
        try {
            return constructor.newInstance(args);
        } catch (InvocationTargetException e) {
            throw e.getCause();
        }
    }",method,
"    @Override
    public String toString() {
        return constructor.toString();
    }",method,
"public class Batch implements Closeable {
    private final List<Queueable> elements;
    private final LongVector seqNums;
    private final Queue queue;
    private final AtomicBoolean closed;
    public Batch(List<Queueable> elements, LongVector seqNums, Queue q) {
        this.elements = elements;
        this.seqNums = seqNums;
        this.queue = q;
        this.closed = new AtomicBoolean(false);
    }
    // close acks the batch ackable events
    public void close() throws IOException {
        if (closed.getAndSet(true) == false) {
              this.queue.ack(this.seqNums);
        } else {
            // TODO: how should we handle double-closing?
            throw new IOException(""double closing batch"");
        }
    }
    public int size() {
        return elements.size();
    }
    public List<? extends Queueable> getElements() {
        return elements;
    }
    public LongVector getSeqNums() { return this.seqNums; }
    public Queue getQueue() {
        return queue;
    }
}",class,
"public class Checkpoint {
//    Checkpoint file structure see FileCheckpointIO
    public static final int VERSION = 1;
    private final int pageNum;             // local per-page page number
    private final int firstUnackedPageNum; // queue-wide global pointer, only valid in the head checkpoint
    private final long firstUnackedSeqNum; // local per-page unacknowledged tracking
    private final long minSeqNum;          // local per-page minimum seqNum
    private final int elementCount;        // local per-page element count
    public Checkpoint(int pageNum, int firstUnackedPageNum, long firstUnackedSeqNum, long minSeqNum, int elementCount) {
        this.pageNum = pageNum;
        this.firstUnackedPageNum = firstUnackedPageNum;
        this.firstUnackedSeqNum = firstUnackedSeqNum;
        this.minSeqNum = minSeqNum;
        this.elementCount = elementCount;
    }
    public int getPageNum() {
        return this.pageNum;
    }
    public int getFirstUnackedPageNum() {
        return this.firstUnackedPageNum;
    }
    public long getFirstUnackedSeqNum() {
        return this.firstUnackedSeqNum;
    }
    public long getMinSeqNum() {
        return this.minSeqNum;
    }
    public int getElementCount() {
        return this.elementCount;
    }
    // @return true if this checkpoint indicates a fulle acked page
    public boolean isFullyAcked() {
        return this.elementCount > 0 && this.firstUnackedSeqNum >= this.minSeqNum + this.elementCount;
    }
    // @return the highest seqNum in this page or -1 for an initial checkpoint
    public long maxSeqNum() {
        return this.minSeqNum + this.elementCount - 1;
    }
    public String toString() {
        return ""pageNum="" + this.pageNum + "", firstUnackedPageNum="" + this.firstUnackedPageNum + "", firstUnackedSeqNum="" + this.firstUnackedSeqNum + "", minSeqNum="" + this.minSeqNum + "", elementCount="" + this.elementCount + "", isFullyAcked="" + (this.isFullyAcked() ? ""yes"" : ""no"");
    }
    public boolean equals(Checkpoint other) {
        if (this == other ) { return true; }
        return (this.pageNum == other.pageNum && this.firstUnackedPageNum == other.firstUnackedPageNum && this.firstUnackedSeqNum == other.firstUnackedSeqNum && this.minSeqNum == other.minSeqNum && this.elementCount == other.elementCount);
    }
}",class,
"    public Batch(List<Queueable> elements, LongVector seqNums, Queue q) {
        this.elements = elements;
        this.seqNums = seqNums;
        this.queue = q;
        this.closed = new AtomicBoolean(false);
    }",method,
"    public void close() throws IOException {
        if (closed.getAndSet(true) == false) {
              this.queue.ack(this.seqNums);
        } else {
            // TODO: how should we handle double-closing?
            throw new IOException(""double closing batch"");
        }
    }",method,
"    public int size() {
        return elements.size();
    }",method,
"    public List<? extends Queueable> getElements() {
        return elements;
    }",method,
    public LongVector getSeqNums() { return this.seqNums; },method,
"    public Queue getQueue() {
        return queue;
    }",method,
"    public Checkpoint(int pageNum, int firstUnackedPageNum, long firstUnackedSeqNum, long minSeqNum, int elementCount) {
        this.pageNum = pageNum;
        this.firstUnackedPageNum = firstUnackedPageNum;
        this.firstUnackedSeqNum = firstUnackedSeqNum;
        this.minSeqNum = minSeqNum;
        this.elementCount = elementCount;
    }",method,
"    public int getPageNum() {
        return this.pageNum;
    }",method,
"    public int getFirstUnackedPageNum() {
        return this.firstUnackedPageNum;
    }",method,
"    public long getFirstUnackedSeqNum() {
        return this.firstUnackedSeqNum;
    }",method,
"    public long getMinSeqNum() {
        return this.minSeqNum;
    }",method,
"    public int getElementCount() {
        return this.elementCount;
    }",method,
"    public boolean isFullyAcked() {
        return this.elementCount > 0 && this.firstUnackedSeqNum >= this.minSeqNum + this.elementCount;
    }",method,
"    public long maxSeqNum() {
        return this.minSeqNum + this.elementCount - 1;
    }",method,
"    public String toString() {
        return ""pageNum="" + this.pageNum + "", firstUnackedPageNum="" + this.firstUnackedPageNum + "", firstUnackedSeqNum="" + this.firstUnackedSeqNum + "", minSeqNum="" + this.minSeqNum + "", elementCount="" + this.elementCount + "", isFullyAcked="" + (this.isFullyAcked() ? ""yes"" : ""no"");
    }",method,

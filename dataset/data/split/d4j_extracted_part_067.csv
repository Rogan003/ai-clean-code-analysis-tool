code_snippet,type,score
"    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) {
        return false;
    }",method,
"    @Override
    public ChannelFuture register(Channel channel) {
        return register(new DefaultChannelPromise(channel, this));
    }",method,
"    @Override
    public ChannelFuture register(ChannelPromise promise) {
        ObjectUtil.checkNotNull(promise, ""promise"");
        promise.channel().unsafe().register(this, promise);
        return promise;
    }",method,
"    @Deprecated
    @Override
    public ChannelFuture register(Channel channel, ChannelPromise promise) {
        channel.unsafe().register(this, promise);
        return promise;
    }",method,
"    @Override
    public boolean inEventLoop() {
        return true;
    }",method,
"    @Override
    public boolean inEventLoop(Thread thread) {
        return true;
    }",method,
"public class GroovyResultOfObjectAllocationIgnoredInspection extends BaseInspection {
  @Override
  @Nls
  @NotNull
  public String getDisplayName() {
    return ""Result of object allocation ignored"";
  }
  @Override
  @Nullable
  protected String buildErrorString(Object... args) {
    return ""Result of <code>new #ref"" + (args[0].equals(new Integer(0)) ? ""()"" : ""[]"") + ""</code> is ignored #loc"";
  }
  @Override
  public boolean isEnabledByDefault() {
    return true;
  }
  @NotNull
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new Visitor();
  }
  private static class Visitor extends BaseInspectionVisitor {
    @Override
    public void visitNewExpression(@NotNull GrNewExpression newExpression) {
      super.visitNewExpression(newExpression);
      final GrCodeReferenceElement refElement = newExpression.getReferenceElement();
      if (refElement == null) return;      //new expression is not correct so we shouldn't check it
      final PsiElement parent = newExpression.getParent();
      if (parent instanceof GrCodeBlock || parent instanceof GroovyFile) {
        if (parent instanceof GrOpenBlock || parent instanceof GrClosableBlock) {
          if (ControlFlowUtils.openBlockCompletesWithStatement(((GrCodeBlock)parent), newExpression)) {
            return;
          }
        }
        registerError(refElement, newExpression.getArrayCount());
      }
    }
  }
}",class,
"  private static class Visitor extends BaseInspectionVisitor {
    @Override
    public void visitNewExpression(@NotNull GrNewExpression newExpression) {
      super.visitNewExpression(newExpression);
      final GrCodeReferenceElement refElement = newExpression.getReferenceElement();
      if (refElement == null) return;      //new expression is not correct so we shouldn't check it
      final PsiElement parent = newExpression.getParent();
      if (parent instanceof GrCodeBlock || parent instanceof GroovyFile) {
        if (parent instanceof GrOpenBlock || parent instanceof GrClosableBlock) {
          if (ControlFlowUtils.openBlockCompletesWithStatement(((GrCodeBlock)parent), newExpression)) {
            return;
          }
        }
        registerError(refElement, newExpression.getArrayCount());
      }
    }
  }",class,
"  @Override
  @Nls
  @NotNull
  public String getDisplayName() {
    return ""Result of object allocation ignored"";
  }",method,
"  @Override
  @Nullable
  protected String buildErrorString(Object... args) {
    return ""Result of <code>new #ref"" + (args[0].equals(new Integer(0)) ? ""()"" : ""[]"") + ""</code> is ignored #loc"";
  }",method,
"  @Override
  public boolean isEnabledByDefault() {
    return true;
  }",method,
"  @NotNull
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new Visitor();
  }",method,
"    @Override
    public void visitNewExpression(@NotNull GrNewExpression newExpression) {
      super.visitNewExpression(newExpression);
      final GrCodeReferenceElement refElement = newExpression.getReferenceElement();
      if (refElement == null) return;      //new expression is not correct so we shouldn't check it
      final PsiElement parent = newExpression.getParent();
      if (parent instanceof GrCodeBlock || parent instanceof GroovyFile) {
        if (parent instanceof GrOpenBlock || parent instanceof GrClosableBlock) {
          if (ControlFlowUtils.openBlockCompletesWithStatement(((GrCodeBlock)parent), newExpression)) {
            return;
          }
        }
        registerError(refElement, newExpression.getArrayCount());
      }
    }",method,
"      if (parent instanceof GrCodeBlock || parent instanceof GroovyFile) {
        if (parent instanceof GrOpenBlock || parent instanceof GrClosableBlock) {
          if (ControlFlowUtils.openBlockCompletesWithStatement(((GrCodeBlock)parent), newExpression)) {
            return;
          }
        }
        registerError(refElement, newExpression.getArrayCount());
      }",method,
"        if (parent instanceof GrOpenBlock || parent instanceof GrClosableBlock) {
          if (ControlFlowUtils.openBlockCompletesWithStatement(((GrCodeBlock)parent), newExpression)) {
            return;
          }
        }",method,
"public class StartActivity extends BaseGameActivity {
	// ===========================================================
	// Constants
	// ===========================================================
	private static final int CAMERA_WIDTH = 480;
	private static final int CAMERA_HEIGHT = 320;
	// ===========================================================
	// Fields
	// ===========================================================
	private Camera mCamera;
	private Texture mTexture, mBatTexture;
	private TextureRegion mSplashTextureRegion;
	private TiledTextureRegion mBatTextureRegion;
	private Handler mHandler;
	// ===========================================================
	// Constructors
	// ===========================================================
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	@Override
	public Engine onLoadEngine() {
		mHandler = new Handler();
		this.mCamera = new Camera(0, 0, CAMERA_WIDTH, CAMERA_HEIGHT);
		return new Engine(new EngineOptions(true, ScreenOrientation.LANDSCAPE, new RatioResolutionPolicy(CAMERA_WIDTH, CAMERA_HEIGHT), this.mCamera));
	}
	@Override
	public void onLoadResources() {
		TextureRegionFactory.setAssetBasePath(""gfx/Splash/"");
		this.mTexture = new Texture(512, 1024, TextureOptions.BILINEAR_PREMULTIPLYALPHA);
		this.mSplashTextureRegion = TextureRegionFactory.createFromAsset(this.mTexture, this, ""Splashscreen.png"", 0, 0);
		this.mBatTexture = new Texture(256, 256, TextureOptions.DEFAULT);
		this.mBatTextureRegion = TextureRegionFactory.createTiledFromAsset(this.mBatTexture, this, ""bat_tiled.png"", 0, 0, 2, 2);
		//this.mBatTextureRegion = TextureRegionFactory.createTiledFromAsset(this.mTexture, this, ""bat_tiled.png"", 0, 513, 2, 2);
		this.mEngine.getTextureManager().loadTexture(this.mTexture);
		this.mEngine.getTextureManager().loadTexture(this.mBatTexture);
	}
	@Override
	public Scene onLoadScene() {
		this.mEngine.registerUpdateHandler(new FPSLogger());
		final Scene scene = new Scene(1);
		final int centerX = (CAMERA_WIDTH - this.mSplashTextureRegion.getWidth()) / 2;
		final int centerY = (CAMERA_HEIGHT - this.mSplashTextureRegion.getHeight()) / 2;
		final Sprite splash = new Sprite(centerX, centerY, this.mSplashTextureRegion);
		scene.getLastChild().attachChild(splash);
		final AnimatedSprite bat = new AnimatedSprite(350, 100, this.mBatTextureRegion);
		bat.animate(100);
		scene.getLastChild().attachChild(bat);
		return scene;
	}
	@Override
	public void onLoadComplete() {
		mHandler.postDelayed(mLaunchTask,5000);
	}
    private Runnable mLaunchTask = new Runnable() {
        public void run() {
    		Intent myIntent = new Intent(StartActivity.this, MainMenuActivity.class);
    		StartActivity.this.startActivity(myIntent);
    		StartActivity.this.finish();
        }
     };
	// ===========================================================
	// Methods
	// ===========================================================
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	@Override
	public Engine onLoadEngine() {
		mHandler = new Handler();
		this.mCamera = new Camera(0, 0, CAMERA_WIDTH, CAMERA_HEIGHT);
		return new Engine(new EngineOptions(true, ScreenOrientation.LANDSCAPE, new RatioResolutionPolicy(CAMERA_WIDTH, CAMERA_HEIGHT), this.mCamera));
	}",method,
"	@Override
	public void onLoadResources() {
		TextureRegionFactory.setAssetBasePath(""gfx/Splash/"");
		this.mTexture = new Texture(512, 1024, TextureOptions.BILINEAR_PREMULTIPLYALPHA);
		this.mSplashTextureRegion = TextureRegionFactory.createFromAsset(this.mTexture, this, ""Splashscreen.png"", 0, 0);
		this.mBatTexture = new Texture(256, 256, TextureOptions.DEFAULT);
		this.mBatTextureRegion = TextureRegionFactory.createTiledFromAsset(this.mBatTexture, this, ""bat_tiled.png"", 0, 0, 2, 2);
		//this.mBatTextureRegion = TextureRegionFactory.createTiledFromAsset(this.mTexture, this, ""bat_tiled.png"", 0, 513, 2, 2);
		this.mEngine.getTextureManager().loadTexture(this.mTexture);
		this.mEngine.getTextureManager().loadTexture(this.mBatTexture);
	}",method,
"	@Override
	public Scene onLoadScene() {
		this.mEngine.registerUpdateHandler(new FPSLogger());
		final Scene scene = new Scene(1);
		final int centerX = (CAMERA_WIDTH - this.mSplashTextureRegion.getWidth()) / 2;
		final int centerY = (CAMERA_HEIGHT - this.mSplashTextureRegion.getHeight()) / 2;
		final Sprite splash = new Sprite(centerX, centerY, this.mSplashTextureRegion);
		scene.getLastChild().attachChild(splash);
		final AnimatedSprite bat = new AnimatedSprite(350, 100, this.mBatTextureRegion);
		bat.animate(100);
		scene.getLastChild().attachChild(bat);
		return scene;
	}",method,
"	@Override
	public void onLoadComplete() {
		mHandler.postDelayed(mLaunchTask,5000);
	}",method,
"        public void run() {
    		Intent myIntent = new Intent(StartActivity.this, MainMenuActivity.class);
    		StartActivity.this.startActivity(myIntent);
    		StartActivity.this.finish();
        }",method,
"public class NioEventLoopTest extends AbstractEventLoopTest {
    @Override
    protected EventLoopGroup newEventLoopGroup() {
        return new NioEventLoopGroup();
    }
    @Override
    protected Class<? extends ServerSocketChannel> newChannel() {
        return NioServerSocketChannel.class;
    }
    @Test
    public void testRebuildSelector() throws Exception {
        EventLoopGroup group = new NioEventLoopGroup(1);
        final NioEventLoop loop = (NioEventLoop) group.next();
        try {
            Channel channel = new NioServerSocketChannel();
            loop.register(channel).syncUninterruptibly();
            Selector selector = loop.unwrappedSelector();
            assertSame(selector, ((NioEventLoop) channel.eventLoop()).unwrappedSelector());
            assertTrue(selector.isOpen());
            // Submit to the EventLoop so we are sure its really executed in a non-async manner.
            loop.submit(new Runnable() {
                @Override
                public void run() {
                    loop.rebuildSelector();
                }
            }).syncUninterruptibly();
            Selector newSelector = ((NioEventLoop) channel.eventLoop()).unwrappedSelector();
            assertTrue(newSelector.isOpen());
            assertNotSame(selector, newSelector);
            assertFalse(selector.isOpen());
            channel.close().syncUninterruptibly();
        } finally {
            group.shutdownGracefully();
        }
    }
}",class,
"    @Override
    protected EventLoopGroup newEventLoopGroup() {
        return new NioEventLoopGroup();
    }",method,
"    @Override
    protected Class<? extends ServerSocketChannel> newChannel() {
        return NioServerSocketChannel.class;
    }",method,
"    @Test
    public void testRebuildSelector() throws Exception {
        EventLoopGroup group = new NioEventLoopGroup(1);
        final NioEventLoop loop = (NioEventLoop) group.next();
        try {
            Channel channel = new NioServerSocketChannel();
            loop.register(channel).syncUninterruptibly();
            Selector selector = loop.unwrappedSelector();
            assertSame(selector, ((NioEventLoop) channel.eventLoop()).unwrappedSelector());
            assertTrue(selector.isOpen());
            // Submit to the EventLoop so we are sure its really executed in a non-async manner.
            loop.submit(new Runnable() {
                @Override
                public void run() {
                    loop.rebuildSelector();
                }
            }).syncUninterruptibly();
            Selector newSelector = ((NioEventLoop) channel.eventLoop()).unwrappedSelector();
            assertTrue(newSelector.isOpen());
            assertNotSame(selector, newSelector);
            assertFalse(selector.isOpen());
            channel.close().syncUninterruptibly();
        } finally {
            group.shutdownGracefully();
        }
    }",method,
"            loop.submit(new Runnable() {
                @Override
                public void run() {
                    loop.rebuildSelector();
                }
            }",method,
"                @Override
                public void run() {
                    loop.rebuildSelector();
                }",method,
"public class DelegationPanel extends JPanel {
  private final JRadioButton myRbModifyCalls;
  private final JRadioButton myRbGenerateDelegate;
  public DelegationPanel() {
    final BoxLayout boxLayout = new BoxLayout(this, BoxLayout.X_AXIS);
    setLayout(boxLayout);
    add(new JLabel(RefactoringBundle.message(""delegation.panel.method.calls.label"")));
    myRbModifyCalls = new JRadioButton();
    myRbModifyCalls.setText(RefactoringBundle.message(""delegation.panel.modify.radio""));
    add(myRbModifyCalls);
    myRbGenerateDelegate = new JRadioButton();
    myRbGenerateDelegate.setText(RefactoringBundle.message(""delegation.panel.delegate.via.overloading.method""));
    add(myRbGenerateDelegate);
    myRbModifyCalls.setSelected(true);
    final ButtonGroup bg = new ButtonGroup();
    bg.add(myRbModifyCalls);
    bg.add(myRbGenerateDelegate);
    add(Box.createHorizontalGlue());
    myRbModifyCalls.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }
    });
    myRbGenerateDelegate.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }
    });
  }
  protected void stateModified() {
  }
  public boolean isModifyCalls() {
    return myRbModifyCalls.isSelected();
  }
  public boolean isGenerateDelegate() {
    return myRbGenerateDelegate.isSelected();
  }
}",class,
"  public DelegationPanel() {
    final BoxLayout boxLayout = new BoxLayout(this, BoxLayout.X_AXIS);
    setLayout(boxLayout);
    add(new JLabel(RefactoringBundle.message(""delegation.panel.method.calls.label"")));
    myRbModifyCalls = new JRadioButton();
    myRbModifyCalls.setText(RefactoringBundle.message(""delegation.panel.modify.radio""));
    add(myRbModifyCalls);
    myRbGenerateDelegate = new JRadioButton();
    myRbGenerateDelegate.setText(RefactoringBundle.message(""delegation.panel.delegate.via.overloading.method""));
    add(myRbGenerateDelegate);
    myRbModifyCalls.setSelected(true);
    final ButtonGroup bg = new ButtonGroup();
    bg.add(myRbModifyCalls);
    bg.add(myRbGenerateDelegate);
    add(Box.createHorizontalGlue());
    myRbModifyCalls.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }
    });
    myRbGenerateDelegate.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }
    });
  }",method,
"    myRbModifyCalls.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }
    }",method,
"      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }",method,
"    myRbGenerateDelegate.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }
    }",method,
"      @Override
      public void itemStateChanged(ItemEvent e) {
        stateModified();
      }",method,
"  protected void stateModified() {
  }",method,
"  public boolean isModifyCalls() {
    return myRbModifyCalls.isSelected();
  }",method,
"  public boolean isGenerateDelegate() {
    return myRbGenerateDelegate.isSelected();
  }",method,
"public class Handler implements PageHandler<Context> {
	@Inject
	private JspViewer m_jspViewer;
	@Inject
	private PayloadNormalizer m_normalizePayload;
	@Inject
	private ProductLineConfigManager m_productLineConfigManager;
	@Inject
	private GraphCreator m_graphCreator;
	@Override
	@PayloadMeta(Payload.class)
	@InboundActionMeta(name = ""database"")
	public void handleInbound(Context ctx) throws ServletException, IOException {
	}
	@Override
	@OutboundActionMeta(name = ""database"")
	public void handleOutbound(Context ctx) throws ServletException, IOException {
		Model model = new Model(ctx);
		Payload payload = ctx.getPayload();
		normalize(model, payload);
		long date = payload.getDate();
		int timeRange = payload.getTimeRange();
		Date start = new Date(date - (timeRange - 1) * TimeHelper.ONE_HOUR);
		Date end = new Date(date + TimeHelper.ONE_HOUR);
		switch (payload.getAction()) {
		case VIEW:
			Map<String, LineChart> charts = m_graphCreator.buildChartsByProductLine(payload.getGroup(),
			      payload.getProduct(), start, end);
			model.setLineCharts(new ArrayList<LineChart>(charts.values()));
			model.setGroups(DatabaseGroup.KEY_GROUPS.keySet());
			break;
		}
		m_jspViewer.view(ctx, model);
	}
	private void normalize(Model model, Payload payload) {
		List<ProductLine> databases = new ArrayList<ProductLine>(m_productLineConfigManager.queryDatabaseProductLines()
		      .values());
		model.setPage(ReportPage.DATABASE);
		model.setProductLines(databases);
		model.setAction(payload.getAction());
		m_normalizePayload.normalize(model, payload);
		if (StringUtils.isEmpty(payload.getProduct())) {
			if (databases.size() > 0) {
				payload.setProduct(databases.get(0).getId());
			} else {
				payload.setProduct(""Default"");
			}
		}
		int timeRange = payload.getTimeRange();
		Date startTime = new Date(payload.getDate() - (timeRange - 1) * TimeHelper.ONE_HOUR);
		Date endTime = new Date(payload.getDate() + TimeHelper.ONE_HOUR - 1);
		model.setStartTime(startTime);
		model.setEndTime(endTime);
	}
}",class,
"	@Override
	@PayloadMeta(Payload.class)
	@InboundActionMeta(name = ""database"")
	public void handleInbound(Context ctx) throws ServletException, IOException {
	}",method,
"	@Override
	@OutboundActionMeta(name = ""database"")
	public void handleOutbound(Context ctx) throws ServletException, IOException {
		Model model = new Model(ctx);
		Payload payload = ctx.getPayload();
		normalize(model, payload);
		long date = payload.getDate();
		int timeRange = payload.getTimeRange();
		Date start = new Date(date - (timeRange - 1) * TimeHelper.ONE_HOUR);
		Date end = new Date(date + TimeHelper.ONE_HOUR);
		switch (payload.getAction()) {
		case VIEW:
			Map<String, LineChart> charts = m_graphCreator.buildChartsByProductLine(payload.getGroup(),
			      payload.getProduct(), start, end);
			model.setLineCharts(new ArrayList<LineChart>(charts.values()));
			model.setGroups(DatabaseGroup.KEY_GROUPS.keySet());
			break;
		}
		m_jspViewer.view(ctx, model);
	}",method,
"	private void normalize(Model model, Payload payload) {
		List<ProductLine> databases = new ArrayList<ProductLine>(m_productLineConfigManager.queryDatabaseProductLines()
		      .values());
		model.setPage(ReportPage.DATABASE);
		model.setProductLines(databases);
		model.setAction(payload.getAction());
		m_normalizePayload.normalize(model, payload);
		if (StringUtils.isEmpty(payload.getProduct())) {
			if (databases.size() > 0) {
				payload.setProduct(databases.get(0).getId());
			} else {
				payload.setProduct(""Default"");
			}
		}
		int timeRange = payload.getTimeRange();
		Date startTime = new Date(payload.getDate() - (timeRange - 1) * TimeHelper.ONE_HOUR);
		Date endTime = new Date(payload.getDate() + TimeHelper.ONE_HOUR - 1);
		model.setStartTime(startTime);
		model.setEndTime(endTime);
	}",method,
"	private JspFile(String path) {
		m_path = path;
	}",method,
"	public String getPath() {
		return m_path;
	}",method,
"public class DefaultCacheableService implements CacheableService<Long> {
	private final AtomicLong counter = new AtomicLong();
	private final AtomicLong nullInvocations = new AtomicLong();
	@Override
	@Cacheable(""testCache"")
	public Long cache(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(""testCache"")
	public Long cacheNull(Object arg1) {
		return null;
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long cacheSync(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long cacheSyncNull(Object arg1) {
		return null;
	}
	@Override
	@CacheEvict(""testCache"")
	public void invalidate(Object arg1) {
	}
	@Override
	@CacheEvict(""testCache"")
	public void evictWithException(Object arg1) {
		throw new RuntimeException(""exception thrown - evict should NOT occur"");
	}
	@Override
	@CacheEvict(cacheNames = ""testCache"", allEntries = true)
	public void evictAll(Object arg1) {
	}
	@Override
	@CacheEvict(cacheNames = ""testCache"", beforeInvocation = true)
	public void evictEarly(Object arg1) {
		throw new RuntimeException(""exception thrown - evict should still occur"");
	}
	@Override
	@CacheEvict(cacheNames = ""testCache"", key = ""#p0"")
	public void evict(Object arg1, Object arg2) {
	}
	@Override
	@CacheEvict(cacheNames = ""testCache"", key = ""#p0"", beforeInvocation = true)
	public void invalidateEarly(Object arg1, Object arg2) {
		throw new RuntimeException(""exception thrown - evict should still occur"");
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", condition = ""#p0 == 3"")
	public Long conditional(int classField) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true, condition = ""#p0 == 3"")
	public Long conditionalSync(int field) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", unless = ""#result > 10"")
	public Long unless(int arg) {
		return (long) arg;
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", key = ""#p0"")
	public Long key(Object arg1, Object arg2) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"")
	public Long varArgsKey(Object... args) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", key = ""#root.methodName"")
	public Long name(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", key = ""#root.methodName + #root.method.name + #root.targetClass + #root.target"")
	public Long rootVars(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", keyGenerator = ""customKeyGenerator"")
	public Long customKeyGenerator(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", keyGenerator = ""unknownBeanName"")
	public Long unknownCustomKeyGenerator(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", cacheManager = ""customCacheManager"")
	public Long customCacheManager(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", cacheManager = ""unknownBeanName"")
	public Long unknownCustomCacheManager(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@CachePut(""testCache"")
	public Long update(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@CachePut(cacheNames = ""testCache"", condition = ""#arg.equals(3)"")
	public Long conditionalUpdate(Object arg) {
		return Long.valueOf(arg.toString());
	}
	@Override
	@Cacheable(""testCache"")
	public Long nullValue(Object arg1) {
		nullInvocations.incrementAndGet();
		return null;
	}
	@Override
	public Number nullInvocations() {
		return nullInvocations.get();
	}
	@Override
	@Cacheable(""testCache"")
	public Long throwChecked(Object arg1) throws Exception {
		throw new IOException(arg1.toString());
	}
	@Override
	@Cacheable(""testCache"")
	public Long throwUnchecked(Object arg1) {
		throw new UnsupportedOperationException(arg1.toString());
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long throwCheckedSync(Object arg1) throws Exception {
		throw new IOException(arg1.toString());
	}
	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long throwUncheckedSync(Object arg1) {
		throw new UnsupportedOperationException(arg1.toString());
	}
	// multi annotations
	@Override
	@Caching(cacheable = { @Cacheable(""primary""), @Cacheable(""secondary"") })
	public Long multiCache(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Caching(evict = { @CacheEvict(""primary""), @CacheEvict(cacheNames = ""secondary"", key = ""#p0""), @CacheEvict(cacheNames = ""primary"", key = ""#p0 + 'A'"") })
	public Long multiEvict(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Caching(cacheable = { @Cacheable(cacheNames = ""primary"", key = ""#root.methodName"") }, evict = { @CacheEvict(""secondary"") })
	public Long multiCacheAndEvict(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Caching(cacheable = { @Cacheable(cacheNames = ""primary"", condition = ""#p0 == 3"") }, evict = { @CacheEvict(""secondary"") })
	public Long multiConditionalCacheAndEvict(Object arg1) {
		return counter.getAndIncrement();
	}
	@Override
	@Caching(put = { @CachePut(""primary""), @CachePut(""secondary"") })
	public Long multiUpdate(Object arg1) {
		return Long.valueOf(arg1.toString());
	}
	@Override
	@CachePut(cacheNames = ""primary"", key = ""#result.id"")
	public TestEntity putRefersToResult(TestEntity arg1) {
		arg1.setId(Long.MIN_VALUE);
		return arg1;
	}
}",class,
"	@Override
	@Cacheable(""testCache"")
	public Long cache(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(""testCache"")
	public Long cacheNull(Object arg1) {
		return null;
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long cacheSync(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long cacheSyncNull(Object arg1) {
		return null;
	}",method,
"	@Override
	@CacheEvict(""testCache"")
	public void invalidate(Object arg1) {
	}",method,
"	@Override
	@CacheEvict(""testCache"")
	public void evictWithException(Object arg1) {
		throw new RuntimeException(""exception thrown - evict should NOT occur"");
	}",method,
"	@Override
	@CacheEvict(cacheNames = ""testCache"", allEntries = true)
	public void evictAll(Object arg1) {
	}",method,
"	@Override
	@CacheEvict(cacheNames = ""testCache"", beforeInvocation = true)
	public void evictEarly(Object arg1) {
		throw new RuntimeException(""exception thrown - evict should still occur"");
	}",method,
"	@Override
	@CacheEvict(cacheNames = ""testCache"", key = ""#p0"")
	public void evict(Object arg1, Object arg2) {
	}",method,
"	@Override
	@CacheEvict(cacheNames = ""testCache"", key = ""#p0"", beforeInvocation = true)
	public void invalidateEarly(Object arg1, Object arg2) {
		throw new RuntimeException(""exception thrown - evict should still occur"");
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", condition = ""#p0 == 3"")
	public Long conditional(int classField) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true, condition = ""#p0 == 3"")
	public Long conditionalSync(int field) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", unless = ""#result > 10"")
	public Long unless(int arg) {
		return (long) arg;
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", key = ""#p0"")
	public Long key(Object arg1, Object arg2) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"")
	public Long varArgsKey(Object... args) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", key = ""#root.methodName"")
	public Long name(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", key = ""#root.methodName + #root.method.name + #root.targetClass + #root.target"")
	public Long rootVars(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", keyGenerator = ""customKeyGenerator"")
	public Long customKeyGenerator(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", keyGenerator = ""unknownBeanName"")
	public Long unknownCustomKeyGenerator(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", cacheManager = ""customCacheManager"")
	public Long customCacheManager(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", cacheManager = ""unknownBeanName"")
	public Long unknownCustomCacheManager(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@CachePut(""testCache"")
	public Long update(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@CachePut(cacheNames = ""testCache"", condition = ""#arg.equals(3)"")
	public Long conditionalUpdate(Object arg) {
		return Long.valueOf(arg.toString());
	}",method,
"	@Override
	@Cacheable(""testCache"")
	public Long nullValue(Object arg1) {
		nullInvocations.incrementAndGet();
		return null;
	}",method,
"	@Override
	public Number nullInvocations() {
		return nullInvocations.get();
	}",method,
"	@Override
	@Cacheable(""testCache"")
	public Long throwChecked(Object arg1) throws Exception {
		throw new IOException(arg1.toString());
	}",method,
"	@Override
	@Cacheable(""testCache"")
	public Long throwUnchecked(Object arg1) {
		throw new UnsupportedOperationException(arg1.toString());
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long throwCheckedSync(Object arg1) throws Exception {
		throw new IOException(arg1.toString());
	}",method,
"	@Override
	@Cacheable(cacheNames = ""testCache"", sync = true)
	public Long throwUncheckedSync(Object arg1) {
		throw new UnsupportedOperationException(arg1.toString());
	}",method,
"	@Override
	@Caching(cacheable = { @Cacheable(""primary""), @Cacheable(""secondary"") })
	public Long multiCache(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Caching(evict = { @CacheEvict(""primary""), @CacheEvict(cacheNames = ""secondary"", key = ""#p0""), @CacheEvict(cacheNames = ""primary"", key = ""#p0 + 'A'"") })
	public Long multiEvict(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Caching(cacheable = { @Cacheable(cacheNames = ""primary"", key = ""#root.methodName"") }, evict = { @CacheEvict(""secondary"") })
	public Long multiCacheAndEvict(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Caching(cacheable = { @Cacheable(cacheNames = ""primary"", condition = ""#p0 == 3"") }, evict = { @CacheEvict(""secondary"") })
	public Long multiConditionalCacheAndEvict(Object arg1) {
		return counter.getAndIncrement();
	}",method,
"	@Override
	@Caching(put = { @CachePut(""primary""), @CachePut(""secondary"") })
	public Long multiUpdate(Object arg1) {
		return Long.valueOf(arg1.toString());
	}",method,
"	@Override
	@CachePut(cacheNames = ""primary"", key = ""#result.id"")
	public TestEntity putRefersToResult(TestEntity arg1) {
		arg1.setId(Long.MIN_VALUE);
		return arg1;
	}",method,
"public class ShardOrganizationManager
{
    private static final Logger log = Logger.get(ShardOrganizationManager.class);
    private final ScheduledExecutorService discoveryService = newScheduledThreadPool(1, daemonThreadsNamed(""shard-organization-discovery""));
    private final AtomicBoolean started = new AtomicBoolean();
    private final IDBI dbi;
    private final MetadataDao metadataDao;
    private final ShardOrganizerDao organizerDao;
    private final ShardManager shardManager;
    private final boolean enabled;
    private final long organizationIntervalMillis;
    private final String currentNodeIdentifier;
    private final ShardOrganizer organizer;
    private final Set<Long> tablesInProgress = newConcurrentHashSet();
    @Inject
    public ShardOrganizationManager(
            @ForMetadata IDBI dbi,
            NodeManager nodeManager,
            ShardManager shardManager,
            ShardOrganizer organizer,
            StorageManagerConfig config)
    {
        this(dbi,
                nodeManager.getCurrentNode().getNodeIdentifier(),
                shardManager,
                organizer,
                config.isOrganizationEnabled(),
                config.getOrganizationInterval());
    }
    public ShardOrganizationManager(
            IDBI dbi,
            String currentNodeIdentifier,
            ShardManager shardManager,
            ShardOrganizer organizer,
            boolean enabled,
            Duration organizationInterval)
    {
        this.dbi = requireNonNull(dbi, ""dbi is null"");
        this.metadataDao = onDemandDao(dbi, MetadataDao.class);
        this.organizerDao = onDemandDao(dbi, ShardOrganizerDao.class);
        this.organizer = requireNonNull(organizer, ""organizer is null"");
        this.shardManager = requireNonNull(shardManager, ""shardManager is null"");
        this.currentNodeIdentifier = requireNonNull(currentNodeIdentifier, ""currentNodeIdentifier is null"");
        this.enabled = enabled;
        requireNonNull(organizationInterval, ""organizationInterval is null"");
        this.organizationIntervalMillis = max(1, organizationInterval.roundTo(MILLISECONDS));
    }
    @PostConstruct
    public void start()
    {
        if (!enabled || started.getAndSet(true)) {
            return;
        }
        startDiscovery();
    }
    @PreDestroy
    public void shutdown()
    {
        discoveryService.shutdownNow();
    }
    private void startDiscovery()
    {
        discoveryService.scheduleWithFixedDelay(() -> {
            try {
                // jitter to avoid overloading database
                SECONDS.sleep(ThreadLocalRandom.current().nextLong(1, 5 * 60));
                log.info(""Running shard organizer..."");
                submitJobs(discoverAndInitializeTablesToOrganize());
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            catch (Throwable t) {
                log.error(t, ""Error running shard organizer"");
            }
        }, 0, 5, MINUTES);
    }
    @VisibleForTesting
    Set<Long> discoverAndInitializeTablesToOrganize()
    {
        Set<Long> enabledTableIds = metadataDao.getOrganizationEligibleTables();
        Set<TableOrganizationInfo> tableOrganizationInfo = organizerDao.getNodeTableOrganizationInfo(currentNodeIdentifier);
        Map<Long, TableOrganizationInfo> organizationInfos = Maps.uniqueIndex(tableOrganizationInfo, TableOrganizationInfo::getTableId);
        // If this is the first time organizing a table, initialize the organization info for it
        difference(enabledTableIds, organizationInfos.keySet())
                .forEach(tableId -> organizerDao.insertNode(currentNodeIdentifier, tableId));
        ImmutableSet.Builder<Long> tableIds = ImmutableSet.builder();
        for (Long tableId : enabledTableIds) {
            TableOrganizationInfo info = organizationInfos.get(tableId);
            if (info == null || shouldRunOrganization(info)) {
                tableIds.add(tableId);
            }
        }
        return tableIds.build();
    }
    private void submitJobs(Set<Long> tableIds)
    {
        tableIds.forEach(this::runOrganization);
    }
    private void runOrganization(long tableId)
    {
        Set<ShardMetadata> shardMetadatas = shardManager.getNodeShards(currentNodeIdentifier, tableId);
        Table tableInfo = metadataDao.getTableInformation(tableId);
        Set<ShardMetadata> filteredShards = shardMetadatas.stream()
                .filter(shard -> !organizer.inProgress(shard.getShardUuid()))
                .collect(toSet());
        Collection<ShardIndexInfo> indexInfos = getOrganizationEligibleShards(dbi, metadataDao, tableInfo, filteredShards, true);
        Set<OrganizationSet> organizationSets = createOrganizationSets(tableInfo, indexInfos);
        if (organizationSets.isEmpty()) {
            return;
        }
        log.info(""Created %s organization set(s) from %s shards for table ID %s"", organizationSets.size(), filteredShards.size(), tableId);
        long lastStartTime = System.currentTimeMillis();
        tablesInProgress.add(tableId);
        ImmutableList.Builder<CompletableFuture<?>> futures = ImmutableList.builder();
        for (OrganizationSet organizationSet : organizationSets) {
            futures.add(organizer.enqueue(organizationSet));
        }
        allAsList(futures.build())
                .whenComplete((value, throwable) -> {
                    tablesInProgress.remove(tableId);
                    organizerDao.updateLastStartTime(currentNodeIdentifier, tableId, lastStartTime);
                });
    }
    private boolean shouldRunOrganization(TableOrganizationInfo info)
    {
        // skip if organization is in progress for this table
        if (tablesInProgress.contains(info.getTableId())) {
            return false;
        }
        if (!info.getLastStartTimeMillis().isPresent()) {
            return true;
        }
        return (System.currentTimeMillis() - info.getLastStartTimeMillis().getAsLong()) >= organizationIntervalMillis;
    }
    @VisibleForTesting
    static Set<OrganizationSet> createOrganizationSets(Table tableInfo, Collection<ShardIndexInfo> shards)
    {
        return getShardsByDaysBuckets(tableInfo, shards).stream()
                .map(indexInfos -> getOverlappingOrganizationSets(tableInfo, indexInfos))
                .flatMap(Collection::stream)
                .collect(toSet());
    }
    private static Set<OrganizationSet> getOverlappingOrganizationSets(Table tableInfo, Collection<ShardIndexInfo> shards)
    {
        if (shards.size() <= 1) {
            return ImmutableSet.of();
        }
        // Sort by low marker for the range
        List<ShardIndexInfo> sortedShards = shards.stream()
                .sorted((o1, o2) -> {
                    ShardRange sortRange1 = o1.getSortRange().get();
                    ShardRange sortRange2 = o2.getSortRange().get();
                    return ComparisonChain.start()
                            .compare(sortRange1.getMinTuple(), sortRange2.getMinTuple())
                            .compare(sortRange2.getMaxTuple(), sortRange1.getMaxTuple())
                            .result();
                })
                .collect(toList());
        Set<OrganizationSet> organizationSets = new HashSet<>();
        ImmutableSet.Builder<ShardIndexInfo> builder = ImmutableSet.builder();
        builder.add(sortedShards.get(0));
        int previousRange = 0;
        int nextRange = previousRange + 1;
        while (nextRange < sortedShards.size()) {
            ShardRange sortRange1 = sortedShards.get(previousRange).getSortRange().get();
            ShardRange sortRange2 = sortedShards.get(nextRange).getSortRange().get();
            if (sortRange1.overlaps(sortRange2) && !sortRange1.adjacent(sortRange2)) {
                builder.add(sortedShards.get(nextRange));
                if (!sortRange1.encloses(sortRange2)) {
                    previousRange = nextRange;
                }
            }
            else {
                Set<ShardIndexInfo> indexInfos = builder.build();
                if (indexInfos.size() > 1) {
                    organizationSets.add(createOrganizationSet(tableInfo.getTableId(), indexInfos));
                }
                builder = ImmutableSet.builder();
                previousRange = nextRange;
                builder.add(sortedShards.get(previousRange));
            }
            nextRange++;
        }
        Set<ShardIndexInfo> indexInfos = builder.build();
        if (indexInfos.size() > 1) {
            organizationSets.add(createOrganizationSet(tableInfo.getTableId(), indexInfos));
        }
        return organizationSets;
    }
}",class,
"    @Inject
    public ShardOrganizationManager(
            @ForMetadata IDBI dbi,
            NodeManager nodeManager,
            ShardManager shardManager,
            ShardOrganizer organizer,
            StorageManagerConfig config)
    {
        this(dbi,
                nodeManager.getCurrentNode().getNodeIdentifier(),
                shardManager,
                organizer,
                config.isOrganizationEnabled(),
                config.getOrganizationInterval());
    }",method,
"    public ShardOrganizationManager(
            IDBI dbi,
            String currentNodeIdentifier,
            ShardManager shardManager,
            ShardOrganizer organizer,
            boolean enabled,
            Duration organizationInterval)
    {
        this.dbi = requireNonNull(dbi, ""dbi is null"");
        this.metadataDao = onDemandDao(dbi, MetadataDao.class);
        this.organizerDao = onDemandDao(dbi, ShardOrganizerDao.class);
        this.organizer = requireNonNull(organizer, ""organizer is null"");
        this.shardManager = requireNonNull(shardManager, ""shardManager is null"");
        this.currentNodeIdentifier = requireNonNull(currentNodeIdentifier, ""currentNodeIdentifier is null"");
        this.enabled = enabled;
        requireNonNull(organizationInterval, ""organizationInterval is null"");
        this.organizationIntervalMillis = max(1, organizationInterval.roundTo(MILLISECONDS));
    }",method,
"    @PostConstruct
    public void start()
    {
        if (!enabled || started.getAndSet(true)) {
            return;
        }
        startDiscovery();
    }",method,
"    @PreDestroy
    public void shutdown()
    {
        discoveryService.shutdownNow();
    }",method,
"    private void startDiscovery()
    {
        discoveryService.scheduleWithFixedDelay(() -> {
            try {
                // jitter to avoid overloading database
                SECONDS.sleep(ThreadLocalRandom.current().nextLong(1, 5 * 60));
                log.info(""Running shard organizer..."");
                submitJobs(discoverAndInitializeTablesToOrganize());
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            catch (Throwable t) {
                log.error(t, ""Error running shard organizer"");
            }
        }, 0, 5, MINUTES);
    }",method,
"            catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }",method,
"            catch (Throwable t) {
                log.error(t, ""Error running shard organizer"");
            }",method,
"    @VisibleForTesting
    Set<Long> discoverAndInitializeTablesToOrganize()
    {
        Set<Long> enabledTableIds = metadataDao.getOrganizationEligibleTables();
        Set<TableOrganizationInfo> tableOrganizationInfo = organizerDao.getNodeTableOrganizationInfo(currentNodeIdentifier);
        Map<Long, TableOrganizationInfo> organizationInfos = Maps.uniqueIndex(tableOrganizationInfo, TableOrganizationInfo::getTableId);
        // If this is the first time organizing a table, initialize the organization info for it
        difference(enabledTableIds, organizationInfos.keySet())
                .forEach(tableId -> organizerDao.insertNode(currentNodeIdentifier, tableId));
        ImmutableSet.Builder<Long> tableIds = ImmutableSet.builder();
        for (Long tableId : enabledTableIds) {
            TableOrganizationInfo info = organizationInfos.get(tableId);
            if (info == null || shouldRunOrganization(info)) {
                tableIds.add(tableId);
            }
        }
        return tableIds.build();
    }",method,
"        for (Long tableId : enabledTableIds) {
            TableOrganizationInfo info = organizationInfos.get(tableId);
            if (info == null || shouldRunOrganization(info)) {
                tableIds.add(tableId);
            }
        }",method,
"    private void submitJobs(Set<Long> tableIds)
    {
        tableIds.forEach(this::runOrganization);
    }",method,
"    private void runOrganization(long tableId)
    {
        Set<ShardMetadata> shardMetadatas = shardManager.getNodeShards(currentNodeIdentifier, tableId);
        Table tableInfo = metadataDao.getTableInformation(tableId);
        Set<ShardMetadata> filteredShards = shardMetadatas.stream()
                .filter(shard -> !organizer.inProgress(shard.getShardUuid()))
                .collect(toSet());
        Collection<ShardIndexInfo> indexInfos = getOrganizationEligibleShards(dbi, metadataDao, tableInfo, filteredShards, true);
        Set<OrganizationSet> organizationSets = createOrganizationSets(tableInfo, indexInfos);
        if (organizationSets.isEmpty()) {
            return;
        }
        log.info(""Created %s organization set(s) from %s shards for table ID %s"", organizationSets.size(), filteredShards.size(), tableId);
        long lastStartTime = System.currentTimeMillis();
        tablesInProgress.add(tableId);
        ImmutableList.Builder<CompletableFuture<?>> futures = ImmutableList.builder();
        for (OrganizationSet organizationSet : organizationSets) {
            futures.add(organizer.enqueue(organizationSet));
        }
        allAsList(futures.build())
                .whenComplete((value, throwable) -> {
                    tablesInProgress.remove(tableId);
                    organizerDao.updateLastStartTime(currentNodeIdentifier, tableId, lastStartTime);
                });
    }",method,
"        for (OrganizationSet organizationSet : organizationSets) {
            futures.add(organizer.enqueue(organizationSet));
        }",method,
"    private boolean shouldRunOrganization(TableOrganizationInfo info)
    {
        // skip if organization is in progress for this table
        if (tablesInProgress.contains(info.getTableId())) {
            return false;
        }
        if (!info.getLastStartTimeMillis().isPresent()) {
            return true;
        }
        return (System.currentTimeMillis() - info.getLastStartTimeMillis().getAsLong()) >= organizationIntervalMillis;
    }",method,
"    @VisibleForTesting
    static Set<OrganizationSet> createOrganizationSets(Table tableInfo, Collection<ShardIndexInfo> shards)
    {
        return getShardsByDaysBuckets(tableInfo, shards).stream()
                .map(indexInfos -> getOverlappingOrganizationSets(tableInfo, indexInfos))
                .flatMap(Collection::stream)
                .collect(toSet());
    }",method,
"    private static Set<OrganizationSet> getOverlappingOrganizationSets(Table tableInfo, Collection<ShardIndexInfo> shards)
    {
        if (shards.size() <= 1) {
            return ImmutableSet.of();
        }
        // Sort by low marker for the range
        List<ShardIndexInfo> sortedShards = shards.stream()
                .sorted((o1, o2) -> {
                    ShardRange sortRange1 = o1.getSortRange().get();
                    ShardRange sortRange2 = o2.getSortRange().get();
                    return ComparisonChain.start()
                            .compare(sortRange1.getMinTuple(), sortRange2.getMinTuple())
                            .compare(sortRange2.getMaxTuple(), sortRange1.getMaxTuple())
                            .result();
                })
                .collect(toList());
        Set<OrganizationSet> organizationSets = new HashSet<>();
        ImmutableSet.Builder<ShardIndexInfo> builder = ImmutableSet.builder();
        builder.add(sortedShards.get(0));
        int previousRange = 0;
        int nextRange = previousRange + 1;
        while (nextRange < sortedShards.size()) {
            ShardRange sortRange1 = sortedShards.get(previousRange).getSortRange().get();
            ShardRange sortRange2 = sortedShards.get(nextRange).getSortRange().get();
            if (sortRange1.overlaps(sortRange2) && !sortRange1.adjacent(sortRange2)) {
                builder.add(sortedShards.get(nextRange));
                if (!sortRange1.encloses(sortRange2)) {
                    previousRange = nextRange;
                }
            }
            else {
                Set<ShardIndexInfo> indexInfos = builder.build();
                if (indexInfos.size() > 1) {
                    organizationSets.add(createOrganizationSet(tableInfo.getTableId(), indexInfos));
                }
                builder = ImmutableSet.builder();
                previousRange = nextRange;
                builder.add(sortedShards.get(previousRange));
            }
            nextRange++;
        }
        Set<ShardIndexInfo> indexInfos = builder.build();
        if (indexInfos.size() > 1) {
            organizationSets.add(createOrganizationSet(tableInfo.getTableId(), indexInfos));
        }
        return organizationSets;
    }",method,
"import java.util.List;
class OverridingMethodsDialog extends DialogWrapper {
  private final List<UsageInfo> myOverridingMethods;
  private final String[] myMethodText;
  private final boolean[] myChecked;
  private static final int CHECK_COLUMN = 0;
  private Table myTable;
   private final UsagePreviewPanel myUsagePreviewPanel;
  public OverridingMethodsDialog(Project project, List<UsageInfo> overridingMethods) {
    super(project, true);
    myOverridingMethods = overridingMethods;
    myChecked = new boolean[myOverridingMethods.size()];
    for (int i = 0; i < myChecked.length; i++) {
      myChecked[i] = true;
    }
    myMethodText = new String[myOverridingMethods.size()];
    for (int i = 0; i < myMethodText.length; i++) {
      myMethodText[i] = PsiFormatUtil.formatMethod(
              ((SafeDeleteOverridingMethodUsageInfo) myOverridingMethods.get(i)).getOverridingMethod(),
              PsiSubstitutor.EMPTY, PsiFormatUtilBase.SHOW_CONTAINING_CLASS
                                    | PsiFormatUtilBase.SHOW_NAME | PsiFormatUtilBase.SHOW_PARAMETERS | PsiFormatUtilBase.SHOW_TYPE,
              PsiFormatUtilBase.SHOW_TYPE
      );
    }
    myUsagePreviewPanel = new UsagePreviewPanel(project, new UsageViewPresentation());
    setTitle(RefactoringBundle.message(""unused.overriding.methods.title""));
    init();
  }
  protected String getDimensionServiceKey() {
    return ""#com.intellij.refactoring.safeDelete.OverridingMethodsDialog"";
  }
  public ArrayList<UsageInfo> getSelected() {
    ArrayList<UsageInfo> result = new ArrayList<>();
    for (int i = 0; i < myChecked.length; i++) {
      if(myChecked[i]) {
        result.add(myOverridingMethods.get(i));
      }
    }
    return result;
  }
  @NotNull
  protected Action[] createActions() {
    return new Action[]{getOKAction(), getCancelAction()};
  }
  protected void doHelpAction() {
    HelpManager.getInstance().invokeHelp(HelpID.SAFE_DELETE_OVERRIDING);
  }
  protected JComponent createNorthPanel() {
    JPanel panel = new JPanel();
    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
    panel.add(new JLabel(RefactoringBundle.message(""there.are.unused.methods.that.override.methods.you.delete"")));
    panel.add(new JLabel(RefactoringBundle.message(""choose.the.ones.you.want.to.be.deleted"")));
    return panel;
  }
  public JComponent getPreferredFocusedComponent() {
    return myTable;
  }
  @Override
  protected void dispose() {
    Disposer.dispose(myUsagePreviewPanel);
    super.dispose();
  }
  protected JComponent createCenterPanel() {
    JPanel panel = new JPanel(new BorderLayout());
    panel.setBorder(BorderFactory.createEmptyBorder(8, 0, 4, 0));
    final MyTableModel tableModel = new MyTableModel();
    myTable = new Table(tableModel);
    myTable.setShowGrid(false);
    TableColumnModel columnModel = myTable.getColumnModel();
//    columnModel.getColumn(DISPLAY_NAME_COLUMN).setCellRenderer(new MemberSelectionTable.MyTableRenderer());
    TableColumn checkboxColumn = columnModel.getColumn(CHECK_COLUMN);
    TableUtil.setupCheckboxColumn(checkboxColumn);
    checkboxColumn.setCellRenderer(new BooleanTableCellRenderer());
    // make SPACE check/uncheck selected rows
    @NonNls InputMap inputMap = myTable.getInputMap();
    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), ""enable_disable"");
    @NonNls final ActionMap actionMap = myTable.getActionMap();
    actionMap.put(""enable_disable"", new AbstractAction() {
      public void actionPerformed(ActionEvent e) {
        if (myTable.isEditing()) return;
        int[] rows = myTable.getSelectedRows();
        if (rows.length > 0) {
          boolean valueToBeSet = false;
          for (int row : rows) {
            if (!myChecked[row]) {
              valueToBeSet = true;
              break;
            }
          }
          for (int row : rows) {
            myChecked[row] = valueToBeSet;
          }
          tableModel.updateData();
        }
      }
    });
    panel.setLayout(new BorderLayout());
    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTable);
    panel.add(scrollPane, BorderLayout.CENTER);
    ListSelectionListener selectionListener = new ListSelectionListener() {
      public void valueChanged(final ListSelectionEvent e) {
        int index = myTable.getSelectionModel().getLeadSelectionIndex();
        if (index != -1) {
          UsageInfo usageInfo = myOverridingMethods.get(index);
          myUsagePreviewPanel.updateLayout(Collections.singletonList(usageInfo));
        }
        else {
          myUsagePreviewPanel.updateLayout(null);
        }
      }
    };
    myTable.getSelectionModel().addListSelectionListener(selectionListener);
    final Splitter splitter = new Splitter(true, 0.3f);
    splitter.setFirstComponent(panel);
    splitter.setSecondComponent(myUsagePreviewPanel);
    myUsagePreviewPanel.updateLayout(null);
    Disposer.register(myDisposable, new Disposable(){
      public void dispose() {
        splitter.dispose();
      }
    });
    if (tableModel.getRowCount() != 0) {
      myTable.getSelectionModel().addSelectionInterval(0,0);
    }
    return splitter;
  }
  class MyTableModel extends AbstractTableModel {
    public int getRowCount() {
      return myChecked.length;
    }
    public String getColumnName(int column) {
      switch(column) {
        case CHECK_COLUMN:
          return "" "";
        default:
          return RefactoringBundle.message(""method.column"");
      }
    }
    public Class getColumnClass(int columnIndex) {
      switch(columnIndex) {
        case CHECK_COLUMN:
          return Boolean.class;
        default:
          return String.class;
      }
    }
    public int getColumnCount() {
      return 2;
    }
    public Object getValueAt(int rowIndex, int columnIndex) {
      if(columnIndex == CHECK_COLUMN) {
        return Boolean.valueOf(myChecked[rowIndex]);
      }
      else {
        return myMethodText[rowIndex];
      }
    }
    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
      if(columnIndex == CHECK_COLUMN) {
        myChecked[rowIndex] = ((Boolean) aValue).booleanValue();
      }
    }
    public boolean isCellEditable(int rowIndex, int columnIndex) {
      return columnIndex == CHECK_COLUMN;
    }
    void updateData() {
      fireTableDataChanged();
    }
  }
}",class,
"  class MyTableModel extends AbstractTableModel {
    public int getRowCount() {
      return myChecked.length;
    }
    public String getColumnName(int column) {
      switch(column) {
        case CHECK_COLUMN:
          return "" "";
        default:
          return RefactoringBundle.message(""method.column"");
      }
    }
    public Class getColumnClass(int columnIndex) {
      switch(columnIndex) {
        case CHECK_COLUMN:
          return Boolean.class;
        default:
          return String.class;
      }
    }
    public int getColumnCount() {
      return 2;
    }
    public Object getValueAt(int rowIndex, int columnIndex) {
      if(columnIndex == CHECK_COLUMN) {
        return Boolean.valueOf(myChecked[rowIndex]);
      }
      else {
        return myMethodText[rowIndex];
      }
    }
    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
      if(columnIndex == CHECK_COLUMN) {
        myChecked[rowIndex] = ((Boolean) aValue).booleanValue();
      }
    }
    public boolean isCellEditable(int rowIndex, int columnIndex) {
      return columnIndex == CHECK_COLUMN;
    }
    void updateData() {
      fireTableDataChanged();
    }
  }",class,
"  public OverridingMethodsDialog(Project project, List<UsageInfo> overridingMethods) {
    super(project, true);
    myOverridingMethods = overridingMethods;
    myChecked = new boolean[myOverridingMethods.size()];
    for (int i = 0; i < myChecked.length; i++) {
      myChecked[i] = true;
    }
    myMethodText = new String[myOverridingMethods.size()];
    for (int i = 0; i < myMethodText.length; i++) {
      myMethodText[i] = PsiFormatUtil.formatMethod(
              ((SafeDeleteOverridingMethodUsageInfo) myOverridingMethods.get(i)).getOverridingMethod(),
              PsiSubstitutor.EMPTY, PsiFormatUtilBase.SHOW_CONTAINING_CLASS
                                    | PsiFormatUtilBase.SHOW_NAME | PsiFormatUtilBase.SHOW_PARAMETERS | PsiFormatUtilBase.SHOW_TYPE,
              PsiFormatUtilBase.SHOW_TYPE
      );
    }
    myUsagePreviewPanel = new UsagePreviewPanel(project, new UsageViewPresentation());
    setTitle(RefactoringBundle.message(""unused.overriding.methods.title""));
    init();
  }",method,
"    for (int i = 0; i < myChecked.length; i++) {
      myChecked[i] = true;
    }",method,
"    for (int i = 0; i < myMethodText.length; i++) {
      myMethodText[i] = PsiFormatUtil.formatMethod(
              ((SafeDeleteOverridingMethodUsageInfo) myOverridingMethods.get(i)).getOverridingMethod(),
              PsiSubstitutor.EMPTY, PsiFormatUtilBase.SHOW_CONTAINING_CLASS
                                    | PsiFormatUtilBase.SHOW_NAME | PsiFormatUtilBase.SHOW_PARAMETERS | PsiFormatUtilBase.SHOW_TYPE,
              PsiFormatUtilBase.SHOW_TYPE
      );
    }",method,
"  protected String getDimensionServiceKey() {
    return ""#com.intellij.refactoring.safeDelete.OverridingMethodsDialog"";
  }",method,
"  public ArrayList<UsageInfo> getSelected() {
    ArrayList<UsageInfo> result = new ArrayList<>();
    for (int i = 0; i < myChecked.length; i++) {
      if(myChecked[i]) {
        result.add(myOverridingMethods.get(i));
      }
    }
    return result;
  }",method,

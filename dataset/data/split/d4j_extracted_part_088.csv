code_snippet,type,score
"			@Override
			public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) { }",method,
"			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }",method,
"			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/ (float) seekBar.getMax();
				int width = (int) (percent * (float) getSlidingMenu().getWidth());
				getSlidingMenu().setShadowWidth(width);
				getSlidingMenu().invalidate();
			}",method,
"		fadeEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				getSlidingMenu().setFadeEnabled(isChecked);
			}			
		}",method,
"			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				getSlidingMenu().setFadeEnabled(isChecked);
			}",method,
"		fadeDeg.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setFadeDegree((float) seekBar.getProgress()/seekBar.getMax());
			}			
		}",method,
"			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }",method,
"			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }",method,
"			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setFadeDegree((float) seekBar.getProgress()/seekBar.getMax());
			}",method,
"public abstract class BaseViewAction extends DumbAwareAction {
  @Override
  public final void update(final AnActionEvent e) {
    ViewContext context = getViewFacade(e);
    Content[] content = getContent(e);
    if (context != null && content != null) {
      if (containsInvalidContent(content)) {
        e.getPresentation().setEnabled(false);
      } else {
        update(e, context, content);
      }
    } else {
      e.getPresentation().setEnabled(false);
    }
  }
  private boolean containsInvalidContent(Content[] content) {
    for (Content each : content) {
      if (!each.isValid()) {
        return true;
      }
    }
    return false;
  }
  protected void update(AnActionEvent e, ViewContext context, Content[] content) {
  }
  @Override
  public final void actionPerformed(final AnActionEvent e) {
    actionPerformed(e, getViewFacade(e), getContent(e));
  }
  protected abstract void actionPerformed(AnActionEvent e, ViewContext context, Content[] content);
  @Nullable
  private ViewContext getViewFacade(final AnActionEvent e) {
    return e.getData(ViewContext.CONTEXT_KEY);
  }
  @Nullable
  private Content[] getContent(final AnActionEvent e) {
    return e.getData(ViewContext.CONTENT_KEY);
  }
  @Nullable
  protected static Tab getTabFor(final ViewContext context, final Content[] content) {
    Grid grid = context.findGridFor(content[0]);
    return context.getTabFor(grid);
  }
  protected final void setEnabled(AnActionEvent e, boolean enabled) {
    e.getPresentation().setVisible(enabled);
  }
}",class,
"  @Override
  public final void update(final AnActionEvent e) {
    ViewContext context = getViewFacade(e);
    Content[] content = getContent(e);
    if (context != null && content != null) {
      if (containsInvalidContent(content)) {
        e.getPresentation().setEnabled(false);
      } else {
        update(e, context, content);
      }
    } else {
      e.getPresentation().setEnabled(false);
    }
  }",method,
"    if (context != null && content != null) {
      if (containsInvalidContent(content)) {
        e.getPresentation().setEnabled(false);
      } else {
        update(e, context, content);
      }
    }",method,
"  private boolean containsInvalidContent(Content[] content) {
    for (Content each : content) {
      if (!each.isValid()) {
        return true;
      }
    }
    return false;
  }",method,
"    for (Content each : content) {
      if (!each.isValid()) {
        return true;
      }
    }",method,
"  protected void update(AnActionEvent e, ViewContext context, Content[] content) {
  }",method,
"  @Override
  public final void actionPerformed(final AnActionEvent e) {
    actionPerformed(e, getViewFacade(e), getContent(e));
  }",method,
"  @Nullable
  private ViewContext getViewFacade(final AnActionEvent e) {
    return e.getData(ViewContext.CONTEXT_KEY);
  }",method,
"  @Nullable
  private Content[] getContent(final AnActionEvent e) {
    return e.getData(ViewContext.CONTENT_KEY);
  }",method,
"  @Nullable
  protected static Tab getTabFor(final ViewContext context, final Content[] content) {
    Grid grid = context.findGridFor(content[0]);
    return context.getTabFor(grid);
  }",method,
"  protected final void setEnabled(AnActionEvent e, boolean enabled) {
    e.getPresentation().setVisible(enabled);
  }",method,
"public class OracleSelectTest57 extends OracleTest {
    public void test_0() throws Exception {
        String sql = //
                ""SELECT TRIM(BOTH FROM EUCD) AS \""value\"",NTLANG1 AS \""text\"" "" //
                + "" FROM T_HT_WREM_ENUMLANG_D""
                + "" WHERE TYPE=?""
                + "" ORDER BY \""value\"" ASC""; //
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement stmt = statementList.get(0);
        print(statementList);
        Assert.assertEquals(1, statementList.size());
        OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
        stmt.accept(visitor);
        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
        System.out.println(""coditions : "" + visitor.getConditions());
        System.out.println(""relationships : "" + visitor.getRelationships());
        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
        Assert.assertEquals(1, visitor.getTables().size());
        Assert.assertEquals(2, visitor.getColumns().size());
        {
            String text = SQLUtils.toOracleString(stmt);
            Assert.assertEquals(""SELECT TRIM(BOTH FROM EUCD) AS \""value\"", NTLANG1 AS \""text\""""
                    + ""\nFROM T_HT_WREM_ENUMLANG_D""
                    + ""\nWHERE TYPE = ?""
                    + ""\nORDER BY \""value\"" ASC"", text);
        }
        {
            String text = SQLUtils.toOracleString(stmt, SQLUtils.DEFAULT_LCASE_FORMAT_OPTION);
            Assert.assertEquals(""select TRIM(BOTH from EUCD) as \""value\"", NTLANG1 as \""text\""""
                    + ""\nfrom T_HT_WREM_ENUMLANG_D""
                    + ""\nwhere TYPE = ?""
                    + ""\norder by \""value\"" asc"", text);
        }
        // Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""acduser.vw_acd_info"", ""xzqh"")));
        // Assert.assertTrue(visitor.getOrderByColumns().contains(new TableStat.Column(""employees"", ""last_name"")));
    }
}",class,
"    public void test_0() throws Exception {
        String sql = //
                ""SELECT TRIM(BOTH FROM EUCD) AS \""value\"",NTLANG1 AS \""text\"" "" //
                + "" FROM T_HT_WREM_ENUMLANG_D""
                + "" WHERE TYPE=?""
                + "" ORDER BY \""value\"" ASC""; //
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement stmt = statementList.get(0);
        print(statementList);
        Assert.assertEquals(1, statementList.size());
        OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
        stmt.accept(visitor);
        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
        System.out.println(""coditions : "" + visitor.getConditions());
        System.out.println(""relationships : "" + visitor.getRelationships());
        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
        Assert.assertEquals(1, visitor.getTables().size());
        Assert.assertEquals(2, visitor.getColumns().size());
        {
            String text = SQLUtils.toOracleString(stmt);
            Assert.assertEquals(""SELECT TRIM(BOTH FROM EUCD) AS \""value\"", NTLANG1 AS \""text\""""
                    + ""\nFROM T_HT_WREM_ENUMLANG_D""
                    + ""\nWHERE TYPE = ?""
                    + ""\nORDER BY \""value\"" ASC"", text);
        }
        {
            String text = SQLUtils.toOracleString(stmt, SQLUtils.DEFAULT_LCASE_FORMAT_OPTION);
            Assert.assertEquals(""select TRIM(BOTH from EUCD) as \""value\"", NTLANG1 as \""text\""""
                    + ""\nfrom T_HT_WREM_ENUMLANG_D""
                    + ""\nwhere TYPE = ?""
                    + ""\norder by \""value\"" asc"", text);
        }
        // Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""acduser.vw_acd_info"", ""xzqh"")));
        // Assert.assertTrue(visitor.getOrderByColumns().contains(new TableStat.Column(""employees"", ""last_name"")));
    }",method,
"public class IdentityRecordList {
  private static final String TAG = IdentityRecordList.class.getSimpleName();
  private final List<IdentityRecord> identityRecords = new LinkedList<>();
  public void add(Optional<IdentityRecord> identityRecord) {
    if (identityRecord.isPresent()) {
      identityRecords.add(identityRecord.get());
    }
  }
  public void replaceWith(IdentityRecordList identityRecordList) {
    identityRecords.clear();
    identityRecords.addAll(identityRecordList.identityRecords);
  }
  public boolean isVerified() {
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() != VerifiedStatus.VERIFIED) {
        return false;
      }
    }
    return identityRecords.size() > 0;
  }
  public boolean isUnverified() {
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        return true;
      }
    }
    return false;
  }
  public boolean isUntrusted() {
    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        return true;
      }
    }
    return false;
  }
  public List<IdentityRecord> getUntrustedRecords() {
    List<IdentityRecord> results = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        results.add(identityRecord);
      }
    }
    return results;
  }
  public List<Recipient> getUntrustedRecipients(Context context) {
    List<Recipient> untrusted = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        untrusted.add(Recipient.from(context, identityRecord.getAddress(), false));
      }
    }
    return untrusted;
  }
  public List<IdentityRecord> getUnverifiedRecords() {
    List<IdentityRecord> results = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        results.add(identityRecord);
      }
    }
    return results;
  }
  public List<Recipient> getUnverifiedRecipients(Context context) {
    List<Recipient> unverified = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        unverified.add(Recipient.from(context, identityRecord.getAddress(), false));
      }
    }
    return unverified;
  }
  private boolean isUntrusted(IdentityRecord identityRecord) {
    return !identityRecord.isApprovedNonBlocking() &&
           System.currentTimeMillis() - identityRecord.getTimestamp() < TimeUnit.SECONDS.toMillis(5);
  }
}",class,
"  public void add(Optional<IdentityRecord> identityRecord) {
    if (identityRecord.isPresent()) {
      identityRecords.add(identityRecord.get());
    }
  }",method,
"  public void replaceWith(IdentityRecordList identityRecordList) {
    identityRecords.clear();
    identityRecords.addAll(identityRecordList.identityRecords);
  }",method,
"  public boolean isVerified() {
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() != VerifiedStatus.VERIFIED) {
        return false;
      }
    }
    return identityRecords.size() > 0;
  }",method,
"    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() != VerifiedStatus.VERIFIED) {
        return false;
      }
    }",method,
"  public boolean isUnverified() {
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        return true;
      }
    }
    return false;
  }",method,
"    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        return true;
      }
    }",method,
"  public boolean isUntrusted() {
    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        return true;
      }
    }
    return false;
  }",method,
"    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        return true;
      }
    }",method,
"  public List<IdentityRecord> getUntrustedRecords() {
    List<IdentityRecord> results = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        results.add(identityRecord);
      }
    }
    return results;
  }",method,
"    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        results.add(identityRecord);
      }
    }",method,
"  public List<Recipient> getUntrustedRecipients(Context context) {
    List<Recipient> untrusted = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        untrusted.add(Recipient.from(context, identityRecord.getAddress(), false));
      }
    }
    return untrusted;
  }",method,
"    for (IdentityRecord identityRecord : identityRecords) {
      if (isUntrusted(identityRecord)) {
        untrusted.add(Recipient.from(context, identityRecord.getAddress(), false));
      }
    }",method,
"  public List<IdentityRecord> getUnverifiedRecords() {
    List<IdentityRecord> results = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        results.add(identityRecord);
      }
    }
    return results;
  }",method,
"    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        results.add(identityRecord);
      }
    }",method,
"  public List<Recipient> getUnverifiedRecipients(Context context) {
    List<Recipient> unverified = new LinkedList<>();
    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        unverified.add(Recipient.from(context, identityRecord.getAddress(), false));
      }
    }
    return unverified;
  }",method,
"    for (IdentityRecord identityRecord : identityRecords) {
      if (identityRecord.getVerifiedStatus() == VerifiedStatus.UNVERIFIED) {
        unverified.add(Recipient.from(context, identityRecord.getAddress(), false));
      }
    }",method,
"  private boolean isUntrusted(IdentityRecord identityRecord) {
    return !identityRecord.isApprovedNonBlocking() &&
           System.currentTimeMillis() - identityRecord.getTimestamp() < TimeUnit.SECONDS.toMillis(5);
  }",method,
"public final class AccelerometerListener {
    private static final String TAG = ""AccelerometerListener"";
    private static final boolean DEBUG = true;
    private static final boolean VDEBUG = false;
    private SensorManager mSensorManager;
    private Sensor mSensor;
    // mOrientation is the orientation value most recently reported to the client.
    private int mOrientation;
    // mPendingOrientation is the latest orientation computed based on the sensor value.
    // This is sent to the client after a rebounce delay, at which point it is copied to
    // mOrientation.
    private int mPendingOrientation;
    private OrientationListener mListener;
    // Device orientation
    public static final int ORIENTATION_UNKNOWN = 0;
    public static final int ORIENTATION_VERTICAL = 1;
    public static final int ORIENTATION_HORIZONTAL = 2;
    private static final int ORIENTATION_CHANGED = 1234;
    private static final int VERTICAL_DEBOUNCE = 100;
    private static final int HORIZONTAL_DEBOUNCE = 500;
    private static final double VERTICAL_ANGLE = 50.0;
    public interface OrientationListener {
        public void orientationChanged(int orientation);
    }
    public AccelerometerListener(Context context, OrientationListener listener) {
        mListener = listener;
        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    }
    public void enable(boolean enable) {
        if (DEBUG) Log.d(TAG, ""enable("" + enable + "")"");
        synchronized (this) {
            if (enable) {
                mOrientation = ORIENTATION_UNKNOWN;
                mPendingOrientation = ORIENTATION_UNKNOWN;
                mSensorManager.registerListener(mSensorListener, mSensor,
                        SensorManager.SENSOR_DELAY_NORMAL);
            } else {
                mSensorManager.unregisterListener(mSensorListener);
                mHandler.removeMessages(ORIENTATION_CHANGED);
            }
        }
    }
    private void setOrientation(int orientation) {
        synchronized (this) {
            if (mPendingOrientation == orientation) {
                // Pending orientation has not changed, so do nothing.
                return;
            }
            // Cancel any pending messages.
            // We will either start a new timer or cancel alltogether
            // if the orientation has not changed.
            mHandler.removeMessages(ORIENTATION_CHANGED);
            if (mOrientation != orientation) {
                // Set timer to send an event if the orientation has changed since its
                // previously reported value.
                mPendingOrientation = orientation;
                Message m = mHandler.obtainMessage(ORIENTATION_CHANGED);
                // set delay to our debounce timeout
                int delay = (orientation == ORIENTATION_VERTICAL ? VERTICAL_DEBOUNCE
                                                                 : HORIZONTAL_DEBOUNCE);
                mHandler.sendMessageDelayed(m, delay);
            } else {
                // no message is pending
                mPendingOrientation = ORIENTATION_UNKNOWN;
            }
        }
    }
    private void onSensorEvent(double x, double y, double z) {
        if (VDEBUG) Log.d(TAG, ""onSensorEvent("" + x + "", "" + y + "", "" + z + "")"");
        // If some values are exactly zero, then likely the sensor is not powered up yet.
        // ignore these events to avoid false horizontal positives.
        if (x == 0.0 || y == 0.0 || z == 0.0) return;
        // magnitude of the acceleration vector projected onto XY plane
        double xy = Math.sqrt(x*x + y*y);
        // compute the vertical angle
        double angle = Math.atan2(xy, z);
        // convert to degrees
        angle = angle * 180.0 / Math.PI;
        int orientation = (angle >  VERTICAL_ANGLE ? ORIENTATION_VERTICAL : ORIENTATION_HORIZONTAL);
        if (VDEBUG) Log.d(TAG, ""angle: "" + angle + "" orientation: "" + orientation);
        setOrientation(orientation);
    }
    SensorEventListener mSensorListener = new SensorEventListener() {
        public void onSensorChanged(SensorEvent event) {
            onSensorEvent(event.values[0], event.values[1], event.values[2]);
        }
        public void onAccuracyChanged(Sensor sensor, int accuracy) {
            // ignore
        }
    };
    Handler mHandler = new AccelerometerHandler(this);
    private static class AccelerometerHandler extends Handler {
        WeakReference<AccelerometerListener> l;
        AccelerometerHandler(AccelerometerListener listener){
            l = new WeakReference<AccelerometerListener>(listener);
        }
        public void handleMessage(Message msg) {
            AccelerometerListener listener = l.get();
            if(listener == null) {
                return;
            }
            switch (msg.what) {
            case ORIENTATION_CHANGED:
                synchronized (listener) {
                    listener.mOrientation = listener.mPendingOrientation;
                    if (DEBUG) {
                        Log.d(TAG, ""orientation: "" +
                            (listener.mOrientation == ORIENTATION_HORIZONTAL ? ""horizontal""
                                : (listener.mOrientation == ORIENTATION_VERTICAL ? ""vertical""
                                    : ""unknown"")));
                    }
                    listener.mListener.orientationChanged(listener.mOrientation);
                }
                break;
            }
        }
    };
}",class,
"    private static class AccelerometerHandler extends Handler {
        WeakReference<AccelerometerListener> l;
        AccelerometerHandler(AccelerometerListener listener){
            l = new WeakReference<AccelerometerListener>(listener);
        }
        public void handleMessage(Message msg) {
            AccelerometerListener listener = l.get();
            if(listener == null) {
                return;
            }
            switch (msg.what) {
            case ORIENTATION_CHANGED:
                synchronized (listener) {
                    listener.mOrientation = listener.mPendingOrientation;
                    if (DEBUG) {
                        Log.d(TAG, ""orientation: "" +
                            (listener.mOrientation == ORIENTATION_HORIZONTAL ? ""horizontal""
                                : (listener.mOrientation == ORIENTATION_VERTICAL ? ""vertical""
                                    : ""unknown"")));
                    }
                    listener.mListener.orientationChanged(listener.mOrientation);
                }
                break;
            }
        }
    }",class,
"    public AccelerometerListener(Context context, OrientationListener listener) {
        mListener = listener;
        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    }",method,
"    public void enable(boolean enable) {
        if (DEBUG) Log.d(TAG, ""enable("" + enable + "")"");
        synchronized (this) {
            if (enable) {
                mOrientation = ORIENTATION_UNKNOWN;
                mPendingOrientation = ORIENTATION_UNKNOWN;
                mSensorManager.registerListener(mSensorListener, mSensor,
                        SensorManager.SENSOR_DELAY_NORMAL);
            } else {
                mSensorManager.unregisterListener(mSensorListener);
                mHandler.removeMessages(ORIENTATION_CHANGED);
            }
        }
    }",method,
"        synchronized (this) {
            if (enable) {
                mOrientation = ORIENTATION_UNKNOWN;
                mPendingOrientation = ORIENTATION_UNKNOWN;
                mSensorManager.registerListener(mSensorListener, mSensor,
                        SensorManager.SENSOR_DELAY_NORMAL);
            } else {
                mSensorManager.unregisterListener(mSensorListener);
                mHandler.removeMessages(ORIENTATION_CHANGED);
            }
        }",method,
"            if (enable) {
                mOrientation = ORIENTATION_UNKNOWN;
                mPendingOrientation = ORIENTATION_UNKNOWN;
                mSensorManager.registerListener(mSensorListener, mSensor,
                        SensorManager.SENSOR_DELAY_NORMAL);
            }",method,
"    private void setOrientation(int orientation) {
        synchronized (this) {
            if (mPendingOrientation == orientation) {
                // Pending orientation has not changed, so do nothing.
                return;
            }
            // Cancel any pending messages.
            // We will either start a new timer or cancel alltogether
            // if the orientation has not changed.
            mHandler.removeMessages(ORIENTATION_CHANGED);
            if (mOrientation != orientation) {
                // Set timer to send an event if the orientation has changed since its
                // previously reported value.
                mPendingOrientation = orientation;
                Message m = mHandler.obtainMessage(ORIENTATION_CHANGED);
                // set delay to our debounce timeout
                int delay = (orientation == ORIENTATION_VERTICAL ? VERTICAL_DEBOUNCE
                                                                 : HORIZONTAL_DEBOUNCE);
                mHandler.sendMessageDelayed(m, delay);
            } else {
                // no message is pending
                mPendingOrientation = ORIENTATION_UNKNOWN;
            }
        }
    }",method,
"        synchronized (this) {
            if (mPendingOrientation == orientation) {
                // Pending orientation has not changed, so do nothing.
                return;
            }
            // Cancel any pending messages.
            // We will either start a new timer or cancel alltogether
            // if the orientation has not changed.
            mHandler.removeMessages(ORIENTATION_CHANGED);
            if (mOrientation != orientation) {
                // Set timer to send an event if the orientation has changed since its
                // previously reported value.
                mPendingOrientation = orientation;
                Message m = mHandler.obtainMessage(ORIENTATION_CHANGED);
                // set delay to our debounce timeout
                int delay = (orientation == ORIENTATION_VERTICAL ? VERTICAL_DEBOUNCE
                                                                 : HORIZONTAL_DEBOUNCE);
                mHandler.sendMessageDelayed(m, delay);
            } else {
                // no message is pending
                mPendingOrientation = ORIENTATION_UNKNOWN;
            }
        }",method,
"            if (mPendingOrientation == orientation) {
                // Pending orientation has not changed, so do nothing.
                return;
            }",method,
"            if (mOrientation != orientation) {
                // Set timer to send an event if the orientation has changed since its
                // previously reported value.
                mPendingOrientation = orientation;
                Message m = mHandler.obtainMessage(ORIENTATION_CHANGED);
                // set delay to our debounce timeout
                int delay = (orientation == ORIENTATION_VERTICAL ? VERTICAL_DEBOUNCE
                                                                 : HORIZONTAL_DEBOUNCE);
                mHandler.sendMessageDelayed(m, delay);
            }",method,
"    private void onSensorEvent(double x, double y, double z) {
        if (VDEBUG) Log.d(TAG, ""onSensorEvent("" + x + "", "" + y + "", "" + z + "")"");
        // If some values are exactly zero, then likely the sensor is not powered up yet.
        // ignore these events to avoid false horizontal positives.
        if (x == 0.0 || y == 0.0 || z == 0.0) return;
        // magnitude of the acceleration vector projected onto XY plane
        double xy = Math.sqrt(x*x + y*y);
        // compute the vertical angle
        double angle = Math.atan2(xy, z);
        // convert to degrees
        angle = angle * 180.0 / Math.PI;
        int orientation = (angle >  VERTICAL_ANGLE ? ORIENTATION_VERTICAL : ORIENTATION_HORIZONTAL);
        if (VDEBUG) Log.d(TAG, ""angle: "" + angle + "" orientation: "" + orientation);
        setOrientation(orientation);
    }",method,
"        public void onSensorChanged(SensorEvent event) {
            onSensorEvent(event.values[0], event.values[1], event.values[2]);
        }",method,
"        public void onAccuracyChanged(Sensor sensor, int accuracy) {
            // ignore
        }",method,
"        AccelerometerHandler(AccelerometerListener listener){
            l = new WeakReference<AccelerometerListener>(listener);
        }",method,
"        public void handleMessage(Message msg) {
            AccelerometerListener listener = l.get();
            if(listener == null) {
                return;
            }
            switch (msg.what) {
            case ORIENTATION_CHANGED:
                synchronized (listener) {
                    listener.mOrientation = listener.mPendingOrientation;
                    if (DEBUG) {
                        Log.d(TAG, ""orientation: "" +
                            (listener.mOrientation == ORIENTATION_HORIZONTAL ? ""horizontal""
                                : (listener.mOrientation == ORIENTATION_VERTICAL ? ""vertical""
                                    : ""unknown"")));
                    }
                    listener.mListener.orientationChanged(listener.mOrientation);
                }
                break;
            }
        }",method,
"            if(listener == null) {
                return;
            }",method,
"            switch (msg.what) {
            case ORIENTATION_CHANGED:
                synchronized (listener) {
                    listener.mOrientation = listener.mPendingOrientation;
                    if (DEBUG) {
                        Log.d(TAG, ""orientation: "" +
                            (listener.mOrientation == ORIENTATION_HORIZONTAL ? ""horizontal""
                                : (listener.mOrientation == ORIENTATION_VERTICAL ? ""vertical""
                                    : ""unknown"")));
                    }
                    listener.mListener.orientationChanged(listener.mOrientation);
                }
                break;
            }",method,
"                synchronized (listener) {
                    listener.mOrientation = listener.mPendingOrientation;
                    if (DEBUG) {
                        Log.d(TAG, ""orientation: "" +
                            (listener.mOrientation == ORIENTATION_HORIZONTAL ? ""horizontal""
                                : (listener.mOrientation == ORIENTATION_VERTICAL ? ""vertical""
                                    : ""unknown"")));
                    }
                    listener.mListener.orientationChanged(listener.mOrientation);
                }",method,
"                    if (DEBUG) {
                        Log.d(TAG, ""orientation: "" +
                            (listener.mOrientation == ORIENTATION_HORIZONTAL ? ""horizontal""
                                : (listener.mOrientation == ORIENTATION_VERTICAL ? ""vertical""
                                    : ""unknown"")));
                    }",method,
"public class ZipkinServerTest {
  @Autowired
  ConfigurableWebApplicationContext context;
  MockMvc mockMvc;
  @Before
  public void init() {
    mockMvc = MockMvcBuilders.webAppContextSetup(context).build();
  }
  @Test
  public void readsBackSpanName() throws Exception {
    String service = ""web"";
    Endpoint endpoint = Endpoint.create(service, 127 << 24 | 1, 80);
    Annotation ann = Annotation.create(System.currentTimeMillis() * 1000, SERVER_RECV, endpoint);
    Span span = Span.builder().id(1L).traceId(1L).name(""get"").addAnnotation(ann).build();
    // write the span to the server
    performAsync(post(""/api/v1/spans"").content(Codec.JSON.writeSpans(asList(span))))
        .andExpect(status().isAccepted());
    // sleep as the the storage operation is async
    Thread.sleep(1000);
    // read back the span name, given its service
    mockMvc.perform(get(""/api/v1/spans?serviceName="" + service))
        .andExpect(status().isOk())
        .andExpect(content().string(""[\"""" + span.name + ""\""]""));
  }
  ResultActions performAsync(MockHttpServletRequestBuilder request) throws Exception {
    return mockMvc.perform(asyncDispatch(mockMvc.perform(request).andReturn()));
  }
}",class,
"  @Before
  public void init() {
    mockMvc = MockMvcBuilders.webAppContextSetup(context).build();
  }",method,
"  @Test
  public void readsBackSpanName() throws Exception {
    String service = ""web"";
    Endpoint endpoint = Endpoint.create(service, 127 << 24 | 1, 80);
    Annotation ann = Annotation.create(System.currentTimeMillis() * 1000, SERVER_RECV, endpoint);
    Span span = Span.builder().id(1L).traceId(1L).name(""get"").addAnnotation(ann).build();
    // write the span to the server
    performAsync(post(""/api/v1/spans"").content(Codec.JSON.writeSpans(asList(span))))
        .andExpect(status().isAccepted());
    // sleep as the the storage operation is async
    Thread.sleep(1000);
    // read back the span name, given its service
    mockMvc.perform(get(""/api/v1/spans?serviceName="" + service))
        .andExpect(status().isOk())
        .andExpect(content().string(""[\"""" + span.name + ""\""]""));
  }",method,
"  ResultActions performAsync(MockHttpServletRequestBuilder request) throws Exception {
    return mockMvc.perform(asyncDispatch(mockMvc.perform(request).andReturn()));
  }",method,
"import com.android.org.conscrypt.TrustedCertificateIndex;
class KeyStoreCertificateSource implements CertificateSource {
    private final Object mLock = new Object();
    private final KeyStore mKeyStore;
    private TrustedCertificateIndex mIndex;
    private Set<X509Certificate> mCertificates;
    public KeyStoreCertificateSource(KeyStore ks) {
        mKeyStore = ks;
    }
    @Override
    public Set<X509Certificate> getCertificates() {
        ensureInitialized();
        return mCertificates;
    }
    private void ensureInitialized() {
        synchronized (mLock) {
            if (mCertificates != null) {
                return;
            }
            try {
                TrustedCertificateIndex localIndex = new TrustedCertificateIndex();
                Set<X509Certificate> certificates = new ArraySet<>(mKeyStore.size());
                for (Enumeration<String> en = mKeyStore.aliases(); en.hasMoreElements();) {
                    String alias = en.nextElement();
                    X509Certificate cert = (X509Certificate) mKeyStore.getCertificate(alias);
                    if (cert != null) {
                        certificates.add(cert);
                        localIndex.index(cert);
                    }
                }
                mIndex = localIndex;
                mCertificates = certificates;
            } catch (KeyStoreException e) {
                throw new RuntimeException(""Failed to load certificates from KeyStore"", e);
            }
        }
    }
    @Override
    public X509Certificate findBySubjectAndPublicKey(X509Certificate cert) {
        ensureInitialized();
        java.security.cert.TrustAnchor anchor = mIndex.findBySubjectAndPublicKey(cert);
        if (anchor == null) {
            return null;
        }
        return anchor.getTrustedCert();
    }
    @Override
    public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
        ensureInitialized();
        java.security.cert.TrustAnchor anchor = mIndex.findByIssuerAndSignature(cert);
        if (anchor == null) {
            return null;
        }
        return anchor.getTrustedCert();
    }
    @Override
    public Set<X509Certificate> findAllByIssuerAndSignature(X509Certificate cert) {
        ensureInitialized();
        Set<java.security.cert.TrustAnchor> anchors = mIndex.findAllByIssuerAndSignature(cert);
        if (anchors.isEmpty()) {
            return Collections.<X509Certificate>emptySet();
        }
        Set<X509Certificate> certs = new ArraySet<X509Certificate>(anchors.size());
        for (java.security.cert.TrustAnchor anchor : anchors) {
            certs.add(anchor.getTrustedCert());
        }
        return certs;
    }
    @Override
    public void handleTrustStorageUpdate() {
        // Nothing to do.
    }
}",class,
"    public KeyStoreCertificateSource(KeyStore ks) {
        mKeyStore = ks;
    }",method,
"    @Override
    public Set<X509Certificate> getCertificates() {
        ensureInitialized();
        return mCertificates;
    }",method,
"    private void ensureInitialized() {
        synchronized (mLock) {
            if (mCertificates != null) {
                return;
            }
            try {
                TrustedCertificateIndex localIndex = new TrustedCertificateIndex();
                Set<X509Certificate> certificates = new ArraySet<>(mKeyStore.size());
                for (Enumeration<String> en = mKeyStore.aliases(); en.hasMoreElements();) {
                    String alias = en.nextElement();
                    X509Certificate cert = (X509Certificate) mKeyStore.getCertificate(alias);
                    if (cert != null) {
                        certificates.add(cert);
                        localIndex.index(cert);
                    }
                }
                mIndex = localIndex;
                mCertificates = certificates;
            } catch (KeyStoreException e) {
                throw new RuntimeException(""Failed to load certificates from KeyStore"", e);
            }
        }
    }",method,
"        synchronized (mLock) {
            if (mCertificates != null) {
                return;
            }
            try {
                TrustedCertificateIndex localIndex = new TrustedCertificateIndex();
                Set<X509Certificate> certificates = new ArraySet<>(mKeyStore.size());
                for (Enumeration<String> en = mKeyStore.aliases(); en.hasMoreElements();) {
                    String alias = en.nextElement();
                    X509Certificate cert = (X509Certificate) mKeyStore.getCertificate(alias);
                    if (cert != null) {
                        certificates.add(cert);
                        localIndex.index(cert);
                    }
                }
                mIndex = localIndex;
                mCertificates = certificates;
            } catch (KeyStoreException e) {
                throw new RuntimeException(""Failed to load certificates from KeyStore"", e);
            }
        }",method,
"            if (mCertificates != null) {
                return;
            }",method,
"                    if (cert != null) {
                        certificates.add(cert);
                        localIndex.index(cert);
                    }",method,
"    @Override
    public X509Certificate findBySubjectAndPublicKey(X509Certificate cert) {
        ensureInitialized();
        java.security.cert.TrustAnchor anchor = mIndex.findBySubjectAndPublicKey(cert);
        if (anchor == null) {
            return null;
        }
        return anchor.getTrustedCert();
    }",method,
"        if (anchor == null) {
            return null;
        }",method,
"    @Override
    public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
        ensureInitialized();
        java.security.cert.TrustAnchor anchor = mIndex.findByIssuerAndSignature(cert);
        if (anchor == null) {
            return null;
        }
        return anchor.getTrustedCert();
    }",method,
"        if (anchor == null) {
            return null;
        }",method,
"    @Override
    public Set<X509Certificate> findAllByIssuerAndSignature(X509Certificate cert) {
        ensureInitialized();
        Set<java.security.cert.TrustAnchor> anchors = mIndex.findAllByIssuerAndSignature(cert);
        if (anchors.isEmpty()) {
            return Collections.<X509Certificate>emptySet();
        }
        Set<X509Certificate> certs = new ArraySet<X509Certificate>(anchors.size());
        for (java.security.cert.TrustAnchor anchor : anchors) {
            certs.add(anchor.getTrustedCert());
        }
        return certs;
    }",method,
"        for (java.security.cert.TrustAnchor anchor : anchors) {
            certs.add(anchor.getTrustedCert());
        }",method,
"    @Override
    public void handleTrustStorageUpdate() {
        // Nothing to do.
    }",method,
"public class TrickyAspectJPointcutExpressionTests {
	@Test
	public void testManualProxyJavaWithUnconditionalPointcut() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		testAdvice(new DefaultPointcutAdvisor(logAdvice), logAdvice, target, ""TestServiceImpl"");
	}
	@Test
	public void testManualProxyJavaWithStaticPointcut() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""execution(* %s.TestService.*(..))"", getClass().getName()));
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, target, ""TestServiceImpl"");
	}
	@Test
	public void testManualProxyJavaWithDynamicPointcut() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""@within(%s.Log)"", getClass().getName()));
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, target, ""TestServiceImpl"");
	}
	@Test
	public void testManualProxyJavaWithDynamicPointcutAndProxyTargetClass() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""@within(%s.Log)"", getClass().getName()));
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, target, ""TestServiceImpl"", true);
	}
	@Test
	public void testManualProxyJavaWithStaticPointcutAndTwoClassLoaders() throws Exception {
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""execution(* %s.TestService.*(..))"", getClass().getName()));
		// Test with default class loader first...
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, new TestServiceImpl(), ""TestServiceImpl"");
		// Then try again with a different class loader on the target...
		SimpleThrowawayClassLoader loader = new SimpleThrowawayClassLoader(new TestServiceImpl().getClass().getClassLoader());
		// Make sure the interface is loaded from the  parent class loader
		loader.excludeClass(TestService.class.getName());
		loader.excludeClass(TestException.class.getName());
		TestService other = (TestService) loader.loadClass(TestServiceImpl.class.getName()).newInstance();
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, other, ""TestServiceImpl"");
	}
	private void testAdvice(Advisor advisor, LogUserAdvice logAdvice, TestService target, String message)
			throws Exception {
		testAdvice(advisor, logAdvice, target, message, false);
	}
	private void testAdvice(Advisor advisor, LogUserAdvice logAdvice, TestService target, String message,
			boolean proxyTargetClass) throws Exception {
		logAdvice.reset();
		ProxyFactory factory = new ProxyFactory(target);
		factory.setProxyTargetClass(proxyTargetClass);
		factory.addAdvisor(advisor);
		TestService bean = (TestService) factory.getProxy();
		assertEquals(0, logAdvice.getCountThrows());
		try {
			bean.sayHello();
			fail(""Expected exception"");
		}
		catch (TestException ex) {
			assertEquals(message, ex.getMessage());
		}
		assertEquals(1, logAdvice.getCountThrows());
	}
	public static class SimpleThrowawayClassLoader extends OverridingClassLoader {
		public SimpleThrowawayClassLoader(ClassLoader parent) {
			super(parent);
		}
	}
	@SuppressWarnings(""serial"")
	public static class TestException extends RuntimeException {
		public TestException(String string) {
			super(string);
		}
	}
	@Target({ ElementType.METHOD, ElementType.TYPE })
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Inherited
	public static @interface Log {
	}
	public static interface TestService {
		public String sayHello();
	}
	@Log
	public static class TestServiceImpl implements TestService {
		@Override
		public String sayHello() {
			throw new TestException(""TestServiceImpl"");
		}
	}
	public class LogUserAdvice implements MethodBeforeAdvice, ThrowsAdvice {
		private int countBefore = 0;
		private int countThrows = 0;
		@Override
		public void before(Method method, Object[] objects, @Nullable Object o) throws Throwable {
			countBefore++;
		}
		public void afterThrowing(Exception ex) throws Throwable {
			countThrows++;
			throw ex;
		}
		public int getCountBefore() {
			return countBefore;
		}
		public int getCountThrows() {
			return countThrows;
		}
		public void reset() {
			countThrows = 0;
			countBefore = 0;
		}
	}
}",class,
"		// Test with default class loader first...
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, new TestServiceImpl(), ""TestServiceImpl"");
		// Then try again with a different class loader on the target...
		SimpleThrowawayClassLoader loader = new SimpleThrowawayClassLoader(new TestServiceImpl().getClass().getClassLoader());
		// Make sure the interface is loaded from the  parent class loader
		loader.excludeClass(TestService.class.getName());
		loader.excludeClass(TestException.class.getName());
		TestService other = (TestService) loader.loadClass(TestServiceImpl.class.getName()).newInstance();
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, other, ""TestServiceImpl"");
	}
	private void testAdvice(Advisor advisor, LogUserAdvice logAdvice, TestService target, String message)
			throws Exception {
		testAdvice(advisor, logAdvice, target, message, false);
	}",class,
"	public static class SimpleThrowawayClassLoader extends OverridingClassLoader {
		public SimpleThrowawayClassLoader(ClassLoader parent) {
			super(parent);
		}
	}",class,
"	public static class TestException extends RuntimeException {
		public TestException(String string) {
			super(string);
		}
	}",class,
"	public static class TestServiceImpl implements TestService {
		@Override
		public String sayHello() {
			throw new TestException(""TestServiceImpl"");
		}
	}",class,
"	public class LogUserAdvice implements MethodBeforeAdvice, ThrowsAdvice {
		private int countBefore = 0;
		private int countThrows = 0;
		@Override
		public void before(Method method, Object[] objects, @Nullable Object o) throws Throwable {
			countBefore++;
		}
		public void afterThrowing(Exception ex) throws Throwable {
			countThrows++;
			throw ex;
		}
		public int getCountBefore() {
			return countBefore;
		}
		public int getCountThrows() {
			return countThrows;
		}
		public void reset() {
			countThrows = 0;
			countBefore = 0;
		}
	}",class,
"	@Test
	public void testManualProxyJavaWithUnconditionalPointcut() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		testAdvice(new DefaultPointcutAdvisor(logAdvice), logAdvice, target, ""TestServiceImpl"");
	}",method,
"	@Test
	public void testManualProxyJavaWithStaticPointcut() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""execution(* %s.TestService.*(..))"", getClass().getName()));
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, target, ""TestServiceImpl"");
	}",method,
"	@Test
	public void testManualProxyJavaWithDynamicPointcut() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""@within(%s.Log)"", getClass().getName()));
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, target, ""TestServiceImpl"");
	}",method,
"	@Test
	public void testManualProxyJavaWithDynamicPointcutAndProxyTargetClass() throws Exception {
		TestService target = new TestServiceImpl();
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""@within(%s.Log)"", getClass().getName()));
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, target, ""TestServiceImpl"", true);
	}",method,
"	@Test
	public void testManualProxyJavaWithStaticPointcutAndTwoClassLoaders() throws Exception {
		LogUserAdvice logAdvice = new LogUserAdvice();
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(String.format(""execution(* %s.TestService.*(..))"", getClass().getName()));
		// Test with default class loader first...
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, new TestServiceImpl(), ""TestServiceImpl"");
		// Then try again with a different class loader on the target...
		SimpleThrowawayClassLoader loader = new SimpleThrowawayClassLoader(new TestServiceImpl().getClass().getClassLoader());
		// Make sure the interface is loaded from the  parent class loader
		loader.excludeClass(TestService.class.getName());
		loader.excludeClass(TestException.class.getName());
		TestService other = (TestService) loader.loadClass(TestServiceImpl.class.getName()).newInstance();
		testAdvice(new DefaultPointcutAdvisor(pointcut, logAdvice), logAdvice, other, ""TestServiceImpl"");
	}",method,
"	private void testAdvice(Advisor advisor, LogUserAdvice logAdvice, TestService target, String message)
			throws Exception {
		testAdvice(advisor, logAdvice, target, message, false);
	}",method,
"	private void testAdvice(Advisor advisor, LogUserAdvice logAdvice, TestService target, String message,
			boolean proxyTargetClass) throws Exception {
		logAdvice.reset();
		ProxyFactory factory = new ProxyFactory(target);
		factory.setProxyTargetClass(proxyTargetClass);
		factory.addAdvisor(advisor);
		TestService bean = (TestService) factory.getProxy();
		assertEquals(0, logAdvice.getCountThrows());
		try {
			bean.sayHello();
			fail(""Expected exception"");
		}
		catch (TestException ex) {
			assertEquals(message, ex.getMessage());
		}
		assertEquals(1, logAdvice.getCountThrows());
	}",method,
"		catch (TestException ex) {
			assertEquals(message, ex.getMessage());
		}",method,
"		public SimpleThrowawayClassLoader(ClassLoader parent) {
			super(parent);
		}",method,
"		public TestException(String string) {
			super(string);
		}",method,
"		@Override
		public String sayHello() {
			throw new TestException(""TestServiceImpl"");
		}",method,
"		@Override
		public void before(Method method, Object[] objects, @Nullable Object o) throws Throwable {
			countBefore++;
		}",method,
"		public void afterThrowing(Exception ex) throws Throwable {
			countThrows++;
			throw ex;
		}",method,
"		public int getCountBefore() {
			return countBefore;
		}",method,
"		public int getCountThrows() {
			return countThrows;
		}",method,
"		public void reset() {
			countThrows = 0;
			countBefore = 0;
		}",method,
"public class VectorFunction extends mikera.vectorz.functions.VectorFunction implements clojure.lang.IFn {
	private final int inputDimensions;
	private final int outputDimensions;
	private final IFunction[] functions;
	private VectorFunction(int inputs, int outputs, IFunction[] functions) {
		this.inputDimensions=inputs;
		this.outputDimensions=outputs;
		this.functions=functions;
	}
	public static VectorFunction create(int inputDims, List<IFunction> functions) {
		IFunction[] funcs=functions.toArray(new IFunction[functions.size()]);
		return new VectorFunction(inputDims,funcs.length,funcs);
	}
	public IFunction getFunction(int i) {
		return functions[i];
	}
	@Override
	public void transform(AVector source, AVector dest) {
		for (int i=0; i<outputDimensions; i++) {
			double v=getTransformedComponent(i,source);
			dest.set(i,v);
		}
	}
	private double getTransformedComponent(int i, AVector source) {
		double v;
		switch (inputDimensions) {
			case 0: v=functions[i].calc(); break;
			case 1: v=functions[i].calc(source.get(0)); break;
			case 2: v=functions[i].calc(source.get(0),source.get(1)); break;
			case 3: v=functions[i].calc(source.get(0),source.get(1),source.get(2)); break;
			default: v=functions[i].calc(source.get(0),source.get(1),source.get(2),source.get(3)); break;
		}
		return v;
	}
	private double getTransformedComponent(int i, Vector3 source) {
		return functions[i].calc(source.x,source.y,source.z);
	}
	public void transform(AVector source, Vector3 dest) {
		assert(outputDimensions==3);
		dest.x=getTransformedComponent(0,source);
		dest.y=getTransformedComponent(1,source);
		dest.z=getTransformedComponent(2,source);
	}
	public void transform(Vector3 source, Vector3 dest) {
		assert(inputDimensions==3);
		assert(outputDimensions==3);
		dest.x=getTransformedComponent(0,source);
		dest.y=getTransformedComponent(1,source);
		dest.z=getTransformedComponent(2,source);
	}
	@Override
	public int inputDimensions() {
		return inputDimensions;
	}
	@Override
	public int outputDimensions() {
		return outputDimensions;
	}
	@Override
	public Object call() throws Exception {
		throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public void run() {
		throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke() {
		throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1) {
		return transform(Vectorz.toVector(arg1));
	}
	@Override
	public Object invoke(Object arg1, Object arg2) {
		throw new ArityException(2,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3) {
		throw new ArityException(3,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4) {
		throw new ArityException(4,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5) {
		throw new ArityException(5,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6) {
		throw new ArityException(6,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7) {
		throw new ArityException(7,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8) {
		throw new ArityException(8,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9) {
		throw new ArityException(9,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10) {
		throw new ArityException(10,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11) {
		throw new ArityException(11,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12) {
		throw new ArityException(12,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13) {
		throw new ArityException(13,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13, Object arg14) {
		throw new ArityException(14,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15) {
		throw new ArityException(15,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16) {
		throw new ArityException(16,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17) {
		throw new ArityException(17,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17, Object arg18) {
		throw new ArityException(18,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17,
			Object arg18, Object arg19) {
		throw new ArityException(19,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17,
			Object arg18, Object arg19, Object arg20) {
		throw new ArityException(20,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17,
			Object arg18, Object arg19, Object arg20, Object... args) {
		throw new ArityException(20+args.length,""VectorFunctsion requires exactly one argument"");
	}
	@Override
	public Object applyTo(ISeq arglist) {
		if (arglist==null) throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
		Object o=arglist.first();
		ISeq next=arglist.next();
		if (next!=null) throw new ArityException(RT.count(arglist),""VectorFunctsion requires exactly one argument"");
		return invoke(o);
	}
}",class,
"	private VectorFunction(int inputs, int outputs, IFunction[] functions) {
		this.inputDimensions=inputs;
		this.outputDimensions=outputs;
		this.functions=functions;
	}",method,

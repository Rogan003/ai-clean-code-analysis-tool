code_snippet,type,score
"}class MyClass {
  void f() {
    String response;
    AutoCloseable resource;
    try (resource<caret>) {
    }
  }
}",class,
"}class Foo {
    boolean foo(Object o, final PairFunction<String, ElementType, Boolean> fun){
        boolean result = true;
        result |= fun.fun(path);
        if (o instanceof String) {
            o.subst<caret>
        }
    }
    void foo(String s) {}
}",class,
"}
class Foo {
    boolean foo(Object o, final PairFunction<String, ElementType, Boolean> fun){
        boolean result = true;
        result |= fun.fun(path);
        if (o instanceof String) {
            ((String) o).substring(<caret>)
        }
    }
    void foo(String s) {}
}",class,
"  @NotNull<caret>
  String foo() {
    return null;
  }",method,
"  void m() {
    try { } catch (RuntimeException | My<caret>) { }
  }",method,
"  void m() {
    try { } catch (RuntimeException | MyException<caret>) { }
  }",method,
"  void m() {
    try { } catch (RuntimeException | My<caret> e) { }
  }",method,
"  void m() {
    try { } catch (RuntimeException | MyException<caret> e) { }
  }",method,
"    void foo() {
        Class<String> classOfString = (Class<? <caret>>)aClass.cast(Long.class);
    }",method,
"    switch (a) {
      <caret>
    }",method,
"  void f() {
    try (A<caret>) {
    }
  }",method,
"    try (A<caret>) {
    }",method,
"  void f() {
    try (AutoCloseable<caret>) {
    }
  }",method,
"    try (AutoCloseable<caret>) {
    }",method,
"  void f() {
    try (final My<caret>) {
    }
  }",method,
"    try (final My<caret>) {
    }",method,
"  void f() {
    try (final MyResource<caret>) {
    }
  }",method,
"    try (final MyResource<caret>) {
    }",method,
"  void f() {
    try (My<caret> r) {
    }
  }",method,
"    try (My<caret> r) {
    }",method,
"  void f() {
    try (MyResource<caret> r) {
    }
  }",method,
"    try (MyResource<caret> r) {
    }",method,
"  void f() {
    try (MyResource r1 = null; MyResource<caret>) {
    }
  }",method,
"    try (MyResource r1 = null; MyResource<caret>) {
    }",method,
"  void f() {
    String response;
    AutoCloseable resource;
    try (re<caret>) {
    }
  }",method,
"    try (re<caret>) {
    }",method,
"  void f() {
    String response;
    AutoCloseable resource;
    try (resource<caret>) {
    }
  }",method,
"    try (resource<caret>) {
    }",method,
"    boolean foo(Object o, final PairFunction<String, ElementType, Boolean> fun){
        boolean result = true;
        result |= fun.fun(path);
        if (o instanceof String) {
            o.subst<caret>
        }
    }",method,
"        if (o instanceof String) {
            o.subst<caret>
        }",method,
    void foo(String s) {},method,
"    boolean foo(Object o, final PairFunction<String, ElementType, Boolean> fun){
        boolean result = true;
        result |= fun.fun(path);
        if (o instanceof String) {
            ((String) o).substring(<caret>)
        }
    }",method,
"        if (o instanceof String) {
            ((String) o).substring(<caret>)
        }",method,
    void foo(String s) {},method,
"public class PyUnusedLocalInspection extends PyInspection {
  private static Key<PyUnusedLocalInspectionVisitor> KEY = Key.create(""PyUnusedLocal.Visitor"");
  public boolean ignoreTupleUnpacking = true;
  public boolean ignoreLambdaParameters = true;
  public boolean ignoreLoopIterationVariables = true;
  @NotNull
  @Nls
  public String getDisplayName() {
    return PyBundle.message(""INSP.NAME.unused"");
  }
  @NotNull
  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder,
                                        final boolean isOnTheFly,
                                        @NotNull LocalInspectionToolSession session) {
    final PyUnusedLocalInspectionVisitor visitor = new PyUnusedLocalInspectionVisitor(holder,
                                                                                      session,
                                                                                      ignoreTupleUnpacking,
                                                                                      ignoreLambdaParameters,
                                                                                      ignoreLoopIterationVariables);
    // buildVisitor() will be called on injected files in the same session - don't overwrite if we already have one
    final PyUnusedLocalInspectionVisitor existingVisitor = session.getUserData(KEY);
    if (existingVisitor == null) {
      session.putUserData(KEY, visitor);
    }
    return visitor;
  }
  @Override
  public void inspectionFinished(@NotNull LocalInspectionToolSession session, @NotNull ProblemsHolder holder) {
    final PyUnusedLocalInspectionVisitor visitor = session.getUserData(KEY);
    if (visitor != null) {
      visitor.registerProblems();
      session.putUserData(KEY, null);
    }
  }
  @Override
  public JComponent createOptionsPanel() {
    MultipleCheckboxOptionsPanel panel = new MultipleCheckboxOptionsPanel(this);
    panel.addCheckbox(""Ignore variables used in tuple unpacking"", ""ignoreTupleUnpacking"");
    panel.addCheckbox(""Ignore lambda parameters"", ""ignoreLambdaParameters"");
    panel.addCheckbox(""Ignore range iteration variables"", ""ignoreLoopIterationVariables"");
    return panel;
  }
}",class,
"  @NotNull
  @Nls
  public String getDisplayName() {
    return PyBundle.message(""INSP.NAME.unused"");
  }",method,
"  @NotNull
  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder,
                                        final boolean isOnTheFly,
                                        @NotNull LocalInspectionToolSession session) {
    final PyUnusedLocalInspectionVisitor visitor = new PyUnusedLocalInspectionVisitor(holder,
                                                                                      session,
                                                                                      ignoreTupleUnpacking,
                                                                                      ignoreLambdaParameters,
                                                                                      ignoreLoopIterationVariables);
    // buildVisitor() will be called on injected files in the same session - don't overwrite if we already have one
    final PyUnusedLocalInspectionVisitor existingVisitor = session.getUserData(KEY);
    if (existingVisitor == null) {
      session.putUserData(KEY, visitor);
    }
    return visitor;
  }",method,
"    if (existingVisitor == null) {
      session.putUserData(KEY, visitor);
    }",method,
"  @Override
  public void inspectionFinished(@NotNull LocalInspectionToolSession session, @NotNull ProblemsHolder holder) {
    final PyUnusedLocalInspectionVisitor visitor = session.getUserData(KEY);
    if (visitor != null) {
      visitor.registerProblems();
      session.putUserData(KEY, null);
    }
  }",method,
"    if (visitor != null) {
      visitor.registerProblems();
      session.putUserData(KEY, null);
    }",method,
"  @Override
  public JComponent createOptionsPanel() {
    MultipleCheckboxOptionsPanel panel = new MultipleCheckboxOptionsPanel(this);
    panel.addCheckbox(""Ignore variables used in tuple unpacking"", ""ignoreTupleUnpacking"");
    panel.addCheckbox(""Ignore lambda parameters"", ""ignoreLambdaParameters"");
    panel.addCheckbox(""Ignore range iteration variables"", ""ignoreLoopIterationVariables"");
    return panel;
  }",method,
"public class SuiteTest {
    public static class TestA {
        @Test
        public void pass() {
        }
    }
    public static class TestB {
        @Test
        public void fail() {
            Assert.fail();
        }
    }
    @RunWith(Suite.class)
    @SuiteClasses({TestA.class, TestB.class})
    public static class All {
    }
    @RunWith(Suite.class)
    @SuiteClasses(TestA.class)
    static class NonPublicSuite {
    }
    @RunWith(Suite.class)
    @SuiteClasses(TestA.class)
    static class NonPublicSuiteWithBeforeClass {
        @BeforeClass
        public static void doesNothing() {}
    }
    public static class InheritsAll extends All {
    }
    @Test
    public void ensureTestIsRun() {
        JUnitCore core = new JUnitCore();
        Result result = core.run(All.class);
        assertEquals(2, result.getRunCount());
        assertEquals(1, result.getFailureCount());
    }
    @Test
    public void ensureInheritedTestIsRun() {
        JUnitCore core = new JUnitCore();
        Result result = core.run(InheritsAll.class);
        assertEquals(2, result.getRunCount());
        assertEquals(1, result.getFailureCount());
    }
    @Test
    public void suiteTestCountIsCorrect() throws Exception {
        Runner runner = Request.aClass(All.class).getRunner();
        assertEquals(2, runner.testCount());
    }
    @Test
    public void suiteClassDoesNotNeedToBePublic() {
        JUnitCore core = new JUnitCore();
        Result result = core.run(NonPublicSuite.class);
        assertEquals(1, result.getRunCount());
        assertEquals(0, result.getFailureCount());
    }
    @Test
    public void nonPublicSuiteClassWithBeforeClassPasses() {
        assertThat(testResult(NonPublicSuiteWithBeforeClass.class), isSuccessful());
    }
    @Test
    public void ensureSuitesWorkWithForwardCompatibility() {
        junit.framework.Test test = new JUnit4TestAdapter(All.class);
        TestResult result = new TestResult();
        test.run(result);
        assertEquals(2, result.runCount());
    }
    @Test
    public void forwardCompatibilityWorksWithGetTests() {
        JUnit4TestAdapter adapter = new JUnit4TestAdapter(All.class);
        List<? extends junit.framework.Test> tests = adapter.getTests();
        assertEquals(2, tests.size());
    }
    @Test
    public void forwardCompatibilityWorksWithTestCount() {
        JUnit4TestAdapter adapter = new JUnit4TestAdapter(All.class);
        assertEquals(2, adapter.countTestCases());
    }
    private static String log = """";
    @RunWith(Suite.class)
    @SuiteClasses({TestA.class, TestB.class})
    public static class AllWithBeforeAndAfterClass {
        @BeforeClass
        public static void before() {
            log += ""before "";
        }
        @AfterClass
        public static void after() {
            log += ""after "";
        }
    }
    @Test
    public void beforeAndAfterClassRunOnSuite() {
        log = """";
        JUnitCore.runClasses(AllWithBeforeAndAfterClass.class);
        assertEquals(""before after "", log);
    }
    @RunWith(Suite.class)
    public static class AllWithOutAnnotation {
    }
    @Test
    public void withoutSuiteClassAnnotationProducesFailure() {
        Result result = JUnitCore.runClasses(AllWithOutAnnotation.class);
        assertEquals(1, result.getFailureCount());
        String expected = String.format(
                ""class '%s' must have a SuiteClasses annotation"",
                AllWithOutAnnotation.class.getName());
        assertEquals(expected, result.getFailures().get(0).getMessage());
    }
    @RunWith(Suite.class)
    @SuiteClasses(InfiniteLoop.class)
    static public class InfiniteLoop {
    }
    @Test
    public void whatHappensWhenASuiteHasACycle() {
        Result result = JUnitCore.runClasses(InfiniteLoop.class);
        assertEquals(1, result.getFailureCount());
    }
    @RunWith(Suite.class)
    @SuiteClasses({BiInfiniteLoop.class, BiInfiniteLoop.class})
    static public class BiInfiniteLoop {
    }
    @Test
    public void whatHappensWhenASuiteHasAForkingCycle() {
        Result result = JUnitCore.runClasses(BiInfiniteLoop.class);
        assertEquals(2, result.getFailureCount());
    }
    // The interesting case here is that Hydra indirectly contains two copies of
    // itself (if it only contains one, Java's StackOverflowError eventually
    // bails us out)
    @RunWith(Suite.class)
    @SuiteClasses({Hercules.class})
    static public class Hydra {
    }
    @RunWith(Suite.class)
    @SuiteClasses({Hydra.class, Hydra.class})
    static public class Hercules {
    }
    @Test
    public void whatHappensWhenASuiteContainsItselfIndirectly() {
        Result result = JUnitCore.runClasses(Hydra.class);
        assertEquals(2, result.getFailureCount());
    }
    @RunWith(Suite.class)
    @SuiteClasses({})
    public class WithoutDefaultConstructor {
        public WithoutDefaultConstructor(int i) {
        }
    }
    @Test
    public void suiteShouldBeOKwithNonDefaultConstructor() throws Exception {
        Result result = JUnitCore.runClasses(WithoutDefaultConstructor.class);
        assertTrue(result.wasSuccessful());
    }
    @RunWith(Suite.class)
    public class NoSuiteClassesAnnotation {
    }
    @Test
    public void suiteShouldComplainAboutNoSuiteClassesAnnotation() {
        assertThat(testResult(NoSuiteClassesAnnotation.class), hasSingleFailureContaining(""SuiteClasses""));
    }
}",class,
"    public static class TestA {
        @Test
        public void pass() {
        }
    }",class,
"    public static class TestB {
        @Test
        public void fail() {
            Assert.fail();
        }
    }",class,
"    public static class All {
    }",class,
"    static class NonPublicSuite {
    }",class,
"    static class NonPublicSuiteWithBeforeClass {
        @BeforeClass
        public static void doesNothing() {}
    }",class,
"    public static class InheritsAll extends All {
    }",class,
"    public static class AllWithBeforeAndAfterClass {
        @BeforeClass
        public static void before() {
            log += ""before "";
        }
        @AfterClass
        public static void after() {
            log += ""after "";
        }
    }",class,
"    public static class AllWithOutAnnotation {
    }",class,
"    static public class InfiniteLoop {
    }",class,
"    static public class BiInfiniteLoop {
    }",class,
"    static public class Hydra {
    }",class,
"    static public class Hercules {
    }",class,
"    public class WithoutDefaultConstructor {
        public WithoutDefaultConstructor(int i) {
        }
    }",class,
"    public class NoSuiteClassesAnnotation {
    }",class,
"        @Test
        public void pass() {
        }",method,
"        @Test
        public void fail() {
            Assert.fail();
        }",method,
"        @BeforeClass
        public static void doesNothing() {}",method,
"    @Test
    public void ensureTestIsRun() {
        JUnitCore core = new JUnitCore();
        Result result = core.run(All.class);
        assertEquals(2, result.getRunCount());
        assertEquals(1, result.getFailureCount());
    }",method,
"    @Test
    public void ensureInheritedTestIsRun() {
        JUnitCore core = new JUnitCore();
        Result result = core.run(InheritsAll.class);
        assertEquals(2, result.getRunCount());
        assertEquals(1, result.getFailureCount());
    }",method,
"    @Test
    public void suiteTestCountIsCorrect() throws Exception {
        Runner runner = Request.aClass(All.class).getRunner();
        assertEquals(2, runner.testCount());
    }",method,
"    @Test
    public void suiteClassDoesNotNeedToBePublic() {
        JUnitCore core = new JUnitCore();
        Result result = core.run(NonPublicSuite.class);
        assertEquals(1, result.getRunCount());
        assertEquals(0, result.getFailureCount());
    }",method,
"    @Test
    public void nonPublicSuiteClassWithBeforeClassPasses() {
        assertThat(testResult(NonPublicSuiteWithBeforeClass.class), isSuccessful());
    }",method,
"    @Test
    public void ensureSuitesWorkWithForwardCompatibility() {
        junit.framework.Test test = new JUnit4TestAdapter(All.class);
        TestResult result = new TestResult();
        test.run(result);
        assertEquals(2, result.runCount());
    }",method,
"    @Test
    public void forwardCompatibilityWorksWithGetTests() {
        JUnit4TestAdapter adapter = new JUnit4TestAdapter(All.class);
        List<? extends junit.framework.Test> tests = adapter.getTests();
        assertEquals(2, tests.size());
    }",method,
"    @Test
    public void forwardCompatibilityWorksWithTestCount() {
        JUnit4TestAdapter adapter = new JUnit4TestAdapter(All.class);
        assertEquals(2, adapter.countTestCases());
    }",method,
"        @BeforeClass
        public static void before() {
            log += ""before "";
        }",method,
"        @AfterClass
        public static void after() {
            log += ""after "";
        }",method,
"    @Test
    public void beforeAndAfterClassRunOnSuite() {
        log = """";
        JUnitCore.runClasses(AllWithBeforeAndAfterClass.class);
        assertEquals(""before after "", log);
    }",method,
"    @Test
    public void withoutSuiteClassAnnotationProducesFailure() {
        Result result = JUnitCore.runClasses(AllWithOutAnnotation.class);
        assertEquals(1, result.getFailureCount());
        String expected = String.format(
                ""class '%s' must have a SuiteClasses annotation"",
                AllWithOutAnnotation.class.getName());
        assertEquals(expected, result.getFailures().get(0).getMessage());
    }",method,
"    @Test
    public void whatHappensWhenASuiteHasACycle() {
        Result result = JUnitCore.runClasses(InfiniteLoop.class);
        assertEquals(1, result.getFailureCount());
    }",method,
"    @Test
    public void whatHappensWhenASuiteHasAForkingCycle() {
        Result result = JUnitCore.runClasses(BiInfiniteLoop.class);
        assertEquals(2, result.getFailureCount());
    }",method,
"    @Test
    public void whatHappensWhenASuiteContainsItselfIndirectly() {
        Result result = JUnitCore.runClasses(Hydra.class);
        assertEquals(2, result.getFailureCount());
    }",method,
"        public WithoutDefaultConstructor(int i) {
        }",method,
"    @Test
    public void suiteShouldBeOKwithNonDefaultConstructor() throws Exception {
        Result result = JUnitCore.runClasses(WithoutDefaultConstructor.class);
        assertTrue(result.wasSuccessful());
    }",method,
"    @Test
    public void suiteShouldComplainAboutNoSuiteClassesAnnotation() {
        assertThat(testResult(NoSuiteClassesAnnotation.class), hasSingleFailureContaining(""SuiteClasses""));
    }",method,
"public class IngestExternalFileOptionsTest {
  @ClassRule
  public static final RocksMemoryResource rocksMemoryResource
      = new RocksMemoryResource();
  public static final Random rand =
      PlatformRandomHelper.getPlatformSpecificRandomFactory();
  @Test
  public void createExternalSstFileInfoWithoutParameters() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      assertThat(options).isNotNull();
    }
  }
  @Test
  public void createExternalSstFileInfoWithParameters() {
    final boolean moveFiles = rand.nextBoolean();
    final boolean snapshotConsistency = rand.nextBoolean();
    final boolean allowGlobalSeqNo = rand.nextBoolean();
    final boolean allowBlockingFlush = rand.nextBoolean();
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions(moveFiles, snapshotConsistency,
        allowGlobalSeqNo, allowBlockingFlush)) {
      assertThat(options).isNotNull();
      assertThat(options.moveFiles()).isEqualTo(moveFiles);
      assertThat(options.snapshotConsistency()).isEqualTo(snapshotConsistency);
      assertThat(options.allowGlobalSeqNo()).isEqualTo(allowGlobalSeqNo);
      assertThat(options.allowBlockingFlush()).isEqualTo(allowBlockingFlush);
    }
  }
  @Test
  public void moveFiles() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean moveFiles = rand.nextBoolean();
      options.setMoveFiles(moveFiles);
      assertThat(options.moveFiles()).isEqualTo(moveFiles);
    }
  }
  @Test
  public void snapshotConsistency() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean snapshotConsistency = rand.nextBoolean();
      options.setSnapshotConsistency(snapshotConsistency);
      assertThat(options.snapshotConsistency()).isEqualTo(snapshotConsistency);
    }
  }
  @Test
  public void allowGlobalSeqNo() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean allowGlobalSeqNo = rand.nextBoolean();
      options.setAllowGlobalSeqNo(allowGlobalSeqNo);
      assertThat(options.allowGlobalSeqNo()).isEqualTo(allowGlobalSeqNo);
    }
  }
  @Test
  public void allowBlockingFlush() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean allowBlockingFlush = rand.nextBoolean();
      options.setAllowBlockingFlush(allowBlockingFlush);
      assertThat(options.allowBlockingFlush()).isEqualTo(allowBlockingFlush);
    }
  }
}",class,
"  @Test
  public void createExternalSstFileInfoWithoutParameters() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      assertThat(options).isNotNull();
    }
  }",method,
"  @Test
  public void createExternalSstFileInfoWithParameters() {
    final boolean moveFiles = rand.nextBoolean();
    final boolean snapshotConsistency = rand.nextBoolean();
    final boolean allowGlobalSeqNo = rand.nextBoolean();
    final boolean allowBlockingFlush = rand.nextBoolean();
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions(moveFiles, snapshotConsistency,
        allowGlobalSeqNo, allowBlockingFlush)) {
      assertThat(options).isNotNull();
      assertThat(options.moveFiles()).isEqualTo(moveFiles);
      assertThat(options.snapshotConsistency()).isEqualTo(snapshotConsistency);
      assertThat(options.allowGlobalSeqNo()).isEqualTo(allowGlobalSeqNo);
      assertThat(options.allowBlockingFlush()).isEqualTo(allowBlockingFlush);
    }
  }",method,
"  @Test
  public void moveFiles() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean moveFiles = rand.nextBoolean();
      options.setMoveFiles(moveFiles);
      assertThat(options.moveFiles()).isEqualTo(moveFiles);
    }
  }",method,
"  @Test
  public void snapshotConsistency() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean snapshotConsistency = rand.nextBoolean();
      options.setSnapshotConsistency(snapshotConsistency);
      assertThat(options.snapshotConsistency()).isEqualTo(snapshotConsistency);
    }
  }",method,
"  @Test
  public void allowGlobalSeqNo() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean allowGlobalSeqNo = rand.nextBoolean();
      options.setAllowGlobalSeqNo(allowGlobalSeqNo);
      assertThat(options.allowGlobalSeqNo()).isEqualTo(allowGlobalSeqNo);
    }
  }",method,
"  @Test
  public void allowBlockingFlush() {
    try (final IngestExternalFileOptions options =
        new IngestExternalFileOptions()) {
      final boolean allowBlockingFlush = rand.nextBoolean();
      options.setAllowBlockingFlush(allowBlockingFlush);
      assertThat(options.allowBlockingFlush()).isEqualTo(allowBlockingFlush);
    }
  }",method,
"public class EachToForIntention extends Intention {
  @NonNls public static final String OUTER = ""Outer"";
  @NonNls public static final String HINT = ""Replace with For-In"";
  @NotNull
  @Override
  protected PsiElementPredicate getElementPredicate() {
    return new EachToForPredicate();
  }
  @Override
  protected void processIntention(@NotNull PsiElement element, @NotNull Project project, Editor editor) throws IncorrectOperationException {
    final GrMethodCallExpression expression = (GrMethodCallExpression)element;
    final GrClosableBlock block = expression.getClosureArguments()[0];
    final GrParameterList parameterList = block.getParameterList();
    final GrParameter[] parameters = parameterList.getParameters();
    String var;
    if (parameters.length == 1) {
      var = parameters[0].getText();
      var = StringUtil.replace(var, GrModifier.DEF, """");
    }
    else {
      var = ""it"";
    }
    final GrExpression invokedExpression = expression.getInvokedExpression();
    GrExpression qualifier = ((GrReferenceExpression)invokedExpression).getQualifierExpression();
    final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(element.getProject());
    if (qualifier == null) {
      qualifier = elementFactory.createExpressionFromText(""this"");
    }
    StringBuilder builder = new StringBuilder();
    builder.append(""for ("").append(var).append("" in "").append(qualifier.getText()).append("") {\n"");
    String text = block.getText();
    final PsiElement blockArrow = block.getArrow();
    int index;
    if (blockArrow != null) {
      index = blockArrow.getStartOffsetInParent() + blockArrow.getTextLength();
    }
    else {
      index = 1;
    }
    while (index < text.length() && Character.isWhitespace(text.charAt(index))) index++;
    text = text.substring(index, text.length() - 1);
    builder.append(text);
    builder.append(""}"");
    final GrStatement statement = elementFactory.createStatementFromText(builder.toString());
    GrForStatement forStatement = (GrForStatement)expression.replaceWithStatement(statement);
    final GrForClause clause = forStatement.getClause();
    GrVariable variable = clause.getDeclaredVariable();
    forStatement = updateReturnStatements(forStatement);
    if (variable == null) return;
    if (ApplicationManager.getApplication().isUnitTestMode()) return;
    final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);
    final Document doc = documentManager.getDocument(element.getContainingFile());
    if (doc == null) return;
    documentManager.doPostponedOperationsAndUnblockDocument(doc);
    editor.getCaretModel().moveToOffset(variable.getTextOffset());
    new VariableInplaceRenamer(variable, editor).performInplaceRename();
  }
  private static GrForStatement updateReturnStatements(GrForStatement forStatement) {
    GrStatement body = forStatement.getBody();
    assert body != null;
    final Set<String> usedLabels = ContainerUtil.newHashSet();
    final Ref<Boolean> needLabel = Ref.create(false);
    body.accept(new GroovyRecursiveElementVisitor() {
      private int myLoops = 0;
      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() != null) return;
        if (myLoops > 0) needLabel.set(true);
      }
      @Override
      public void visitLabeledStatement(@NotNull GrLabeledStatement labeledStatement) {
        super.visitLabeledStatement(labeledStatement);
        usedLabels.add(labeledStatement.getName());
      }
      @Override
      public void visitForStatement(@NotNull GrForStatement forStatement) {
        myLoops++;
        super.visitForStatement(forStatement);
        myLoops--;
      }
      @Override
      public void visitWhileStatement(@NotNull GrWhileStatement whileStatement) {
        myLoops++;
        super.visitWhileStatement(whileStatement);
        myLoops--;
      }
      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }
      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }
    });
    GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(forStatement.getProject());
    final String continueText;
    if (needLabel.get()) {
      int i = 0;
      String label = OUTER;
      while (usedLabels.contains(label)) {
        label = OUTER + i;
        i++;
      }
      continueText = ""continue ""+ label;
      GrLabeledStatement labeled = (GrLabeledStatement)factory.createStatementFromText(label + "": while (true){}"");
      labeled.getStatement().replaceWithStatement(forStatement);
      labeled = forStatement.replaceWithStatement(labeled);
      forStatement = (GrForStatement)labeled.getStatement();
      body = forStatement.getBody();
      assert body != null;
    }
    else {
      continueText = ""continue"";
    }
    final GrStatement continueStatement = factory.createStatementFromText(continueText);
    body.accept(new GroovyRecursiveElementVisitor() {
      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() == null) {
          returnStatement.replaceWithStatement(continueStatement);
        }
      }
      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }
      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }
    });
    return forStatement;
  }
  private static class EachToForPredicate implements PsiElementPredicate {
    @Override
    public boolean satisfiedBy(@NotNull PsiElement element) {
      if (element instanceof GrMethodCallExpression) {
        final GrMethodCallExpression expression = (GrMethodCallExpression)element;
//        final PsiElement parent = expression.getParent();
//        if (parent instanceof GrAssignmentExpression) return false;
//        if (parent instanceof GrArgumentList) return false;
//        if (parent instanceof GrReturnStatement) return false;
//        if (!(parent instanceof GrCodeBlock || parent instanceof GrIfStatement|| parent instanceof GrCaseSection)) return false;
        final GrExpression invokedExpression = expression.getInvokedExpression();
        if (invokedExpression instanceof GrReferenceExpression) {
          GrReferenceExpression referenceExpression = (GrReferenceExpression)invokedExpression;
          if (""each"".equals(referenceExpression.getReferenceName())) {
            final GrArgumentList argumentList = expression.getArgumentList();
            if (PsiImplUtil.hasExpressionArguments(argumentList)) return false;
            if (PsiImplUtil.hasNamedArguments(argumentList)) return false;
            final GrClosableBlock[] closureArguments = expression.getClosureArguments();
            if (closureArguments.length != 1) return false;
            final GrParameter[] parameters = closureArguments[0].getParameterList().getParameters();
            if (parameters.length > 1) return false;
            return true;
          }
        }
      }
      return false;
    }
  }
}",class,
"  private static class EachToForPredicate implements PsiElementPredicate {
    @Override
    public boolean satisfiedBy(@NotNull PsiElement element) {
      if (element instanceof GrMethodCallExpression) {
        final GrMethodCallExpression expression = (GrMethodCallExpression)element;
//        final PsiElement parent = expression.getParent();
//        if (parent instanceof GrAssignmentExpression) return false;
//        if (parent instanceof GrArgumentList) return false;
//        if (parent instanceof GrReturnStatement) return false;
//        if (!(parent instanceof GrCodeBlock || parent instanceof GrIfStatement|| parent instanceof GrCaseSection)) return false;
        final GrExpression invokedExpression = expression.getInvokedExpression();
        if (invokedExpression instanceof GrReferenceExpression) {
          GrReferenceExpression referenceExpression = (GrReferenceExpression)invokedExpression;
          if (""each"".equals(referenceExpression.getReferenceName())) {
            final GrArgumentList argumentList = expression.getArgumentList();
            if (PsiImplUtil.hasExpressionArguments(argumentList)) return false;
            if (PsiImplUtil.hasNamedArguments(argumentList)) return false;
            final GrClosableBlock[] closureArguments = expression.getClosureArguments();
            if (closureArguments.length != 1) return false;
            final GrParameter[] parameters = closureArguments[0].getParameterList().getParameters();
            if (parameters.length > 1) return false;
            return true;
          }
        }
      }
      return false;
    }
  }",class,
"  @NonNls public static final String OUTER = ""Outer"";
  @NonNls public static final String HINT = ""Replace with For-In"";
  @NotNull
  @Override
  protected PsiElementPredicate getElementPredicate() {
    return new EachToForPredicate();
  }",method,
"  @Override
  protected void processIntention(@NotNull PsiElement element, @NotNull Project project, Editor editor) throws IncorrectOperationException {
    final GrMethodCallExpression expression = (GrMethodCallExpression)element;
    final GrClosableBlock block = expression.getClosureArguments()[0];
    final GrParameterList parameterList = block.getParameterList();
    final GrParameter[] parameters = parameterList.getParameters();
    String var;
    if (parameters.length == 1) {
      var = parameters[0].getText();
      var = StringUtil.replace(var, GrModifier.DEF, """");
    }
    else {
      var = ""it"";
    }
    final GrExpression invokedExpression = expression.getInvokedExpression();
    GrExpression qualifier = ((GrReferenceExpression)invokedExpression).getQualifierExpression();
    final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(element.getProject());
    if (qualifier == null) {
      qualifier = elementFactory.createExpressionFromText(""this"");
    }
    StringBuilder builder = new StringBuilder();
    builder.append(""for ("").append(var).append("" in "").append(qualifier.getText()).append("") {\n"");
    String text = block.getText();
    final PsiElement blockArrow = block.getArrow();
    int index;
    if (blockArrow != null) {
      index = blockArrow.getStartOffsetInParent() + blockArrow.getTextLength();
    }
    else {
      index = 1;
    }
    while (index < text.length() && Character.isWhitespace(text.charAt(index))) index++;
    text = text.substring(index, text.length() - 1);
    builder.append(text);
    builder.append(""}"");
    final GrStatement statement = elementFactory.createStatementFromText(builder.toString());
    GrForStatement forStatement = (GrForStatement)expression.replaceWithStatement(statement);
    final GrForClause clause = forStatement.getClause();
    GrVariable variable = clause.getDeclaredVariable();
    forStatement = updateReturnStatements(forStatement);
    if (variable == null) return;
    if (ApplicationManager.getApplication().isUnitTestMode()) return;
    final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);
    final Document doc = documentManager.getDocument(element.getContainingFile());
    if (doc == null) return;
    documentManager.doPostponedOperationsAndUnblockDocument(doc);
    editor.getCaretModel().moveToOffset(variable.getTextOffset());
    new VariableInplaceRenamer(variable, editor).performInplaceRename();
  }",method,
"    if (parameters.length == 1) {
      var = parameters[0].getText();
      var = StringUtil.replace(var, GrModifier.DEF, """");
    }",method,
"    if (qualifier == null) {
      qualifier = elementFactory.createExpressionFromText(""this"");
    }",method,
"    if (blockArrow != null) {
      index = blockArrow.getStartOffsetInParent() + blockArrow.getTextLength();
    }",method,
"  private static GrForStatement updateReturnStatements(GrForStatement forStatement) {
    GrStatement body = forStatement.getBody();
    assert body != null;
    final Set<String> usedLabels = ContainerUtil.newHashSet();
    final Ref<Boolean> needLabel = Ref.create(false);
    body.accept(new GroovyRecursiveElementVisitor() {
      private int myLoops = 0;
      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() != null) return;
        if (myLoops > 0) needLabel.set(true);
      }
      @Override
      public void visitLabeledStatement(@NotNull GrLabeledStatement labeledStatement) {
        super.visitLabeledStatement(labeledStatement);
        usedLabels.add(labeledStatement.getName());
      }
      @Override
      public void visitForStatement(@NotNull GrForStatement forStatement) {
        myLoops++;
        super.visitForStatement(forStatement);
        myLoops--;
      }
      @Override
      public void visitWhileStatement(@NotNull GrWhileStatement whileStatement) {
        myLoops++;
        super.visitWhileStatement(whileStatement);
        myLoops--;
      }
      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }
      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }
    });
    GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(forStatement.getProject());
    final String continueText;
    if (needLabel.get()) {
      int i = 0;
      String label = OUTER;
      while (usedLabels.contains(label)) {
        label = OUTER + i;
        i++;
      }
      continueText = ""continue ""+ label;
      GrLabeledStatement labeled = (GrLabeledStatement)factory.createStatementFromText(label + "": while (true){}"");
      labeled.getStatement().replaceWithStatement(forStatement);
      labeled = forStatement.replaceWithStatement(labeled);
      forStatement = (GrForStatement)labeled.getStatement();
      body = forStatement.getBody();
      assert body != null;
    }
    else {
      continueText = ""continue"";
    }
    final GrStatement continueStatement = factory.createStatementFromText(continueText);
    body.accept(new GroovyRecursiveElementVisitor() {
      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() == null) {
          returnStatement.replaceWithStatement(continueStatement);
        }
      }
      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }
      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }
    });
    return forStatement;
  }",method,
"    body.accept(new GroovyRecursiveElementVisitor() {
      private int myLoops = 0;
      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() != null) return;
        if (myLoops > 0) needLabel.set(true);
      }
      @Override
      public void visitLabeledStatement(@NotNull GrLabeledStatement labeledStatement) {
        super.visitLabeledStatement(labeledStatement);
        usedLabels.add(labeledStatement.getName());
      }
      @Override
      public void visitForStatement(@NotNull GrForStatement forStatement) {
        myLoops++;
        super.visitForStatement(forStatement);
        myLoops--;
      }
      @Override
      public void visitWhileStatement(@NotNull GrWhileStatement whileStatement) {
        myLoops++;
        super.visitWhileStatement(whileStatement);
        myLoops--;
      }
      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }
      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }
    }",method,
"      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() != null) return;
        if (myLoops > 0) needLabel.set(true);
      }",method,
"      @Override
      public void visitLabeledStatement(@NotNull GrLabeledStatement labeledStatement) {
        super.visitLabeledStatement(labeledStatement);
        usedLabels.add(labeledStatement.getName());
      }",method,
"      @Override
      public void visitForStatement(@NotNull GrForStatement forStatement) {
        myLoops++;
        super.visitForStatement(forStatement);
        myLoops--;
      }",method,
"      @Override
      public void visitWhileStatement(@NotNull GrWhileStatement whileStatement) {
        myLoops++;
        super.visitWhileStatement(whileStatement);
        myLoops--;
      }",method,
"      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }",method,
"      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }",method,
"    body.accept(new GroovyRecursiveElementVisitor() {
      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() == null) {
          returnStatement.replaceWithStatement(continueStatement);
        }
      }
      @Override
      public void visitClosure(@NotNull GrClosableBlock closure) {
        //don't go into closures
      }
      @Override
      public void visitAnonymousClassDefinition(@NotNull GrAnonymousClassDefinition anonymousClassDefinition) {
        //don't go into anonymous
      }
    }",method,
"      @Override
      public void visitReturnStatement(@NotNull GrReturnStatement returnStatement) {
        if (returnStatement.getReturnValue() == null) {
          returnStatement.replaceWithStatement(continueStatement);
        }
      }",method,

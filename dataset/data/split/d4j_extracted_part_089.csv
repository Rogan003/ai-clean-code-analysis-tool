code_snippet,type,score
"	public static VectorFunction create(int inputDims, List<IFunction> functions) {
		IFunction[] funcs=functions.toArray(new IFunction[functions.size()]);
		return new VectorFunction(inputDims,funcs.length,funcs);
	}",method,
"	public IFunction getFunction(int i) {
		return functions[i];
	}",method,
"	@Override
	public void transform(AVector source, AVector dest) {
		for (int i=0; i<outputDimensions; i++) {
			double v=getTransformedComponent(i,source);
			dest.set(i,v);
		}
	}",method,
"		for (int i=0; i<outputDimensions; i++) {
			double v=getTransformedComponent(i,source);
			dest.set(i,v);
		}",method,
"	private double getTransformedComponent(int i, AVector source) {
		double v;
		switch (inputDimensions) {
			case 0: v=functions[i].calc(); break;
			case 1: v=functions[i].calc(source.get(0)); break;
			case 2: v=functions[i].calc(source.get(0),source.get(1)); break;
			case 3: v=functions[i].calc(source.get(0),source.get(1),source.get(2)); break;
			default: v=functions[i].calc(source.get(0),source.get(1),source.get(2),source.get(3)); break;
		}
		return v;
	}",method,
"		switch (inputDimensions) {
			case 0: v=functions[i].calc(); break;
			case 1: v=functions[i].calc(source.get(0)); break;
			case 2: v=functions[i].calc(source.get(0),source.get(1)); break;
			case 3: v=functions[i].calc(source.get(0),source.get(1),source.get(2)); break;
			default: v=functions[i].calc(source.get(0),source.get(1),source.get(2),source.get(3)); break;
		}",method,
"	private double getTransformedComponent(int i, Vector3 source) {
		return functions[i].calc(source.x,source.y,source.z);
	}",method,
"	public void transform(AVector source, Vector3 dest) {
		assert(outputDimensions==3);
		dest.x=getTransformedComponent(0,source);
		dest.y=getTransformedComponent(1,source);
		dest.z=getTransformedComponent(2,source);
	}",method,
"	public void transform(Vector3 source, Vector3 dest) {
		assert(inputDimensions==3);
		assert(outputDimensions==3);
		dest.x=getTransformedComponent(0,source);
		dest.y=getTransformedComponent(1,source);
		dest.z=getTransformedComponent(2,source);
	}",method,
"	@Override
	public int inputDimensions() {
		return inputDimensions;
	}",method,
"	@Override
	public int outputDimensions() {
		return outputDimensions;
	}",method,
"	@Override
	public Object call() throws Exception {
		throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public void run() {
		throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke() {
		throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1) {
		return transform(Vectorz.toVector(arg1));
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2) {
		throw new ArityException(2,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3) {
		throw new ArityException(3,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4) {
		throw new ArityException(4,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5) {
		throw new ArityException(5,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6) {
		throw new ArityException(6,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7) {
		throw new ArityException(7,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8) {
		throw new ArityException(8,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9) {
		throw new ArityException(9,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10) {
		throw new ArityException(10,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11) {
		throw new ArityException(11,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12) {
		throw new ArityException(12,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13) {
		throw new ArityException(13,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13, Object arg14) {
		throw new ArityException(14,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15) {
		throw new ArityException(15,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16) {
		throw new ArityException(16,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17) {
		throw new ArityException(17,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17, Object arg18) {
		throw new ArityException(18,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17,
			Object arg18, Object arg19) {
		throw new ArityException(19,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17,
			Object arg18, Object arg19, Object arg20) {
		throw new ArityException(20,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4,
			Object arg5, Object arg6, Object arg7, Object arg8, Object arg9,
			Object arg10, Object arg11, Object arg12, Object arg13,
			Object arg14, Object arg15, Object arg16, Object arg17,
			Object arg18, Object arg19, Object arg20, Object... args) {
		throw new ArityException(20+args.length,""VectorFunctsion requires exactly one argument"");
	}",method,
"	@Override
	public Object applyTo(ISeq arglist) {
		if (arglist==null) throw new ArityException(0,""VectorFunctsion requires exactly one argument"");
		Object o=arglist.first();
		ISeq next=arglist.next();
		if (next!=null) throw new ArityException(RT.count(arglist),""VectorFunctsion requires exactly one argument"");
		return invoke(o);
	}",method,
"public class UIDesignerIcons {
  private static Icon load(String path) {
    return IconLoader.getIcon(path, UIDesignerIcons.class);
  }
  @SuppressWarnings(""unused"")
  public static final Icon Button = load(""/com/intellij/uiDesigner/icons/button.png""); // 16x16
  public static final Icon ButtonGroup = load(""/com/intellij/uiDesigner/icons/buttonGroup.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon CheckBox = load(""/com/intellij/uiDesigner/icons/checkBox.png""); // 16x16
  public static final Icon ChooseLocale = load(""/com/intellij/uiDesigner/icons/chooseLocale.png""); // 16x16
  public static final Icon CollapseNode = load(""/com/intellij/uiDesigner/icons/collapseNode.png""); // 9x9
  @SuppressWarnings(""unused"")
  public static final Icon ComboBox = load(""/com/intellij/uiDesigner/icons/comboBox.png""); // 16x16
  public static final Icon DataBindingWizard = load(""/com/intellij/uiDesigner/icons/dataBindingWizard.png""); // 16x16
  public static final Icon DeleteCell = load(""/com/intellij/uiDesigner/icons/deleteCell.png""); // 7x7
  public static final Icon Drag = load(""/com/intellij/uiDesigner/icons/drag.png""); // 11x11
  @SuppressWarnings(""unused"")
  public static final Icon EditorPane = load(""/com/intellij/uiDesigner/icons/editorPane.png""); // 16x16
  public static final Icon Empty = load(""/com/intellij/uiDesigner/icons/empty.png""); // 16x16
  public static final Icon ExpandNode = load(""/com/intellij/uiDesigner/icons/expandNode.png""); // 9x9
  @SuppressWarnings(""unused"")
  public static final Icon FormattedTextField = load(""/com/intellij/uiDesigner/icons/formattedTextField.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Hspacer = load(""/com/intellij/uiDesigner/icons/hspacer.png""); // 16x16
  public static final Icon InsertColumnLeft = load(""/com/intellij/uiDesigner/icons/insertColumnLeft.png""); // 7x7
  public static final Icon InsertColumnRight = load(""/com/intellij/uiDesigner/icons/insertColumnRight.png""); // 7x7
  public static final Icon InsertRowAbove = load(""/com/intellij/uiDesigner/icons/insertRowAbove.png""); // 7x7
  public static final Icon InsertRowBelow = load(""/com/intellij/uiDesigner/icons/insertRowBelow.png""); // 7x7
  public static final Icon InspectionSuppression = load(""/com/intellij/uiDesigner/icons/inspectionSuppression.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Label = load(""/com/intellij/uiDesigner/icons/label.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon List = load(""/com/intellij/uiDesigner/icons/list.png""); // 16x16
  public static final Icon Listener = load(""/com/intellij/uiDesigner/icons/listener.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Panel = load(""/com/intellij/uiDesigner/icons/panel.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon PasswordField = load(""/com/intellij/uiDesigner/icons/passwordField.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Progressbar = load(""/com/intellij/uiDesigner/icons/progressbar.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon RadioButton = load(""/com/intellij/uiDesigner/icons/radioButton.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Scrollbar = load(""/com/intellij/uiDesigner/icons/scrollbar.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon ScrollPane = load(""/com/intellij/uiDesigner/icons/scrollPane.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Separator = load(""/com/intellij/uiDesigner/icons/separator.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Slider = load(""/com/intellij/uiDesigner/icons/slider.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Spinner = load(""/com/intellij/uiDesigner/icons/spinner.png""); // 16x16
  public static final Icon SplitColumn = load(""/com/intellij/uiDesigner/icons/splitColumn.png""); // 7x7
  @SuppressWarnings(""unused"")
  public static final Icon SplitPane = load(""/com/intellij/uiDesigner/icons/splitPane.png""); // 16x16
  public static final Icon SplitRow = load(""/com/intellij/uiDesigner/icons/splitRow.png""); // 7x7
  @SuppressWarnings(""unused"")
  public static final Icon TabbedPane = load(""/com/intellij/uiDesigner/icons/tabbedPane.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Table = load(""/com/intellij/uiDesigner/icons/table.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon TextArea = load(""/com/intellij/uiDesigner/icons/textArea.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon TextField = load(""/com/intellij/uiDesigner/icons/textField.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon TextPane = load(""/com/intellij/uiDesigner/icons/textPane.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Toolbar = load(""/com/intellij/uiDesigner/icons/toolbar.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon ToolbarSeparator = load(""/com/intellij/uiDesigner/icons/toolbarSeparator.png""); // 16x16
  public static final Icon ToolWindowUIDesigner = load(""/com/intellij/uiDesigner/icons/toolWindowUIDesigner.png""); // 13x13
  @SuppressWarnings(""unused"")
  public static final Icon Tree = load(""/com/intellij/uiDesigner/icons/tree.png""); // 16x16
  public static final Icon Unknown_small = load(""/com/intellij/uiDesigner/icons/unknown-small.png""); // 16x16
  public static final Icon Unknown = load(""/com/intellij/uiDesigner/icons/unknown.png""); // 16x16
  @SuppressWarnings(""unused"")
  public static final Icon Vspacer = load(""/com/intellij/uiDesigner/icons/vspacer.png""); // 16x16
}",class,
"  private static Icon load(String path) {
    return IconLoader.getIcon(path, UIDesignerIcons.class);
  }",method,
"public final class AttConstantValue extends BaseAttribute {
    public static final String ATTRIBUTE_NAME = ""ConstantValue"";
    private final TypedConstant constantValue;
    public AttConstantValue(TypedConstant constantValue) {
        super(ATTRIBUTE_NAME);
        if (!((constantValue instanceof CstString) ||
               (constantValue instanceof CstInteger) ||
               (constantValue instanceof CstLong) ||
               (constantValue instanceof CstFloat) ||
               (constantValue instanceof CstDouble))) {
            if (constantValue == null) {
                throw new NullPointerException(""constantValue == null"");
            }
            throw new IllegalArgumentException(""bad type for constantValue"");
        }
        this.constantValue = constantValue;
    }
    public int byteLength() {
        return 8;
    }
    public TypedConstant getConstantValue() {
        return constantValue;
    }
}",class,
"public final class AttDeprecated extends BaseAttribute {
    public static final String ATTRIBUTE_NAME = ""Deprecated"";
    public AttDeprecated() {
        super(ATTRIBUTE_NAME);
    }
    public int byteLength() {
        return 6;
    }
}",class,
"    public AttConstantValue(TypedConstant constantValue) {
        super(ATTRIBUTE_NAME);
        if (!((constantValue instanceof CstString) ||
               (constantValue instanceof CstInteger) ||
               (constantValue instanceof CstLong) ||
               (constantValue instanceof CstFloat) ||
               (constantValue instanceof CstDouble))) {
            if (constantValue == null) {
                throw new NullPointerException(""constantValue == null"");
            }
            throw new IllegalArgumentException(""bad type for constantValue"");
        }
        this.constantValue = constantValue;
    }",method,
"            if (constantValue == null) {
                throw new NullPointerException(""constantValue == null"");
            }",method,
"    public int byteLength() {
        return 8;
    }",method,
"    public TypedConstant getConstantValue() {
        return constantValue;
    }",method,
"    public AttDeprecated() {
        super(ATTRIBUTE_NAME);
    }",method,
"    public int byteLength() {
        return 6;
    }",method,
"public class PhysicsConnectorManager extends ArrayList<PhysicsConnector> implements IUpdateHandler {
	// ===========================================================
	// Constants
	// ===========================================================
	private static final long serialVersionUID = 412969510084261799L;
	// ===========================================================
	// Fields
	// ===========================================================
	// ===========================================================
	// Constructors
	// ===========================================================
	PhysicsConnectorManager() {
	}
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	@Override
	public void onUpdate(final float pSecondsElapsed) {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			physicsConnectors.get(i).onUpdate(pSecondsElapsed);
		}
	}
	@Override
	public void reset() {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			physicsConnectors.get(i).reset();
		}
	}
	// ===========================================================
	// Methods
	// ===========================================================
	public Body findBodyByShape(final IShape pShape) {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			final PhysicsConnector physicsConnector = physicsConnectors.get(i);
			if(physicsConnector.mShape == pShape){
				return physicsConnector.mBody;
			}
		}
		return null;
	}
	public PhysicsConnector findPhysicsConnectorByShape(final IShape pShape) {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			final PhysicsConnector physicsConnector = physicsConnectors.get(i);
			if(physicsConnector.mShape == pShape){
				return physicsConnector;
			}
		}
		return null;
	}
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	PhysicsConnectorManager() {
	}",method,
"	@Override
	public void onUpdate(final float pSecondsElapsed) {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			physicsConnectors.get(i).onUpdate(pSecondsElapsed);
		}
	}",method,
"	@Override
	public void reset() {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			physicsConnectors.get(i).reset();
		}
	}",method,
"	public Body findBodyByShape(final IShape pShape) {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			final PhysicsConnector physicsConnector = physicsConnectors.get(i);
			if(physicsConnector.mShape == pShape){
				return physicsConnector.mBody;
			}
		}
		return null;
	}",method,
"			if(physicsConnector.mShape == pShape){
				return physicsConnector.mBody;
			}",method,
"	public PhysicsConnector findPhysicsConnectorByShape(final IShape pShape) {
		final ArrayList<PhysicsConnector> physicsConnectors = this;
		for(int i = physicsConnectors.size() - 1; i >= 0; i--) {
			final PhysicsConnector physicsConnector = physicsConnectors.get(i);
			if(physicsConnector.mShape == pShape){
				return physicsConnector;
			}
		}
		return null;
	}",method,
"			if(physicsConnector.mShape == pShape){
				return physicsConnector;
			}",method,
"	@Override
	public void setEnvironment(Environment environment) {
		this.environment = environment;
	}",method,
"	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}",method,
"	@Bean(name = MBEAN_EXPORTER_BEAN_NAME)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public AnnotationMBeanExporter mbeanExporter() {
		AnnotationMBeanExporter exporter = new AnnotationMBeanExporter();
		Assert.state(this.enableMBeanExport != null, ""No EnableMBeanExport annotation found"");
		setupDomain(exporter, this.enableMBeanExport);
		setupServer(exporter, this.enableMBeanExport);
		setupRegistrationPolicy(exporter, this.enableMBeanExport);
		return exporter;
	}",method,
"	private void setupDomain(AnnotationMBeanExporter exporter, AnnotationAttributes enableMBeanExport) {
		String defaultDomain = enableMBeanExport.getString(""defaultDomain"");
		if (StringUtils.hasLength(defaultDomain) && this.environment != null) {
			defaultDomain = this.environment.resolvePlaceholders(defaultDomain);
		}
		if (StringUtils.hasText(defaultDomain)) {
			exporter.setDefaultDomain(defaultDomain);
		}
	}",method,
"	private void setupServer(AnnotationMBeanExporter exporter, AnnotationAttributes enableMBeanExport) {
		String server = enableMBeanExport.getString(""server"");
		if (StringUtils.hasLength(server) && this.environment != null) {
			server = this.environment.resolvePlaceholders(server);
		}
		if (StringUtils.hasText(server)) {
			Assert.state(this.beanFactory != null, ""No BeanFactory set"");
			exporter.setServer(this.beanFactory.getBean(server, MBeanServer.class));
		}
		else {
			SpecificPlatform specificPlatform = SpecificPlatform.get();
			if (specificPlatform != null) {
				MBeanServer mbeanServer = specificPlatform.getMBeanServer();
				if (mbeanServer != null) {
					exporter.setServer(mbeanServer);
				}
			}
		}
	}",method,
"			if (specificPlatform != null) {
				MBeanServer mbeanServer = specificPlatform.getMBeanServer();
				if (mbeanServer != null) {
					exporter.setServer(mbeanServer);
				}
			}",method,
"				if (mbeanServer != null) {
					exporter.setServer(mbeanServer);
				}",method,
"	private void setupRegistrationPolicy(AnnotationMBeanExporter exporter, AnnotationAttributes enableMBeanExport) {
		RegistrationPolicy registrationPolicy = enableMBeanExport.getEnum(""registration"");
		exporter.setRegistrationPolicy(registrationPolicy);
	}",method,
"		WEBLOGIC(""weblogic.management.Helper"") {
			@Override
			public MBeanServer getMBeanServer() {
				try {
					return new JndiLocatorDelegate().lookup(""java:comp/env/jmx/runtime"", MBeanServer.class);
				}
				catch (NamingException ex) {
					throw new MBeanServerNotFoundException(""Failed to retrieve WebLogic MBeanServer from JNDI"", ex);
				}
			}
		}",method,
"			@Override
			public MBeanServer getMBeanServer() {
				try {
					return new JndiLocatorDelegate().lookup(""java:comp/env/jmx/runtime"", MBeanServer.class);
				}
				catch (NamingException ex) {
					throw new MBeanServerNotFoundException(""Failed to retrieve WebLogic MBeanServer from JNDI"", ex);
				}
			}",method,
"				catch (NamingException ex) {
					throw new MBeanServerNotFoundException(""Failed to retrieve WebLogic MBeanServer from JNDI"", ex);
				}",method,
"		WEBSPHERE(""com.ibm.websphere.management.AdminServiceFactory"") {
			@Override
			public MBeanServer getMBeanServer() {
				WebSphereMBeanServerFactoryBean fb = new WebSphereMBeanServerFactoryBean();
				fb.afterPropertiesSet();
				return fb.getObject();
			}
		}",method,
"			@Override
			public MBeanServer getMBeanServer() {
				WebSphereMBeanServerFactoryBean fb = new WebSphereMBeanServerFactoryBean();
				fb.afterPropertiesSet();
				return fb.getObject();
			}",method,
"		SpecificPlatform(String identifyingClass) {
			this.identifyingClass = identifyingClass;
		}",method,
"		@Nullable
		public static SpecificPlatform get() {
			ClassLoader classLoader = MBeanExportConfiguration.class.getClassLoader();
			for (SpecificPlatform environment : values()) {
				if (ClassUtils.isPresent(environment.identifyingClass, classLoader)) {
					return environment;
				}
			}
			return null;
		}",method,
"final class NaturalOrdering extends Ordering<Comparable> implements Serializable {
  static final NaturalOrdering INSTANCE = new NaturalOrdering();
  private transient Ordering<Comparable> nullsFirst;
  private transient Ordering<Comparable> nullsLast;
  @Override
  public int compare(Comparable left, Comparable right) {
    checkNotNull(left); // for GWT
    checkNotNull(right);
    return left.compareTo(right);
  }
  @Override
  public <S extends Comparable> Ordering<S> nullsFirst() {
    Ordering<Comparable> result = nullsFirst;
    if (result == null) {
      result = nullsFirst = super.nullsFirst();
    }
    return (Ordering<S>) result;
  }
  @Override
  public <S extends Comparable> Ordering<S> nullsLast() {
    Ordering<Comparable> result = nullsLast;
    if (result == null) {
      result = nullsLast = super.nullsLast();
    }
    return (Ordering<S>) result;
  }
  @Override
  public <S extends Comparable> Ordering<S> reverse() {
    return (Ordering<S>) ReverseNaturalOrdering.INSTANCE;
  }
  // preserving singleton-ness gives equals()/hashCode() for free
  private Object readResolve() {
    return INSTANCE;
  }
  @Override
  public String toString() {
    return ""Ordering.natural()"";
  }
  private NaturalOrdering() {}
  private static final long serialVersionUID = 0;
}",class,
"  @Override
  public int compare(Comparable left, Comparable right) {
    checkNotNull(left); // for GWT
    checkNotNull(right);
    return left.compareTo(right);
  }",method,
"  @Override
  public <S extends Comparable> Ordering<S> nullsFirst() {
    Ordering<Comparable> result = nullsFirst;
    if (result == null) {
      result = nullsFirst = super.nullsFirst();
    }
    return (Ordering<S>) result;
  }",method,
"    if (result == null) {
      result = nullsFirst = super.nullsFirst();
    }",method,
"  @Override
  public <S extends Comparable> Ordering<S> nullsLast() {
    Ordering<Comparable> result = nullsLast;
    if (result == null) {
      result = nullsLast = super.nullsLast();
    }
    return (Ordering<S>) result;
  }",method,
"    if (result == null) {
      result = nullsLast = super.nullsLast();
    }",method,
"  @Override
  public <S extends Comparable> Ordering<S> reverse() {
    return (Ordering<S>) ReverseNaturalOrdering.INSTANCE;
  }",method,
"  private Object readResolve() {
    return INSTANCE;
  }",method,
"  @Override
  public String toString() {
    return ""Ordering.natural()"";
  }",method,
  private NaturalOrdering() {},method,
"public class TableAccessControlRule
{
    private final Set<TablePrivilege> privileges;
    private final Optional<Pattern> userRegex;
    private final Optional<Pattern> schemaRegex;
    private final Optional<Pattern> tableRegex;
    @JsonCreator
    public TableAccessControlRule(
            @JsonProperty(""privileges"") Set<TablePrivilege> privileges,
            @JsonProperty(""user"") Optional<Pattern> userRegex,
            @JsonProperty(""schema"") Optional<Pattern> schemaRegex,
            @JsonProperty(""table"") Optional<Pattern> tableRegex)
    {
        this.privileges = ImmutableSet.copyOf(requireNonNull(privileges, ""privileges is null""));
        this.userRegex = requireNonNull(userRegex, ""userRegex is null"");
        this.schemaRegex = requireNonNull(schemaRegex, ""sourceRegex is null"");
        this.tableRegex = requireNonNull(tableRegex, ""tableRegex is null"");
    }
    public Optional<Set<TablePrivilege>> match(String user, SchemaTableName table)
    {
        if (userRegex.map(regex -> regex.matcher(user).matches()).orElse(true) &&
                schemaRegex.map(regex -> regex.matcher(table.getSchemaName()).matches()).orElse(true) &&
                tableRegex.map(regex -> regex.matcher(table.getTableName()).matches()).orElse(true)) {
            return Optional.of(privileges);
        }
        return Optional.empty();
    }
    public enum TablePrivilege
    {
        SELECT, INSERT, DELETE, OWNERSHIP, GRANT_SELECT
    }
}",class,
"    public Optional<Set<TablePrivilege>> match(String user, SchemaTableName table)
    {
        if (userRegex.map(regex -> regex.matcher(user).matches()).orElse(true) &&
                schemaRegex.map(regex -> regex.matcher(table.getSchemaName()).matches()).orElse(true) &&
                tableRegex.map(regex -> regex.matcher(table.getTableName()).matches()).orElse(true)) {
            return Optional.of(privileges);
        }
        return Optional.empty();
    }",method,
"public class ConvertToClsSet {
	private static final Logger LOG = LoggerFactory.getLogger(ConvertToClsSet.class);
	public static void usage() {
		LOG.info(""<output .jcst or .jar file> <several input dex or jar files> "");
	}
	public static void main(String[] args) throws IOException, DecodeException {
		if (args.length < 2) {
			usage();
			System.exit(1);
		}
		File output = new File(args[0]);
		List<InputFile> inputFiles = new ArrayList<InputFile>(args.length - 1);
		for (int i = 1; i < args.length; i++) {
			File f = new File(args[i]);
			if (f.isDirectory()) {
				addFilesFromDirectory(f, inputFiles);
			} else {
				InputFile.addFilesFrom(f, inputFiles);
			}
		}
		for (InputFile inputFile : inputFiles) {
			LOG.info(""Loaded: {}"", inputFile.getFile());
		}
		RootNode root = new RootNode(new JadxArgs());
		root.load(inputFiles);
		ClsSet set = new ClsSet();
		set.load(root);
		set.save(output);
		LOG.info(""Output: {}"", output);
		LOG.info(""done"");
	}
	private static void addFilesFromDirectory(File dir, List<InputFile> inputFiles) {
		File[] files = dir.listFiles();
		if (files == null) {
			return;
		}
		for (File file : files) {
			if (file.isDirectory()) {
				addFilesFromDirectory(file, inputFiles);
			} else {
				try {
					InputFile.addFilesFrom(file, inputFiles);
				} catch (Exception e) {
					LOG.warn(""Skip file: {}, load error: {}"", file, e.getMessage());
				}
			}
		}
	}
}",class,
"public class NClass {
	private final String name;
	private NClass[] parents;
	private int id;
	public NClass(String name, int id) {
		this.name = name;
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public NClass[] getParents() {
		return parents;
	}
	public void setParents(NClass[] parents) {
		this.parents = parents;
	}
	@Override
	public int hashCode() {
		return name.hashCode();
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		NClass nClass = (NClass) o;
		return name.equals(nClass.name);
	}
	@Override
	public String toString() {
		return name;
	}
}",class,
"	public static void usage() {
		LOG.info(""<output .jcst or .jar file> <several input dex or jar files> "");
	}",method,
"	public static void main(String[] args) throws IOException, DecodeException {
		if (args.length < 2) {
			usage();
			System.exit(1);
		}
		File output = new File(args[0]);
		List<InputFile> inputFiles = new ArrayList<InputFile>(args.length - 1);
		for (int i = 1; i < args.length; i++) {
			File f = new File(args[i]);
			if (f.isDirectory()) {
				addFilesFromDirectory(f, inputFiles);
			} else {
				InputFile.addFilesFrom(f, inputFiles);
			}
		}
		for (InputFile inputFile : inputFiles) {
			LOG.info(""Loaded: {}"", inputFile.getFile());
		}
		RootNode root = new RootNode(new JadxArgs());
		root.load(inputFiles);
		ClsSet set = new ClsSet();
		set.load(root);
		set.save(output);
		LOG.info(""Output: {}"", output);
		LOG.info(""done"");
	}",method,
"		if (args.length < 2) {
			usage();
			System.exit(1);
		}",method,
"		for (int i = 1; i < args.length; i++) {
			File f = new File(args[i]);
			if (f.isDirectory()) {
				addFilesFromDirectory(f, inputFiles);
			} else {
				InputFile.addFilesFrom(f, inputFiles);
			}
		}",method,
"		for (InputFile inputFile : inputFiles) {
			LOG.info(""Loaded: {}"", inputFile.getFile());
		}",method,
"	private static void addFilesFromDirectory(File dir, List<InputFile> inputFiles) {
		File[] files = dir.listFiles();
		if (files == null) {
			return;
		}
		for (File file : files) {
			if (file.isDirectory()) {
				addFilesFromDirectory(file, inputFiles);
			} else {
				try {
					InputFile.addFilesFrom(file, inputFiles);
				} catch (Exception e) {
					LOG.warn(""Skip file: {}, load error: {}"", file, e.getMessage());
				}
			}
		}
	}",method,
"		if (files == null) {
			return;
		}",method,
"		for (File file : files) {
			if (file.isDirectory()) {
				addFilesFromDirectory(file, inputFiles);
			} else {
				try {
					InputFile.addFilesFrom(file, inputFiles);
				} catch (Exception e) {
					LOG.warn(""Skip file: {}, load error: {}"", file, e.getMessage());
				}
			}
		}",method,
"	public NClass(String name, int id) {
		this.name = name;
		this.id = id;
	}",method,
"	public String getName() {
		return name;
	}",method,
"	public int getId() {
		return id;
	}",method,
"	public void setId(int id) {
		this.id = id;
	}",method,
"	public NClass[] getParents() {
		return parents;
	}",method,
"	public void setParents(NClass[] parents) {
		this.parents = parents;
	}",method,
"	@Override
	public int hashCode() {
		return name.hashCode();
	}",method,
"	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		NClass nClass = (NClass) o;
		return name.equals(nClass.name);
	}",method,
"		if (this == o) {
			return true;
		}",method,
"	@Override
	public String toString() {
		return name;
	}",method,

code_snippet,type,score
"    public Set<CompilerPassListener> getListeners() {
        // FIXME: This is ugly but we want to conditionalize output based on JRuby module setting/unsetting
        if (RubyInstanceConfig.IR_COMPILER_DEBUG) {
            addListener(defaultListener);
        } else {
            removeListener(defaultListener);
        }
        return passListeners;
    }",method,
"        if (RubyInstanceConfig.IR_COMPILER_DEBUG) {
            addListener(defaultListener);
        }",method,
"    public InstructionsListener getInstructionsListener() {
        return instrsListener;
    }",method,
"    public IRScopeListener getIRScopeListener() {
        return irScopeListener;
    }",method,
"    public void addListener(CompilerPassListener listener) {
        passListeners.add(listener);
    }",method,
"    public void removeListener(CompilerPassListener listener) {
        passListeners.remove(listener);
    }",method,
"    public void addListener(InstructionsListener listener) {
        if (RubyInstanceConfig.IR_COMPILER_DEBUG || RubyInstanceConfig.IR_VISUALIZER) {
            if (instrsListener != null) {
                throw new RuntimeException(""InstructionsListener is set and other are currently not allowed"");
            }
            instrsListener = listener;
        }
    }",method,
"        if (RubyInstanceConfig.IR_COMPILER_DEBUG || RubyInstanceConfig.IR_VISUALIZER) {
            if (instrsListener != null) {
                throw new RuntimeException(""InstructionsListener is set and other are currently not allowed"");
            }
            instrsListener = listener;
        }",method,
"            if (instrsListener != null) {
                throw new RuntimeException(""InstructionsListener is set and other are currently not allowed"");
            }",method,
"    public void removeListener(InstructionsListener listener) {
        if (instrsListener.equals(listener)) instrsListener = null;
    }",method,
"    public void addListener(IRScopeListener listener) {
        if (RubyInstanceConfig.IR_COMPILER_DEBUG || RubyInstanceConfig.IR_VISUALIZER) {
            if (irScopeListener != null) {
                throw new RuntimeException(""IRScopeListener is set and other are currently not allowed"");
            }
            irScopeListener = listener;
        }
    }",method,
"        if (RubyInstanceConfig.IR_COMPILER_DEBUG || RubyInstanceConfig.IR_VISUALIZER) {
            if (irScopeListener != null) {
                throw new RuntimeException(""IRScopeListener is set and other are currently not allowed"");
            }
            irScopeListener = listener;
        }",method,
"            if (irScopeListener != null) {
                throw new RuntimeException(""IRScopeListener is set and other are currently not allowed"");
            }",method,
"    public LineNumberInstr newLineNumber(int line) {
        if (line >= lineNumbers.length-1) growLineNumbersPool(line);
        if (line < 0) line = 0;
        LineNumberInstr tempVar = lineNumbers[line];
        if (tempVar == null) {
            tempVar = new LineNumberInstr(line);
            lineNumbers[line] = tempVar;
        }
        return tempVar;
    }",method,
"        if (tempVar == null) {
            tempVar = new LineNumberInstr(line);
            lineNumbers[line] = tempVar;
        }",method,
"    public ReceiveSelfInstr getReceiveSelfInstr() {
        return receiveSelfInstr;
    }",method,
"    protected LineNumberInstr[] growLineNumbersPool(int index) {
        int newLength = index * 2;
        LineNumberInstr[] newPool = new LineNumberInstr[newLength];
        System.arraycopy(lineNumbers, 0, newPool, 0, lineNumbers.length);
        lineNumbers = newPool;
        return newPool;
    }",method,
"    public void removeListener(IRScopeListener listener) {
        if (irScopeListener.equals(listener)) irScopeListener = null;
    }",method,
"    public String getMetaClassName() {
        return ""<DUMMY_MC:"" + dummyMetaClassCount++ + "">"";
    }",method,
"    protected TemporaryLocalVariable[] growTemporaryVariablePool(int index) {
        int newLength = index * 2;
        TemporaryLocalVariable[] newPool = new TemporaryLocalVariable[newLength];
        System.arraycopy(temporaryLocalVariables, 0, newPool, 0, temporaryLocalVariables.length);
        temporaryLocalVariables = newPool;
        return newPool;
    }",method,
"    public TemporaryLocalVariable newTemporaryLocalVariable(int index) {
        if (index >= temporaryLocalVariables.length-1) growTemporaryVariablePool(index);
        TemporaryLocalVariable tempVar = temporaryLocalVariables[index];
        if (tempVar == null) {
            tempVar = new TemporaryLocalVariable(index);
            temporaryLocalVariables[index] = tempVar;
        }
        return tempVar;
    }",method,
"        if (tempVar == null) {
            tempVar = new TemporaryLocalVariable(index);
            temporaryLocalVariables[index] = tempVar;
        }",method,
"    protected void optimizeIfSimpleScope(IRScope scope) {
        // We cannot pick the passes if we want an explicit set to run.
        if (RubyInstanceConfig.IR_COMPILER_PASSES != null) return;
        EnumSet<IRFlags> flags = scope.getFlags();
        if (!scope.isUnsafeScope() && !flags.contains(REQUIRES_DYNSCOPE)) {
            if (flags.contains(RECEIVES_CLOSURE_ARG)) optimizeDelegationPass.run(scope);
            deadCodeEliminationPass.run(scope);
            optimizeDynScopesPass.run(scope);
        }
    }",method,
"    public RubyInstanceConfig getInstanceConfig() {
        return config;
    }",method,
"public class MacIntelliJProgressBarUI extends DarculaProgressBarUI {
  public static final int HEIGHT = 6;
  @SuppressWarnings({""MethodOverridesStaticMethodOfSuperclass"", ""UnusedDeclaration""})
  public static ComponentUI createUI(JComponent c) {
    return new MacIntelliJProgressBarUI();
  }
  @Override
  protected void paintDeterminate(Graphics g, JComponent c) {
    Insets insets = progressBar.getInsets();
    int w = c.getWidth();
    int h = c.getHeight();
    int y = (h - HEIGHT) / 2;
    int x = insets.left;
    Icon icon;
    icon = MacIntelliJIconCache.getIcon(""progressLeft"");
    icon.paintIcon(c, g, x, y);
    x += icon.getIconWidth();
    int stop = w - (MacIntelliJIconCache.getIcon(""progressRight"").getIconWidth());
    Graphics gg = g.create(0, 0, w, h);
    gg.setClip(x, y, stop - x, h);
    icon = MacIntelliJIconCache.getIcon(""progressMiddle"");
    while (x < stop) {
      icon.paintIcon(c, gg, x, y);
      x += icon.getIconWidth();
    }
    gg.dispose();
    icon = MacIntelliJIconCache.getIcon(""progressRight"");
    icon.paintIcon(c, g, stop, y);
    int barRectWidth = w - (insets.right + insets.left);
    int barRectHeight = h - (insets.top + insets.bottom);
    int amountFull = getAmountFull(insets, barRectWidth, barRectHeight);
    boolean done = amountFull == barRectWidth;
    Icon left = MacIntelliJIconCache.getIcon(""progressLeft"", true, false);
    Icon middle = MacIntelliJIconCache.getIcon(""progressMiddle"", true, false);
    Icon right = MacIntelliJIconCache.getIcon(""progressRight"", true, false);
    gg = g.create(0, 0, barRectWidth + insets.left - right.getIconWidth(), h);
    gg.setClip(insets.left, y, amountFull - right.getIconWidth(), HEIGHT);
    int cur = left.getIconWidth() + insets.left;
    if (cur <= amountFull) {
      left.paintIcon(c, gg, insets.left, y);
    }
    while (cur < amountFull) {
      middle.paintIcon(c, gg, cur, y);
      cur+=middle.getIconWidth();
    }
    gg.dispose();
    if (done) {
      right.paintIcon(c, g, insets.left + barRectWidth - right.getIconWidth(), y);
    }
  }
  protected volatile int position = 0;
  @Override
  protected void paintIndeterminate(Graphics g, JComponent c) {
    Insets insets = progressBar.getInsets();
    int w = c.getWidth();
    int h = c.getHeight();
    int y = (h - HEIGHT) / 2 + insets.top;
    int x = insets.left;
    Icon icon;
    icon = MacIntelliJIconCache.getIcon(""progressLeft"", true, false);
    icon.paintIcon(c, g, x, y);
    x += icon.getIconWidth();
    int stop = w  - MacIntelliJIconCache.getIcon(""progressRight"", true, false).getIconWidth() - insets.right;
    Graphics gg = g.create(0, 0, w, h);
    gg.setClip(x, y, stop - x, h);
    icon = MacIntelliJIconCache.getIcon(""progressMiddle"", true, false);
    while (x < stop) {
      icon.paintIcon(c, gg, x, y);
      x += icon.getIconWidth();
    }
    gg.dispose();
    icon = MacIntelliJIconCache.getIcon(""progressRight"", true, false);
    icon.paintIcon(c, g, stop, y);
    Icon shadow = MacIntelliJIconCache.getIcon(""progressShadow"");
    int boxWidth = w - insets.left - insets.right;
    if (boxWidth <= 0) return;
    gg = g.create(0, 0, w, h);
    gg.setClip(new RoundRectangle2D.Double(insets.left, y, boxWidth, HEIGHT, HEIGHT, HEIGHT));
    shadow.paintIcon(c, gg, position, y);
    int xx = boxWidth - (position + shadow.getIconWidth());
    if (xx < 0) {
      shadow.paintIcon(c, gg, -xx - shadow.getIconWidth(), y);
    }
    position++;
    position = position % boxWidth;
    gg.dispose();
  }
}",class,
"  @SuppressWarnings({""MethodOverridesStaticMethodOfSuperclass"", ""UnusedDeclaration""})
  public static ComponentUI createUI(JComponent c) {
    return new MacIntelliJProgressBarUI();
  }",method,
"  @Override
  protected void paintDeterminate(Graphics g, JComponent c) {
    Insets insets = progressBar.getInsets();
    int w = c.getWidth();
    int h = c.getHeight();
    int y = (h - HEIGHT) / 2;
    int x = insets.left;
    Icon icon;
    icon = MacIntelliJIconCache.getIcon(""progressLeft"");
    icon.paintIcon(c, g, x, y);
    x += icon.getIconWidth();
    int stop = w - (MacIntelliJIconCache.getIcon(""progressRight"").getIconWidth());
    Graphics gg = g.create(0, 0, w, h);
    gg.setClip(x, y, stop - x, h);
    icon = MacIntelliJIconCache.getIcon(""progressMiddle"");
    while (x < stop) {
      icon.paintIcon(c, gg, x, y);
      x += icon.getIconWidth();
    }
    gg.dispose();
    icon = MacIntelliJIconCache.getIcon(""progressRight"");
    icon.paintIcon(c, g, stop, y);
    int barRectWidth = w - (insets.right + insets.left);
    int barRectHeight = h - (insets.top + insets.bottom);
    int amountFull = getAmountFull(insets, barRectWidth, barRectHeight);
    boolean done = amountFull == barRectWidth;
    Icon left = MacIntelliJIconCache.getIcon(""progressLeft"", true, false);
    Icon middle = MacIntelliJIconCache.getIcon(""progressMiddle"", true, false);
    Icon right = MacIntelliJIconCache.getIcon(""progressRight"", true, false);
    gg = g.create(0, 0, barRectWidth + insets.left - right.getIconWidth(), h);
    gg.setClip(insets.left, y, amountFull - right.getIconWidth(), HEIGHT);
    int cur = left.getIconWidth() + insets.left;
    if (cur <= amountFull) {
      left.paintIcon(c, gg, insets.left, y);
    }
    while (cur < amountFull) {
      middle.paintIcon(c, gg, cur, y);
      cur+=middle.getIconWidth();
    }
    gg.dispose();
    if (done) {
      right.paintIcon(c, g, insets.left + barRectWidth - right.getIconWidth(), y);
    }
  }",method,
"    while (x < stop) {
      icon.paintIcon(c, gg, x, y);
      x += icon.getIconWidth();
    }",method,
"    if (cur <= amountFull) {
      left.paintIcon(c, gg, insets.left, y);
    }",method,
"    while (cur < amountFull) {
      middle.paintIcon(c, gg, cur, y);
      cur+=middle.getIconWidth();
    }",method,
"    if (done) {
      right.paintIcon(c, g, insets.left + barRectWidth - right.getIconWidth(), y);
    }",method,
"  @Override
  protected void paintIndeterminate(Graphics g, JComponent c) {
    Insets insets = progressBar.getInsets();
    int w = c.getWidth();
    int h = c.getHeight();
    int y = (h - HEIGHT) / 2 + insets.top;
    int x = insets.left;
    Icon icon;
    icon = MacIntelliJIconCache.getIcon(""progressLeft"", true, false);
    icon.paintIcon(c, g, x, y);
    x += icon.getIconWidth();
    int stop = w  - MacIntelliJIconCache.getIcon(""progressRight"", true, false).getIconWidth() - insets.right;
    Graphics gg = g.create(0, 0, w, h);
    gg.setClip(x, y, stop - x, h);
    icon = MacIntelliJIconCache.getIcon(""progressMiddle"", true, false);
    while (x < stop) {
      icon.paintIcon(c, gg, x, y);
      x += icon.getIconWidth();
    }
    gg.dispose();
    icon = MacIntelliJIconCache.getIcon(""progressRight"", true, false);
    icon.paintIcon(c, g, stop, y);
    Icon shadow = MacIntelliJIconCache.getIcon(""progressShadow"");
    int boxWidth = w - insets.left - insets.right;
    if (boxWidth <= 0) return;
    gg = g.create(0, 0, w, h);
    gg.setClip(new RoundRectangle2D.Double(insets.left, y, boxWidth, HEIGHT, HEIGHT, HEIGHT));
    shadow.paintIcon(c, gg, position, y);
    int xx = boxWidth - (position + shadow.getIconWidth());
    if (xx < 0) {
      shadow.paintIcon(c, gg, -xx - shadow.getIconWidth(), y);
    }
    position++;
    position = position % boxWidth;
    gg.dispose();
  }",method,
"    while (x < stop) {
      icon.paintIcon(c, gg, x, y);
      x += icon.getIconWidth();
    }",method,
"    if (xx < 0) {
      shadow.paintIcon(c, gg, -xx - shadow.getIconWidth(), y);
    }",method,
"public class JacksonTester<T> extends AbstractJsonMarshalTester<T> {
	private final ObjectMapper objectMapper;
	private Class<?> view;
	protected JacksonTester(ObjectMapper objectMapper) {
		Assert.notNull(objectMapper, ""ObjectMapper must not be null"");
		this.objectMapper = objectMapper;
	}
	public JacksonTester(Class<?> resourceLoadClass, ResolvableType type,
			ObjectMapper objectMapper) {
		this(resourceLoadClass, type, objectMapper, null);
	}
	public JacksonTester(Class<?> resourceLoadClass, ResolvableType type,
			ObjectMapper objectMapper, Class<?> view) {
		super(resourceLoadClass, type);
		Assert.notNull(objectMapper, ""ObjectMapper must not be null"");
		this.objectMapper = objectMapper;
		this.view = view;
	}
	@Override
	protected T readObject(InputStream inputStream, ResolvableType type)
			throws IOException {
		return getObjectReader(type).readValue(inputStream);
	}
	@Override
	protected T readObject(Reader reader, ResolvableType type) throws IOException {
		return getObjectReader(type).readValue(reader);
	}
	private ObjectReader getObjectReader(ResolvableType type) {
		ObjectReader objectReader = this.objectMapper.readerFor(getType(type));
		if (this.view != null) {
			return objectReader.withView(this.view);
		}
		return objectReader;
	}
	@Override
	protected String writeObject(T value, ResolvableType type) throws IOException {
		return getObjectWriter(type).writeValueAsString(value);
	}
	private ObjectWriter getObjectWriter(ResolvableType type) {
		ObjectWriter objectWriter = this.objectMapper.writerFor(getType(type));
		if (this.view != null) {
			return objectWriter.withView(this.view);
		}
		return objectWriter;
	}
	private JavaType getType(ResolvableType type) {
		return this.objectMapper.constructType(type.getType());
	}
	public static void initFields(Object testInstance, ObjectMapper objectMapper) {
		new JacksonFieldInitializer().initFields(testInstance, objectMapper);
	}
	public static void initFields(Object testInstance,
			ObjectFactory<ObjectMapper> objectMapperFactory) {
		new JacksonFieldInitializer().initFields(testInstance, objectMapperFactory);
	}
	public JacksonTester<T> forView(Class<?> view) {
		return new JacksonTester<>(this.getResourceLoadClass(), this.getType(),
				this.objectMapper, view);
	}
	private static class JacksonFieldInitializer extends FieldInitializer<ObjectMapper> {
		protected JacksonFieldInitializer() {
			super(JacksonTester.class);
		}
		@Override
		protected AbstractJsonMarshalTester<Object> createTester(
				Class<?> resourceLoadClass, ResolvableType type,
				ObjectMapper marshaller) {
			return new JacksonTester<>(resourceLoadClass, type, marshaller);
		}
	}
}",class,
"	private static class JacksonFieldInitializer extends FieldInitializer<ObjectMapper> {
		protected JacksonFieldInitializer() {
			super(JacksonTester.class);
		}
		@Override
		protected AbstractJsonMarshalTester<Object> createTester(
				Class<?> resourceLoadClass, ResolvableType type,
				ObjectMapper marshaller) {
			return new JacksonTester<>(resourceLoadClass, type, marshaller);
		}
	}",class,
"	protected JacksonTester(ObjectMapper objectMapper) {
		Assert.notNull(objectMapper, ""ObjectMapper must not be null"");
		this.objectMapper = objectMapper;
	}",method,
"	public JacksonTester(Class<?> resourceLoadClass, ResolvableType type,
			ObjectMapper objectMapper) {
		this(resourceLoadClass, type, objectMapper, null);
	}",method,
"	public JacksonTester(Class<?> resourceLoadClass, ResolvableType type,
			ObjectMapper objectMapper, Class<?> view) {
		super(resourceLoadClass, type);
		Assert.notNull(objectMapper, ""ObjectMapper must not be null"");
		this.objectMapper = objectMapper;
		this.view = view;
	}",method,
"	@Override
	protected T readObject(InputStream inputStream, ResolvableType type)
			throws IOException {
		return getObjectReader(type).readValue(inputStream);
	}",method,
"	@Override
	protected T readObject(Reader reader, ResolvableType type) throws IOException {
		return getObjectReader(type).readValue(reader);
	}",method,
"	private ObjectReader getObjectReader(ResolvableType type) {
		ObjectReader objectReader = this.objectMapper.readerFor(getType(type));
		if (this.view != null) {
			return objectReader.withView(this.view);
		}
		return objectReader;
	}",method,
"		if (this.view != null) {
			return objectReader.withView(this.view);
		}",method,
"	@Override
	protected String writeObject(T value, ResolvableType type) throws IOException {
		return getObjectWriter(type).writeValueAsString(value);
	}",method,
"	private ObjectWriter getObjectWriter(ResolvableType type) {
		ObjectWriter objectWriter = this.objectMapper.writerFor(getType(type));
		if (this.view != null) {
			return objectWriter.withView(this.view);
		}
		return objectWriter;
	}",method,
"		if (this.view != null) {
			return objectWriter.withView(this.view);
		}",method,
"	private JavaType getType(ResolvableType type) {
		return this.objectMapper.constructType(type.getType());
	}",method,
"	public static void initFields(Object testInstance, ObjectMapper objectMapper) {
		new JacksonFieldInitializer().initFields(testInstance, objectMapper);
	}",method,
"	public static void initFields(Object testInstance,
			ObjectFactory<ObjectMapper> objectMapperFactory) {
		new JacksonFieldInitializer().initFields(testInstance, objectMapperFactory);
	}",method,
"	public JacksonTester<T> forView(Class<?> view) {
		return new JacksonTester<>(this.getResourceLoadClass(), this.getType(),
				this.objectMapper, view);
	}",method,
"		protected JacksonFieldInitializer() {
			super(JacksonTester.class);
		}",method,
"		@Override
		protected AbstractJsonMarshalTester<Object> createTester(
				Class<?> resourceLoadClass, ResolvableType type,
				ObjectMapper marshaller) {
			return new JacksonTester<>(resourceLoadClass, type, marshaller);
		}",method,
"public class LoadCommandCommonFieldsUtilsTest {
  @Test
  public void testCanCreate() {
    LoadCommandCommonFields command =
        LoadCommandCommonFields.of(
            123, UnsignedInteger.fromIntBits(111), UnsignedInteger.fromIntBits(222));
    assertThat(command.getOffsetInBinary(), equalTo(123));
    assertThat(command.getCmd(), equalTo(UnsignedInteger.fromIntBits(111)));
    assertThat(command.getCmdsize(), equalTo(UnsignedInteger.fromIntBits(222)));
  }
  @Test
  public void testCreatingFromBuffer() throws Exception {
    byte[] commandBytes = BaseEncoding.base16().decode(""FFFF000000AA00000008"");
    ByteBuffer buffer = ByteBuffer.wrap(commandBytes).order(ByteOrder.BIG_ENDIAN);
    buffer.position(2);
    LoadCommandCommonFields fields = LoadCommandCommonFieldsUtils.createFromBuffer(buffer);
    assertThat(fields.getCmd(), equalToObject(UnsignedInteger.fromIntBits(0xAA)));
    assertThat(fields.getCmdsize(), equalToObject(UnsignedInteger.fromIntBits(0x08)));
    assertThat(fields.getOffsetInBinary(), equalTo(2));
  }
  @Test
  public void testGetBytes() {
    LoadCommandCommonFields fields =
        LoadCommandCommonFields.of(
            1, UnsignedInteger.fromIntBits(2), UnsignedInteger.fromIntBits(3));
    byte[] expected = BaseEncoding.base16().decode(""0000000200000003"");
    byte[] expectedSwapped = BaseEncoding.base16().decode(""0200000003000000"");
    ByteBuffer bigEndian = ByteBuffer.allocate(expected.length).order(ByteOrder.BIG_ENDIAN);
    LoadCommandCommonFieldsUtils.writeCommandToBuffer(fields, bigEndian);
    ByteBuffer littleEndian = ByteBuffer.allocate(expected.length).order(ByteOrder.LITTLE_ENDIAN);
    LoadCommandCommonFieldsUtils.writeCommandToBuffer(fields, littleEndian);
    assertThat(bigEndian.array(), equalTo(expected));
    assertThat(littleEndian.array(), equalTo(expectedSwapped));
  }
}",class,
"  @Test
  public void testCanCreate() {
    LoadCommandCommonFields command =
        LoadCommandCommonFields.of(
            123, UnsignedInteger.fromIntBits(111), UnsignedInteger.fromIntBits(222));
    assertThat(command.getOffsetInBinary(), equalTo(123));
    assertThat(command.getCmd(), equalTo(UnsignedInteger.fromIntBits(111)));
    assertThat(command.getCmdsize(), equalTo(UnsignedInteger.fromIntBits(222)));
  }",method,
"  @Test
  public void testCreatingFromBuffer() throws Exception {
    byte[] commandBytes = BaseEncoding.base16().decode(""FFFF000000AA00000008"");
    ByteBuffer buffer = ByteBuffer.wrap(commandBytes).order(ByteOrder.BIG_ENDIAN);
    buffer.position(2);
    LoadCommandCommonFields fields = LoadCommandCommonFieldsUtils.createFromBuffer(buffer);
    assertThat(fields.getCmd(), equalToObject(UnsignedInteger.fromIntBits(0xAA)));
    assertThat(fields.getCmdsize(), equalToObject(UnsignedInteger.fromIntBits(0x08)));
    assertThat(fields.getOffsetInBinary(), equalTo(2));
  }",method,
"  @Test
  public void testGetBytes() {
    LoadCommandCommonFields fields =
        LoadCommandCommonFields.of(
            1, UnsignedInteger.fromIntBits(2), UnsignedInteger.fromIntBits(3));
    byte[] expected = BaseEncoding.base16().decode(""0000000200000003"");
    byte[] expectedSwapped = BaseEncoding.base16().decode(""0200000003000000"");
    ByteBuffer bigEndian = ByteBuffer.allocate(expected.length).order(ByteOrder.BIG_ENDIAN);
    LoadCommandCommonFieldsUtils.writeCommandToBuffer(fields, bigEndian);
    ByteBuffer littleEndian = ByteBuffer.allocate(expected.length).order(ByteOrder.LITTLE_ENDIAN);
    LoadCommandCommonFieldsUtils.writeCommandToBuffer(fields, littleEndian);
    assertThat(bigEndian.array(), equalTo(expected));
    assertThat(littleEndian.array(), equalTo(expectedSwapped));
  }",method,
"public class WebServer {
  private static final String INDEX_CONTEXT_PATH = ""/"";
  private static final String ARTIFACTS_CONTEXT_PATH = ""/artifacts"";
  private static final String STATIC_CONTEXT_PATH = ""/static"";
  private static final String TRACE_CONTEXT_PATH = ""/trace"";
  private static final String TRACES_CONTEXT_PATH = ""/traces"";
  private static final String TRACE_DATA_CONTEXT_PATH = ""/tracedata"";
  private Optional<Integer> port;
  private final ProjectFilesystem projectFilesystem;
  private final Server server;
  private final StreamingWebSocketServlet streamingWebSocketServlet;
  private final ArtifactCacheHandler artifactCacheHandler;
  public WebServer(int port, ProjectFilesystem projectFilesystem) {
    this.projectFilesystem = projectFilesystem;
    this.port = Optional.empty();
    this.server = new Server(port);
    this.streamingWebSocketServlet = new StreamingWebSocketServlet();
    this.artifactCacheHandler = new ArtifactCacheHandler(projectFilesystem);
  }
  public Optional<Integer> getPort() {
    if (!port.isPresent()) {
      for (Connector connector : server.getConnectors()) {
        if (connector instanceof ServerConnector) {
          port = Optional.of(((ServerConnector) connector).getLocalPort());
          break;
        }
      }
    }
    return port;
  }
  public WebServerBuckEventListener createListener() {
    return new WebServerBuckEventListener(this);
  }
  public StreamingWebSocketServlet getStreamingWebSocketServlet() {
    return streamingWebSocketServlet;
  }
  public synchronized void updateAndStartIfNeeded(Optional<ArtifactCache> artifactCache)
      throws WebServerException {
    artifactCacheHandler.setArtifactCache(artifactCache);
    if (server.isStarted()) {
      return;
    }
    // Package up all of the handlers into a ContextHandlerCollection to serve as the handler for
    // the server.
    ImmutableList<? extends Handler> handlers = createHandlers();
    ContextHandlerCollection contexts = new ContextHandlerCollection();
    contexts.setHandlers(handlers.toArray(new Handler[0]));
    server.setHandler(contexts);
    try {
      server.start();
    } catch (Exception e) {
      throw new WebServerException(""Cannot start Websocket server."", e);
    }
  }
  @VisibleForTesting
  ImmutableList<ContextHandler> createHandlers() {
    Map<String, Handler> contextPathToHandler = new HashMap<>();
    contextPathToHandler.put(INDEX_CONTEXT_PATH, new TemplateHandler(new IndexHandlerDelegate()));
    StaticResourcesHandler staticResourcesHandler = new StaticResourcesHandler();
    contextPathToHandler.put(STATIC_CONTEXT_PATH, staticResourcesHandler);
    // Handlers for traces.
    BuildTraces buildTraces = new BuildTraces(projectFilesystem);
    contextPathToHandler.put(
        TRACE_CONTEXT_PATH, new TemplateHandler(new TraceHandlerDelegate(buildTraces)));
    contextPathToHandler.put(
        TRACES_CONTEXT_PATH, new TemplateHandler(new TracesHandlerDelegate(buildTraces)));
    contextPathToHandler.put(TRACE_DATA_CONTEXT_PATH, new TraceDataHandler(buildTraces));
    contextPathToHandler.put(ARTIFACTS_CONTEXT_PATH, artifactCacheHandler);
    ImmutableList.Builder<ContextHandler> handlers = ImmutableList.builder();
    for (Map.Entry<String, Handler> entry : contextPathToHandler.entrySet()) {
      String contextPath = entry.getKey();
      Handler handler = entry.getValue();
      ContextHandler contextHandler = new ContextHandler(contextPath);
      contextHandler.setHandler(handler);
      handlers.add(contextHandler);
    }
    // Create a handler that acts as a WebSocket server.
    ServletContextHandler servletContextHandler =
        new ServletContextHandler(
             server,
             ""/ws"",
             true,
             false);
    servletContextHandler.addServlet(new ServletHolder(streamingWebSocketServlet), ""/build"");
    handlers.add(servletContextHandler);
    return handlers.build();
  }
  public synchronized void stop() throws WebServerException {
    if (!server.isRunning()) {
      return;
    }
    try {
      server.stop();
    } catch (Exception e) {
      throw new WebServerException(""Cannot stop Websocket server."", e);
    }
  }
  @SuppressWarnings(""serial"")
  public static class WebServerException extends Exception {
    public WebServerException(String message, Exception clause) {
      super(message, clause);
    }
  }
}",class,
"  public static class WebServerException extends Exception {
    public WebServerException(String message, Exception clause) {
      super(message, clause);
    }
  }",class,
"  public WebServer(int port, ProjectFilesystem projectFilesystem) {
    this.projectFilesystem = projectFilesystem;
    this.port = Optional.empty();
    this.server = new Server(port);
    this.streamingWebSocketServlet = new StreamingWebSocketServlet();
    this.artifactCacheHandler = new ArtifactCacheHandler(projectFilesystem);
  }",method,
"  public Optional<Integer> getPort() {
    if (!port.isPresent()) {
      for (Connector connector : server.getConnectors()) {
        if (connector instanceof ServerConnector) {
          port = Optional.of(((ServerConnector) connector).getLocalPort());
          break;
        }
      }
    }
    return port;
  }",method,
"        if (connector instanceof ServerConnector) {
          port = Optional.of(((ServerConnector) connector).getLocalPort());
          break;
        }",method,
"  public WebServerBuckEventListener createListener() {
    return new WebServerBuckEventListener(this);
  }",method,
"  public StreamingWebSocketServlet getStreamingWebSocketServlet() {
    return streamingWebSocketServlet;
  }",method,
"  public synchronized void updateAndStartIfNeeded(Optional<ArtifactCache> artifactCache)
      throws WebServerException {
    artifactCacheHandler.setArtifactCache(artifactCache);
    if (server.isStarted()) {
      return;
    }
    // Package up all of the handlers into a ContextHandlerCollection to serve as the handler for
    // the server.
    ImmutableList<? extends Handler> handlers = createHandlers();
    ContextHandlerCollection contexts = new ContextHandlerCollection();
    contexts.setHandlers(handlers.toArray(new Handler[0]));
    server.setHandler(contexts);
    try {
      server.start();
    } catch (Exception e) {
      throw new WebServerException(""Cannot start Websocket server."", e);
    }
  }",method,
"  @VisibleForTesting
  ImmutableList<ContextHandler> createHandlers() {
    Map<String, Handler> contextPathToHandler = new HashMap<>();
    contextPathToHandler.put(INDEX_CONTEXT_PATH, new TemplateHandler(new IndexHandlerDelegate()));
    StaticResourcesHandler staticResourcesHandler = new StaticResourcesHandler();
    contextPathToHandler.put(STATIC_CONTEXT_PATH, staticResourcesHandler);
    // Handlers for traces.
    BuildTraces buildTraces = new BuildTraces(projectFilesystem);
    contextPathToHandler.put(
        TRACE_CONTEXT_PATH, new TemplateHandler(new TraceHandlerDelegate(buildTraces)));
    contextPathToHandler.put(
        TRACES_CONTEXT_PATH, new TemplateHandler(new TracesHandlerDelegate(buildTraces)));
    contextPathToHandler.put(TRACE_DATA_CONTEXT_PATH, new TraceDataHandler(buildTraces));
    contextPathToHandler.put(ARTIFACTS_CONTEXT_PATH, artifactCacheHandler);
    ImmutableList.Builder<ContextHandler> handlers = ImmutableList.builder();
    for (Map.Entry<String, Handler> entry : contextPathToHandler.entrySet()) {
      String contextPath = entry.getKey();
      Handler handler = entry.getValue();
      ContextHandler contextHandler = new ContextHandler(contextPath);
      contextHandler.setHandler(handler);
      handlers.add(contextHandler);
    }
    // Create a handler that acts as a WebSocket server.
    ServletContextHandler servletContextHandler =
        new ServletContextHandler(
             server,
             ""/ws"",
             true,
             false);
    servletContextHandler.addServlet(new ServletHolder(streamingWebSocketServlet), ""/build"");
    handlers.add(servletContextHandler);
    return handlers.build();
  }",method,
"  public synchronized void stop() throws WebServerException {
    if (!server.isRunning()) {
      return;
    }
    try {
      server.stop();
    } catch (Exception e) {
      throw new WebServerException(""Cannot stop Websocket server."", e);
    }
  }",method,
"    public WebServerException(String message, Exception clause) {
      super(message, clause);
    }",method,
"public class Generics {
    private Generics() {  }
    public static Class<?> getTypeParameter(Class<?> klass) {
        return getTypeParameter(klass, Object.class);
    }
    @SuppressWarnings(""unchecked"")
    public static <T> Class<T> getTypeParameter(Class<?> klass, Class<? super T> bound) {
        Type t = requireNonNull(klass);
        while (t instanceof Class<?>) {
            t = ((Class<?>) t).getGenericSuperclass();
        }
        if (t instanceof ParameterizedType) {
            // should typically have one of type parameters (first one) that matches:
            for (Type param : ((ParameterizedType) t).getActualTypeArguments()) {
                if (param instanceof Class<?>) {
                    final Class<T> cls = determineClass(bound, param);
                    if (cls != null) {
                        return cls;
                    }
                } else if (param instanceof TypeVariable) {
                    for (Type paramBound : ((TypeVariable<?>) param).getBounds()) {
                        if (paramBound instanceof Class<?>) {
                            final Class<T> cls = determineClass(bound, paramBound);
                            if (cls != null) {
                                return cls;
                            }
                        }
                    }
                }
            }
        }
        throw new IllegalStateException(""Cannot figure out type parameterization for "" + klass.getName());
    }
    @SuppressWarnings(""unchecked"")
    private static <T> Class<T> determineClass(Class<? super T> bound, Type candidate) {
        if (candidate instanceof Class<?>) {
            final Class<?> cls = (Class<?>) candidate;
            if (bound.isAssignableFrom(cls)) {
                return (Class<T>) cls;
            }
        }
        return null;
    }
}",class,
    private Generics() {  },method,
"    public static Class<?> getTypeParameter(Class<?> klass) {
        return getTypeParameter(klass, Object.class);
    }",method,
"    @SuppressWarnings(""unchecked"")
    public static <T> Class<T> getTypeParameter(Class<?> klass, Class<? super T> bound) {
        Type t = requireNonNull(klass);
        while (t instanceof Class<?>) {
            t = ((Class<?>) t).getGenericSuperclass();
        }
        if (t instanceof ParameterizedType) {
            // should typically have one of type parameters (first one) that matches:
            for (Type param : ((ParameterizedType) t).getActualTypeArguments()) {
                if (param instanceof Class<?>) {
                    final Class<T> cls = determineClass(bound, param);
                    if (cls != null) {
                        return cls;
                    }
                } else if (param instanceof TypeVariable) {
                    for (Type paramBound : ((TypeVariable<?>) param).getBounds()) {
                        if (paramBound instanceof Class<?>) {
                            final Class<T> cls = determineClass(bound, paramBound);
                            if (cls != null) {
                                return cls;
                            }
                        }
                    }
                }
            }
        }
        throw new IllegalStateException(""Cannot figure out type parameterization for "" + klass.getName());
    }",method,
"        while (t instanceof Class<?>) {
            t = ((Class<?>) t).getGenericSuperclass();
        }",method,
"        if (t instanceof ParameterizedType) {
            // should typically have one of type parameters (first one) that matches:
            for (Type param : ((ParameterizedType) t).getActualTypeArguments()) {
                if (param instanceof Class<?>) {
                    final Class<T> cls = determineClass(bound, param);
                    if (cls != null) {
                        return cls;
                    }
                } else if (param instanceof TypeVariable) {
                    for (Type paramBound : ((TypeVariable<?>) param).getBounds()) {
                        if (paramBound instanceof Class<?>) {
                            final Class<T> cls = determineClass(bound, paramBound);
                            if (cls != null) {
                                return cls;
                            }
                        }
                    }
                }
            }
        }",method,
"                if (param instanceof Class<?>) {
                    final Class<T> cls = determineClass(bound, param);
                    if (cls != null) {
                        return cls;
                    }
                }",method,
"                    if (cls != null) {
                        return cls;
                    }",method,
"                        if (paramBound instanceof Class<?>) {
                            final Class<T> cls = determineClass(bound, paramBound);
                            if (cls != null) {
                                return cls;
                            }
                        }",method,
"                            if (cls != null) {
                                return cls;
                            }",method,
"    @SuppressWarnings(""unchecked"")
    private static <T> Class<T> determineClass(Class<? super T> bound, Type candidate) {
        if (candidate instanceof Class<?>) {
            final Class<?> cls = (Class<?>) candidate;
            if (bound.isAssignableFrom(cls)) {
                return (Class<T>) cls;
            }
        }
        return null;
    }",method,
"        if (candidate instanceof Class<?>) {
            final Class<?> cls = (Class<?>) candidate;
            if (bound.isAssignableFrom(cls)) {
                return (Class<T>) cls;
            }
        }",method,
"public class RoomPlayerlistFragment extends ListFragment implements OnItemClickListener {
    private Netplay netplay;
    private RoomPlayerlistAdapter adapter;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        netplay = Netplay.getAppInstance(getActivity().getApplicationContext());
        adapter = new RoomPlayerlistAdapter();
        adapter.setSource(netplay.roomPlayerlist);
        setListAdapter(adapter);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        adapter.invalidate();
    }
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        registerForContextMenu(getListView());
        getListView().setOnItemClickListener(this);
    }
    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        AdapterContextMenuInfo info = (AdapterContextMenuInfo)menuInfo;
        String playerName = adapter.getItem(info.position).player.name;
        MenuInflater inflater = getActivity().getMenuInflater();
        inflater.inflate(R.menu.room_playerlist_context, menu);
        if(netplay.isChief() && !playerName.equals(netplay.getPlayerName())) {
            inflater.inflate(R.menu.room_playerlist_chief_context, menu);
        }
        menu.setHeaderIcon(R.drawable.human);
        menu.setHeaderTitle(playerName);
    }
    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo)item.getMenuInfo();
        PlayerInRoom player = adapter.getItem(info.position);
        switch(item.getItemId()) {
        case R.id.player_info:
            netplay.sendPlayerInfoQuery(player.player.name);
            return true;
        case R.id.player_kick:
            netplay.sendKick(player.player.name);
            return true;
        default:
            return super.onContextItemSelected(item);
        }
    }
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_playerlist, container, false);
    }
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        Player player = adapter.getItem(position).player;
        if(player.name.equals(netplay.getPlayerName())) {
            netplay.sendToggleReady();
        }
    }
}",class,
"    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        netplay = Netplay.getAppInstance(getActivity().getApplicationContext());
        adapter = new RoomPlayerlistAdapter();
        adapter.setSource(netplay.roomPlayerlist);
        setListAdapter(adapter);
    }",method,
"    @Override
    public void onDestroy() {
        super.onDestroy();
        adapter.invalidate();
    }",method,
"    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        registerForContextMenu(getListView());
        getListView().setOnItemClickListener(this);
    }",method,
"    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        AdapterContextMenuInfo info = (AdapterContextMenuInfo)menuInfo;
        String playerName = adapter.getItem(info.position).player.name;
        MenuInflater inflater = getActivity().getMenuInflater();
        inflater.inflate(R.menu.room_playerlist_context, menu);
        if(netplay.isChief() && !playerName.equals(netplay.getPlayerName())) {
            inflater.inflate(R.menu.room_playerlist_chief_context, menu);
        }
        menu.setHeaderIcon(R.drawable.human);
        menu.setHeaderTitle(playerName);
    }",method,
"    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterContextMenuInfo info = (AdapterContextMenuInfo)item.getMenuInfo();
        PlayerInRoom player = adapter.getItem(info.position);
        switch(item.getItemId()) {
        case R.id.player_info:
            netplay.sendPlayerInfoQuery(player.player.name);
            return true;
        case R.id.player_kick:
            netplay.sendKick(player.player.name);
            return true;
        default:
            return super.onContextItemSelected(item);
        }
    }",method,
"    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_playerlist, container, false);
    }",method,
"    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        Player player = adapter.getItem(position).player;
        if(player.name.equals(netplay.getPlayerName())) {
            netplay.sendToggleReady();
        }
    }",method,
"public class DependencyJson implements Serializable{
    private List<String> mainDex = new LinkedList<String>();
    private Map<String, ArrayList<String>> awbs    = new HashMap<String, ArrayList<String>>();
    public List<String> getMainDex() {
        return mainDex;
    }
    public void setMainDex(List<String> mainDex) {
        this.mainDex = mainDex;
    }
    public Map<String, ArrayList<String>> getAwbs() {
        return awbs;
    }
    public void setAwbs(Map<String, ArrayList<String>> awbs) {
        this.awbs = awbs;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DependencyJson that = (DependencyJson) o;
        if (mainDex != null ? !mainDex.equals(that.mainDex) : that.mainDex != null) return false;
        return awbs != null ? awbs.equals(that.awbs) : that.awbs == null;
    }
    @Override
    public int hashCode() {
        int result = mainDex != null ? mainDex.hashCode() : 0;
        result = 31 * result + (awbs != null ? awbs.hashCode() : 0);
        return result;
    }
}",class,
"    public List<String> getMainDex() {
        return mainDex;
    }",method,
"    public void setMainDex(List<String> mainDex) {
        this.mainDex = mainDex;
    }",method,
"    public Map<String, ArrayList<String>> getAwbs() {
        return awbs;
    }",method,
"    public void setAwbs(Map<String, ArrayList<String>> awbs) {
        this.awbs = awbs;
    }",method,
"    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DependencyJson that = (DependencyJson) o;
        if (mainDex != null ? !mainDex.equals(that.mainDex) : that.mainDex != null) return false;
        return awbs != null ? awbs.equals(that.awbs) : that.awbs == null;
    }",method,
"    @Override
    public int hashCode() {
        int result = mainDex != null ? mainDex.hashCode() : 0;
        result = 31 * result + (awbs != null ? awbs.hashCode() : 0);
        return result;
    }",method,
"public class GrNumberConverter extends GrTypeConverter {
  @Override
  public boolean isApplicableTo(@NotNull ApplicableTo position) {
    return position != ApplicableTo.METHOD_PARAMETER;
  }
  @Nullable
  @Override
  public ConversionResult isConvertibleEx(@NotNull PsiType targetType,
                                          @NotNull PsiType actualType,
                                          @NotNull GroovyPsiElement context,
                                          @NotNull ApplicableTo currentPosition) {
    if (PsiUtil.isCompileStatic(context)) return isCSConvertible(targetType, actualType);
    if (TypesUtil.isNumericType(targetType) && TypesUtil.isNumericType(actualType)) {
      return OK;
    }
    return null;
  }
  @Nullable
  private static ConversionResult isCSConvertible(@NotNull PsiType targetType, @NotNull PsiType actualType) {
    if (TypesUtil.isClassType(actualType, JAVA_MATH_BIG_DECIMAL))
      return isFloatOrDoubleType(targetType) ? OK : null;
    if (TypesUtil.isClassType(targetType, JAVA_MATH_BIG_DECIMAL))
      return TypesUtil.isNumericType(actualType) ? OK : ERROR;
    if (TypesUtil.isClassType(targetType, JAVA_MATH_BIG_INTEGER))
      return TypesUtil.isIntegralNumberType(actualType) ? OK : ERROR;
    if (TypesUtil.isClassType(actualType, JAVA_MATH_BIG_INTEGER))
      return TypesUtil.isClassType(targetType, JAVA_MATH_BIG_INTEGER) || TypesUtil.isClassType(targetType, JAVA_MATH_BIG_DECIMAL) ? OK : null;
    if (TypesUtil.isNumericType(targetType) && TypesUtil.isNumericType(actualType)) {
      return OK;
    }
    return null;
  }
}",class,
"  @Override
  public boolean isApplicableTo(@NotNull ApplicableTo position) {
    return position != ApplicableTo.METHOD_PARAMETER;
  }",method,
"  @Nullable
  @Override
  public ConversionResult isConvertibleEx(@NotNull PsiType targetType,
                                          @NotNull PsiType actualType,
                                          @NotNull GroovyPsiElement context,
                                          @NotNull ApplicableTo currentPosition) {
    if (PsiUtil.isCompileStatic(context)) return isCSConvertible(targetType, actualType);
    if (TypesUtil.isNumericType(targetType) && TypesUtil.isNumericType(actualType)) {
      return OK;
    }
    return null;
  }",method,
"  @Nullable
  private static ConversionResult isCSConvertible(@NotNull PsiType targetType, @NotNull PsiType actualType) {
    if (TypesUtil.isClassType(actualType, JAVA_MATH_BIG_DECIMAL))
      return isFloatOrDoubleType(targetType) ? OK : null;
    if (TypesUtil.isClassType(targetType, JAVA_MATH_BIG_DECIMAL))
      return TypesUtil.isNumericType(actualType) ? OK : ERROR;
    if (TypesUtil.isClassType(targetType, JAVA_MATH_BIG_INTEGER))
      return TypesUtil.isIntegralNumberType(actualType) ? OK : ERROR;
    if (TypesUtil.isClassType(actualType, JAVA_MATH_BIG_INTEGER))
      return TypesUtil.isClassType(targetType, JAVA_MATH_BIG_INTEGER) || TypesUtil.isClassType(targetType, JAVA_MATH_BIG_DECIMAL) ? OK : null;
    if (TypesUtil.isNumericType(targetType) && TypesUtil.isNumericType(actualType)) {
      return OK;
    }
    return null;
  }",method,
"import javax.annotation.Nullable;
class AppendingZipOutputStreamImpl implements CustomZipOutputStream.Impl {
  private final OutputStream delegate;
  private final boolean throwExceptionsOnDuplicate;
  private final Clock clock;
  private long currentOffset = 0;
  private List<EntryAccounting> entries = new LinkedList<>();
  @Nullable private EntryAccounting currentEntry = null;
  private Set<String> seenNames = new HashSet<>();
  public AppendingZipOutputStreamImpl(
      Clock clock, OutputStream stream, boolean throwExceptionsOnDuplicate) {
    this.delegate = stream;
    this.clock = clock;
    this.throwExceptionsOnDuplicate = throwExceptionsOnDuplicate;
  }
  @Override
  public void actuallyWrite(byte[] b, int off, int len) throws IOException {
    Preconditions.checkNotNull(currentEntry);
    currentEntry.write(delegate, b, off, len);
  }
  @Override
  public void actuallyPutNextEntry(ZipEntry entry) throws IOException {
    if (throwExceptionsOnDuplicate && !seenNames.add(entry.getName())) {
      // Same exception as ZipOutputStream.
      throw new ZipException(""duplicate entry: "" + entry.getName());
    }
    currentEntry = new EntryAccounting(clock, entry, currentOffset);
    entries.add(currentEntry);
    currentOffset += currentEntry.writeLocalFileHeader(delegate);
  }
  @Override
  public void actuallyCloseEntry() throws IOException {
    if (currentEntry == null) {
      return; // no-op
    }
    currentOffset += currentEntry.finish(delegate);
    currentEntry = null;
  }
  @Override
  public void actuallyClose() throws IOException {
    new CentralDirectory().writeCentralDirectory(delegate, currentOffset, entries);
    delegate.close();
  }
}",class,
"  public AppendingZipOutputStreamImpl(
      Clock clock, OutputStream stream, boolean throwExceptionsOnDuplicate) {
    this.delegate = stream;
    this.clock = clock;
    this.throwExceptionsOnDuplicate = throwExceptionsOnDuplicate;
  }",method,
"  @Override
  public void actuallyWrite(byte[] b, int off, int len) throws IOException {
    Preconditions.checkNotNull(currentEntry);
    currentEntry.write(delegate, b, off, len);
  }",method,

code_snippet,type,score
"		connectButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				onConnect();
			}
		}",method,
"			public void actionPerformed(ActionEvent e) {
				onConnect();
			}",method,
"		sendButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				onInsert();
			}
		}",method,
"			public void actionPerformed(ActionEvent e) {
				onInsert();
			}",method,
"		frame.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
                System.exit(0);
			}
		}",method,
"			public void windowClosing(WindowEvent e) {
                System.exit(0);
			}",method,
"	public void disconnect() {
		try {
			ftClient.disconnect();
		}
		catch (IOException e) {}
		connectButton.setLabel(""Connect"");
		addrField.setBackground(Color.WHITE);
		sendButton.setEnabled(false);
	}",method,
		catch (IOException e) {},method,
"	public void connect() {
		try {
			if (ftClient.connect(addrField.getText())) {
				connectButton.setLabel(""Disconnect"");
				addrField.setBackground(conColor);
				sendButton.setEnabled(true);
			}
		}
		catch (IOException e) {
			disconnect();
		}
	}",method,
"		catch (IOException e) {
			disconnect();
		}",method,
"	public void onConnect() {
		if (ftClient.isConnected()) {
			disconnect();
		} else {
			connect();
		}
	}",method,
"	public void onInsert() {
		System.out.println(""Inserting marker"");
		System.out.println(typeField.getText());
		System.out.println(valueField.getText());
		try {
			SamplesEventsCount count = ftClient.poll();
			BufferEvent E = new BufferEvent(typeField.getText(), valueField.getText(), count.nSamples);
			ftClient.putEvent(E);
		}
		catch (IOException e) {
			disconnect();
		}		
	}",method,
"		catch (IOException e) {
			disconnect();
		}",method,
"	public static void main(String[] args) {
		if (args.length>=1) {
			new MarkerGUI(args[0]);
		} else {
			new MarkerGUI(""localhost:1972"");
		}
	}",method,
"		if (args.length>=1) {
			new MarkerGUI(args[0]);
		}",method,
"public class MethodLinker
extends      SimplifiedVisitor
implements   ClassVisitor,
             MemberVisitor
{
    // An object that is reset and reused every time.
    // The map: [class member name+' '+descriptor - class member info]
    private final Map memberMap = new HashMap();
    // Implementations for ClassVisitor.
    public void visitAnyClass(Clazz clazz)
    {
        // Collect all non-private members in this class hierarchy.
        clazz.hierarchyAccept(true, true, true, false,
            new AllMethodVisitor(
            new MemberAccessFilter(0, ClassConstants.ACC_PRIVATE | ClassConstants.ACC_STATIC,
            this)));
        // Clean up for the next class hierarchy.
        memberMap.clear();
    }
    // Implementations for MemberVisitor.
    public void visitAnyMember(Clazz clazz, Member member)
    {
        // Get the class member's name and descriptor.
        String name       = member.getName(clazz);
        String descriptor = member.getDescriptor(clazz);
        // Special cases: <clinit> and <init> are always kept unchanged.
        // We can ignore them here.
        if (ClassUtil.isInitializer(name))
        {
            return;
        }
        // See if we've already come across a method with the same name and
        // descriptor.
        String key = name + ' ' + descriptor;
        Member otherMember = (Member)memberMap.get(key);
        if (otherMember == null)
        {
            // Get the last method in the chain.
            Member thisLastMember = lastMember(member);
            // Store the new class method in the map.
            memberMap.put(key, thisLastMember);
        }
        else
        {
            // Link both members.
            link(member, otherMember);
        }
    }
    // Small utility methods.
    private static void link(Member member1, Member member2)
    {
        // Get the last methods in the both chains.
        Member lastMember1 = lastMember(member1);
        Member lastMember2 = lastMember(member2);
        // Check if both link chains aren't already ending in the same element.
        if (!lastMember1.equals(lastMember2))
        {
            // Merge the two chains, with the library members last.
            if (lastMember2 instanceof LibraryMember)
            {
                lastMember1.setVisitorInfo(lastMember2);
            }
            else
            {
                lastMember2.setVisitorInfo(lastMember1);
            }
        }
    }
    public static Member lastMember(Member member)
    {
        Member lastMember = member;
        while (lastMember.getVisitorInfo() != null &&
               lastMember.getVisitorInfo() instanceof Member)
        {
            lastMember = (Member)lastMember.getVisitorInfo();
        }
        return lastMember;
    }
    public static VisitorAccepter lastVisitorAccepter(VisitorAccepter visitorAccepter)
    {
        VisitorAccepter lastVisitorAccepter = visitorAccepter;
        while (lastVisitorAccepter.getVisitorInfo() != null &&
               lastVisitorAccepter.getVisitorInfo() instanceof VisitorAccepter)
        {
            lastVisitorAccepter = (VisitorAccepter)lastVisitorAccepter.getVisitorInfo();
        }
        return lastVisitorAccepter;
    }
}",class,
"    // The map: [class member name+' '+descriptor - class member info]
    private final Map memberMap = new HashMap();
    // Implementations for ClassVisitor.
    public void visitAnyClass(Clazz clazz)
    {
        // Collect all non-private members in this class hierarchy.
        clazz.hierarchyAccept(true, true, true, false,
            new AllMethodVisitor(
            new MemberAccessFilter(0, ClassConstants.ACC_PRIVATE | ClassConstants.ACC_STATIC,
            this)));
        // Clean up for the next class hierarchy.
        memberMap.clear();
    }",class,
"        // Collect all non-private members in this class hierarchy.
        clazz.hierarchyAccept(true, true, true, false,
            new AllMethodVisitor(
            new MemberAccessFilter(0, ClassConstants.ACC_PRIVATE | ClassConstants.ACC_STATIC,
            this)));
        // Clean up for the next class hierarchy.
        memberMap.clear();
    }
    // Implementations for MemberVisitor.
    public void visitAnyMember(Clazz clazz, Member member)
    {
        // Get the class member's name and descriptor.
        String name       = member.getName(clazz);
        String descriptor = member.getDescriptor(clazz);
        // Special cases: <clinit> and <init> are always kept unchanged.
        // We can ignore them here.
        if (ClassUtil.isInitializer(name))
        {
            return;
        }
        // See if we've already come across a method with the same name and
        // descriptor.
        String key = name + ' ' + descriptor;
        Member otherMember = (Member)memberMap.get(key);
        if (otherMember == null)
        {
            // Get the last method in the chain.
            Member thisLastMember = lastMember(member);
            // Store the new class method in the map.
            memberMap.put(key, thisLastMember);
        }
        else
        {
            // Link both members.
            link(member, otherMember);
        }
    }",class,
"        // Get the class member's name and descriptor.
        String name       = member.getName(clazz);
        String descriptor = member.getDescriptor(clazz);
        // Special cases: <clinit> and <init> are always kept unchanged.
        // We can ignore them here.
        if (ClassUtil.isInitializer(name))
        {
            return;
        }",class,
"            // Store the new class method in the map.
            memberMap.put(key, thisLastMember);
        }
        else
        {
            // Link both members.
            link(member, otherMember);
        }",class,
"    public void visitAnyClass(Clazz clazz)
    {
        // Collect all non-private members in this class hierarchy.
        clazz.hierarchyAccept(true, true, true, false,
            new AllMethodVisitor(
            new MemberAccessFilter(0, ClassConstants.ACC_PRIVATE | ClassConstants.ACC_STATIC,
            this)));
        // Clean up for the next class hierarchy.
        memberMap.clear();
    }",method,
"    public void visitAnyMember(Clazz clazz, Member member)
    {
        // Get the class member's name and descriptor.
        String name       = member.getName(clazz);
        String descriptor = member.getDescriptor(clazz);
        // Special cases: <clinit> and <init> are always kept unchanged.
        // We can ignore them here.
        if (ClassUtil.isInitializer(name))
        {
            return;
        }
        // See if we've already come across a method with the same name and
        // descriptor.
        String key = name + ' ' + descriptor;
        Member otherMember = (Member)memberMap.get(key);
        if (otherMember == null)
        {
            // Get the last method in the chain.
            Member thisLastMember = lastMember(member);
            // Store the new class method in the map.
            memberMap.put(key, thisLastMember);
        }
        else
        {
            // Link both members.
            link(member, otherMember);
        }
    }",method,
"        if (otherMember == null)
        {
            // Get the last method in the chain.
            Member thisLastMember = lastMember(member);
            // Store the new class method in the map.
            memberMap.put(key, thisLastMember);
        }",method,
"    private static void link(Member member1, Member member2)
    {
        // Get the last methods in the both chains.
        Member lastMember1 = lastMember(member1);
        Member lastMember2 = lastMember(member2);
        // Check if both link chains aren't already ending in the same element.
        if (!lastMember1.equals(lastMember2))
        {
            // Merge the two chains, with the library members last.
            if (lastMember2 instanceof LibraryMember)
            {
                lastMember1.setVisitorInfo(lastMember2);
            }
            else
            {
                lastMember2.setVisitorInfo(lastMember1);
            }
        }
    }",method,
"            if (lastMember2 instanceof LibraryMember)
            {
                lastMember1.setVisitorInfo(lastMember2);
            }",method,
"    public static Member lastMember(Member member)
    {
        Member lastMember = member;
        while (lastMember.getVisitorInfo() != null &&
               lastMember.getVisitorInfo() instanceof Member)
        {
            lastMember = (Member)lastMember.getVisitorInfo();
        }
        return lastMember;
    }",method,
"    public static VisitorAccepter lastVisitorAccepter(VisitorAccepter visitorAccepter)
    {
        VisitorAccepter lastVisitorAccepter = visitorAccepter;
        while (lastVisitorAccepter.getVisitorInfo() != null &&
               lastVisitorAccepter.getVisitorInfo() instanceof VisitorAccepter)
        {
            lastVisitorAccepter = (VisitorAccepter)lastVisitorAccepter.getVisitorInfo();
        }
        return lastVisitorAccepter;
    }",method,
"public String toString(){
	return name.toString();
}",method,
"public static ISeq all(){
	return RT.seq(namespaces.values());
}",method,
"public Symbol getName(){
	return name;
}",method,
"public IPersistentMap getMappings(){
	return mappings.get();
}",method,
"public Var intern(Symbol sym){
	if(sym.ns != null)
		{
		throw new IllegalArgumentException(""Can't intern namespace-qualified symbol"");
		}
	IPersistentMap map = getMappings();
	Object o;
	Var v = null;
	while((o = map.valAt(sym)) == null)
		{
		if(v == null)
			v = new Var(this, sym);
		IPersistentMap newMap = map.assoc(sym, v);
		mappings.compareAndSet(map, newMap);
		map = getMappings();
		}
	if(o instanceof Var && ((Var) o).ns == this)
		return (Var) o;
	if(v == null)
		v = new Var(this, sym);
	warnOrFailOnReplace(sym, o, v);
	while(!mappings.compareAndSet(map, map.assoc(sym, v)))
		map = getMappings();
	return v;
}",method,
"	if(sym.ns != null)
		{
		throw new IllegalArgumentException(""Can't intern namespace-qualified symbol"");
		}",method,
"private void warnOrFailOnReplace(Symbol sym, Object o, Object v){
    if (o instanceof Var)
        {
        Namespace ns = ((Var)o).ns;
        if (ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOJURE_NS))
            return;
        if (ns != RT.CLOJURE_NS)
            throw new IllegalStateException(sym + "" already refers to: "" + o + "" in namespace: "" + name);
        }
	RT.errPrintWriter().println(""WARNING: "" + sym + "" already refers to: "" + o + "" in namespace: "" + name
		+ "", being replaced by: "" + v);
}",method,
"    if (o instanceof Var)
        {
        Namespace ns = ((Var)o).ns;
        if (ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOJURE_NS))
            return;
        if (ns != RT.CLOJURE_NS)
            throw new IllegalStateException(sym + "" already refers to: "" + o + "" in namespace: "" + name);
        }",method,
"	if(sym.ns != null)
		{
		throw new IllegalArgumentException(""Can't intern namespace-qualified symbol"");
		}",method,
"public static boolean areDifferentInstancesOfSameClassName(Class cls1, Class cls2) {
    return (cls1 != cls2) && (cls1.getName().equals(cls2.getName()));
}",method,
"    if(sym.ns != null)
        {
        throw new IllegalArgumentException(""Can't intern namespace-qualified symbol"");
        }",method,
"public void unmap(Symbol sym) {
	if(sym.ns != null)
		{
		throw new IllegalArgumentException(""Can't unintern namespace-qualified symbol"");
		}
	IPersistentMap map = getMappings();
	while(map.containsKey(sym))
		{
		IPersistentMap newMap = map.without(sym);
		mappings.compareAndSet(map, newMap);
		map = getMappings();
		}
}",method,
"	if(sym.ns != null)
		{
		throw new IllegalArgumentException(""Can't unintern namespace-qualified symbol"");
		}",method,
"Namespace(Symbol name){
	super(name.meta());
	this.name = name;
	mappings.set(RT.DEFAULT_IMPORTS);
	aliases.set(RT.map());
}",method,
"public class RunInspectionAction extends GotoActionBase {
  private static final Logger LOGGER = Logger.getInstance(RunInspectionAction.class);
  public RunInspectionAction() {
    getTemplatePresentation().setText(IdeBundle.message(""goto.inspection.action.text""));
  }
  @Override
  protected void gotoActionPerformed(final AnActionEvent e) {
    final Project project = e.getData(CommonDataKeys.PROJECT);
    if (project == null) return;
    PsiDocumentManager.getInstance(project).commitAllDocuments();
    final PsiElement psiElement = CommonDataKeys.PSI_ELEMENT.getData(e.getDataContext());
    final PsiFile psiFile = CommonDataKeys.PSI_FILE.getData(e.getDataContext());
    final VirtualFile virtualFile = CommonDataKeys.VIRTUAL_FILE.getData(e.getDataContext());
    FeatureUsageTracker.getInstance().triggerFeatureUsed(""navigation.goto.inspection"");
    final GotoInspectionModel model = new GotoInspectionModel(project);
    showNavigationPopup(e, model, new GotoActionCallback<Object>() {
      @Override
      protected ChooseByNameFilter<Object> createFilter(@NotNull ChooseByNamePopup popup) {
        popup.setSearchInAnyPlace(true);
        return super.createFilter(popup);
      }
      @Override
      public void elementChosen(ChooseByNamePopup popup, final Object element) {
        ApplicationManager.getApplication().invokeLater(
          () -> runInspection(project, ((InspectionToolWrapper)element).getShortName(), virtualFile, psiElement, psiFile));
      }
    }, false);
  }
  public static void runInspection(final @NotNull Project project,
                                   @NotNull String shortName,
                                   @Nullable VirtualFile virtualFile,
                                   PsiElement psiElement,
                                   PsiFile psiFile) {
    final PsiElement element = psiFile == null ? psiElement : psiFile;
    final InspectionProfile currentProfile = InspectionProjectProfileManager.getInstance(project).getCurrentProfile();
    final InspectionToolWrapper toolWrapper = element != null ? currentProfile.getInspectionTool(shortName, element)
                                                              : currentProfile.getInspectionTool(shortName, project);
    LOGGER.assertTrue(toolWrapper != null, ""Missed inspection: "" + shortName);
    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManager.getInstance(project);
    final Module module = virtualFile != null ? ModuleUtilCore.findModuleForFile(virtualFile, project) : null;
    AnalysisScope analysisScope = null;
    if (psiFile != null) {
      analysisScope = new AnalysisScope(psiFile);
    }
    else {
      if (virtualFile != null && virtualFile.isDirectory()) {
        final PsiDirectory psiDirectory = PsiManager.getInstance(project).findDirectory(virtualFile);
        if (psiDirectory != null) {
          analysisScope = new AnalysisScope(psiDirectory);
        }
      }
      if (analysisScope == null && virtualFile != null) {
        analysisScope = new AnalysisScope(project, Arrays.asList(virtualFile));
      }
      if (analysisScope == null) {
        analysisScope = new AnalysisScope(project);
      }
    }
    final AnalysisUIOptions options = AnalysisUIOptions.getInstance(project);
    final FileFilterPanel fileFilterPanel = new FileFilterPanel();
    fileFilterPanel.init(options);
    final AnalysisScope initialAnalysisScope = analysisScope;
    final BaseAnalysisActionDialog dialog = new BaseAnalysisActionDialog(
      ""Run '"" + toolWrapper.getDisplayName() + ""'"",
      AnalysisScopeBundle.message(""analysis.scope.title"", InspectionsBundle.message(""inspection.action.noun"")),
      project, analysisScope, module, true, options, psiElement) {
      private InspectionToolWrapper myUpdatedSettingsToolWrapper;
      @Nullable
      @Override
      protected JComponent getAdditionalActionSettings(Project project) {
        final JPanel fileFilter = fileFilterPanel.getPanel();
        if (toolWrapper.getTool().createOptionsPanel() != null) {
          JPanel additionPanel = new JPanel();
          additionPanel.setLayout(new GridBagLayout());
          additionPanel.add(fileFilter, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0));
          myUpdatedSettingsToolWrapper = copyToolWithSettings(toolWrapper);//new InheritOptionsForToolPanel(toolWrapper.getShortName(), project);
          additionPanel.add(new TitledSeparator(IdeBundle.message(""goto.inspection.action.choose.inherit.settings.from"")), new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0));
          JComponent optionsPanel = myUpdatedSettingsToolWrapper.getTool().createOptionsPanel();
          LOGGER.assertTrue(optionsPanel != null);
          GridBagConstraints constraints =
            new GridBagConstraints(0, 2, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0);
          if (UIUtil.hasScrollPane(optionsPanel)) {
            additionPanel.add(optionsPanel, constraints);
          }
          else {
            additionPanel.add(ScrollPaneFactory.createScrollPane(optionsPanel, SideBorder.NONE), constraints);
          }
          return additionPanel;
        } else {
          return fileFilter;
        }
      }
      @NotNull
      @Override
      public AnalysisScope getScope(@NotNull AnalysisUIOptions uiOptions,
                                    @NotNull AnalysisScope defaultScope,
                                    @NotNull Project project,
                                    Module module) {
        final AnalysisScope scope = super.getScope(uiOptions, defaultScope, project, module);
        final GlobalSearchScope filterScope = fileFilterPanel.getSearchScope();
        if (filterScope == null) {
          return scope;
        }
        scope.setFilter(filterScope);
        return scope;
      }
      private AnalysisScope getScope() {
        return getScope(options, initialAnalysisScope, project, module);
      }
      private InspectionToolWrapper getToolWrapper() {
        return myUpdatedSettingsToolWrapper == null ? toolWrapper : myUpdatedSettingsToolWrapper;
      }
      @NotNull
      @Override
      protected Action[] createActions() {
        final List<Action> actions = new ArrayList<>();
        final boolean hasFixAll = toolWrapper.getTool() instanceof CleanupLocalInspectionTool;
        actions.add(new AbstractAction(hasFixAll ? AnalysisScopeBundle.message(""action.analyze.verb"")
                                                 : CommonBundle.getOkButtonText()) {
          {
            putValue(DEFAULT_ACTION, Boolean.TRUE);
          }
          @Override
          public void actionPerformed(ActionEvent e) {
            RunInspectionIntention.rerunInspection(getToolWrapper(), managerEx, getScope(), null);
            close(DialogWrapper.OK_EXIT_CODE);
          }
        });
        if (hasFixAll) {
          actions.add(new AbstractAction(""Fix All"") {
            @Override
            public void actionPerformed(ActionEvent e) {
              InspectionToolWrapper wrapper = getToolWrapper();
              InspectionProfileImpl cleanupToolProfile = RunInspectionIntention.createProfile(wrapper, managerEx, null);
              managerEx.createNewGlobalContext(false)
                .codeCleanup(getScope(), cleanupToolProfile, ""Cleanup by "" + wrapper.getDisplayName(), null, false);
              close(DialogWrapper.OK_EXIT_CODE);
            }
          });
        }
        actions.add(getCancelAction());
        if (SystemInfo.isMac) {
          Collections.reverse(actions);
        }
        return actions.toArray(new Action[actions.size()]);
      }
    };
    dialog.showAndGet();
  }
  private static InspectionToolWrapper copyToolWithSettings(@NotNull final InspectionToolWrapper tool) {
    final Element options = new Element(""copy"");
    tool.getTool().writeSettings(options);
    final InspectionToolWrapper copiedTool = tool.createCopy();
    copiedTool.getTool().readSettings(options);
    return copiedTool;
  }
}",class,
"  public RunInspectionAction() {
    getTemplatePresentation().setText(IdeBundle.message(""goto.inspection.action.text""));
  }",method,
"  @Override
  protected void gotoActionPerformed(final AnActionEvent e) {
    final Project project = e.getData(CommonDataKeys.PROJECT);
    if (project == null) return;
    PsiDocumentManager.getInstance(project).commitAllDocuments();
    final PsiElement psiElement = CommonDataKeys.PSI_ELEMENT.getData(e.getDataContext());
    final PsiFile psiFile = CommonDataKeys.PSI_FILE.getData(e.getDataContext());
    final VirtualFile virtualFile = CommonDataKeys.VIRTUAL_FILE.getData(e.getDataContext());
    FeatureUsageTracker.getInstance().triggerFeatureUsed(""navigation.goto.inspection"");
    final GotoInspectionModel model = new GotoInspectionModel(project);
    showNavigationPopup(e, model, new GotoActionCallback<Object>() {
      @Override
      protected ChooseByNameFilter<Object> createFilter(@NotNull ChooseByNamePopup popup) {
        popup.setSearchInAnyPlace(true);
        return super.createFilter(popup);
      }
      @Override
      public void elementChosen(ChooseByNamePopup popup, final Object element) {
        ApplicationManager.getApplication().invokeLater(
          () -> runInspection(project, ((InspectionToolWrapper)element).getShortName(), virtualFile, psiElement, psiFile));
      }
    }, false);
  }",method,
"    showNavigationPopup(e, model, new GotoActionCallback<Object>() {
      @Override
      protected ChooseByNameFilter<Object> createFilter(@NotNull ChooseByNamePopup popup) {
        popup.setSearchInAnyPlace(true);
        return super.createFilter(popup);
      }
      @Override
      public void elementChosen(ChooseByNamePopup popup, final Object element) {
        ApplicationManager.getApplication().invokeLater(
          () -> runInspection(project, ((InspectionToolWrapper)element).getShortName(), virtualFile, psiElement, psiFile));
      }
    }",method,
"      @Override
      protected ChooseByNameFilter<Object> createFilter(@NotNull ChooseByNamePopup popup) {
        popup.setSearchInAnyPlace(true);
        return super.createFilter(popup);
      }",method,
"      @Override
      public void elementChosen(ChooseByNamePopup popup, final Object element) {
        ApplicationManager.getApplication().invokeLater(
          () -> runInspection(project, ((InspectionToolWrapper)element).getShortName(), virtualFile, psiElement, psiFile));
      }",method,
"  public static void runInspection(final @NotNull Project project,
                                   @NotNull String shortName,
                                   @Nullable VirtualFile virtualFile,
                                   PsiElement psiElement,
                                   PsiFile psiFile) {
    final PsiElement element = psiFile == null ? psiElement : psiFile;
    final InspectionProfile currentProfile = InspectionProjectProfileManager.getInstance(project).getCurrentProfile();
    final InspectionToolWrapper toolWrapper = element != null ? currentProfile.getInspectionTool(shortName, element)
                                                              : currentProfile.getInspectionTool(shortName, project);
    LOGGER.assertTrue(toolWrapper != null, ""Missed inspection: "" + shortName);
    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManager.getInstance(project);
    final Module module = virtualFile != null ? ModuleUtilCore.findModuleForFile(virtualFile, project) : null;
    AnalysisScope analysisScope = null;
    if (psiFile != null) {
      analysisScope = new AnalysisScope(psiFile);
    }
    else {
      if (virtualFile != null && virtualFile.isDirectory()) {
        final PsiDirectory psiDirectory = PsiManager.getInstance(project).findDirectory(virtualFile);
        if (psiDirectory != null) {
          analysisScope = new AnalysisScope(psiDirectory);
        }
      }
      if (analysisScope == null && virtualFile != null) {
        analysisScope = new AnalysisScope(project, Arrays.asList(virtualFile));
      }
      if (analysisScope == null) {
        analysisScope = new AnalysisScope(project);
      }
    }
    final AnalysisUIOptions options = AnalysisUIOptions.getInstance(project);
    final FileFilterPanel fileFilterPanel = new FileFilterPanel();
    fileFilterPanel.init(options);
    final AnalysisScope initialAnalysisScope = analysisScope;
    final BaseAnalysisActionDialog dialog = new BaseAnalysisActionDialog(
      ""Run '"" + toolWrapper.getDisplayName() + ""'"",
      AnalysisScopeBundle.message(""analysis.scope.title"", InspectionsBundle.message(""inspection.action.noun"")),
      project, analysisScope, module, true, options, psiElement) {
      private InspectionToolWrapper myUpdatedSettingsToolWrapper;
      @Nullable
      @Override
      protected JComponent getAdditionalActionSettings(Project project) {
        final JPanel fileFilter = fileFilterPanel.getPanel();
        if (toolWrapper.getTool().createOptionsPanel() != null) {
          JPanel additionPanel = new JPanel();
          additionPanel.setLayout(new GridBagLayout());
          additionPanel.add(fileFilter, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0));
          myUpdatedSettingsToolWrapper = copyToolWithSettings(toolWrapper);//new InheritOptionsForToolPanel(toolWrapper.getShortName(), project);
          additionPanel.add(new TitledSeparator(IdeBundle.message(""goto.inspection.action.choose.inherit.settings.from"")), new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0));
          JComponent optionsPanel = myUpdatedSettingsToolWrapper.getTool().createOptionsPanel();
          LOGGER.assertTrue(optionsPanel != null);
          GridBagConstraints constraints =
            new GridBagConstraints(0, 2, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0);
          if (UIUtil.hasScrollPane(optionsPanel)) {
            additionPanel.add(optionsPanel, constraints);
          }
          else {
            additionPanel.add(ScrollPaneFactory.createScrollPane(optionsPanel, SideBorder.NONE), constraints);
          }
          return additionPanel;
        } else {
          return fileFilter;
        }
      }
      @NotNull
      @Override
      public AnalysisScope getScope(@NotNull AnalysisUIOptions uiOptions,
                                    @NotNull AnalysisScope defaultScope,
                                    @NotNull Project project,
                                    Module module) {
        final AnalysisScope scope = super.getScope(uiOptions, defaultScope, project, module);
        final GlobalSearchScope filterScope = fileFilterPanel.getSearchScope();
        if (filterScope == null) {
          return scope;
        }
        scope.setFilter(filterScope);
        return scope;
      }
      private AnalysisScope getScope() {
        return getScope(options, initialAnalysisScope, project, module);
      }
      private InspectionToolWrapper getToolWrapper() {
        return myUpdatedSettingsToolWrapper == null ? toolWrapper : myUpdatedSettingsToolWrapper;
      }
      @NotNull
      @Override
      protected Action[] createActions() {
        final List<Action> actions = new ArrayList<>();
        final boolean hasFixAll = toolWrapper.getTool() instanceof CleanupLocalInspectionTool;
        actions.add(new AbstractAction(hasFixAll ? AnalysisScopeBundle.message(""action.analyze.verb"")
                                                 : CommonBundle.getOkButtonText()) {
          {
            putValue(DEFAULT_ACTION, Boolean.TRUE);
          }
          @Override
          public void actionPerformed(ActionEvent e) {
            RunInspectionIntention.rerunInspection(getToolWrapper(), managerEx, getScope(), null);
            close(DialogWrapper.OK_EXIT_CODE);
          }
        });
        if (hasFixAll) {
          actions.add(new AbstractAction(""Fix All"") {
            @Override
            public void actionPerformed(ActionEvent e) {
              InspectionToolWrapper wrapper = getToolWrapper();
              InspectionProfileImpl cleanupToolProfile = RunInspectionIntention.createProfile(wrapper, managerEx, null);
              managerEx.createNewGlobalContext(false)
                .codeCleanup(getScope(), cleanupToolProfile, ""Cleanup by "" + wrapper.getDisplayName(), null, false);
              close(DialogWrapper.OK_EXIT_CODE);
            }
          });
        }
        actions.add(getCancelAction());
        if (SystemInfo.isMac) {
          Collections.reverse(actions);
        }
        return actions.toArray(new Action[actions.size()]);
      }
    };
    dialog.showAndGet();
  }",method,
"    if (psiFile != null) {
      analysisScope = new AnalysisScope(psiFile);
    }",method,
"        if (psiDirectory != null) {
          analysisScope = new AnalysisScope(psiDirectory);
        }",method,
"      if (analysisScope == null && virtualFile != null) {
        analysisScope = new AnalysisScope(project, Arrays.asList(virtualFile));
      }",method,
"      if (analysisScope == null) {
        analysisScope = new AnalysisScope(project);
      }",method,
"      @Nullable
      @Override
      protected JComponent getAdditionalActionSettings(Project project) {
        final JPanel fileFilter = fileFilterPanel.getPanel();
        if (toolWrapper.getTool().createOptionsPanel() != null) {
          JPanel additionPanel = new JPanel();
          additionPanel.setLayout(new GridBagLayout());
          additionPanel.add(fileFilter, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0));
          myUpdatedSettingsToolWrapper = copyToolWithSettings(toolWrapper);//new InheritOptionsForToolPanel(toolWrapper.getShortName(), project);
          additionPanel.add(new TitledSeparator(IdeBundle.message(""goto.inspection.action.choose.inherit.settings.from"")), new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0));
          JComponent optionsPanel = myUpdatedSettingsToolWrapper.getTool().createOptionsPanel();
          LOGGER.assertTrue(optionsPanel != null);
          GridBagConstraints constraints =
            new GridBagConstraints(0, 2, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, JBUI.emptyInsets(), 0, 0);
          if (UIUtil.hasScrollPane(optionsPanel)) {
            additionPanel.add(optionsPanel, constraints);
          }
          else {
            additionPanel.add(ScrollPaneFactory.createScrollPane(optionsPanel, SideBorder.NONE), constraints);
          }
          return additionPanel;
        } else {
          return fileFilter;
        }
      }",method,
"      @NotNull
      @Override
      public AnalysisScope getScope(@NotNull AnalysisUIOptions uiOptions,
                                    @NotNull AnalysisScope defaultScope,
                                    @NotNull Project project,
                                    Module module) {
        final AnalysisScope scope = super.getScope(uiOptions, defaultScope, project, module);
        final GlobalSearchScope filterScope = fileFilterPanel.getSearchScope();
        if (filterScope == null) {
          return scope;
        }
        scope.setFilter(filterScope);
        return scope;
      }",method,
"        if (filterScope == null) {
          return scope;
        }",method,
"      private AnalysisScope getScope() {
        return getScope(options, initialAnalysisScope, project, module);
      }",method,
"      private InspectionToolWrapper getToolWrapper() {
        return myUpdatedSettingsToolWrapper == null ? toolWrapper : myUpdatedSettingsToolWrapper;
      }",method,
"      @NotNull
      @Override
      protected Action[] createActions() {
        final List<Action> actions = new ArrayList<>();
        final boolean hasFixAll = toolWrapper.getTool() instanceof CleanupLocalInspectionTool;
        actions.add(new AbstractAction(hasFixAll ? AnalysisScopeBundle.message(""action.analyze.verb"")
                                                 : CommonBundle.getOkButtonText()) {
          {
            putValue(DEFAULT_ACTION, Boolean.TRUE);
          }
          @Override
          public void actionPerformed(ActionEvent e) {
            RunInspectionIntention.rerunInspection(getToolWrapper(), managerEx, getScope(), null);
            close(DialogWrapper.OK_EXIT_CODE);
          }
        });
        if (hasFixAll) {
          actions.add(new AbstractAction(""Fix All"") {
            @Override
            public void actionPerformed(ActionEvent e) {
              InspectionToolWrapper wrapper = getToolWrapper();
              InspectionProfileImpl cleanupToolProfile = RunInspectionIntention.createProfile(wrapper, managerEx, null);
              managerEx.createNewGlobalContext(false)
                .codeCleanup(getScope(), cleanupToolProfile, ""Cleanup by "" + wrapper.getDisplayName(), null, false);
              close(DialogWrapper.OK_EXIT_CODE);
            }
          });
        }
        actions.add(getCancelAction());
        if (SystemInfo.isMac) {
          Collections.reverse(actions);
        }
        return actions.toArray(new Action[actions.size()]);
      }",method,
"          @Override
          public void actionPerformed(ActionEvent e) {
            RunInspectionIntention.rerunInspection(getToolWrapper(), managerEx, getScope(), null);
            close(DialogWrapper.OK_EXIT_CODE);
          }",method,
"        if (hasFixAll) {
          actions.add(new AbstractAction(""Fix All"") {
            @Override
            public void actionPerformed(ActionEvent e) {
              InspectionToolWrapper wrapper = getToolWrapper();
              InspectionProfileImpl cleanupToolProfile = RunInspectionIntention.createProfile(wrapper, managerEx, null);
              managerEx.createNewGlobalContext(false)
                .codeCleanup(getScope(), cleanupToolProfile, ""Cleanup by "" + wrapper.getDisplayName(), null, false);
              close(DialogWrapper.OK_EXIT_CODE);
            }
          });
        }",method,
"          actions.add(new AbstractAction(""Fix All"") {
            @Override
            public void actionPerformed(ActionEvent e) {
              InspectionToolWrapper wrapper = getToolWrapper();
              InspectionProfileImpl cleanupToolProfile = RunInspectionIntention.createProfile(wrapper, managerEx, null);
              managerEx.createNewGlobalContext(false)
                .codeCleanup(getScope(), cleanupToolProfile, ""Cleanup by "" + wrapper.getDisplayName(), null, false);
              close(DialogWrapper.OK_EXIT_CODE);
            }
          }",method,
"            @Override
            public void actionPerformed(ActionEvent e) {
              InspectionToolWrapper wrapper = getToolWrapper();
              InspectionProfileImpl cleanupToolProfile = RunInspectionIntention.createProfile(wrapper, managerEx, null);
              managerEx.createNewGlobalContext(false)
                .codeCleanup(getScope(), cleanupToolProfile, ""Cleanup by "" + wrapper.getDisplayName(), null, false);
              close(DialogWrapper.OK_EXIT_CODE);
            }",method,
"        if (SystemInfo.isMac) {
          Collections.reverse(actions);
        }",method,
"  private static InspectionToolWrapper copyToolWithSettings(@NotNull final InspectionToolWrapper tool) {
    final Element options = new Element(""copy"");
    tool.getTool().writeSettings(options);
    final InspectionToolWrapper copiedTool = tool.createCopy();
    copiedTool.getTool().readSettings(options);
    return copiedTool;
  }",method,
"public class App {
  private static final Logger LOGGER = LoggerFactory.getLogger(App.class);
  public static void main(String[] args) {
    List<Integer> integerList = new ArrayList<>();
    integerList.addAll(Arrays.asList(1, -61, 14, -22, 18, -87, 6, 64, -82, 26, -98, 97, 45, 23, 2,
        -68, 45));
    prettyPrint(""The initial list contains: "", integerList);
    List<Integer> firstFiveNegatives =
        SimpleFluentIterable.fromCopyOf(integerList).filter(negatives()).first(3).asList();
    prettyPrint(""The first three negative values are: "", firstFiveNegatives);
    List<Integer> lastTwoPositives =
        SimpleFluentIterable.fromCopyOf(integerList).filter(positives()).last(2).asList();
    prettyPrint(""The last two positive values are: "", lastTwoPositives);
    SimpleFluentIterable
        .fromCopyOf(integerList)
        .filter(number -> number % 2 == 0)
        .first()
        .ifPresent(evenNumber -> LOGGER.info(""The first even number is: {}"", evenNumber));
    List<String> transformedList =
        SimpleFluentIterable.fromCopyOf(integerList).filter(negatives()).map(transformToString())
            .asList();
    prettyPrint(""A string-mapped list of negative numbers contains: "", transformedList);
    List<String> lastTwoOfFirstFourStringMapped =
        LazyFluentIterable.from(integerList).filter(positives()).first(4).last(2)
            .map(number -> ""String["" + valueOf(number) + ""]"").asList();
    prettyPrint(
        ""The lazy list contains the last two of the first four positive numbers mapped to Strings: "",
        lastTwoOfFirstFourStringMapped);
    LazyFluentIterable
        .from(integerList)
        .filter(negatives())
        .first(2)
        .last()
        .ifPresent(lastOfFirstTwo -> LOGGER.info(""The last of the first two negatives is: {}"", lastOfFirstTwo));
  }
  private static Function<Integer, String> transformToString() {
    return integer -> ""String["" + valueOf(integer) + ""]"";
  }
  private static Predicate<? super Integer> negatives() {
    return integer -> integer < 0;
  }
  private static Predicate<? super Integer> positives() {
    return integer -> integer > 0;
  }
  private static <E> void prettyPrint(String prefix, Iterable<E> iterable) {
    prettyPrint("", "", prefix, iterable);
  }
  private static <E> void prettyPrint(String delimiter, String prefix,
                                         Iterable<E> iterable) {
    StringJoiner joiner = new StringJoiner(delimiter, prefix, ""."");
    Iterator<E> iterator = iterable.iterator();
    while (iterator.hasNext()) {
      joiner.add(iterator.next().toString());
    }
    LOGGER.info(joiner.toString());
  }
}",class,
"  public static void main(String[] args) {
    List<Integer> integerList = new ArrayList<>();
    integerList.addAll(Arrays.asList(1, -61, 14, -22, 18, -87, 6, 64, -82, 26, -98, 97, 45, 23, 2,
        -68, 45));
    prettyPrint(""The initial list contains: "", integerList);
    List<Integer> firstFiveNegatives =
        SimpleFluentIterable.fromCopyOf(integerList).filter(negatives()).first(3).asList();
    prettyPrint(""The first three negative values are: "", firstFiveNegatives);
    List<Integer> lastTwoPositives =
        SimpleFluentIterable.fromCopyOf(integerList).filter(positives()).last(2).asList();
    prettyPrint(""The last two positive values are: "", lastTwoPositives);
    SimpleFluentIterable
        .fromCopyOf(integerList)
        .filter(number -> number % 2 == 0)
        .first()
        .ifPresent(evenNumber -> LOGGER.info(""The first even number is: {}"", evenNumber));
    List<String> transformedList =
        SimpleFluentIterable.fromCopyOf(integerList).filter(negatives()).map(transformToString())
            .asList();
    prettyPrint(""A string-mapped list of negative numbers contains: "", transformedList);
    List<String> lastTwoOfFirstFourStringMapped =
        LazyFluentIterable.from(integerList).filter(positives()).first(4).last(2)
            .map(number -> ""String["" + valueOf(number) + ""]"").asList();
    prettyPrint(
        ""The lazy list contains the last two of the first four positive numbers mapped to Strings: "",
        lastTwoOfFirstFourStringMapped);
    LazyFluentIterable
        .from(integerList)
        .filter(negatives())
        .first(2)
        .last()
        .ifPresent(lastOfFirstTwo -> LOGGER.info(""The last of the first two negatives is: {}"", lastOfFirstTwo));
  }",method,
"  private static Function<Integer, String> transformToString() {
    return integer -> ""String["" + valueOf(integer) + ""]"";
  }",method,
"  private static Predicate<? super Integer> negatives() {
    return integer -> integer < 0;
  }",method,
"  private static Predicate<? super Integer> positives() {
    return integer -> integer > 0;
  }",method,
"  private static <E> void prettyPrint(String prefix, Iterable<E> iterable) {
    prettyPrint("", "", prefix, iterable);
  }",method,
"  private static <E> void prettyPrint(String delimiter, String prefix,
                                         Iterable<E> iterable) {
    StringJoiner joiner = new StringJoiner(delimiter, prefix, ""."");
    Iterator<E> iterator = iterable.iterator();
    while (iterator.hasNext()) {
      joiner.add(iterator.next().toString());
    }
    LOGGER.info(joiner.toString());
  }",method,
"  class PropertiesComponentStorage implements Storage {
    private static final Logger LOG = Logger.getInstance(""#com.intellij.util.config.Storage.PropertiesComponentStorage"");
    private final PropertiesComponent myPropertiesComponent;
    private final String myPrefix;
    public PropertiesComponentStorage(String prefix, PropertiesComponent propertiesComponent) {
      LOG.assertTrue(propertiesComponent != null || ApplicationManager.getApplication().isUnitTestMode());
      myPropertiesComponent = propertiesComponent;
      myPrefix = prefix;
    }
    public PropertiesComponentStorage(String prefix) {
      this(prefix, PropertiesComponent.getInstance());
    }
    @Override
    public void put(String key, String value) {
      if (myPropertiesComponent != null) {
        myPropertiesComponent.setValue(myPrefix + key, value);
      }
    }
    @Override
    public String get(String key) {
      return myPropertiesComponent != null ? myPropertiesComponent.getValue(myPrefix + key) : null;
    }
    @Override
    public String toString() {
      return ""PropertiesComponentStorage: "" + myPrefix;
    }
  }",class,
"  class MapStorage implements Storage {
    private final Map<String, String> myValues = new HashMap<>();
    @Override
    public String get(String key) {
      return myValues.get(key);
    }
    @Override
    public void put(String key, String value) {
      myValues.put(key, value);
    }
    public Iterator<String> getKeys() {
      return Collections.unmodifiableCollection(myValues.keySet()).iterator();
    }
  }",class,
"    public PropertiesComponentStorage(String prefix, PropertiesComponent propertiesComponent) {
      LOG.assertTrue(propertiesComponent != null || ApplicationManager.getApplication().isUnitTestMode());
      myPropertiesComponent = propertiesComponent;
      myPrefix = prefix;
    }",method,
"    public PropertiesComponentStorage(String prefix) {
      this(prefix, PropertiesComponent.getInstance());
    }",method,
"    @Override
    public void put(String key, String value) {
      if (myPropertiesComponent != null) {
        myPropertiesComponent.setValue(myPrefix + key, value);
      }
    }",method,
"      if (myPropertiesComponent != null) {
        myPropertiesComponent.setValue(myPrefix + key, value);
      }",method,
"    @Override
    public String get(String key) {
      return myPropertiesComponent != null ? myPropertiesComponent.getValue(myPrefix + key) : null;
    }",method,
"    @Override
    public String toString() {
      return ""PropertiesComponentStorage: "" + myPrefix;
    }",method,
"    @Override
    public String get(String key) {
      return myValues.get(key);
    }",method,
"    @Override
    public void put(String key, String value) {
      myValues.put(key, value);
    }",method,
"    public Iterator<String> getKeys() {
      return Collections.unmodifiableCollection(myValues.keySet()).iterator();
    }",method,
"                    description = ""The fully qualified class name of the multi data set iterator class to use."",
                    arity = 1)
    private String dataSetIteratorFactoryClazz = null;
    @Parameter(names = {""--multiDataSetIteratorFactoryClazz""}",class,
"                    description = ""The fully qualified class name of the multi data set iterator class to use."",
                    arity = 1)
    private String multiDataSetIteratorFactoryClazz = null;
    @Parameter(names = {""--modelOutputPath""}",class,
"                    description = ""The fully qualified class name of the multi data set iterator class to use."",
                    arity = 1, required = true)
    private String modelOutputPath = null;
    @Parameter(names = {""--uiUrl""}",class,
"    public static void main(String[] args) throws Exception {
        new ParallelWrapperMain().runMain(args);
    }",method,
"    public void runMain(String... args) throws Exception {
        JCommander jcmdr = new JCommander(this);
        try {
            jcmdr.parse(args);
        } catch (ParameterException e) {
            System.err.println(e.getMessage());
            //User provides invalid input -> print the usage info
            jcmdr.usage();
            try {
                Thread.sleep(500);
            } catch (Exception e2) {
            }
            System.exit(1);
        }
        run();
    }",method,
"public class TestPrestoThriftBigint
{
    @Test
    public void testReadBlock()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {false, true, false, false, false, false, true},
                new long[] {2, 0, 1, 3, 8, 4, 0});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(2L, null, 1L, 3L, 8L, 4L, null));
    }
    @Test
    public void testReadBlockAllNullsOption1()
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {true, true, true, true, true, true, true},
                null);
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(null, null, null, null, null, null, null));
    }
    @Test
    public void testReadBlockAllNullsOption2()
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {true, true, true, true, true, true, true},
                new long[] {0, 0, 0, 0, 0, 0, 0});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(null, null, null, null, null, null, null));
    }
    @Test
    public void testReadBlockAllNonNullOption1()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(
                null,
                new long[] {2, 7, 1, 3, 8, 4, 5});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(2L, 7L, 1L, 3L, 8L, 4L, 5L));
    }
    @Test
    public void testReadBlockAllNonNullOption2()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {false, false, false, false, false, false, false},
                new long[] {2, 7, 1, 3, 8, 4, 5});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(2L, 7L, 1L, 3L, 8L, 4L, 5L));
    }
    @Test(expectedExceptions = IllegalArgumentException.class)
    public void testReadBlockWrongActualType()
            throws Exception
    {
        PrestoThriftBlock columnsData = integerData(new PrestoThriftInteger(null, null));
        columnsData.toBlock(BIGINT);
    }
    @Test(expectedExceptions = IllegalArgumentException.class)
    public void testReadBlockWrongDesiredType()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(null, null);
        columnsData.toBlock(INTEGER);
    }
    @Test
    public void testWriteBlockAlternating()
            throws Exception
    {
        Block source = longBlock(1, null, 2, null, 3, null, 4, null, 5, null, 6, null, 7, null);
        PrestoThriftBlock column = fromBlock(source);
        assertNotNull(column.getBigintData());
        assertEquals(column.getBigintData().getNulls(),
                new boolean[] {false, true, false, true, false, true, false, true, false, true, false, true, false, true});
        assertEquals(column.getBigintData().getLongs(),
                new long[] {1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0});
    }
    @Test
    public void testWriteBlockAllNulls()
            throws Exception
    {
        Block source = longBlock(null, null, null, null, null);
        PrestoThriftBlock column = fromBlock(source);
        assertNotNull(column.getBigintData());
        assertEquals(column.getBigintData().getNulls(), new boolean[] {true, true, true, true, true});
        assertNull(column.getBigintData().getLongs());
    }
    @Test
    public void testWriteBlockAllNonNull()
            throws Exception
    {
        Block source = longBlock(1, 2, 3, 4, 5);
        PrestoThriftBlock column = fromBlock(source);
        assertNotNull(column.getBigintData());
        assertNull(column.getBigintData().getNulls());
        assertEquals(column.getBigintData().getLongs(), new long[] {1, 2, 3, 4, 5});
    }
    @Test
    public void testWriteBlockEmpty()
            throws Exception
    {
        PrestoThriftBlock column = fromBlock(longBlock());
        assertNotNull(column.getBigintData());
        assertNull(column.getBigintData().getNulls());
        assertNull(column.getBigintData().getLongs());
    }
    @Test
    public void testWriteBlockSingleValue()
            throws Exception
    {
        PrestoThriftBlock column = fromBlock(longBlock(1));
        assertNotNull(column.getBigintData());
        assertNull(column.getBigintData().getNulls());
        assertEquals(column.getBigintData().getLongs(), new long[] {1});
    }
    private void assertBlockEquals(Block block, List<Long> expected)
    {
        assertEquals(block.getPositionCount(), expected.size());
        for (int i = 0; i < expected.size(); i++) {
            if (expected.get(i) == null) {
                assertTrue(block.isNull(i));
            }
            else {
                assertEquals(block.getLong(i, 0), expected.get(i).longValue());
            }
        }
    }
    private static Block longBlock(Integer... values)
    {
        BlockBuilder blockBuilder = BIGINT.createBlockBuilder(new BlockBuilderStatus(), values.length);
        for (Integer value : values) {
            if (value == null) {
                blockBuilder.appendNull();
            }
            else {
                blockBuilder.writeLong(value).closeEntry();
            }
        }
        return blockBuilder.build();
    }
    private static PrestoThriftBlock longColumn(boolean[] nulls, long[] longs)
    {
        return bigintData(new PrestoThriftBigint(nulls, longs));
    }
    private static List<Long> list(Long... values)
    {
        return unmodifiableList(Arrays.asList(values));
    }
}",class,
"    @Test
    public void testReadBlock()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {false, true, false, false, false, false, true},
                new long[] {2, 0, 1, 3, 8, 4, 0});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(2L, null, 1L, 3L, 8L, 4L, null));
    }",method,
"    @Test
    public void testReadBlockAllNullsOption1()
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {true, true, true, true, true, true, true},
                null);
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(null, null, null, null, null, null, null));
    }",method,
"    @Test
    public void testReadBlockAllNullsOption2()
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {true, true, true, true, true, true, true},
                new long[] {0, 0, 0, 0, 0, 0, 0});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(null, null, null, null, null, null, null));
    }",method,
"    @Test
    public void testReadBlockAllNonNullOption1()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(
                null,
                new long[] {2, 7, 1, 3, 8, 4, 5});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(2L, 7L, 1L, 3L, 8L, 4L, 5L));
    }",method,
"    @Test
    public void testReadBlockAllNonNullOption2()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(
                new boolean[] {false, false, false, false, false, false, false},
                new long[] {2, 7, 1, 3, 8, 4, 5});
        Block actual = columnsData.toBlock(BIGINT);
        assertBlockEquals(actual, list(2L, 7L, 1L, 3L, 8L, 4L, 5L));
    }",method,
"    @Test(expectedExceptions = IllegalArgumentException.class)
    public void testReadBlockWrongActualType()
            throws Exception
    {
        PrestoThriftBlock columnsData = integerData(new PrestoThriftInteger(null, null));
        columnsData.toBlock(BIGINT);
    }",method,
"    @Test(expectedExceptions = IllegalArgumentException.class)
    public void testReadBlockWrongDesiredType()
            throws Exception
    {
        PrestoThriftBlock columnsData = longColumn(null, null);
        columnsData.toBlock(INTEGER);
    }",method,
"    @Test
    public void testWriteBlockAlternating()
            throws Exception
    {
        Block source = longBlock(1, null, 2, null, 3, null, 4, null, 5, null, 6, null, 7, null);
        PrestoThriftBlock column = fromBlock(source);
        assertNotNull(column.getBigintData());
        assertEquals(column.getBigintData().getNulls(),
                new boolean[] {false, true, false, true, false, true, false, true, false, true, false, true, false, true});
        assertEquals(column.getBigintData().getLongs(),
                new long[] {1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0});
    }",method,
"    @Test
    public void testWriteBlockAllNulls()
            throws Exception
    {
        Block source = longBlock(null, null, null, null, null);
        PrestoThriftBlock column = fromBlock(source);
        assertNotNull(column.getBigintData());
        assertEquals(column.getBigintData().getNulls(), new boolean[] {true, true, true, true, true});
        assertNull(column.getBigintData().getLongs());
    }",method,
"    @Test
    public void testWriteBlockAllNonNull()
            throws Exception
    {
        Block source = longBlock(1, 2, 3, 4, 5);
        PrestoThriftBlock column = fromBlock(source);
        assertNotNull(column.getBigintData());
        assertNull(column.getBigintData().getNulls());
        assertEquals(column.getBigintData().getLongs(), new long[] {1, 2, 3, 4, 5});
    }",method,
"    @Test
    public void testWriteBlockEmpty()
            throws Exception
    {
        PrestoThriftBlock column = fromBlock(longBlock());
        assertNotNull(column.getBigintData());
        assertNull(column.getBigintData().getNulls());
        assertNull(column.getBigintData().getLongs());
    }",method,
"    @Test
    public void testWriteBlockSingleValue()
            throws Exception
    {
        PrestoThriftBlock column = fromBlock(longBlock(1));
        assertNotNull(column.getBigintData());
        assertNull(column.getBigintData().getNulls());
        assertEquals(column.getBigintData().getLongs(), new long[] {1});
    }",method,
"    private void assertBlockEquals(Block block, List<Long> expected)
    {
        assertEquals(block.getPositionCount(), expected.size());
        for (int i = 0; i < expected.size(); i++) {
            if (expected.get(i) == null) {
                assertTrue(block.isNull(i));
            }
            else {
                assertEquals(block.getLong(i, 0), expected.get(i).longValue());
            }
        }
    }",method,

code_snippet,type,score
"  @NotNull
  private static SimpleDiffRequest createRequest(@Nullable Project project,
                                                 @NotNull Change leftChange,
                                                 @NotNull Change rightChange,
                                                 @NotNull UserDataHolder context,
                                                 @NotNull ProgressIndicator indicator)
    throws DiffRequestProducerException {
    String requestTitle = getRequestTitle(leftChange);
    ContentRevision leftRevision = leftChange.getBeforeRevision();
    ContentRevision centerRevision = leftChange.getAfterRevision();
    ContentRevision rightRevision = rightChange.getBeforeRevision();
    if (leftRevision == null) {
      return createTwoSideRequest(project, centerRevision, rightRevision, requestTitle,
                                  ChangeDiffRequestProducer.MERGED_VERSION, ChangeDiffRequestProducer.SERVER_VERSION,
                                  context, indicator);
    }
    else if (rightRevision == null) {
      return createTwoSideRequest(project, leftRevision, centerRevision, requestTitle,
                                  ChangeDiffRequestProducer.YOUR_VERSION, ChangeDiffRequestProducer.MERGED_VERSION,
                                  context, indicator);
    }
    else if (centerRevision == null) {
      return createTwoSideRequest(project, leftRevision, rightRevision, requestTitle,
                                  ChangeDiffRequestProducer.YOUR_VERSION, ChangeDiffRequestProducer.SERVER_VERSION,
                                  context, indicator);
    }
    return new SimpleDiffRequest(requestTitle,
                                 ChangeDiffRequestProducer.createContent(project, leftRevision, context, indicator),
                                 ChangeDiffRequestProducer.createContent(project, centerRevision, context, indicator),
                                 ChangeDiffRequestProducer.createContent(project, rightRevision, context, indicator),
                                 getRevisionTitle(leftRevision, ChangeDiffRequestProducer.YOUR_VERSION),
                                 getRevisionTitle(centerRevision, ChangeDiffRequestProducer.MERGED_VERSION),
                                 getRevisionTitle(rightRevision, ChangeDiffRequestProducer.SERVER_VERSION));
  }",method,
"    if (leftRevision == null) {
      return createTwoSideRequest(project, centerRevision, rightRevision, requestTitle,
                                  ChangeDiffRequestProducer.MERGED_VERSION, ChangeDiffRequestProducer.SERVER_VERSION,
                                  context, indicator);
    }",method,
"    else if (rightRevision == null) {
      return createTwoSideRequest(project, leftRevision, centerRevision, requestTitle,
                                  ChangeDiffRequestProducer.YOUR_VERSION, ChangeDiffRequestProducer.MERGED_VERSION,
                                  context, indicator);
    }",method,
"    else if (centerRevision == null) {
      return createTwoSideRequest(project, leftRevision, rightRevision, requestTitle,
                                  ChangeDiffRequestProducer.YOUR_VERSION, ChangeDiffRequestProducer.SERVER_VERSION,
                                  context, indicator);
    }",method,
"  @NotNull
  private static SimpleDiffRequest createTwoSideRequest(@Nullable Project project,
                                                        @Nullable ContentRevision leftRevision,
                                                        @Nullable ContentRevision rightRevision,
                                                        @NotNull String requestTitle,
                                                        @NotNull String leftTitle,
                                                        @NotNull String rightTitle,
                                                        @NotNull UserDataHolder context,
                                                        @NotNull ProgressIndicator indicator)
    throws DiffRequestProducerException {
    return new SimpleDiffRequest(requestTitle,
                                 ChangeDiffRequestProducer.createContent(project, leftRevision, context, indicator),
                                 ChangeDiffRequestProducer.createContent(project, rightRevision, context, indicator),
                                 getRevisionTitle(leftRevision, leftTitle),
                                 getRevisionTitle(rightRevision, rightTitle));
  }",method,
"    @Nullable private final Project myProject;
    @NotNull private final MergedChange myMergedChange;
    public MyProducer(@Nullable Project project, @NotNull MergedChange mergedChange) {
      myProject = project;
      assert mergedChange.getSourceChanges().size() == 2;
      myMergedChange = mergedChange;
    }",method,
"    @NotNull
    @Override
    public DiffRequest process(@NotNull UserDataHolder context, @NotNull ProgressIndicator indicator)
      throws DiffRequestProducerException, ProcessCanceledException {
      List<Change> sourceChanges = myMergedChange.getSourceChanges();
      SimpleDiffRequest request = createRequest(myProject, sourceChanges.get(0), sourceChanges.get(1), context, indicator);
      request.putUserData(DiffUserDataKeys.THREESIDE_DIFF_WITH_RESULT, true);
      return request;
    }",method,
"    @NotNull
    @Override
    public String getName() {
      return getRequestTitle(myMergedChange);
    }",method,
"    @NotNull
    @Override
    public FilePath getFilePath() {
      return ChangesUtil.getFilePath(myMergedChange);
    }",method,
"    @NotNull
    @Override
    public FileStatus getFileStatus() {
      return myMergedChange.getFileStatus();
    }",method,
"    @Test(description = ""convert a simple TypeScript Node model"")
    public void simpleModelTest() {
        final Model model = new ModelImpl()
                .description(""a sample model"")
                .property(""id"", new LongProperty())
                .property(""name"", new StringProperty())
                .property(""createdAt"", new DateTimeProperty())
                .property(""birthDate"", new DateProperty())
                .required(""id"")
                .required(""name"");
        final DefaultCodegen codegen = new TypeScriptNodeClientCodegen();
        final CodegenModel cm = codegen.fromModel(""sample"", model);
        Assert.assertEquals(cm.name, ""sample"");
        Assert.assertEquals(cm.classname, ""Sample"");
        Assert.assertEquals(cm.description, ""a sample model"");
        Assert.assertEquals(cm.vars.size(), 4);
        final CodegenProperty property1 = cm.vars.get(0);
        Assert.assertEquals(property1.baseName, ""id"");
        Assert.assertEquals(property1.datatype, ""number"");
        Assert.assertEquals(property1.name, ""id"");
        Assert.assertEquals(property1.defaultValue, ""null"");
        Assert.assertEquals(property1.baseType, ""number"");
        Assert.assertTrue(property1.hasMore);
        Assert.assertTrue(property1.required);
        Assert.assertTrue(property1.isNotContainer);
        final CodegenProperty property2 = cm.vars.get(1);
        Assert.assertEquals(property2.baseName, ""name"");
        Assert.assertEquals(property2.datatype, ""string"");
        Assert.assertEquals(property2.name, ""name"");
        Assert.assertEquals(property2.defaultValue, ""null"");
        Assert.assertEquals(property2.baseType, ""string"");
        Assert.assertTrue(property2.hasMore);
        Assert.assertTrue(property2.required);
        Assert.assertTrue(property2.isNotContainer);
        final CodegenProperty property3 = cm.vars.get(2);
        Assert.assertEquals(property3.baseName, ""createdAt"");
        Assert.assertEquals(property3.complexType, null);
        Assert.assertEquals(property3.datatype, ""Date"");
        Assert.assertEquals(property3.name, ""createdAt"");
        Assert.assertEquals(property3.defaultValue, ""null"");
        Assert.assertTrue(property3.hasMore);
        Assert.assertFalse(property3.required);
        Assert.assertTrue(property3.isNotContainer);
        final CodegenProperty property4 = cm.vars.get(3);
        Assert.assertEquals(property4.baseName, ""birthDate"");
        Assert.assertEquals(property4.complexType, null);
        Assert.assertEquals(property4.datatype, ""string"");
        Assert.assertEquals(property4.name, ""birthDate"");
        Assert.assertEquals(property4.defaultValue, ""null"");
        Assert.assertFalse(property4.hasMore);
        Assert.assertFalse(property4.required);
        Assert.assertTrue(property4.isNotContainer);
    }",method,
"    @Test(description = ""convert a model with list property"")
    public void listPropertyTest() {
        final Model model = new ModelImpl()
                .description(""a sample model"")
                .property(""id"", new LongProperty())
                .property(""urls"", new ArrayProperty().items(new StringProperty()))
                .required(""id"");
        final DefaultCodegen codegen = new TypeScriptNodeClientCodegen();
        final CodegenModel cm = codegen.fromModel(""sample"", model);
        Assert.assertEquals(cm.name, ""sample"");
        Assert.assertEquals(cm.classname, ""Sample"");
        Assert.assertEquals(cm.description, ""a sample model"");
        Assert.assertEquals(cm.vars.size(), 2);
        final CodegenProperty property1 = cm.vars.get(0);
        Assert.assertEquals(property1.baseName, ""id"");
        Assert.assertEquals(property1.datatype, ""number"");
        Assert.assertEquals(property1.name, ""id"");
        Assert.assertEquals(property1.defaultValue, ""null"");
        Assert.assertEquals(property1.baseType, ""number"");
        Assert.assertTrue(property1.hasMore);
        Assert.assertTrue(property1.required);
        Assert.assertTrue(property1.isNotContainer);
        final CodegenProperty property2 = cm.vars.get(1);
        Assert.assertEquals(property2.baseName, ""urls"");
        Assert.assertEquals(property2.datatype, ""Array<string>"");
        Assert.assertEquals(property2.name, ""urls"");
        Assert.assertEquals(property2.baseType, ""Array"");
        Assert.assertFalse(property2.hasMore);
        Assert.assertFalse(property2.required);
        Assert.assertTrue(property2.isContainer);
    }",method,
"    @Test(description = ""convert a model with complex property"")
    public void complexPropertyTest() {
        final Model model = new ModelImpl()
                .description(""a sample model"")
                .property(""children"", new RefProperty(""#/definitions/Children""));
        final DefaultCodegen codegen = new TypeScriptNodeClientCodegen();
        final CodegenModel cm = codegen.fromModel(""sample"", model);
        Assert.assertEquals(cm.name, ""sample"");
        Assert.assertEquals(cm.classname, ""Sample"");
        Assert.assertEquals(cm.description, ""a sample model"");
        Assert.assertEquals(cm.vars.size(), 1);
        final CodegenProperty property1 = cm.vars.get(0);
        Assert.assertEquals(property1.baseName, ""children"");
        Assert.assertEquals(property1.datatype, ""Children"");
        Assert.assertEquals(property1.name, ""children"");
        Assert.assertEquals(property1.baseType, ""Children"");
        Assert.assertFalse(property1.required);
        Assert.assertTrue(property1.isNotContainer);
    }",method,
"    @Test(description = ""convert a model with complex list property"")
    public void complexListPropertyTest() {
        final Model model = new ModelImpl()
                .description(""a sample model"")
                .property(""children"", new ArrayProperty()
                        .items(new RefProperty(""#/definitions/Children"")));
        final DefaultCodegen codegen = new TypeScriptNodeClientCodegen();
        final CodegenModel cm = codegen.fromModel(""sample"", model);
        Assert.assertEquals(cm.name, ""sample"");
        Assert.assertEquals(cm.classname, ""Sample"");
        Assert.assertEquals(cm.description, ""a sample model"");
        Assert.assertEquals(cm.vars.size(), 1);
        final CodegenProperty property1 = cm.vars.get(0);
        Assert.assertEquals(property1.baseName, ""children"");
        Assert.assertEquals(property1.complexType, ""Children"");
        Assert.assertEquals(property1.datatype, ""Array<Children>"");
        Assert.assertEquals(property1.name, ""children"");
        Assert.assertEquals(property1.baseType, ""Array"");
        Assert.assertFalse(property1.required);
        Assert.assertTrue(property1.isContainer);
    }",method,
"    @Test(description = ""convert an array model"")
    public void arrayModelTest() {
        final Model model = new ArrayModel()
                .description(""an array model"")
                .items(new RefProperty(""#/definitions/Children""));
        final DefaultCodegen codegen = new TypeScriptNodeClientCodegen();
        final CodegenModel cm = codegen.fromModel(""sample"", model);
        Assert.assertEquals(cm.name, ""sample"");
        Assert.assertEquals(cm.classname, ""Sample"");
        Assert.assertEquals(cm.description, ""an array model"");
        Assert.assertEquals(cm.vars.size(), 0);
    }",method,
"public class Hessian2StreamingInput {
    private Hessian2Input _in;
    public Hessian2StreamingInput(InputStream is) {
        _in = new Hessian2Input(new StreamingInputStream(is));
    }
    public Object readObject()
            throws IOException {
        return _in.readStreamingObject();
    }
    public void close()
            throws IOException {
        _in.close();
    }
    static class StreamingInputStream extends InputStream {
        private InputStream _is;
        private int _length;
        StreamingInputStream(InputStream is) {
            _is = is;
        }
        public int read()
                throws IOException {
            InputStream is = _is;
            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P')
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff));
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }
            _length--;
            return is.read();
        }
        public int read(byte[] buffer, int offset, int length)
                throws IOException {
            InputStream is = _is;
            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P') {
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff)
                            + "" ("" + (char) code + "")"");
                }
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }
            int sublen = _length;
            if (length < sublen)
                sublen = length;
            sublen = is.read(buffer, offset, sublen);
            if (sublen < 0)
                return -1;
            _length -= sublen;
            return sublen;
        }
    }
}",class,
"    static class StreamingInputStream extends InputStream {
        private InputStream _is;
        private int _length;
        StreamingInputStream(InputStream is) {
            _is = is;
        }
        public int read()
                throws IOException {
            InputStream is = _is;
            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P')
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff));
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }
            _length--;
            return is.read();
        }
        public int read(byte[] buffer, int offset, int length)
                throws IOException {
            InputStream is = _is;
            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P') {
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff)
                            + "" ("" + (char) code + "")"");
                }
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }
            int sublen = _length;
            if (length < sublen)
                sublen = length;
            sublen = is.read(buffer, offset, sublen);
            if (sublen < 0)
                return -1;
            _length -= sublen;
            return sublen;
        }
    }",class,
"    public Hessian2StreamingInput(InputStream is) {
        _in = new Hessian2Input(new StreamingInputStream(is));
    }",method,
"    public Object readObject()
            throws IOException {
        return _in.readStreamingObject();
    }",method,
"    public void close()
            throws IOException {
        _in.close();
    }",method,
"        StreamingInputStream(InputStream is) {
            _is = is;
        }",method,
"        public int read()
                throws IOException {
            InputStream is = _is;
            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P')
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff));
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }
            _length--;
            return is.read();
        }",method,
"            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P')
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff));
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }",method,
"        public int read(byte[] buffer, int offset, int length)
                throws IOException {
            InputStream is = _is;
            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P') {
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff)
                            + "" ("" + (char) code + "")"");
                }
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }
            int sublen = _length;
            if (length < sublen)
                sublen = length;
            sublen = is.read(buffer, offset, sublen);
            if (sublen < 0)
                return -1;
            _length -= sublen;
            return sublen;
        }",method,
"            while (_length == 0) {
                int code = is.read();
                if (code < 0)
                    return -1;
                else if (code != 'p' && code != 'P') {
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff)
                            + "" ("" + (char) code + "")"");
                }
                int d1 = is.read();
                int d2 = is.read();
                if (d2 < 0)
                    return -1;
                _length = (d1 << 8) + d2;
            }",method,
"                else if (code != 'p' && code != 'P') {
                    throw new HessianProtocolException(""expected streaming packet at 0x""
                            + Integer.toHexString(code & 0xff)
                            + "" ("" + (char) code + "")"");
                }",method,
"import java.util.List;
class GitInteractiveRebaseFile {
  @NonNls private static final String CYGDRIVE_PREFIX = ""/cygdrive/"";
  @NotNull private final Project myProject;
  @NotNull private final VirtualFile myRoot;
  @NotNull private final String myFile;
  GitInteractiveRebaseFile(@NotNull Project project, @NotNull VirtualFile root, @NotNull String rebaseFilePath) {
    myProject = project;
    myRoot = root;
    myFile = adjustFilePath(rebaseFilePath);
  }
  @NotNull
  public List<GitRebaseEntry> load() throws IOException, NoopException {
    String encoding = GitConfigUtil.getLogEncoding(myProject, myRoot);
    List<GitRebaseEntry> entries = ContainerUtil.newArrayList();
    final StringScanner s = new StringScanner(FileUtil.loadFile(new File(myFile), encoding));
    boolean noop = false;
    while (s.hasMoreData()) {
      if (s.isEol() || s.startsWith(GitUtil.COMMENT_CHAR)) {
        s.nextLine();
        continue;
      }
      if (s.startsWith(""noop"")) {
        noop = true;
        s.nextLine();
        continue;
      }
      String action = s.spaceToken();
      String hash = s.spaceToken();
      String comment = s.line();
      entries.add(new GitRebaseEntry(action, hash, comment));
    }
    if (noop && entries.isEmpty()) {
      throw new NoopException();
    }
    return entries;
  }
  public void cancel() throws IOException {
    PrintWriter out = new PrintWriter(new FileWriter(myFile));
    try {
      out.println(""# rebase is cancelled"");
    }
    finally {
      out.close();
    }
  }
  public void save(@NotNull List<GitRebaseEntry> entries) throws IOException {
    String encoding = GitConfigUtil.getLogEncoding(myProject, myRoot);
    PrintWriter out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(myFile), encoding));
    try {
      for (GitRebaseEntry e : entries) {
        if (e.getAction() != GitRebaseEntry.Action.skip) {
          out.println(e.getAction().toString() + "" "" + e.getCommit() + "" "" + e.getSubject());
        }
      }
    }
    finally {
      out.close();
    }
  }
  @NotNull
  private static String adjustFilePath(@NotNull String file) {
    if (SystemInfo.isWindows && file.startsWith(CYGDRIVE_PREFIX)) {
      final int prefixSize = CYGDRIVE_PREFIX.length();
      return file.substring(prefixSize, prefixSize + 1) + "":"" + file.substring(prefixSize + 1);
    }
    return file;
  }
  static class NoopException extends Exception {
  }
}",class,
"  static class NoopException extends Exception {
  }",class,
"  @NonNls private static final String CYGDRIVE_PREFIX = ""/cygdrive/"";
  @NotNull private final Project myProject;
  @NotNull private final VirtualFile myRoot;
  @NotNull private final String myFile;
  GitInteractiveRebaseFile(@NotNull Project project, @NotNull VirtualFile root, @NotNull String rebaseFilePath) {
    myProject = project;
    myRoot = root;
    myFile = adjustFilePath(rebaseFilePath);
  }",method,
"  @NotNull
  public List<GitRebaseEntry> load() throws IOException, NoopException {
    String encoding = GitConfigUtil.getLogEncoding(myProject, myRoot);
    List<GitRebaseEntry> entries = ContainerUtil.newArrayList();
    final StringScanner s = new StringScanner(FileUtil.loadFile(new File(myFile), encoding));
    boolean noop = false;
    while (s.hasMoreData()) {
      if (s.isEol() || s.startsWith(GitUtil.COMMENT_CHAR)) {
        s.nextLine();
        continue;
      }
      if (s.startsWith(""noop"")) {
        noop = true;
        s.nextLine();
        continue;
      }
      String action = s.spaceToken();
      String hash = s.spaceToken();
      String comment = s.line();
      entries.add(new GitRebaseEntry(action, hash, comment));
    }
    if (noop && entries.isEmpty()) {
      throw new NoopException();
    }
    return entries;
  }",method,
"  public void cancel() throws IOException {
    PrintWriter out = new PrintWriter(new FileWriter(myFile));
    try {
      out.println(""# rebase is cancelled"");
    }
    finally {
      out.close();
    }
  }",method,
"  public void save(@NotNull List<GitRebaseEntry> entries) throws IOException {
    String encoding = GitConfigUtil.getLogEncoding(myProject, myRoot);
    PrintWriter out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(myFile), encoding));
    try {
      for (GitRebaseEntry e : entries) {
        if (e.getAction() != GitRebaseEntry.Action.skip) {
          out.println(e.getAction().toString() + "" "" + e.getCommit() + "" "" + e.getSubject());
        }
      }
    }
    finally {
      out.close();
    }
  }",method,
"      for (GitRebaseEntry e : entries) {
        if (e.getAction() != GitRebaseEntry.Action.skip) {
          out.println(e.getAction().toString() + "" "" + e.getCommit() + "" "" + e.getSubject());
        }
      }",method,
"  @NotNull
  private static String adjustFilePath(@NotNull String file) {
    if (SystemInfo.isWindows && file.startsWith(CYGDRIVE_PREFIX)) {
      final int prefixSize = CYGDRIVE_PREFIX.length();
      return file.substring(prefixSize, prefixSize + 1) + "":"" + file.substring(prefixSize + 1);
    }
    return file;
  }",method,
"public class Main {
  private static ExecutorService threadPool;
  private OptionSet options;
  private AetherPackageLoader packageLoader;
  private Session session;
  public static void main(String[] args) throws Exception {
    if(args.length >= 1 && (args[0].equals(""build"") || args[0].equals(""install"")) ) {
      Builder.execute(args[0], Arrays.copyOfRange(args, 1, args.length));
      return;
    }
    OptionSet optionSet;
    try {
      optionSet = new OptionSet(args);
    } catch(OptionException e) {
      System.err.println(e.getMessage());
      OptionSet.printHelp(System.out);
      System.exit(-1);
      return;
    }
    if(optionSet.isHelpRequested()) {
      OptionSet.printHelp(System.out);
      System.exit(0);
    }
    // Set process-wide flags
    if(optionSet.isFlagSet(OptionSet.COMPILE_LOOPS)) {
      ForFunction.COMPILE_LOOPS = true;
    }
    try {
      new Main(optionSet).run();
    } finally {
      if(Profiler.ENABLED) {
        System.out.flush();
        Profiler.dumpTotalRunningTime();
        Profiler.dump(System.out);
      }
    }
  }
  public Main(OptionSet options) {
    this.options = options;
  }
  public void run() {
    configureLogging();
    try {
      initSession();
      this.session.setCommandLineArguments(""renjin"", options.getArguments());
      if(options.isFlagSet(OptionSet.PROFILE)) {
        Profiler.ENABLED = true;
      }
      if(options.hasExpression()) {
        evaluateExpression(options.getExpression());
      } else if(options.hasFile()) {
        evaluateFile(options.getFile());
      } else {
        startInteractive();
      }
    } catch (Exception e) {
      e.printStackTrace();
      System.exit(-1);
    }
  }
  private void startInteractive() throws Exception {
    JlineRepl repl = new JlineRepl(session);
    repl.setInteractive(true);
    JLineAetherListener listener = new JLineAetherListener(repl.getReader());
    packageLoader.setTransferListener(listener);
    packageLoader.setPackageListener(listener);
    repl.run();
  }
  private void configureLogging() {
    Logger.getLogger("""").setLevel(Level.OFF);
  }
  private void evaluateFile(String fileName) throws Exception {
    File file = new File(fileName);
    evaluate(new FileInputStream(file));
  }
  private void evaluateExpression(String expression) throws Exception {
    evaluate(new ByteArrayInputStream(expression.getBytes()));
  }
  private void evaluate(InputStream in) throws Exception {
    UnsupportedTerminal term = new UnsupportedTerminal();
    ConsoleReader consoleReader = new ConsoleReader(in, System.out, term);
    JlineRepl repl = new JlineRepl(session, consoleReader);
    repl.setEcho(true);
    repl.setStopOnError(true);
    repl.setInteractive(false);
    try {
      repl.run();
    } catch(Exception e) {
      // Stack trace already printed by Repl
      System.err.println(""Execution halted"");
    } finally {
      if (threadPool != null && !threadPool.isShutdown()) {
        threadPool.shutdown();
      }
    }
  }
  public void initSession() throws Exception {
    threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    packageLoader = new AetherPackageLoader();
    this.session = new SessionBuilder()
        .setPackageLoader(packageLoader)
        .setExecutorService(threadPool)
        .withDefaultPackages()
        .build();
  }
}",class,
"public class OptionException extends RuntimeException {
  public OptionException(String message) {
    super(message);
  }
}",class,
"  public static void main(String[] args) throws Exception {
    if(args.length >= 1 && (args[0].equals(""build"") || args[0].equals(""install"")) ) {
      Builder.execute(args[0], Arrays.copyOfRange(args, 1, args.length));
      return;
    }
    OptionSet optionSet;
    try {
      optionSet = new OptionSet(args);
    } catch(OptionException e) {
      System.err.println(e.getMessage());
      OptionSet.printHelp(System.out);
      System.exit(-1);
      return;
    }
    if(optionSet.isHelpRequested()) {
      OptionSet.printHelp(System.out);
      System.exit(0);
    }
    // Set process-wide flags
    if(optionSet.isFlagSet(OptionSet.COMPILE_LOOPS)) {
      ForFunction.COMPILE_LOOPS = true;
    }
    try {
      new Main(optionSet).run();
    } finally {
      if(Profiler.ENABLED) {
        System.out.flush();
        Profiler.dumpTotalRunningTime();
        Profiler.dump(System.out);
      }
    }
  }",method,
"      if(Profiler.ENABLED) {
        System.out.flush();
        Profiler.dumpTotalRunningTime();
        Profiler.dump(System.out);
      }",method,
"  public Main(OptionSet options) {
    this.options = options;
  }",method,
"  public void run() {
    configureLogging();
    try {
      initSession();
      this.session.setCommandLineArguments(""renjin"", options.getArguments());
      if(options.isFlagSet(OptionSet.PROFILE)) {
        Profiler.ENABLED = true;
      }
      if(options.hasExpression()) {
        evaluateExpression(options.getExpression());
      } else if(options.hasFile()) {
        evaluateFile(options.getFile());
      } else {
        startInteractive();
      }
    } catch (Exception e) {
      e.printStackTrace();
      System.exit(-1);
    }
  }",method,
"  private void startInteractive() throws Exception {
    JlineRepl repl = new JlineRepl(session);
    repl.setInteractive(true);
    JLineAetherListener listener = new JLineAetherListener(repl.getReader());
    packageLoader.setTransferListener(listener);
    packageLoader.setPackageListener(listener);
    repl.run();
  }",method,
"  private void configureLogging() {
    Logger.getLogger("""").setLevel(Level.OFF);
  }",method,
"  private void evaluateFile(String fileName) throws Exception {
    File file = new File(fileName);
    evaluate(new FileInputStream(file));
  }",method,
"  private void evaluateExpression(String expression) throws Exception {
    evaluate(new ByteArrayInputStream(expression.getBytes()));
  }",method,
"  private void evaluate(InputStream in) throws Exception {
    UnsupportedTerminal term = new UnsupportedTerminal();
    ConsoleReader consoleReader = new ConsoleReader(in, System.out, term);
    JlineRepl repl = new JlineRepl(session, consoleReader);
    repl.setEcho(true);
    repl.setStopOnError(true);
    repl.setInteractive(false);
    try {
      repl.run();
    } catch(Exception e) {
      // Stack trace already printed by Repl
      System.err.println(""Execution halted"");
    } finally {
      if (threadPool != null && !threadPool.isShutdown()) {
        threadPool.shutdown();
      }
    }
  }",method,
"  public void initSession() throws Exception {
    threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    packageLoader = new AetherPackageLoader();
    this.session = new SessionBuilder()
        .setPackageLoader(packageLoader)
        .setExecutorService(threadPool)
        .withDefaultPackages()
        .build();
  }",method,
"  public OptionException(String message) {
    super(message);
  }",method,
"public class btConvexPointCloudShape extends btPolyhedralConvexAabbCachingShape {
	private long swigCPtr;
	protected btConvexPointCloudShape(final String className, long cPtr, boolean cMemoryOwn) {
		super(className, CollisionJNI.btConvexPointCloudShape_SWIGUpcast(cPtr), cMemoryOwn);
		swigCPtr = cPtr;
	}
	public btConvexPointCloudShape(long cPtr, boolean cMemoryOwn) {
		this(""btConvexPointCloudShape"", cPtr, cMemoryOwn);
		construct();
	}
	@Override
	protected void reset(long cPtr, boolean cMemoryOwn) {
		if (!destroyed)
			destroy();
		super.reset(CollisionJNI.btConvexPointCloudShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
	}
	public static long getCPtr(btConvexPointCloudShape obj) {
		return (obj == null) ? 0 : obj.swigCPtr;
	}
	@Override
	protected void finalize() throws Throwable {
		if (!destroyed)
			destroy();
		super.finalize();
	}
  @Override protected synchronized void delete() {
		if (swigCPtr != 0) {
			if (swigCMemOwn) {
				swigCMemOwn = false;
				CollisionJNI.delete_btConvexPointCloudShape(swigCPtr);
			}
			swigCPtr = 0;
		}
		super.delete();
	}
  public btConvexPointCloudShape() {
    this(CollisionJNI.new_btConvexPointCloudShape__SWIG_0(), true);
  }
  public btConvexPointCloudShape(btVector3 points, int numPoints, Vector3 localScaling, boolean computeAabb) {
    this(CollisionJNI.new_btConvexPointCloudShape__SWIG_1(btVector3.getCPtr(points), points, numPoints, localScaling, computeAabb), true);
  }
  public btConvexPointCloudShape(btVector3 points, int numPoints, Vector3 localScaling) {
    this(CollisionJNI.new_btConvexPointCloudShape__SWIG_2(btVector3.getCPtr(points), points, numPoints, localScaling), true);
  }
  public void setPoints(btVector3 points, int numPoints, boolean computeAabb, Vector3 localScaling) {
    CollisionJNI.btConvexPointCloudShape_setPoints__SWIG_0(swigCPtr, this, btVector3.getCPtr(points), points, numPoints, computeAabb, localScaling);
  }
  public void setPoints(btVector3 points, int numPoints, boolean computeAabb) {
    CollisionJNI.btConvexPointCloudShape_setPoints__SWIG_1(swigCPtr, this, btVector3.getCPtr(points), points, numPoints, computeAabb);
  }
  public void setPoints(btVector3 points, int numPoints) {
    CollisionJNI.btConvexPointCloudShape_setPoints__SWIG_2(swigCPtr, this, btVector3.getCPtr(points), points, numPoints);
  }
  public btVector3 getUnscaledPoints() {
    long cPtr = CollisionJNI.btConvexPointCloudShape_getUnscaledPoints__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new btVector3(cPtr, false);
  }
  public int getNumPoints() {
    return CollisionJNI.btConvexPointCloudShape_getNumPoints(swigCPtr, this);
  }
  public Vector3 getScaledPoint(int index) {
	return CollisionJNI.btConvexPointCloudShape_getScaledPoint(swigCPtr, this, index);
}
}",class,
"	protected btConvexPointCloudShape(final String className, long cPtr, boolean cMemoryOwn) {
		super(className, CollisionJNI.btConvexPointCloudShape_SWIGUpcast(cPtr), cMemoryOwn);
		swigCPtr = cPtr;
	}",method,
"	public btConvexPointCloudShape(long cPtr, boolean cMemoryOwn) {
		this(""btConvexPointCloudShape"", cPtr, cMemoryOwn);
		construct();
	}",method,
"	@Override
	protected void reset(long cPtr, boolean cMemoryOwn) {
		if (!destroyed)
			destroy();
		super.reset(CollisionJNI.btConvexPointCloudShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
	}",method,
"	public static long getCPtr(btConvexPointCloudShape obj) {
		return (obj == null) ? 0 : obj.swigCPtr;
	}",method,
"	@Override
	protected void finalize() throws Throwable {
		if (!destroyed)
			destroy();
		super.finalize();
	}",method,
"  @Override protected synchronized void delete() {
		if (swigCPtr != 0) {
			if (swigCMemOwn) {
				swigCMemOwn = false;
				CollisionJNI.delete_btConvexPointCloudShape(swigCPtr);
			}
			swigCPtr = 0;
		}",method,
"			if (swigCMemOwn) {
				swigCMemOwn = false;
				CollisionJNI.delete_btConvexPointCloudShape(swigCPtr);
			}",method,
"  public btConvexPointCloudShape() {
    this(CollisionJNI.new_btConvexPointCloudShape__SWIG_0(), true);
  }",method,
"  public btConvexPointCloudShape(btVector3 points, int numPoints, Vector3 localScaling, boolean computeAabb) {
    this(CollisionJNI.new_btConvexPointCloudShape__SWIG_1(btVector3.getCPtr(points), points, numPoints, localScaling, computeAabb), true);
  }",method,
"  public btConvexPointCloudShape(btVector3 points, int numPoints, Vector3 localScaling) {
    this(CollisionJNI.new_btConvexPointCloudShape__SWIG_2(btVector3.getCPtr(points), points, numPoints, localScaling), true);
  }",method,
"  public void setPoints(btVector3 points, int numPoints, boolean computeAabb, Vector3 localScaling) {
    CollisionJNI.btConvexPointCloudShape_setPoints__SWIG_0(swigCPtr, this, btVector3.getCPtr(points), points, numPoints, computeAabb, localScaling);
  }",method,
"  public void setPoints(btVector3 points, int numPoints, boolean computeAabb) {
    CollisionJNI.btConvexPointCloudShape_setPoints__SWIG_1(swigCPtr, this, btVector3.getCPtr(points), points, numPoints, computeAabb);
  }",method,
"  public void setPoints(btVector3 points, int numPoints) {
    CollisionJNI.btConvexPointCloudShape_setPoints__SWIG_2(swigCPtr, this, btVector3.getCPtr(points), points, numPoints);
  }",method,
"  public btVector3 getUnscaledPoints() {
    long cPtr = CollisionJNI.btConvexPointCloudShape_getUnscaledPoints__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new btVector3(cPtr, false);
  }",method,
"  public int getNumPoints() {
    return CollisionJNI.btConvexPointCloudShape_getNumPoints(swigCPtr, this);
  }",method,
"  public Vector3 getScaledPoint(int index) {
	return CollisionJNI.btConvexPointCloudShape_getScaledPoint(swigCPtr, this, index);
}",method,
"public class DomElementsProblemsHolderImpl implements DomElementsProblemsHolder {
  private final Map<DomElement, Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>>> myCachedErrors =
    ContainerUtil.newConcurrentMap();
  private final Map<DomElement, Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>>> myCachedChildrenErrors =
    ContainerUtil.newConcurrentMap();
  private final List<Annotation> myAnnotations = new ArrayList<>();
  private final Function<DomElement, List<DomElementProblemDescriptor>> myDomProblemsGetter =
    s -> {
      final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> map = myCachedErrors.get(s);
      return map != null ? ContainerUtil.concat(map.values()) : Collections.emptyList();
    };
  private final DomFileElement myElement;
  private static final Factory<Map<Class<? extends DomElementsInspection>,List<DomElementProblemDescriptor>>> CONCURRENT_HASH_MAP_FACTORY =
    () -> ContainerUtil.newConcurrentMap();
  private static final Factory<List<DomElementProblemDescriptor>> SMART_LIST_FACTORY = () -> new SmartList<>();
  private final Set<Class<? extends DomElementsInspection>> myPassedInspections = new THashSet<>();
  public DomElementsProblemsHolderImpl(final DomFileElement element) {
    myElement = element;
  }
  public final void appendProblems(final DomElementAnnotationHolderImpl holder, final Class<? extends DomElementsInspection> inspectionClass) {
    if (isInspectionCompleted(inspectionClass)) return;
    for (final DomElementProblemDescriptor descriptor : holder) {
      addProblem(descriptor, inspectionClass);
    }
    myAnnotations.addAll(holder.getAnnotations());
    myPassedInspections.add(inspectionClass);
  }
  @Override
  public final boolean isInspectionCompleted(@NotNull final DomElementsInspection inspection) {
    return isInspectionCompleted(inspection.getClass());
  }
  public final boolean isInspectionCompleted(final Class<? extends DomElementsInspection> inspectionClass) {
    synchronized (DomElementAnnotationsManagerImpl.LOCK) {
      return myPassedInspections.contains(inspectionClass);
    }
  }
  public final List<Annotation> getAnnotations() {
    return myAnnotations;
  }
  public final void addProblem(final DomElementProblemDescriptor descriptor, final Class<? extends DomElementsInspection> inspection) {
    ContainerUtil.getOrCreate(ContainerUtil.getOrCreate(myCachedErrors, descriptor.getDomElement(), CONCURRENT_HASH_MAP_FACTORY), inspection,
                              SMART_LIST_FACTORY).add(descriptor);
    myCachedChildrenErrors.clear();
  }
  @Override
  @NotNull
  public synchronized List<DomElementProblemDescriptor> getProblems(DomElement domElement) {
    if (domElement == null || !domElement.isValid()) return Collections.emptyList();
    return myDomProblemsGetter.fun(domElement);
  }
  @Override
  public List<DomElementProblemDescriptor> getProblems(final DomElement domElement, boolean includeXmlProblems) {
    return getProblems(domElement);
  }
  @Override
  public List<DomElementProblemDescriptor> getProblems(final DomElement domElement,
                                                       final boolean includeXmlProblems,
                                                       final boolean withChildren) {
    if (!withChildren || domElement == null || !domElement.isValid()) {
      return getProblems(domElement);
    }
    return ContainerUtil.concat(getProblemsMap(domElement).values());
  }
  @Override
  public List<DomElementProblemDescriptor> getProblems(DomElement domElement,
                                                       final boolean includeXmlProblems,
                                                       final boolean withChildren,
                                                       final HighlightSeverity minSeverity) {
    return getProblems(domElement, withChildren, minSeverity);
  }
  @Override
  public List<DomElementProblemDescriptor> getProblems(final DomElement domElement, final boolean withChildren, final HighlightSeverity minSeverity) {
    return ContainerUtil.findAll(getProblems(domElement, true, withChildren),
                                 object -> SeverityRegistrar.getSeverityRegistrar(domElement.getManager().getProject()).compare(object.getHighlightSeverity(), minSeverity) >= 0);
  }
  @NotNull
  private Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> getProblemsMap(final DomElement domElement) {
    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> map = myCachedChildrenErrors.get(domElement);
    if (map != null) {
      return map;
    }
    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> problems = new THashMap<>();
    if (domElement == myElement) {
      for (Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> listMap : myCachedErrors.values()) {
        mergeMaps(problems, listMap);
      }
    } else {
      mergeMaps(problems, myCachedErrors.get(domElement));
      if (DomUtil.hasXml(domElement)) {
        domElement.acceptChildren(new DomElementVisitor() {
          @Override
          public void visitDomElement(DomElement element) {
            mergeMaps(problems, getProblemsMap(element));
          }
        });
      }
    }
    myCachedChildrenErrors.put(domElement, problems);
    return problems;
  }
  private static <T> void mergeMaps(final Map<T, List<DomElementProblemDescriptor>> accumulator, @Nullable final Map<T, List<DomElementProblemDescriptor>> toAdd) {
    if (toAdd == null) return;
    for (final Map.Entry<T, List<DomElementProblemDescriptor>> entry : toAdd.entrySet()) {
      ContainerUtil.getOrCreate(accumulator, entry.getKey(), SMART_LIST_FACTORY).addAll(entry.getValue());
    }
  }
  @Override
  public List<DomElementProblemDescriptor> getAllProblems() {
    return getProblems(myElement, false, true);
  }
  @Override
  public List<DomElementProblemDescriptor> getAllProblems(@NotNull DomElementsInspection inspection) {
    if (!myElement.isValid()) {
      return Collections.emptyList();
    }
    final List<DomElementProblemDescriptor> list = getProblemsMap(myElement).get(inspection.getClass());
    return list != null ? new ArrayList<>(list) : Collections.emptyList();
  }
}",class,
"  public DomElementsProblemsHolderImpl(final DomFileElement element) {
    myElement = element;
  }",method,
"  public final void appendProblems(final DomElementAnnotationHolderImpl holder, final Class<? extends DomElementsInspection> inspectionClass) {
    if (isInspectionCompleted(inspectionClass)) return;
    for (final DomElementProblemDescriptor descriptor : holder) {
      addProblem(descriptor, inspectionClass);
    }
    myAnnotations.addAll(holder.getAnnotations());
    myPassedInspections.add(inspectionClass);
  }",method,
"    for (final DomElementProblemDescriptor descriptor : holder) {
      addProblem(descriptor, inspectionClass);
    }",method,
"  @Override
  public final boolean isInspectionCompleted(@NotNull final DomElementsInspection inspection) {
    return isInspectionCompleted(inspection.getClass());
  }",method,
"  public final boolean isInspectionCompleted(final Class<? extends DomElementsInspection> inspectionClass) {
    synchronized (DomElementAnnotationsManagerImpl.LOCK) {
      return myPassedInspections.contains(inspectionClass);
    }
  }",method,
"    synchronized (DomElementAnnotationsManagerImpl.LOCK) {
      return myPassedInspections.contains(inspectionClass);
    }",method,
"  public final List<Annotation> getAnnotations() {
    return myAnnotations;
  }",method,
"  public final void addProblem(final DomElementProblemDescriptor descriptor, final Class<? extends DomElementsInspection> inspection) {
    ContainerUtil.getOrCreate(ContainerUtil.getOrCreate(myCachedErrors, descriptor.getDomElement(), CONCURRENT_HASH_MAP_FACTORY), inspection,
                              SMART_LIST_FACTORY).add(descriptor);
    myCachedChildrenErrors.clear();
  }",method,
"  @Override
  @NotNull
  public synchronized List<DomElementProblemDescriptor> getProblems(DomElement domElement) {
    if (domElement == null || !domElement.isValid()) return Collections.emptyList();
    return myDomProblemsGetter.fun(domElement);
  }",method,
"  @Override
  public List<DomElementProblemDescriptor> getProblems(final DomElement domElement, boolean includeXmlProblems) {
    return getProblems(domElement);
  }",method,
"  @Override
  public List<DomElementProblemDescriptor> getProblems(final DomElement domElement,
                                                       final boolean includeXmlProblems,
                                                       final boolean withChildren) {
    if (!withChildren || domElement == null || !domElement.isValid()) {
      return getProblems(domElement);
    }
    return ContainerUtil.concat(getProblemsMap(domElement).values());
  }",method,
"  @Override
  public List<DomElementProblemDescriptor> getProblems(DomElement domElement,
                                                       final boolean includeXmlProblems,
                                                       final boolean withChildren,
                                                       final HighlightSeverity minSeverity) {
    return getProblems(domElement, withChildren, minSeverity);
  }",method,
"  @Override
  public List<DomElementProblemDescriptor> getProblems(final DomElement domElement, final boolean withChildren, final HighlightSeverity minSeverity) {
    return ContainerUtil.findAll(getProblems(domElement, true, withChildren),
                                 object -> SeverityRegistrar.getSeverityRegistrar(domElement.getManager().getProject()).compare(object.getHighlightSeverity(), minSeverity) >= 0);
  }",method,
"  @NotNull
  private Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> getProblemsMap(final DomElement domElement) {
    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> map = myCachedChildrenErrors.get(domElement);
    if (map != null) {
      return map;
    }
    final Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> problems = new THashMap<>();
    if (domElement == myElement) {
      for (Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> listMap : myCachedErrors.values()) {
        mergeMaps(problems, listMap);
      }
    } else {
      mergeMaps(problems, myCachedErrors.get(domElement));
      if (DomUtil.hasXml(domElement)) {
        domElement.acceptChildren(new DomElementVisitor() {
          @Override
          public void visitDomElement(DomElement element) {
            mergeMaps(problems, getProblemsMap(element));
          }
        });
      }
    }
    myCachedChildrenErrors.put(domElement, problems);
    return problems;
  }",method,
"    if (map != null) {
      return map;
    }",method,
"    if (domElement == myElement) {
      for (Map<Class<? extends DomElementsInspection>, List<DomElementProblemDescriptor>> listMap : myCachedErrors.values()) {
        mergeMaps(problems, listMap);
      }
    }",method,
"        domElement.acceptChildren(new DomElementVisitor() {
          @Override
          public void visitDomElement(DomElement element) {
            mergeMaps(problems, getProblemsMap(element));
          }
        }",method,
"          @Override
          public void visitDomElement(DomElement element) {
            mergeMaps(problems, getProblemsMap(element));
          }",method,
"  private static <T> void mergeMaps(final Map<T, List<DomElementProblemDescriptor>> accumulator, @Nullable final Map<T, List<DomElementProblemDescriptor>> toAdd) {
    if (toAdd == null) return;
    for (final Map.Entry<T, List<DomElementProblemDescriptor>> entry : toAdd.entrySet()) {
      ContainerUtil.getOrCreate(accumulator, entry.getKey(), SMART_LIST_FACTORY).addAll(entry.getValue());
    }
  }",method,
"  @Override
  public List<DomElementProblemDescriptor> getAllProblems() {
    return getProblems(myElement, false, true);
  }",method,
"  @Override
  public List<DomElementProblemDescriptor> getAllProblems(@NotNull DomElementsInspection inspection) {
    if (!myElement.isValid()) {
      return Collections.emptyList();
    }
    final List<DomElementProblemDescriptor> list = getProblemsMap(myElement).get(inspection.getClass());
    return list != null ? new ArrayList<>(list) : Collections.emptyList();
  }",method,
"public final class ClassLoaderSafeConnectorPageSinkProvider
        implements ConnectorPageSinkProvider
{
    private final ConnectorPageSinkProvider delegate;
    private final ClassLoader classLoader;
    public ClassLoaderSafeConnectorPageSinkProvider(ConnectorPageSinkProvider delegate, ClassLoader classLoader)
    {
        this.delegate = requireNonNull(delegate, ""delegate is null"");
        this.classLoader = requireNonNull(classLoader, ""classLoader is null"");
    }
    @Override
    public ConnectorPageSink createPageSink(ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorOutputTableHandle outputTableHandle)
    {
        try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {
            return new ClassLoaderSafeConnectorPageSink(delegate.createPageSink(transactionHandle, session, outputTableHandle), classLoader);
        }
    }
    @Override
    public ConnectorPageSink createPageSink(ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorInsertTableHandle insertTableHandle)
    {
        try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {
            return new ClassLoaderSafeConnectorPageSink(delegate.createPageSink(transactionHandle, session, insertTableHandle), classLoader);
        }
    }
}",class,
"    public ClassLoaderSafeConnectorPageSinkProvider(ConnectorPageSinkProvider delegate, ClassLoader classLoader)
    {
        this.delegate = requireNonNull(delegate, ""delegate is null"");
        this.classLoader = requireNonNull(classLoader, ""classLoader is null"");
    }",method,
"    @Override
    public ConnectorPageSink createPageSink(ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorOutputTableHandle outputTableHandle)
    {
        try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {
            return new ClassLoaderSafeConnectorPageSink(delegate.createPageSink(transactionHandle, session, outputTableHandle), classLoader);
        }
    }",method,
"    @Override
    public ConnectorPageSink createPageSink(ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorInsertTableHandle insertTableHandle)
    {
        try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {
            return new ClassLoaderSafeConnectorPageSink(delegate.createPageSink(transactionHandle, session, insertTableHandle), classLoader);
        }
    }",method,
"public class RentData implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    @OneToOne
    private CarData carData;
    @OneToOne
    private CustomerData customerData;
    private String startDate;
    private String endDate;
    private String serviceData;
    private String addressA;
    private String addressB;
    private String price;
    public RentData() {
    }
    public RentData(CarData carData, CustomerData customerData, String startDate, String endDate, String serviceData, String addressA, String addressB, String price) {
        this.carData = carData;
        this.customerData = customerData;
        this.startDate = startDate;
        this.endDate = endDate;
        this.serviceData = serviceData;
        this.addressA = addressA;
        this.addressB = addressB;
        this.price = price;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public CarData getCarData() {
        return carData;
    }
    public void setCarData(CarData carData) {
        this.carData = carData;
    }
    public CustomerData getCustomerData() {
        return customerData;
    }
    public void setCustomerData(CustomerData customerData) {
        this.customerData = customerData;
    }
    public String getStartDate() {
        return startDate;
    }
    public void setStartDate(String startDate) {
        this.startDate = startDate;
    }
    public String getEndDate() {
        return endDate;
    }
    public void setEndDate(String endDate) {
        this.endDate = endDate;
    }
    public String getServiceData() {
        return serviceData;
    }
    public void setServiceData(String serviceData) {
        this.serviceData = serviceData;
    }
    public String getAddressA() {
        return addressA;
    }
    public void setAddressA(String addressA) {
        this.addressA = addressA;
    }
    public String getAddressB() {
        return addressB;
    }
    public void setAddressB(String addressB) {
        this.addressB = addressB;
    }
    public String getPrice() {
        return price;
    }
    public void setPrice(String price) {
        this.price = price;
    }
}",class,
"    public RentData() {
    }",method,
"    public RentData(CarData carData, CustomerData customerData, String startDate, String endDate, String serviceData, String addressA, String addressB, String price) {
        this.carData = carData;
        this.customerData = customerData;
        this.startDate = startDate;
        this.endDate = endDate;
        this.serviceData = serviceData;
        this.addressA = addressA;
        this.addressB = addressB;
        this.price = price;
    }",method,
"    public int getId() {
        return id;
    }",method,
"    public void setId(int id) {
        this.id = id;
    }",method,
"    public CarData getCarData() {
        return carData;
    }",method,
"    public void setCarData(CarData carData) {
        this.carData = carData;
    }",method,
"    public CustomerData getCustomerData() {
        return customerData;
    }",method,
"    public void setCustomerData(CustomerData customerData) {
        this.customerData = customerData;
    }",method,
"    public String getStartDate() {
        return startDate;
    }",method,
"    public void setStartDate(String startDate) {
        this.startDate = startDate;
    }",method,

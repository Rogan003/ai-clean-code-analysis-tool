code_snippet,type,score
"  public AutoFitTextureView(final Context context, final AttributeSet attrs, final int defStyle) {
    super(context, attrs, defStyle);
  }",method,
"  public void setAspectRatio(final int width, final int height) {
    if (width < 0 || height < 0) {
      throw new IllegalArgumentException(""Size cannot be negative."");
    }
    ratioWidth = width;
    ratioHeight = height;
    requestLayout();
  }",method,
"    if (width < 0 || height < 0) {
      throw new IllegalArgumentException(""Size cannot be negative."");
    }",method,
"  @Override
  protected void onMeasure(final int widthMeasureSpec, final int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    final int width = MeasureSpec.getSize(widthMeasureSpec);
    final int height = MeasureSpec.getSize(heightMeasureSpec);
    if (0 == ratioWidth || 0 == ratioHeight) {
      setMeasuredDimension(width, height);
    } else {
      if (width < height * ratioWidth / ratioHeight) {
        setMeasuredDimension(width, width * ratioHeight / ratioWidth);
      } else {
        setMeasuredDimension(height * ratioWidth / ratioHeight, height);
      }
    }
  }",method,
"    if (0 == ratioWidth || 0 == ratioHeight) {
      setMeasuredDimension(width, height);
    }",method,
"      if (width < height * ratioWidth / ratioHeight) {
        setMeasuredDimension(width, width * ratioHeight / ratioWidth);
      }",method,
"public class JmsListenerEndpointRegistryTests {
	private final JmsListenerEndpointRegistry registry = new JmsListenerEndpointRegistry();
	private final JmsListenerContainerTestFactory containerFactory = new JmsListenerContainerTestFactory();
	@Rule
	public final ExpectedException thrown = ExpectedException.none();
	@Test
	public void createWithNullEndpoint() {
		thrown.expect(IllegalArgumentException.class);
		registry.registerListenerContainer(null, containerFactory);
	}
	@Test
	public void createWithNullEndpointId() {
		thrown.expect(IllegalArgumentException.class);
		registry.registerListenerContainer(new SimpleJmsListenerEndpoint(), containerFactory);
	}
	@Test
	public void createWithNullContainerFactory() {
		thrown.expect(IllegalArgumentException.class);
		registry.registerListenerContainer(createEndpoint(""foo"", ""myDestination""), null);
	}
	@Test
	public void createWithDuplicateEndpointId() {
		registry.registerListenerContainer(createEndpoint(""test"", ""queue""), containerFactory);
		thrown.expect(IllegalStateException.class);
		registry.registerListenerContainer(createEndpoint(""test"", ""queue""), containerFactory);
	}
	private SimpleJmsListenerEndpoint createEndpoint(String id, String destinationName) {
		SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
		endpoint.setId(id);
		endpoint.setDestination(destinationName);
		return endpoint;
	}
}",class,
"	@Test
	public void createWithNullEndpoint() {
		thrown.expect(IllegalArgumentException.class);
		registry.registerListenerContainer(null, containerFactory);
	}",method,
"	@Test
	public void createWithNullEndpointId() {
		thrown.expect(IllegalArgumentException.class);
		registry.registerListenerContainer(new SimpleJmsListenerEndpoint(), containerFactory);
	}",method,
"	@Test
	public void createWithNullContainerFactory() {
		thrown.expect(IllegalArgumentException.class);
		registry.registerListenerContainer(createEndpoint(""foo"", ""myDestination""), null);
	}",method,
"	@Test
	public void createWithDuplicateEndpointId() {
		registry.registerListenerContainer(createEndpoint(""test"", ""queue""), containerFactory);
		thrown.expect(IllegalStateException.class);
		registry.registerListenerContainer(createEndpoint(""test"", ""queue""), containerFactory);
	}",method,
"	private SimpleJmsListenerEndpoint createEndpoint(String id, String destinationName) {
		SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
		endpoint.setId(id);
		endpoint.setDestination(destinationName);
		return endpoint;
	}",method,
"public class AbstractQueueTest extends JSR166TestCase {
    // android-note: Removed because the CTS runner does a bad job of
    // retrying tests that have suite() declarations.
    //
    // public static void main(String[] args) {
    //     main(suite(), args);
    // }
    // public static Test suite() {
    //     return new TestSuite(AbstractQueueTest.class);
    // }
    static class Succeed extends AbstractQueue<Integer> {
        public boolean offer(Integer x) {
            if (x == null) throw new NullPointerException();
            return true;
        }
        public Integer peek() { return one; }
        public Integer poll() { return one; }
        public int size() { return 0; }
        public Iterator iterator() { return null; } // not needed
    }
    static class Fail extends AbstractQueue<Integer> {
        public boolean offer(Integer x) {
            if (x == null) throw new NullPointerException();
            return false;
        }
        public Integer peek() { return null; }
        public Integer poll() { return null; }
        public int size() { return 0; }
        public Iterator iterator() { return null; } // not needed
    }
    public void testAddS() {
        Succeed q = new Succeed();
        assertTrue(q.add(two));
    }
    public void testAddF() {
        Fail q = new Fail();
        try {
            q.add(one);
            shouldThrow();
        } catch (IllegalStateException success) {}
    }
    public void testAddNPE() {
        Succeed q = new Succeed();
        try {
            q.add(null);
            shouldThrow();
        } catch (NullPointerException success) {}
    }
    public void testRemoveS() {
        Succeed q = new Succeed();
        q.remove();
    }
    public void testRemoveF() {
        Fail q = new Fail();
        try {
            q.remove();
            shouldThrow();
        } catch (NoSuchElementException success) {}
    }
    public void testElementS() {
        Succeed q = new Succeed();
        q.element();
    }
    public void testElementF() {
        Fail q = new Fail();
        try {
            q.element();
            shouldThrow();
        } catch (NoSuchElementException success) {}
    }
    public void testAddAll1() {
        Succeed q = new Succeed();
        try {
            q.addAll(null);
            shouldThrow();
        } catch (NullPointerException success) {}
    }
    public void testAddAllSelf() {
        Succeed q = new Succeed();
        try {
            q.addAll(q);
            shouldThrow();
        } catch (IllegalArgumentException success) {}
    }
    public void testAddAll2() {
        Succeed q = new Succeed();
        Integer[] ints = new Integer[SIZE];
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (NullPointerException success) {}
    }
    public void testAddAll3() {
        Succeed q = new Succeed();
        Integer[] ints = new Integer[SIZE];
        for (int i = 0; i < SIZE - 1; ++i)
            ints[i] = new Integer(i);
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (NullPointerException success) {}
    }
    public void testAddAll4() {
        Fail q = new Fail();
        Integer[] ints = new Integer[SIZE];
        for (int i = 0; i < SIZE; ++i)
            ints[i] = new Integer(i);
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (IllegalStateException success) {}
    }
}",class,
"    static class Succeed extends AbstractQueue<Integer> {
        public boolean offer(Integer x) {
            if (x == null) throw new NullPointerException();
            return true;
        }
        public Integer peek() { return one; }
        public Integer poll() { return one; }
        public int size() { return 0; }
        public Iterator iterator() { return null; } // not needed
    }",class,
"    static class Fail extends AbstractQueue<Integer> {
        public boolean offer(Integer x) {
            if (x == null) throw new NullPointerException();
            return false;
        }
        public Integer peek() { return null; }
        public Integer poll() { return null; }
        public int size() { return 0; }
        public Iterator iterator() { return null; } // not needed
    }",class,
"        public boolean offer(Integer x) {
            if (x == null) throw new NullPointerException();
            return true;
        }",method,
        public Integer peek() { return one; },method,
        public Integer poll() { return one; },method,
        public int size() { return 0; },method,
        public Iterator iterator() { return null; },method,
"        public boolean offer(Integer x) {
            if (x == null) throw new NullPointerException();
            return false;
        }",method,
        public Integer peek() { return null; },method,
        public Integer poll() { return null; },method,
        public int size() { return 0; },method,
        public Iterator iterator() { return null; },method,
"    public void testAddS() {
        Succeed q = new Succeed();
        assertTrue(q.add(two));
    }",method,
"    public void testAddF() {
        Fail q = new Fail();
        try {
            q.add(one);
            shouldThrow();
        } catch (IllegalStateException success) {}
    }",method,
"    public void testAddNPE() {
        Succeed q = new Succeed();
        try {
            q.add(null);
            shouldThrow();
        } catch (NullPointerException success) {}
    }",method,
"    public void testRemoveS() {
        Succeed q = new Succeed();
        q.remove();
    }",method,
"    public void testRemoveF() {
        Fail q = new Fail();
        try {
            q.remove();
            shouldThrow();
        } catch (NoSuchElementException success) {}
    }",method,
"    public void testElementS() {
        Succeed q = new Succeed();
        q.element();
    }",method,
"    public void testElementF() {
        Fail q = new Fail();
        try {
            q.element();
            shouldThrow();
        } catch (NoSuchElementException success) {}
    }",method,
"    public void testAddAll1() {
        Succeed q = new Succeed();
        try {
            q.addAll(null);
            shouldThrow();
        } catch (NullPointerException success) {}
    }",method,
"    public void testAddAllSelf() {
        Succeed q = new Succeed();
        try {
            q.addAll(q);
            shouldThrow();
        } catch (IllegalArgumentException success) {}
    }",method,
"    public void testAddAll2() {
        Succeed q = new Succeed();
        Integer[] ints = new Integer[SIZE];
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (NullPointerException success) {}
    }",method,
"    public void testAddAll3() {
        Succeed q = new Succeed();
        Integer[] ints = new Integer[SIZE];
        for (int i = 0; i < SIZE - 1; ++i)
            ints[i] = new Integer(i);
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (NullPointerException success) {}
    }",method,
"    public void testAddAll4() {
        Fail q = new Fail();
        Integer[] ints = new Integer[SIZE];
        for (int i = 0; i < SIZE; ++i)
            ints[i] = new Integer(i);
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (IllegalStateException success) {}
    }",method,
"public abstract class AbstractListenerWriteFlushProcessor<T> implements Processor<Publisher<? extends T>, Void> {
	protected final Log logger = LogFactory.getLog(getClass());
	private final WriteResultPublisher resultPublisher = new WriteResultPublisher();
	private final AtomicReference<State> state = new AtomicReference<>(State.UNSUBSCRIBED);
	private volatile boolean subscriberCompleted;
	@Nullable
	private Subscription subscription;
	// Subscriber implementation...
	@Override
	public final void onSubscribe(Subscription subscription) {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onSubscribe: "" + subscription);
		}
		this.state.get().onSubscribe(this, subscription);
	}
	@Override
	public final void onNext(Publisher<? extends T> publisher) {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onNext: "" + publisher);
		}
		this.state.get().onNext(this, publisher);
	}
	@Override
	public final void onError(Throwable t) {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onError: "" + t);
		}
		this.state.get().onError(this, t);
	}
	@Override
	public final void onComplete() {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onComplete"");
		}
		this.state.get().onComplete(this);
	}
	// Publisher implementation...
	@Override
	public final void subscribe(Subscriber<? super Void> subscriber) {
		this.resultPublisher.subscribe(subscriber);
	}
	protected void cancel() {
		if (this.subscription != null) {
			this.subscription.cancel();
		}
	}
	protected void flushingFailed(Throwable t) {
	}
	protected abstract Processor<? super T, Void> createWriteProcessor();
	protected abstract void flush() throws IOException;
	protected abstract boolean isWritePossible();
	protected abstract boolean isFlushPending();
	protected final void onFlushPossible() {
		this.state.get().onFlushPossible(this);
	}
	private void flushIfPossible() {
		if (isWritePossible()) {
			onFlushPossible();
		}
	}
	private boolean changeState(State oldState, State newState) {
		return this.state.compareAndSet(oldState, newState);
	}
	private void writeComplete() {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" writeComplete"");
		}
		this.state.get().writeComplete(this);
	}
	private enum State {
		UNSUBSCRIBED {
			@Override
			public <T> void onSubscribe(AbstractListenerWriteFlushProcessor<T> processor, Subscription subscription) {
				Assert.notNull(subscription, ""Subscription must not be null"");
				if (processor.changeState(this, REQUESTED)) {
					processor.subscription = subscription;
					subscription.request(1);
				}
				else {
					super.onSubscribe(processor, subscription);
				}
			}
		},
		REQUESTED {
			@Override
			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> chunk) {
				if (processor.changeState(this, RECEIVED)) {
					Processor<? super T, Void> chunkProcessor = processor.createWriteProcessor();
					chunk.subscribe(chunkProcessor);
					chunkProcessor.subscribe(new WriteSubscriber(processor));
				}
			}
			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				if (processor.changeState(this, COMPLETED)) {
					processor.resultPublisher.publishComplete();
				}
			}
		},
		RECEIVED {
			@Override
			public <T> void writeComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				try {
					processor.flush();
				}
				catch (IOException ex) {
					processor.flushingFailed(ex);
					return;
				}
				if (processor.subscriberCompleted) {
					if (processor.isFlushPending()) {
						// Ensure the final flush
						processor.changeState(this, FLUSHING);
						processor.flushIfPossible();
					}
					else if (processor.changeState(this, COMPLETED)) {
						processor.resultPublisher.publishComplete();
					}
				}
				else {
					if (processor.changeState(this, REQUESTED)) {
						Assert.state(processor.subscription != null, ""No subscription"");
						processor.subscription.request(1);
					}
				}
			}
			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				processor.subscriberCompleted = true;
			}
		},
		FLUSHING {
			public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {
				try {
					processor.flush();
				}
				catch (IOException ex) {
					processor.flushingFailed(ex);
					return;
				}
				if (processor.changeState(this, COMPLETED)) {
					processor.resultPublisher.publishComplete();
				}
			}
			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {
				// ignore
			}
			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				// ignore
			}
		},
		COMPLETED {
			@Override
			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {
				// ignore
			}
			@Override
			public <T> void onError(AbstractListenerWriteFlushProcessor<T> processor, Throwable t) {
				// ignore
			}
			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				// ignore
			}
		};
		public <T> void onSubscribe(AbstractListenerWriteFlushProcessor<T> processor, Subscription subscription) {
			subscription.cancel();
		}
		public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {
			throw new IllegalStateException(toString());
		}
		public <T> void onError(AbstractListenerWriteFlushProcessor<T> processor, Throwable ex) {
			if (processor.changeState(this, COMPLETED)) {
				processor.resultPublisher.publishError(ex);
			}
		}
		public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
			throw new IllegalStateException(toString());
		}
		public <T> void writeComplete(AbstractListenerWriteFlushProcessor<T> processor) {
			// ignore
		}
		public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {
			// ignore
		}
		private static class WriteSubscriber implements Subscriber<Void> {
			private final AbstractListenerWriteFlushProcessor<?> processor;
			public WriteSubscriber(AbstractListenerWriteFlushProcessor<?> processor) {
				this.processor = processor;
			}
			@Override
			public void onSubscribe(Subscription subscription) {
				subscription.request(Long.MAX_VALUE);
			}
			@Override
			public void onNext(Void aVoid) {
			}
			@Override
			public void onError(Throwable ex) {
				this.processor.cancel();
				this.processor.onError(ex);
			}
			@Override
			public void onComplete() {
				this.processor.writeComplete();
			}
		}
	}
}",class,
"		private static class WriteSubscriber implements Subscriber<Void> {
			private final AbstractListenerWriteFlushProcessor<?> processor;
			public WriteSubscriber(AbstractListenerWriteFlushProcessor<?> processor) {
				this.processor = processor;
			}
			@Override
			public void onSubscribe(Subscription subscription) {
				subscription.request(Long.MAX_VALUE);
			}
			@Override
			public void onNext(Void aVoid) {
			}
			@Override
			public void onError(Throwable ex) {
				this.processor.cancel();
				this.processor.onError(ex);
			}
			@Override
			public void onComplete() {
				this.processor.writeComplete();
			}
		}",class,
"	@Override
	public final void onSubscribe(Subscription subscription) {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onSubscribe: "" + subscription);
		}
		this.state.get().onSubscribe(this, subscription);
	}",method,
"	@Override
	public final void onNext(Publisher<? extends T> publisher) {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onNext: "" + publisher);
		}
		this.state.get().onNext(this, publisher);
	}",method,
"	@Override
	public final void onError(Throwable t) {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onError: "" + t);
		}
		this.state.get().onError(this, t);
	}",method,
"	@Override
	public final void onComplete() {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" onComplete"");
		}
		this.state.get().onComplete(this);
	}",method,
"	@Override
	public final void subscribe(Subscriber<? super Void> subscriber) {
		this.resultPublisher.subscribe(subscriber);
	}",method,
"	protected void cancel() {
		if (this.subscription != null) {
			this.subscription.cancel();
		}
	}",method,
"		if (this.subscription != null) {
			this.subscription.cancel();
		}",method,
"	protected void flushingFailed(Throwable t) {
	}",method,
"	protected final void onFlushPossible() {
		this.state.get().onFlushPossible(this);
	}",method,
"	private void flushIfPossible() {
		if (isWritePossible()) {
			onFlushPossible();
		}
	}",method,
"	private boolean changeState(State oldState, State newState) {
		return this.state.compareAndSet(oldState, newState);
	}",method,
"	private void writeComplete() {
		if (logger.isTraceEnabled()) {
			logger.trace(this.state + "" writeComplete"");
		}
		this.state.get().writeComplete(this);
	}",method,
"			@Override
			public <T> void onSubscribe(AbstractListenerWriteFlushProcessor<T> processor, Subscription subscription) {
				Assert.notNull(subscription, ""Subscription must not be null"");
				if (processor.changeState(this, REQUESTED)) {
					processor.subscription = subscription;
					subscription.request(1);
				}
				else {
					super.onSubscribe(processor, subscription);
				}
			}",method,
"			@Override
			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> chunk) {
				if (processor.changeState(this, RECEIVED)) {
					Processor<? super T, Void> chunkProcessor = processor.createWriteProcessor();
					chunk.subscribe(chunkProcessor);
					chunkProcessor.subscribe(new WriteSubscriber(processor));
				}
			}",method,
"			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				if (processor.changeState(this, COMPLETED)) {
					processor.resultPublisher.publishComplete();
				}
			}",method,
"			@Override
			public <T> void writeComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				try {
					processor.flush();
				}
				catch (IOException ex) {
					processor.flushingFailed(ex);
					return;
				}
				if (processor.subscriberCompleted) {
					if (processor.isFlushPending()) {
						// Ensure the final flush
						processor.changeState(this, FLUSHING);
						processor.flushIfPossible();
					}
					else if (processor.changeState(this, COMPLETED)) {
						processor.resultPublisher.publishComplete();
					}
				}
				else {
					if (processor.changeState(this, REQUESTED)) {
						Assert.state(processor.subscription != null, ""No subscription"");
						processor.subscription.request(1);
					}
				}
			}",method,
"				catch (IOException ex) {
					processor.flushingFailed(ex);
					return;
				}",method,
"				if (processor.subscriberCompleted) {
					if (processor.isFlushPending()) {
						// Ensure the final flush
						processor.changeState(this, FLUSHING);
						processor.flushIfPossible();
					}
					else if (processor.changeState(this, COMPLETED)) {
						processor.resultPublisher.publishComplete();
					}
				}",method,
"			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				processor.subscriberCompleted = true;
			}",method,
"			public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {
				try {
					processor.flush();
				}
				catch (IOException ex) {
					processor.flushingFailed(ex);
					return;
				}
				if (processor.changeState(this, COMPLETED)) {
					processor.resultPublisher.publishComplete();
				}
			}",method,
"				catch (IOException ex) {
					processor.flushingFailed(ex);
					return;
				}",method,
"			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {
				// ignore
			}",method,
"			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				// ignore
			}",method,
"			@Override
			public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {
				// ignore
			}",method,
"			@Override
			public <T> void onError(AbstractListenerWriteFlushProcessor<T> processor, Throwable t) {
				// ignore
			}",method,
"			@Override
			public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
				// ignore
			}",method,
"		public <T> void onSubscribe(AbstractListenerWriteFlushProcessor<T> processor, Subscription subscription) {
			subscription.cancel();
		}",method,
"		public <T> void onNext(AbstractListenerWriteFlushProcessor<T> processor, Publisher<? extends T> publisher) {
			throw new IllegalStateException(toString());
		}",method,
"		public <T> void onError(AbstractListenerWriteFlushProcessor<T> processor, Throwable ex) {
			if (processor.changeState(this, COMPLETED)) {
				processor.resultPublisher.publishError(ex);
			}
		}",method,
"		public <T> void onComplete(AbstractListenerWriteFlushProcessor<T> processor) {
			throw new IllegalStateException(toString());
		}",method,
"		public <T> void writeComplete(AbstractListenerWriteFlushProcessor<T> processor) {
			// ignore
		}",method,
"		public <T> void onFlushPossible(AbstractListenerWriteFlushProcessor<T> processor) {
			// ignore
		}",method,
"			public WriteSubscriber(AbstractListenerWriteFlushProcessor<?> processor) {
				this.processor = processor;
			}",method,
"			@Override
			public void onSubscribe(Subscription subscription) {
				subscription.request(Long.MAX_VALUE);
			}",method,
"			@Override
			public void onNext(Void aVoid) {
			}",method,
"			@Override
			public void onError(Throwable ex) {
				this.processor.cancel();
				this.processor.onError(ex);
			}",method,
"			@Override
			public void onComplete() {
				this.processor.writeComplete();
			}",method,
"public class WebSocketServerHandshaker07 extends WebSocketServerHandshaker {
    public static final String WEBSOCKET_07_ACCEPT_GUID = ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"";
    private final boolean allowExtensions;
    private final boolean allowMaskMismatch;
    public WebSocketServerHandshaker07(
            String webSocketURL, String subprotocols, boolean allowExtensions, int maxFramePayloadLength) {
        this(webSocketURL, subprotocols, allowExtensions, maxFramePayloadLength, false);
    }
    public WebSocketServerHandshaker07(
            String webSocketURL, String subprotocols, boolean allowExtensions, int maxFramePayloadLength,
            boolean allowMaskMismatch) {
        super(WebSocketVersion.V07, webSocketURL, subprotocols, maxFramePayloadLength);
        this.allowExtensions = allowExtensions;
        this.allowMaskMismatch = allowMaskMismatch;
    }
    @Override
    protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders headers) {
        FullHttpResponse res =
                new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS);
        if (headers != null) {
            res.headers().add(headers);
        }
        CharSequence key = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_KEY);
        if (key == null) {
            throw new WebSocketHandshakeException(""not a WebSocket request: missing key"");
        }
        String acceptSeed = key + WEBSOCKET_07_ACCEPT_GUID;
        byte[] sha1 = WebSocketUtil.sha1(acceptSeed.getBytes(CharsetUtil.US_ASCII));
        String accept = WebSocketUtil.base64(sha1);
        if (logger.isDebugEnabled()) {
            logger.debug(""WebSocket version 07 server handshake key: {}, response: {}."", key, accept);
        }
        res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
        res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
        res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
        String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
        if (subprotocols != null) {
            String selectedSubprotocol = selectSubprotocol(subprotocols);
            if (selectedSubprotocol == null) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Requested subprotocol(s) not supported: {}"", subprotocols);
                }
            } else {
                res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
            }
        }
        return res;
    }
    @Override
    protected WebSocketFrameDecoder newWebsocketDecoder() {
        return new WebSocket07FrameDecoder(true, allowExtensions, maxFramePayloadLength(), allowMaskMismatch);
    }
    @Override
    protected WebSocketFrameEncoder newWebSocketEncoder() {
        return new WebSocket07FrameEncoder(false);
    }
}",class,
"    public WebSocketServerHandshaker07(
            String webSocketURL, String subprotocols, boolean allowExtensions, int maxFramePayloadLength) {
        this(webSocketURL, subprotocols, allowExtensions, maxFramePayloadLength, false);
    }",method,
"    public WebSocketServerHandshaker07(
            String webSocketURL, String subprotocols, boolean allowExtensions, int maxFramePayloadLength,
            boolean allowMaskMismatch) {
        super(WebSocketVersion.V07, webSocketURL, subprotocols, maxFramePayloadLength);
        this.allowExtensions = allowExtensions;
        this.allowMaskMismatch = allowMaskMismatch;
    }",method,
"    @Override
    protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders headers) {
        FullHttpResponse res =
                new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS);
        if (headers != null) {
            res.headers().add(headers);
        }
        CharSequence key = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_KEY);
        if (key == null) {
            throw new WebSocketHandshakeException(""not a WebSocket request: missing key"");
        }
        String acceptSeed = key + WEBSOCKET_07_ACCEPT_GUID;
        byte[] sha1 = WebSocketUtil.sha1(acceptSeed.getBytes(CharsetUtil.US_ASCII));
        String accept = WebSocketUtil.base64(sha1);
        if (logger.isDebugEnabled()) {
            logger.debug(""WebSocket version 07 server handshake key: {}, response: {}."", key, accept);
        }
        res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
        res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
        res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
        String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
        if (subprotocols != null) {
            String selectedSubprotocol = selectSubprotocol(subprotocols);
            if (selectedSubprotocol == null) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Requested subprotocol(s) not supported: {}"", subprotocols);
                }
            } else {
                res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
            }
        }
        return res;
    }",method,
"        if (headers != null) {
            res.headers().add(headers);
        }",method,
"        if (key == null) {
            throw new WebSocketHandshakeException(""not a WebSocket request: missing key"");
        }",method,
"        if (subprotocols != null) {
            String selectedSubprotocol = selectSubprotocol(subprotocols);
            if (selectedSubprotocol == null) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Requested subprotocol(s) not supported: {}"", subprotocols);
                }
            } else {
                res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
            }
        }",method,
"            if (selectedSubprotocol == null) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Requested subprotocol(s) not supported: {}"", subprotocols);
                }
            }",method,
"    @Override
    protected WebSocketFrameDecoder newWebsocketDecoder() {
        return new WebSocket07FrameDecoder(true, allowExtensions, maxFramePayloadLength(), allowMaskMismatch);
    }",method,
"    @Override
    protected WebSocketFrameEncoder newWebSocketEncoder() {
        return new WebSocket07FrameEncoder(false);
    }",method,
"public class TestTryCatch extends AbstractTest {
	private static boolean exc(Object obj) throws Exception {
		if (obj == null) {
			throw new Exception(""test"");
		}
		return (obj instanceof Object);
	}
	private static boolean exc2(Object obj) throws IOException {
		if (obj == null) {
			throw new IOException();
		}
		return true;
	}
	private static boolean test0(Object obj) {
		try {
			synchronized (obj) {
				obj.wait(5);
			}
		} catch (InterruptedException e) {
			return false;
		}
		return true;
	}
	private static boolean test1(Object obj) {
		boolean res = false;
		try {
			res = exc(obj);
		} catch (Exception e) {
			return false;
		}
		return res;
	}
	private static boolean test2(Object obj) {
		try {
			return exc(obj);
		} catch (Exception e) {
			if (obj != null) {
				return true;
			} else {
				return false;
			}
		}
	}
	private static boolean test3(Object obj) {
		boolean res = false;
		try {
			res = exc(obj);
		} catch (Exception e) {
			res = false;
		} finally {
			test0(obj);
		}
		return res;
	}
	private static String test4(Object obj) {
		String res = ""good"";
		try {
			res += exc(obj);
			exc2(""a"");
		} catch (IOException e) {
			res = ""io exc"";
		} catch (Exception e) {
			res = ""exc"";
		}
		return res;
	}
	private static String test5(Object obj) {
		String res = ""good"";
		try {
			res = """" + exc(obj);
			boolean f = exc2(""a"");
			if (!f) {
				res = ""f == false"";
			}
		} catch (Exception e) {
			res = ""exc"";
		}
		return res;
	}
	private static boolean test6(Object obj) {
		boolean res = false;
		while (true) {
			try {
				res = exc2(obj);
				return res;
			} catch (IOException e) {
				res = true;
			} catch (Throwable e) {
				if (obj == null) {
					obj = new Object();
				}
			}
		}
	}
	private static boolean test7() {
		boolean res = false;
		Object obj = null;
		while (true) {
			try {
				res = exc2(obj);
				return res;
			} catch (IOException e) {
				res = true;
				obj = new Object();
			} catch (Throwable e) {
				if (obj == null) {
					res = false;
				}
			}
		}
	}
	private boolean test8(Object obj) {
		this.mDiscovering = false;
		try {
			exc(obj);
		} catch (Exception e) {
			e.toString();
		} finally {
			mDiscovering = true;
		}
		return mDiscovering;
	}
	private boolean test8a(Object obj) {
		this.mDiscovering = false;
		try {
			exc(obj);
		} catch (Exception e) {
			e.toString();
		} finally {
			if (!mDiscovering) {
				mDiscovering = true;
			}
		}
		return mDiscovering;
	}
	private static boolean testSynchronize(Object obj) throws InterruptedException {
		synchronized (obj) {
			if (obj instanceof String) {
				return false;
			}
			obj.wait(5);
		}
		return true;
	}
	// TODO: remove 'synchronized(TestTryCatch.class)' block in decompiled version
	private synchronized static boolean testSynchronize2(Object obj) throws InterruptedException {
		return obj.toString() != null;
	}
	public Object mObject = new Object();
	public boolean mDiscovering = true;
	private boolean testSynchronize3() {
		boolean b = false;
		synchronized (mObject) {
			b = this.mDiscovering;
		}
		return b;
	}
	public int catchInLoop(int i, int j) {
		while (true) {
			try {
				while (i < j) {
					i = j++ / i;
				}
			} catch (RuntimeException e) {
				i = 10;
				continue;
			}
			break;
		}
		return j;
	}
	@Override
	public boolean testRun() throws Exception {
		Object obj = new Object();
		assertTrue(test0(obj));
		assertTrue(test1(obj));
		assertTrue(test2(obj));
		assertTrue(test3(obj));
		assertTrue(test4(obj) != null);
		assertTrue(test5(null) != null);
		assertTrue(test6(obj));
		assertTrue(test7());
		assertTrue(testSynchronize(obj));
		assertFalse(testSynchronize(""str""));
		assertTrue(testSynchronize2(""str""));
		assertTrue(testSynchronize3());
		assertTrue(test8(""a""));
		assertTrue(test8(null));
		assertTrue(test8a(""a""));
		assertTrue(test8a(null));
		assertEquals(catchInLoop(1, 0), 0);
		assertEquals(catchInLoop(0, 1), 2);
		assertEquals(catchInLoop(788, 100), 100);
		return true;
	}
	public static void main(String[] args) throws Exception {
		new TestTryCatch().testRun();
	}
}",class,
"public class TestTypeResolver extends AbstractTest {
	private final int f1;
	public TestTypeResolver() {
		this.f1 = 2;
	}
	public TestTypeResolver(int b1, int b2) {
		// test 'this' move and constructor invocation on moved register
		this(b1, b2, 0, 0, 0);
	}
	public TestTypeResolver(int a1, int a2, int a3, int a4, int a5) {
		this.f1 = a1;
	}
	public static class TestTernaryInSuper extends TestTypeResolver {
		public TestTernaryInSuper(int c) {
//			super(c > 0 ? c : -c, 1);
		}
	}
	// public static Object testVarsPropagation(int a) {
	// Object b = new Exception();
	// if (a == 5)
	// b = 1;
	// return b;
	// }
	//
	// public Object testMoveThis(int a) {
	// TestTypeResolver t = this;
	// if (a == 0)
	// return t;
	//
	// return t.testMoveThis(--a);
	// }
	@Override
	public boolean testRun() throws Exception {
		// assertTrue((Integer) testVarsPropagation(5) == 1);
		// assertTrue(testVarsPropagation(1).getClass() == Exception.class);
		//
		// assertTrue(testMoveThis(f1) == this);
		return true;
	}
	public static void main(String[] args) throws Exception {
		new TestTypeResolver().testRun();
	}
}",class,
"	public static class TestTernaryInSuper extends TestTypeResolver {
		public TestTernaryInSuper(int c) {
//			super(c > 0 ? c : -c, 1);
		}
	}",class,
"public class TestTypeResolver2 extends AbstractTest {
	private static String result = """";
	public void testOverloadedMethods() {
		Object s1 = ""The"";
		Object s2 = ""answer"";
		doPrint((Object) ""You should know:"");
		for (int i = 0; i < 2; i++) {
			doPrint(s1);
			doPrint(s2);
			s1 = ""is"";
			s2 = new Integer(42);
		}
	}
	private static void doPrint(String s1) {
		fail();
	}
	private static void doPrint(Integer s1) {
		fail();
	}
	private static void doPrint(Object s1) {
		// correct call
		result += s1 + "" "";
	}
	@Override
	public boolean testRun() throws Exception {
		testOverloadedMethods();
		assertEquals(result, ""You should know: The answer is 42 "");
		return true;
	}
	public static void main(String[] args) throws Exception {
		(new TestTypeResolver2()).testRun();
	}
}",class,
"	private static boolean exc(Object obj) throws Exception {
		if (obj == null) {
			throw new Exception(""test"");
		}
		return (obj instanceof Object);
	}",method,
"		if (obj == null) {
			throw new Exception(""test"");
		}",method,
"	private static boolean exc2(Object obj) throws IOException {
		if (obj == null) {
			throw new IOException();
		}
		return true;
	}",method,
"		if (obj == null) {
			throw new IOException();
		}",method,
"	private static boolean test0(Object obj) {
		try {
			synchronized (obj) {
				obj.wait(5);
			}
		} catch (InterruptedException e) {
			return false;
		}
		return true;
	}",method,
"			synchronized (obj) {
				obj.wait(5);
			}",method,
"	private static boolean test1(Object obj) {
		boolean res = false;
		try {
			res = exc(obj);
		} catch (Exception e) {
			return false;
		}
		return res;
	}",method,
"	private static boolean test2(Object obj) {
		try {
			return exc(obj);
		} catch (Exception e) {
			if (obj != null) {
				return true;
			} else {
				return false;
			}
		}
	}",method,
"			if (obj != null) {
				return true;
			}",method,
"	private static boolean test3(Object obj) {
		boolean res = false;
		try {
			res = exc(obj);
		} catch (Exception e) {
			res = false;
		} finally {
			test0(obj);
		}
		return res;
	}",method,
"	private static String test4(Object obj) {
		String res = ""good"";
		try {
			res += exc(obj);
			exc2(""a"");
		} catch (IOException e) {
			res = ""io exc"";
		} catch (Exception e) {
			res = ""exc"";
		}
		return res;
	}",method,

code_snippet,type,score
"        @Override
        public NativeModule get() {
          return new DatePickerDialogModule(context);
        }",method,
"      new ModuleSpec(DialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new DialogModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new DialogModule(context);
        }",method,
"      new ModuleSpec(FrescoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new FrescoModule(context, true, mConfig != null ? mConfig.getFrescoConfig() : null);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new FrescoModule(context, true, mConfig != null ? mConfig.getFrescoConfig() : null);
        }",method,
"      new ModuleSpec(I18nManagerModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new I18nManagerModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new I18nManagerModule(context);
        }",method,
"      new ModuleSpec(ImageEditingManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageEditingManager(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new ImageEditingManager(context);
        }",method,
"      new ModuleSpec(ImageLoaderModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageLoaderModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new ImageLoaderModule(context);
        }",method,
"      new ModuleSpec(ImageStoreManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageStoreManager(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new ImageStoreManager(context);
        }",method,
"      new ModuleSpec(IntentModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new IntentModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new IntentModule(context);
        }",method,
"      new ModuleSpec(LocationModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new LocationModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new LocationModule(context);
        }",method,
"      new ModuleSpec(NativeAnimatedModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NativeAnimatedModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new NativeAnimatedModule(context);
        }",method,
"      new ModuleSpec(NetworkingModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NetworkingModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new NetworkingModule(context);
        }",method,
"      new ModuleSpec(NetInfoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NetInfoModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new NetInfoModule(context);
        }",method,
"      new ModuleSpec(PermissionsModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new PermissionsModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new PermissionsModule(context);
        }",method,
"      new ModuleSpec(ShareModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ShareModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new ShareModule(context);
        }",method,
"      new ModuleSpec(StatusBarModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new StatusBarModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new StatusBarModule(context);
        }",method,
"      new ModuleSpec(TimePickerDialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new TimePickerDialogModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new TimePickerDialogModule(context);
        }",method,
"      new ModuleSpec(ToastModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ToastModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new ToastModule(context);
        }",method,
"      new ModuleSpec(VibrationModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new VibrationModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new VibrationModule(context);
        }",method,
"      new ModuleSpec(WebSocketModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new WebSocketModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new WebSocketModule(context);
        }",method,
"  @Override
  public List<Class<? extends JavaScriptModule>> createJSModules() {
    return Collections.emptyList();
  }",method,
"  @Override
  public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
    List<ViewManager> viewManagers = new ArrayList<>();
    viewManagers.add(ARTRenderableViewManager.createARTGroupViewManager());
    viewManagers.add(ARTRenderableViewManager.createARTShapeViewManager());
    viewManagers.add(ARTRenderableViewManager.createARTTextViewManager());
    viewManagers.add(new ReactDialogPickerManager());
    viewManagers.add(new ReactDrawerLayoutManager());
    viewManagers.add(new ReactDropdownPickerManager());
    viewManagers.add(new ReactHorizontalScrollViewManager());
    viewManagers.add(new ReactProgressBarViewManager());
    viewManagers.add(new ReactScrollViewManager());
    viewManagers.add(new ReactSliderManager());
    viewManagers.add(new ReactSwitchManager());
    viewManagers.add(new ReactToolbarManager());
    viewManagers.add(new ReactWebViewManager());
    viewManagers.add(new SwipeRefreshLayoutManager());
    SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(reactContext);
    boolean useFlatUi = preferences.getBoolean(""flat_uiimplementation"", false);
    if (useFlatUi) {
      // Flat managers
      viewManagers.add(new FlatARTSurfaceViewManager());
      viewManagers.add(new RCTTextInlineImageManager());
      viewManagers.add(new RCTImageViewManager());
      viewManagers.add(new RCTModalHostManager());
      viewManagers.add(new RCTRawTextManager());
      viewManagers.add(new RCTTextInputManager());
      viewManagers.add(new RCTTextManager());
      viewManagers.add(new RCTViewManager());
      viewManagers.add(new RCTViewPagerManager());
      viewManagers.add(new RCTVirtualTextManager());
    } else {
      // Native equivalents
      viewManagers.add(new ARTSurfaceViewManager());
      viewManagers.add(new FrescoBasedReactTextInlineImageViewManager());
      viewManagers.add(new ReactImageManager());
      viewManagers.add(new ReactModalHostManager());
      viewManagers.add(new ReactRawTextManager());
      viewManagers.add(new ReactTextInputManager());
      viewManagers.add(new ReactTextViewManager());
      viewManagers.add(new ReactViewManager());
      viewManagers.add(new ReactViewPagerManager());
      viewManagers.add(new ReactVirtualTextViewManager());
    }
    return viewManagers;
  }",method,
"    if (useFlatUi) {
      // Flat managers
      viewManagers.add(new FlatARTSurfaceViewManager());
      viewManagers.add(new RCTTextInlineImageManager());
      viewManagers.add(new RCTImageViewManager());
      viewManagers.add(new RCTModalHostManager());
      viewManagers.add(new RCTRawTextManager());
      viewManagers.add(new RCTTextInputManager());
      viewManagers.add(new RCTTextManager());
      viewManagers.add(new RCTViewManager());
      viewManagers.add(new RCTViewPagerManager());
      viewManagers.add(new RCTVirtualTextManager());
    }",method,
"  @Override
  public ReactModuleInfoProvider getReactModuleInfoProvider() {
    // This has to be done via reflection or we break open source.
    return LazyReactPackage.getReactModuleInfoProviderViaReflection(this);
  }",method,
"public class LLOfButtons1 extends Activity {
    private boolean mButtonPressed = false;
    private Button mFirstButton;
    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        setContentView(R.layout.linear_layout_buttons);
        mFirstButton = findViewById(R.id.button1);
        mFirstButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                mButtonPressed = true;
            }
        });
    }
    public LinearLayout getLayout() {
        return findViewById(R.id.layout);
    }
    public Button getFirstButton() {
        return mFirstButton;
    }
    public boolean buttonClickListenerFired() {
        return mButtonPressed;
    }
    public boolean isInTouchMode() {
        return mFirstButton.isInTouchMode();
    }
}",class,
"public class LLOfButtons2  extends LLOfButtons1 {
}",class,
"    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        setContentView(R.layout.linear_layout_buttons);
        mFirstButton = findViewById(R.id.button1);
        mFirstButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                mButtonPressed = true;
            }
        });
    }",method,
"        mFirstButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                mButtonPressed = true;
            }
        }",method,
"            public void onClick(View v) {
                mButtonPressed = true;
            }",method,
"    public LinearLayout getLayout() {
        return findViewById(R.id.layout);
    }",method,
"    public Button getFirstButton() {
        return mFirstButton;
    }",method,
"    public boolean buttonClickListenerFired() {
        return mButtonPressed;
    }",method,
"    public boolean isInTouchMode() {
        return mFirstButton.isInTouchMode();
    }",method,
"public class LinearGradientFillTextureSourceDecorator extends BaseShapeTextureSourceDecorator {
	// ===========================================================
	// Constants
	// ===========================================================
	// ===========================================================
	// Fields
	// ===========================================================
	protected final LinearGradientDirection mLinearGradientDirection;
	protected final int mFromColor;
	protected final int mToColor;
	// ===========================================================
	// Constructors
	// ===========================================================
	public LinearGradientFillTextureSourceDecorator(final ITextureSource pTextureSource, final ITextureSourceDecoratorShape pTextureSourceDecoratorShape, final int pFromColor, final int pToColor, final LinearGradientDirection pLinearGradientDirection) {
		this(pTextureSource, pTextureSourceDecoratorShape, pFromColor, pToColor, pLinearGradientDirection, null);
	}
	public LinearGradientFillTextureSourceDecorator(final ITextureSource pTextureSource, final ITextureSourceDecoratorShape pTextureSourceDecoratorShape, final int pFromColor, final int pToColor, final LinearGradientDirection pLinearGradientDirection, final TextureSourceDecoratorOptions pTextureSourceDecoratorOptions) {
		super(pTextureSource, pTextureSourceDecoratorShape, pTextureSourceDecoratorOptions);
		this.mFromColor = pFromColor;
		this.mToColor = pToColor;
		this.mLinearGradientDirection = pLinearGradientDirection;
		this.mPaint.setStyle(Style.FILL);
		final int width = pTextureSource.getWidth();
		final int height = pTextureSource.getHeight();
		final float fromX = pLinearGradientDirection.getFromX() * width;
		final float fromY = pLinearGradientDirection.getFromY() * height;
		final float toX = pLinearGradientDirection.getToX() * width;
		final float toY = pLinearGradientDirection.getToY() * height;
		this.mPaint.setShader(new LinearGradient(fromX, fromY, toX, toY, pFromColor, pToColor, TileMode.CLAMP));
	}
	@Override
	public LinearGradientFillTextureSourceDecorator clone() {
		return new LinearGradientFillTextureSourceDecorator(this.mTextureSource, this.mTextureSourceDecoratorShape, this.mFromColor, this.mToColor, this.mLinearGradientDirection, this.mTextureSourceDecoratorOptions);
	}
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	// ===========================================================
	// Methods
	// ===========================================================
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
	public static enum LinearGradientDirection {
		// ===========================================================
		// Elements
		// ===========================================================
		LEFT_TO_RIGHT(0, 0, 1, 0),
		RIGHT_TO_LEFT(1, 0, 0, 0),
		BOTTOM_TO_TOP(0, 0, 0, 1),
		TOP_TO_BOTTOM(0, 1, 0, 0),
		TOPLEFT_TO_BOTTOMRIGHT(0, 0, 1, 1),
		BOTTOMRIGHT_TO_TOPLEFT(1, 1, 0, 0),
		TOPRIGHT_TO_BOTTOMLEFT(1, 0, 0, 1),
		BOTTOMLEFT_TO_TOPRIGHT(0, 1, 1, 0);
		// ===========================================================
		// Constants
		// ===========================================================
		// ===========================================================
		// Fields
		// ===========================================================
		private final int mFromX;
		private final int mFromY;
		private final int mToX;
		private final int mToY;
		// ===========================================================
		// Constructors
		// ===========================================================
		private LinearGradientDirection(final int pFromX, final int pFromY, final int pToX, final int pToY) {
			this.mFromX = pFromX;
			this.mFromY = pFromY;
			this.mToX = pToX;
			this.mToY = pToY;
		}
		// ===========================================================
		// Getter & Setter
		// ===========================================================
		final int getFromX() {
			return this.mFromX;
		}
		final int getFromY() {
			return this.mFromY;
		}
		final int getToX() {
			return this.mToX;
		}
		final int getToY() {
			return this.mToY;
		}
		// ===========================================================
		// Methods from SuperClass/Interfaces
		// ===========================================================
		// ===========================================================
		// Methods
		// ===========================================================
		// ===========================================================
		// Inner and Anonymous Classes
		// ===========================================================
	}
}",class,
"	public LinearGradientFillTextureSourceDecorator(final ITextureSource pTextureSource, final ITextureSourceDecoratorShape pTextureSourceDecoratorShape, final int pFromColor, final int pToColor, final LinearGradientDirection pLinearGradientDirection) {
		this(pTextureSource, pTextureSourceDecoratorShape, pFromColor, pToColor, pLinearGradientDirection, null);
	}",method,
"	public LinearGradientFillTextureSourceDecorator(final ITextureSource pTextureSource, final ITextureSourceDecoratorShape pTextureSourceDecoratorShape, final int pFromColor, final int pToColor, final LinearGradientDirection pLinearGradientDirection, final TextureSourceDecoratorOptions pTextureSourceDecoratorOptions) {
		super(pTextureSource, pTextureSourceDecoratorShape, pTextureSourceDecoratorOptions);
		this.mFromColor = pFromColor;
		this.mToColor = pToColor;
		this.mLinearGradientDirection = pLinearGradientDirection;
		this.mPaint.setStyle(Style.FILL);
		final int width = pTextureSource.getWidth();
		final int height = pTextureSource.getHeight();
		final float fromX = pLinearGradientDirection.getFromX() * width;
		final float fromY = pLinearGradientDirection.getFromY() * height;
		final float toX = pLinearGradientDirection.getToX() * width;
		final float toY = pLinearGradientDirection.getToY() * height;
		this.mPaint.setShader(new LinearGradient(fromX, fromY, toX, toY, pFromColor, pToColor, TileMode.CLAMP));
	}",method,
"	@Override
	public LinearGradientFillTextureSourceDecorator clone() {
		return new LinearGradientFillTextureSourceDecorator(this.mTextureSource, this.mTextureSourceDecoratorShape, this.mFromColor, this.mToColor, this.mLinearGradientDirection, this.mTextureSourceDecoratorOptions);
	}",method,
"		private LinearGradientDirection(final int pFromX, final int pFromY, final int pToX, final int pToY) {
			this.mFromX = pFromX;
			this.mFromY = pFromY;
			this.mToX = pToX;
			this.mToY = pToY;
		}",method,
"		final int getFromX() {
			return this.mFromX;
		}",method,
"		final int getFromY() {
			return this.mFromY;
		}",method,
"		final int getToX() {
			return this.mToX;
		}",method,
"		final int getToY() {
			return this.mToY;
		}",method,
"public class LzoIndex {
  public static final String LZO_INDEX_SUFFIX = "".index"";
  public static final String LZO_TMP_INDEX_SUFFIX = "".index.tmp"";
  public static final long NOT_FOUND = -1;
  private long[] blockPositions_;
  public LzoIndex() { }
  public LzoIndex(int blocks) {
    blockPositions_ = new long[blocks];
  }
  public void set(int blockNumber, long pos) {
    blockPositions_[blockNumber] = pos;
  }
  public int getNumberOfBlocks() {
    return blockPositions_.length;
  }
  public long getPosition(int block) {
    return blockPositions_[block];
  }
  public long findNextPosition(long pos) {
    int block = Arrays.binarySearch(blockPositions_, pos);
    if (block >= 0) {
      // direct hit on a block start position
      return blockPositions_[block];
    } else {
      block = Math.abs(block) - 1;
      if (block > blockPositions_.length - 1) {
        return NOT_FOUND;
      }
      return blockPositions_[block];
    }
  }
  public boolean isEmpty() {
    return blockPositions_ == null || blockPositions_.length == 0;
  }
  public long alignSliceStartToIndex(long start, long end) {
    if (start != 0) {
      // find the next block position from
      // the start of the split
      long newStart = findNextPosition(start);
      if (newStart == NOT_FOUND || newStart >= end) {
        return NOT_FOUND;
      }
      start = newStart;
    }
    return start;
  }
  public long alignSliceEndToIndex(long end, long fileSize) {
    long newEnd = findNextPosition(end);
    if (newEnd != NOT_FOUND) {
      end = newEnd;
    } else {
      // didn't find the next position
      // we have hit the end of the file
      end = fileSize;
    }
    return end;
  }
  public static LzoIndex readIndex(FileSystem fs, Path lzoFile) throws IOException {
    FSDataInputStream indexIn = null;
    Path indexFile = lzoFile.suffix(LZO_INDEX_SUFFIX);
    try {
      indexIn = fs.open(indexFile);
    } catch (IOException fileNotFound) {
      // return empty index, fall back to the unsplittable mode
      return new LzoIndex();
    }
    int capacity = 16 * 1024 * 8; //size for a 4GB file (with 256KB lzo blocks)
    DataOutputBuffer bytes = new DataOutputBuffer(capacity);
    // copy indexIn and close it
    IOUtils.copyBytes(indexIn, bytes, 4*1024, true);
    ByteBuffer bytesIn = ByteBuffer.wrap(bytes.getData(), 0, bytes.getLength());
    int blocks = bytesIn.remaining()/8;
    LzoIndex index = new LzoIndex(blocks);
    for (int i = 0; i < blocks; i++) {
      index.set(i, bytesIn.getLong());
    }
    return index;
  }
  public static void createIndex(FileSystem fs, Path lzoFile)
  throws IOException {
    Configuration conf = fs.getConf();
    CompressionCodecFactory factory = new CompressionCodecFactory(conf);
    CompressionCodec codec = factory.getCodec(lzoFile);
    if (null == codec) {
      throw new IOException(""Could not find codec for file "" + lzoFile +
        "" - you may need to add the LZO codec to your io.compression.codecs "" +
        ""configuration in core-site.xml"");
    }
    ((Configurable) codec).setConf(conf);
    FSDataInputStream is = null;
    FSDataOutputStream os = null;
    Path outputFile = lzoFile.suffix(LZO_INDEX_SUFFIX);
    Path tmpOutputFile = lzoFile.suffix(LZO_TMP_INDEX_SUFFIX);
    // Track whether an exception was thrown or not, so we know to either
    // delete the tmp index file on failure, or rename it to the new index file on success.
    boolean indexingSucceeded = false;
    try {
      is = fs.open(lzoFile);
      os = fs.create(tmpOutputFile);
      LzopDecompressor decompressor = (LzopDecompressor) codec.createDecompressor();
      // Solely for reading the header
      codec.createInputStream(is, decompressor);
      int numCompressedChecksums = decompressor.getCompressedChecksumsCount();
      int numDecompressedChecksums = decompressor.getDecompressedChecksumsCount();
      while (true) {
        // read and ignore, we just want to get to the next int
        int uncompressedBlockSize = is.readInt();
        if (uncompressedBlockSize == 0) {
          break;
        } else if (uncompressedBlockSize < 0) {
          throw new EOFException();
        }
        int compressedBlockSize = is.readInt();
        if (compressedBlockSize <= 0) {
          throw new IOException(""Could not read compressed block size"");
        }
        // See LzopInputStream.getCompressedData
        boolean isUncompressedBlock = (uncompressedBlockSize == compressedBlockSize);
        int numChecksumsToSkip = isUncompressedBlock ?
            numDecompressedChecksums : numDecompressedChecksums + numCompressedChecksums;
        long pos = is.getPos();
        // write the pos of the block start
        os.writeLong(pos - 8);
        // seek to the start of the next block, skip any checksums
        is.seek(pos + compressedBlockSize + (4 * numChecksumsToSkip));
      }
      // If we're here, indexing was successful.
      indexingSucceeded = true;
    } finally {
      // Close any open streams.
      if (is != null) {
        is.close();
      }
      if (os != null) {
        os.close();
      }
      if (!indexingSucceeded) {
        // If indexing didn't succeed (i.e. an exception was thrown), clean up after ourselves.
        fs.delete(tmpOutputFile, false);
      } else {
        // Otherwise, rename filename.lzo.index.tmp to filename.lzo.index.
        fs.rename(tmpOutputFile, outputFile);
      }
    }
  }
}",class,
  public LzoIndex() { },method,
"  public LzoIndex(int blocks) {
    blockPositions_ = new long[blocks];
  }",method,
"  public void set(int blockNumber, long pos) {
    blockPositions_[blockNumber] = pos;
  }",method,
"  public int getNumberOfBlocks() {
    return blockPositions_.length;
  }",method,
"  public long getPosition(int block) {
    return blockPositions_[block];
  }",method,
"  public long findNextPosition(long pos) {
    int block = Arrays.binarySearch(blockPositions_, pos);
    if (block >= 0) {
      // direct hit on a block start position
      return blockPositions_[block];
    } else {
      block = Math.abs(block) - 1;
      if (block > blockPositions_.length - 1) {
        return NOT_FOUND;
      }
      return blockPositions_[block];
    }
  }",method,
"    if (block >= 0) {
      // direct hit on a block start position
      return blockPositions_[block];
    }",method,
"      if (block > blockPositions_.length - 1) {
        return NOT_FOUND;
      }",method,
"  public boolean isEmpty() {
    return blockPositions_ == null || blockPositions_.length == 0;
  }",method,
"  public long alignSliceStartToIndex(long start, long end) {
    if (start != 0) {
      // find the next block position from
      // the start of the split
      long newStart = findNextPosition(start);
      if (newStart == NOT_FOUND || newStart >= end) {
        return NOT_FOUND;
      }
      start = newStart;
    }
    return start;
  }",method,
"    if (start != 0) {
      // find the next block position from
      // the start of the split
      long newStart = findNextPosition(start);
      if (newStart == NOT_FOUND || newStart >= end) {
        return NOT_FOUND;
      }
      start = newStart;
    }",method,
"      if (newStart == NOT_FOUND || newStart >= end) {
        return NOT_FOUND;
      }",method,
"  public long alignSliceEndToIndex(long end, long fileSize) {
    long newEnd = findNextPosition(end);
    if (newEnd != NOT_FOUND) {
      end = newEnd;
    } else {
      // didn't find the next position
      // we have hit the end of the file
      end = fileSize;
    }
    return end;
  }",method,
"    if (newEnd != NOT_FOUND) {
      end = newEnd;
    }",method,
"  public static LzoIndex readIndex(FileSystem fs, Path lzoFile) throws IOException {
    FSDataInputStream indexIn = null;
    Path indexFile = lzoFile.suffix(LZO_INDEX_SUFFIX);
    try {
      indexIn = fs.open(indexFile);
    } catch (IOException fileNotFound) {
      // return empty index, fall back to the unsplittable mode
      return new LzoIndex();
    }
    int capacity = 16 * 1024 * 8; //size for a 4GB file (with 256KB lzo blocks)
    DataOutputBuffer bytes = new DataOutputBuffer(capacity);
    // copy indexIn and close it
    IOUtils.copyBytes(indexIn, bytes, 4*1024, true);
    ByteBuffer bytesIn = ByteBuffer.wrap(bytes.getData(), 0, bytes.getLength());
    int blocks = bytesIn.remaining()/8;
    LzoIndex index = new LzoIndex(blocks);
    for (int i = 0; i < blocks; i++) {
      index.set(i, bytesIn.getLong());
    }
    return index;
  }",method,
"    for (int i = 0; i < blocks; i++) {
      index.set(i, bytesIn.getLong());
    }",method,
"  public static void createIndex(FileSystem fs, Path lzoFile)
  throws IOException {
    Configuration conf = fs.getConf();
    CompressionCodecFactory factory = new CompressionCodecFactory(conf);
    CompressionCodec codec = factory.getCodec(lzoFile);
    if (null == codec) {
      throw new IOException(""Could not find codec for file "" + lzoFile +
        "" - you may need to add the LZO codec to your io.compression.codecs "" +
        ""configuration in core-site.xml"");
    }
    ((Configurable) codec).setConf(conf);
    FSDataInputStream is = null;
    FSDataOutputStream os = null;
    Path outputFile = lzoFile.suffix(LZO_INDEX_SUFFIX);
    Path tmpOutputFile = lzoFile.suffix(LZO_TMP_INDEX_SUFFIX);
    // Track whether an exception was thrown or not, so we know to either
    // delete the tmp index file on failure, or rename it to the new index file on success.
    boolean indexingSucceeded = false;
    try {
      is = fs.open(lzoFile);
      os = fs.create(tmpOutputFile);
      LzopDecompressor decompressor = (LzopDecompressor) codec.createDecompressor();
      // Solely for reading the header
      codec.createInputStream(is, decompressor);
      int numCompressedChecksums = decompressor.getCompressedChecksumsCount();
      int numDecompressedChecksums = decompressor.getDecompressedChecksumsCount();
      while (true) {
        // read and ignore, we just want to get to the next int
        int uncompressedBlockSize = is.readInt();
        if (uncompressedBlockSize == 0) {
          break;
        } else if (uncompressedBlockSize < 0) {
          throw new EOFException();
        }
        int compressedBlockSize = is.readInt();
        if (compressedBlockSize <= 0) {
          throw new IOException(""Could not read compressed block size"");
        }
        // See LzopInputStream.getCompressedData
        boolean isUncompressedBlock = (uncompressedBlockSize == compressedBlockSize);
        int numChecksumsToSkip = isUncompressedBlock ?
            numDecompressedChecksums : numDecompressedChecksums + numCompressedChecksums;
        long pos = is.getPos();
        // write the pos of the block start
        os.writeLong(pos - 8);
        // seek to the start of the next block, skip any checksums
        is.seek(pos + compressedBlockSize + (4 * numChecksumsToSkip));
      }
      // If we're here, indexing was successful.
      indexingSucceeded = true;
    } finally {
      // Close any open streams.
      if (is != null) {
        is.close();
      }
      if (os != null) {
        os.close();
      }
      if (!indexingSucceeded) {
        // If indexing didn't succeed (i.e. an exception was thrown), clean up after ourselves.
        fs.delete(tmpOutputFile, false);
      } else {
        // Otherwise, rename filename.lzo.index.tmp to filename.lzo.index.
        fs.rename(tmpOutputFile, outputFile);
      }
    }
  }",method,
"    if (null == codec) {
      throw new IOException(""Could not find codec for file "" + lzoFile +
        "" - you may need to add the LZO codec to your io.compression.codecs "" +
        ""configuration in core-site.xml"");
    }",method,
"      while (true) {
        // read and ignore, we just want to get to the next int
        int uncompressedBlockSize = is.readInt();
        if (uncompressedBlockSize == 0) {
          break;
        } else if (uncompressedBlockSize < 0) {
          throw new EOFException();
        }
        int compressedBlockSize = is.readInt();
        if (compressedBlockSize <= 0) {
          throw new IOException(""Could not read compressed block size"");
        }
        // See LzopInputStream.getCompressedData
        boolean isUncompressedBlock = (uncompressedBlockSize == compressedBlockSize);
        int numChecksumsToSkip = isUncompressedBlock ?
            numDecompressedChecksums : numDecompressedChecksums + numCompressedChecksums;
        long pos = is.getPos();
        // write the pos of the block start
        os.writeLong(pos - 8);
        // seek to the start of the next block, skip any checksums
        is.seek(pos + compressedBlockSize + (4 * numChecksumsToSkip));
      }",method,
"        if (uncompressedBlockSize == 0) {
          break;
        }",method,
"        if (compressedBlockSize <= 0) {
          throw new IOException(""Could not read compressed block size"");
        }",method,
"      if (is != null) {
        is.close();
      }",method,
"      if (os != null) {
        os.close();
      }",method,
"      if (!indexingSucceeded) {
        // If indexing didn't succeed (i.e. an exception was thrown), clean up after ourselves.
        fs.delete(tmpOutputFile, false);
      }",method,
"public class RemapVisitor extends MethodBodyVisitor {
    private final LocalVarRemapper remapper;
    private final FieldRemapper nodeRemapper;
    private final InstructionAdapter instructionAdapter;
    public RemapVisitor(
            @NotNull MethodVisitor mv,
            @NotNull LocalVarRemapper remapper,
            @NotNull FieldRemapper nodeRemapper,
            boolean copyAnnotationsAndAttributes
    ) {
        super(mv, copyAnnotationsAndAttributes);
        this.instructionAdapter = new InstructionAdapter(mv);
        this.remapper = remapper;
        this.nodeRemapper = nodeRemapper;
    }
    @Override
    public void visitIincInsn(int var, int increment) {
        remapper.visitIincInsn(var, increment, mv);
    }
    @Override
    public void visitVarInsn(int opcode, int var) {
        remapper.visitVarInsn(opcode, var, instructionAdapter);
    }
    @Override
    public void visitLocalVariable(
            @NotNull String name, @NotNull String desc, String signature, @NotNull Label start, @NotNull Label end, int index
    ) {
        remapper.visitLocalVariable(name, desc, signature, start, end, index, mv);
    }
    @Override
    public void visitFieldInsn(int opcode, @NotNull String owner, @NotNull String name, @NotNull String desc) {
        if (name.startsWith(CAPTURED_FIELD_FOLD_PREFIX) &&
            (nodeRemapper instanceof RegeneratedLambdaFieldRemapper || nodeRemapper.isRoot())) {
            FieldInsnNode fin = new FieldInsnNode(opcode, owner, name, desc);
            StackValue inline = nodeRemapper.getFieldForInline(fin, null);
            assert inline != null : ""Captured field should have not null stackValue "" + fin;
            if (Opcodes.PUTSTATIC == opcode) {
                inline.store(StackValue.onStack(inline.type), this);
            }
            else {
                inline.put(inline.type, this);
            }
            return;
        }
        super.visitFieldInsn(opcode, owner, name, desc);
    }
}",class,
"    public RemapVisitor(
            @NotNull MethodVisitor mv,
            @NotNull LocalVarRemapper remapper,
            @NotNull FieldRemapper nodeRemapper,
            boolean copyAnnotationsAndAttributes
    ) {
        super(mv, copyAnnotationsAndAttributes);
        this.instructionAdapter = new InstructionAdapter(mv);
        this.remapper = remapper;
        this.nodeRemapper = nodeRemapper;
    }",method,
"    @Override
    public void visitIincInsn(int var, int increment) {
        remapper.visitIincInsn(var, increment, mv);
    }",method,
"    @Override
    public void visitVarInsn(int opcode, int var) {
        remapper.visitVarInsn(opcode, var, instructionAdapter);
    }",method,
"    @Override
    public void visitLocalVariable(
            @NotNull String name, @NotNull String desc, String signature, @NotNull Label start, @NotNull Label end, int index
    ) {
        remapper.visitLocalVariable(name, desc, signature, start, end, index, mv);
    }",method,
"    @Override
    public void visitFieldInsn(int opcode, @NotNull String owner, @NotNull String name, @NotNull String desc) {
        if (name.startsWith(CAPTURED_FIELD_FOLD_PREFIX) &&
            (nodeRemapper instanceof RegeneratedLambdaFieldRemapper || nodeRemapper.isRoot())) {
            FieldInsnNode fin = new FieldInsnNode(opcode, owner, name, desc);
            StackValue inline = nodeRemapper.getFieldForInline(fin, null);
            assert inline != null : ""Captured field should have not null stackValue "" + fin;
            if (Opcodes.PUTSTATIC == opcode) {
                inline.store(StackValue.onStack(inline.type), this);
            }
            else {
                inline.put(inline.type, this);
            }
            return;
        }
        super.visitFieldInsn(opcode, owner, name, desc);
    }",method,
"            if (Opcodes.PUTSTATIC == opcode) {
                inline.store(StackValue.onStack(inline.type), this);
            }",method,
"final class ScopedTemporaryDirectory extends SimpleFileVisitor<Path> implements Closeable {
  private static final boolean IS_WINDOWS = System.getProperty(""os.name"").startsWith(""Windows"");
  private final Path path;
  public ScopedTemporaryDirectory(String prefix) throws IOException {
    this.path = Files.createTempDirectory(prefix);
  }
  public Path getPath() {
    return this.path;
  }
  public Path subDirectoryOf(String... directories) throws IOException {
    Path sub = this.path;
    for (String directory : directories) {
      sub = sub.resolve(directory);
    }
    return Files.createDirectories(sub);
  }
  private void makeWritable(Path file) throws IOException {
    FileStore fileStore = Files.getFileStore(file);
    if (IS_WINDOWS && fileStore.supportsFileAttributeView(DosFileAttributeView.class)) {
      DosFileAttributeView dosAttribs =
          Files.getFileAttributeView(file, DosFileAttributeView.class);
      if (dosAttribs != null) {
        dosAttribs.setReadOnly(false);
      }
    } else if (fileStore.supportsFileAttributeView(PosixFileAttributeView.class)) {
      PosixFileAttributeView posixAttribs =
          Files.getFileAttributeView(file, PosixFileAttributeView.class);
      if (posixAttribs != null) {
        posixAttribs.setPermissions(EnumSet.of(OWNER_READ, OWNER_WRITE, OWNER_EXECUTE));
      }
    }
  }
  @Override
  public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    if (IS_WINDOWS) {
      makeWritable(dir);
    }
    return FileVisitResult.CONTINUE;
  }
  @Override
  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    if (IS_WINDOWS) {
      makeWritable(file);
    }
    Files.delete(file);
    return FileVisitResult.CONTINUE;
  }
  @Override
  public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    Files.delete(dir);
    return FileVisitResult.CONTINUE;
  }
  @Override
  public void close() throws IOException {
    Files.walkFileTree(path, this);
  }
}",class,
"  public ScopedTemporaryDirectory(String prefix) throws IOException {
    this.path = Files.createTempDirectory(prefix);
  }",method,
"  public Path getPath() {
    return this.path;
  }",method,
"  public Path subDirectoryOf(String... directories) throws IOException {
    Path sub = this.path;
    for (String directory : directories) {
      sub = sub.resolve(directory);
    }
    return Files.createDirectories(sub);
  }",method,
"    for (String directory : directories) {
      sub = sub.resolve(directory);
    }",method,
"  private void makeWritable(Path file) throws IOException {
    FileStore fileStore = Files.getFileStore(file);
    if (IS_WINDOWS && fileStore.supportsFileAttributeView(DosFileAttributeView.class)) {
      DosFileAttributeView dosAttribs =
          Files.getFileAttributeView(file, DosFileAttributeView.class);
      if (dosAttribs != null) {
        dosAttribs.setReadOnly(false);
      }
    } else if (fileStore.supportsFileAttributeView(PosixFileAttributeView.class)) {
      PosixFileAttributeView posixAttribs =
          Files.getFileAttributeView(file, PosixFileAttributeView.class);
      if (posixAttribs != null) {
        posixAttribs.setPermissions(EnumSet.of(OWNER_READ, OWNER_WRITE, OWNER_EXECUTE));
      }
    }
  }",method,
"      if (dosAttribs != null) {
        dosAttribs.setReadOnly(false);
      }",method,
"      if (posixAttribs != null) {
        posixAttribs.setPermissions(EnumSet.of(OWNER_READ, OWNER_WRITE, OWNER_EXECUTE));
      }",method,
"  @Override
  public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    if (IS_WINDOWS) {
      makeWritable(dir);
    }
    return FileVisitResult.CONTINUE;
  }",method,
"    if (IS_WINDOWS) {
      makeWritable(dir);
    }",method,

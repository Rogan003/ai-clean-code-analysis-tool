code_snippet,type,score
"    protected LeakCheck getLeakCheck() {
        return null;
    }",method,
"    public Context getContext() {
        return mContext;
    }",method,
"    protected void waitForIdleSync() {
        if (mHandler == null) {
            mHandler = new Handler(Looper.getMainLooper());
        }
        waitForIdleSync(mHandler);
    }",method,
"        if (mHandler == null) {
            mHandler = new Handler(Looper.getMainLooper());
        }",method,
"    protected void waitForUiOffloadThread() {
        Future<?> future = Dependency.get(UiOffloadThread.class).submit(() -> {});
        try {
            future.get();
        } catch (InterruptedException | ExecutionException e) {
            Log.e(TAG, ""Failed to wait for ui offload thread."", e);
        }
    }",method,
"    public static void waitForIdleSync(Handler h) {
        validateThread(h.getLooper());
        Idler idler = new Idler(null);
        h.getLooper().getQueue().addIdleHandler(idler);
        // Ensure we are non-idle, so the idle handler can run.
        h.post(new EmptyRunnable());
        idler.waitForIdle();
    }",method,
"    private static final void validateThread(Looper l) {
        if (Looper.myLooper() == l) {
            throw new RuntimeException(
                ""This method can not be called from the looper being synced"");
        }
    }",method,
"        public void run() {
        }",method,
"        public Idler(Runnable callback) {
            mCallback = callback;
            mIdle = false;
        }",method,
"        @Override
        public boolean queueIdle() {
            if (mCallback != null) {
                mCallback.run();
            }
            synchronized (this) {
                mIdle = true;
                notifyAll();
            }
            return false;
        }",method,
"            if (mCallback != null) {
                mCallback.run();
            }",method,
"            synchronized (this) {
                mIdle = true;
                notifyAll();
            }",method,
"        public void waitForIdle() {
            synchronized (this) {
                while (!mIdle) {
                    try {
                        wait();
                    } catch (InterruptedException e) {
                    }
                }
            }
        }",method,
"            synchronized (this) {
                while (!mIdle) {
                    try {
                        wait();
                    } catch (InterruptedException e) {
                    }
                }
            }",method,
"                while (!mIdle) {
                    try {
                        wait();
                    } catch (InterruptedException e) {
                    }
                }",method,
"public class ModelApiResponse   {
  @JsonProperty(""code"")
  private Integer code = null;
  @JsonProperty(""type"")
  private String type = null;
  @JsonProperty(""message"")
  private String message = null;
  public ModelApiResponse code(Integer code) {
    this.code = code;
    return this;
  }
    public Integer getCode() {
    return code;
  }
  public void setCode(Integer code) {
    this.code = code;
  }
  public ModelApiResponse type(String type) {
    this.type = type;
    return this;
  }
    public String getType() {
    return type;
  }
  public void setType(String type) {
    this.type = type;
  }
  public ModelApiResponse message(String message) {
    this.message = message;
    return this;
  }
    public String getMessage() {
    return message;
  }
  public void setMessage(String message) {
    this.message = message;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelApiResponse _apiResponse = (ModelApiResponse) o;
    return Objects.equals(code, _apiResponse.code) &&
        Objects.equals(type, _apiResponse.type) &&
        Objects.equals(message, _apiResponse.message);
  }
  @Override
  public int hashCode() {
    return Objects.hash(code, type, message);
  }
  @SuppressWarnings(""StringBufferReplaceableByString"")
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class ModelApiResponse {\n"");
    sb.append(""    code: "").append(toIndentedString(code)).append(""\n"");
    sb.append(""    type: "").append(toIndentedString(type)).append(""\n"");
    sb.append(""    message: "").append(toIndentedString(message)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
  public void validate() {
    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
    Validator validator = factory.getValidator();
    Set<ConstraintViolation<ModelApiResponse>> constraintViolations = validator.validate(this);
    if (constraintViolations.size() > 0) {
      StringBuilder errors = new StringBuilder();
      for (ConstraintViolation<ModelApiResponse> contraintes : constraintViolations) {
        errors.append(String.format(""%s.%s %s\n"",
            contraintes.getRootBeanClass().getSimpleName(),
            contraintes.getPropertyPath(),
            contraintes.getMessage()));
      }
      throw new RuntimeException(""Bean validation : "" + errors);
    }
  }
}",class,
"    sb.append(""class ModelApiResponse {\n"");
    sb.append(""    code: "").append(toIndentedString(code)).append(""\n"");
    sb.append(""    type: "").append(toIndentedString(type)).append(""\n"");
    sb.append(""    message: "").append(toIndentedString(message)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"  public ModelApiResponse code(Integer code) {
    this.code = code;
    return this;
  }",method,
"    public Integer getCode() {
    return code;
  }",method,
"  public void setCode(Integer code) {
    this.code = code;
  }",method,
"  public ModelApiResponse type(String type) {
    this.type = type;
    return this;
  }",method,
"    public String getType() {
    return type;
  }",method,
"  public void setType(String type) {
    this.type = type;
  }",method,
"  public ModelApiResponse message(String message) {
    this.message = message;
    return this;
  }",method,
"    public String getMessage() {
    return message;
  }",method,
"  public void setMessage(String message) {
    this.message = message;
  }",method,
"  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelApiResponse _apiResponse = (ModelApiResponse) o;
    return Objects.equals(code, _apiResponse.code) &&
        Objects.equals(type, _apiResponse.type) &&
        Objects.equals(message, _apiResponse.message);
  }",method,
"    if (this == o) {
      return true;
    }",method,
"  @Override
  public int hashCode() {
    return Objects.hash(code, type, message);
  }",method,
"  @SuppressWarnings(""StringBufferReplaceableByString"")
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class ModelApiResponse {\n"");
    sb.append(""    code: "").append(toIndentedString(code)).append(""\n"");
    sb.append(""    type: "").append(toIndentedString(type)).append(""\n"");
    sb.append(""    message: "").append(toIndentedString(message)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }",method,
"  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",method,
"    if (o == null) {
      return ""null"";
    }",method,
"  public void validate() {
    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
    Validator validator = factory.getValidator();
    Set<ConstraintViolation<ModelApiResponse>> constraintViolations = validator.validate(this);
    if (constraintViolations.size() > 0) {
      StringBuilder errors = new StringBuilder();
      for (ConstraintViolation<ModelApiResponse> contraintes : constraintViolations) {
        errors.append(String.format(""%s.%s %s\n"",
            contraintes.getRootBeanClass().getSimpleName(),
            contraintes.getPropertyPath(),
            contraintes.getMessage()));
      }
      throw new RuntimeException(""Bean validation : "" + errors);
    }
  }",method,
"      for (ConstraintViolation<ModelApiResponse> contraintes : constraintViolations) {
        errors.append(String.format(""%s.%s %s\n"",
            contraintes.getRootBeanClass().getSimpleName(),
            contraintes.getPropertyPath(),
            contraintes.getMessage()));
      }",method,
"public class GuavaOptionalLocalDateTest {
    private final Environment env = new Environment(""test-guava-local-date"", Jackson.newObjectMapper(),
            Validators.newValidator(), new MetricRegistry(), null);
    private TaskDao dao;
    @Before
    public void setupTests() throws IOException {
        final DataSourceFactory dataSourceFactory = new DataSourceFactory();
        dataSourceFactory.setDriverClass(""org.h2.Driver"");
        dataSourceFactory.setUrl(""jdbc:h2:mem:guava-local-date-"" + System.currentTimeMillis() + ""?user=sa"");
        dataSourceFactory.setInitialSize(1);
        final DBI dbi = new DBIFactory().build(env, dataSourceFactory, ""test"");
        try (Handle h = dbi.open()) {
            h.execute(""CREATE TABLE IF NOT EXISTS tasks ("" +
                    ""id INT PRIMARY KEY, "" +
                    ""assignee VARCHAR(255) NOT NULL, "" +
                    ""start_date TIMESTAMP, "" +
                    ""end_date TIMESTAMP, "" +
                    ""comments VARCHAR(1024) "" +
                    "")"");
        }
        dao = dbi.onDemand(TaskDao.class);
    }
    @Test
    public void testPresent() {
        final LocalDate startDate = LocalDate.now();
        final LocalDate endDate = startDate.plusDays(1L);
        dao.insert(1, Optional.of(""John Hughes""), startDate, Optional.of(endDate), Optional.absent());
        assertThat(dao.findEndDateById(1).get()).isEqualTo(endDate);
    }
    @Test
    public void testAbsent() {
        dao.insert(2, Optional.of(""Kate Johansen""), LocalDate.now(),
                Optional.absent(), Optional.of(""To be done""));
        assertThat(dao.findEndDateById(2).isPresent()).isFalse();
    }
    interface TaskDao {
        @SqlUpdate(""INSERT INTO tasks(id, assignee, start_date, end_date, comments) "" +
                ""VALUES (:id, :assignee, :start_date, :end_date, :comments)"")
        void insert(@Bind(""id"") int id, @Bind(""assignee"") Optional<String> assignee,
                    @Bind(""start_date"") LocalDate startDate, @Bind(""end_date"") Optional<LocalDate> endDate,
                    @Bind(""comments"") Optional<String> comments);
        @SqlQuery(""SELECT end_date FROM tasks WHERE id = :id"")
        @SingleValueResult
        Optional<LocalDate> findEndDateById(@Bind(""id"") int id);
    }
}",class,
"    @Before
    public void setupTests() throws IOException {
        final DataSourceFactory dataSourceFactory = new DataSourceFactory();
        dataSourceFactory.setDriverClass(""org.h2.Driver"");
        dataSourceFactory.setUrl(""jdbc:h2:mem:guava-local-date-"" + System.currentTimeMillis() + ""?user=sa"");
        dataSourceFactory.setInitialSize(1);
        final DBI dbi = new DBIFactory().build(env, dataSourceFactory, ""test"");
        try (Handle h = dbi.open()) {
            h.execute(""CREATE TABLE IF NOT EXISTS tasks ("" +
                    ""id INT PRIMARY KEY, "" +
                    ""assignee VARCHAR(255) NOT NULL, "" +
                    ""start_date TIMESTAMP, "" +
                    ""end_date TIMESTAMP, "" +
                    ""comments VARCHAR(1024) "" +
                    "")"");
        }
        dao = dbi.onDemand(TaskDao.class);
    }",method,
"    @Test
    public void testPresent() {
        final LocalDate startDate = LocalDate.now();
        final LocalDate endDate = startDate.plusDays(1L);
        dao.insert(1, Optional.of(""John Hughes""), startDate, Optional.of(endDate), Optional.absent());
        assertThat(dao.findEndDateById(1).get()).isEqualTo(endDate);
    }",method,
"    @Test
    public void testAbsent() {
        dao.insert(2, Optional.of(""Kate Johansen""), LocalDate.now(),
                Optional.absent(), Optional.of(""To be done""));
        assertThat(dao.findEndDateById(2).isPresent()).isFalse();
    }",method,
"public class RtfTransferableData extends AbstractSyntaxAwareInputStreamTransferableData {
  public static final int PRIORITY = 100;
  @NotNull public static final DataFlavor FLAVOR = new DataFlavor(""text/rtf;class=java.io.InputStream"", ""RTF text"");
  @NotNull private static final String HEADER_PREFIX = ""{\\rtf1\\ansi\\deff0"";
  @NotNull private static final String HEADER_SUFFIX = ""}"";
  @NotNull private static final String TAB           = ""\\tab\n"";
  // using undocumented way to denote line break on Mac (used e.g. by TextEdit) to resolve IDEA-165337
  @NotNull private static final String NEW_LINE      = SystemInfo.isMac ? ""\\\n"" : ""\\line\n"";
  @NotNull private static final String BOLD          = ""\\b"";
  @NotNull private static final String ITALIC        = ""\\i"";
  public RtfTransferableData(@NotNull SyntaxInfo syntaxInfo) {
    super(syntaxInfo, FLAVOR);
  }
  @Override
  protected void build(@NotNull final StringBuilder holder, final int maxLength) {
    holder.append(HEADER_PREFIX);
    holder.append(""{\\colortbl;"");
    ColorRegistry colorRegistry = mySyntaxInfo.getColorRegistry();
    for (int id : colorRegistry.getAllIds()) {
      Color color = colorRegistry.dataById(id);
      int[] components = getAdjustedColorComponents(color);
      holder.append(String.format(""\\red%d\\green%d\\blue%d;"", components[0], components[1], components[2]));
    }
    holder.append(""}\n"");
    holder.append(""{\\fonttbl"");
    FontNameRegistry fontNameRegistry = mySyntaxInfo.getFontNameRegistry();
    for (int id : fontNameRegistry.getAllIds()) {
      String fontName = fontNameRegistry.dataById(id);
      holder.append(String.format(""{\\f%d %s;}"", id, fontName));
    }
    holder.append(""}\n"");
    holder.append(""\n\\s0\\box"")
      .append(""\\cbpat"").append(mySyntaxInfo.getDefaultBackground())
      .append(""\\cb"").append(mySyntaxInfo.getDefaultBackground())
      .append(""\\cf"").append(mySyntaxInfo.getDefaultForeground());
    addFontSize(holder, mySyntaxInfo.getFontSize());
    holder.append('\n');
    mySyntaxInfo.processOutputInfo(new MyVisitor(holder, myRawText, mySyntaxInfo, maxLength));
    holder.append(""\\par"");
    holder.append(HEADER_SUFFIX);
  }
  private static int[] getAdjustedColorComponents(Color color) {
    if (SystemInfo.isMac) {
      // on Mac OS color components are expected in Apple's 'Generic RGB' color space
      ColorSpace genericRgbSpace = MacOSApplicationProvider.getInstance().getGenericRgbColorSpace();
      if (genericRgbSpace != null) {
        float[] components = genericRgbSpace.fromRGB(color.getRGBColorComponents(null));
        return new int[] {
          colorComponentFloatToInt(components[0]), 
          colorComponentFloatToInt(components[1]), 
          colorComponentFloatToInt(components[2])
        };
      }
    }
    return new int[] {color.getRed(), color.getGreen(), color.getBlue()};
  }
  private static int colorComponentFloatToInt(float component) {
    return (int)(component * 255 + 0.5f);
  }
  @NotNull
  @Override
  protected String getCharset() {
    return ""US-ASCII"";
  }
  private static void addFontSize(StringBuilder buffer, float fontSize) {
    buffer.append(""\\fs"").append(Math.round(fontSize * 2));
  }
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  private static class MyVisitor implements MarkupHandler {
    @NotNull private final StringBuilder myBuffer;
    @NotNull private final String        myRawText;
    private final int myMaxLength;
    private final int myDefaultBackgroundId;
    private final float myFontSize;
    private int myForegroundId = -1;
    private int myFontNameId   = -1;
    private int myFontStyle    = -1;
    MyVisitor(@NotNull StringBuilder buffer, @NotNull String rawText, @NotNull SyntaxInfo syntaxInfo, int maxLength) {
      myBuffer = buffer;
      myRawText = rawText;
      myMaxLength = maxLength;
      myDefaultBackgroundId = syntaxInfo.getDefaultBackground();
      myFontSize = syntaxInfo.getFontSize();
    }
    @Override
    public void handleText(int startOffset, int endOffset) throws Exception {
      myBuffer.append(""\n"");
      for (int i = startOffset; i < endOffset; i++) {
        char c = myRawText.charAt(i);
        if (c > 127) {
          // Escape non-ascii symbols.
          myBuffer.append(String.format(""\\u%04d?"", (int)c));
          continue;
        }
        switch (c) {
          case '\t':
            myBuffer.append(TAB);
            continue;
          case '\n':
            myBuffer.append(NEW_LINE);
            continue;
          case '\\':
          case '{':
          case '}':
            myBuffer.append('\\');
        }
        myBuffer.append(c);
      }
    }
    @Override
    public void handleBackground(int backgroundId) throws Exception {
      if (backgroundId == myDefaultBackgroundId) {
        myBuffer.append(""\\plain""); // we cannot use \chcbpat with default background id, as it doesn't work in MS Word,
                                    // and we cannot use \chcbpat0 as it doesn't work in OpenOffice
        addFontSize(myBuffer, myFontSize);
        if (myFontNameId >= 0) {
          handleFont(myFontNameId);
        }
        if (myForegroundId >= 0) {
          handleForeground(myForegroundId);
        }
        if (myFontStyle >= 0) {
          handleStyle(myFontStyle);
        }
      }
      else {
        myBuffer.append(""\\chcbpat"").append(backgroundId);
      }
      myBuffer.append(""\\cb"").append(backgroundId);
      myBuffer.append('\n');
    }
    @Override
    public void handleForeground(int foregroundId) throws Exception {
      myBuffer.append(""\\cf"").append(foregroundId).append('\n');
      myForegroundId = foregroundId;
    }
    @Override
    public void handleFont(int fontNameId) throws Exception {
      myBuffer.append(""\\f"").append(fontNameId).append('\n');
      myFontNameId = fontNameId;
    }
    @Override
    public void handleStyle(int style) throws Exception {
      myBuffer.append(ITALIC);
      if ((style & Font.ITALIC) == 0) {
        myBuffer.append('0');
      }
      myBuffer.append(BOLD);
      if ((style & Font.BOLD) == 0) {
        myBuffer.append('0');
      }
      myBuffer.append('\n');
      myFontStyle = style;
    }
    @Override
    public boolean canHandleMore() {
      if (myBuffer.length() > myMaxLength) {
        myBuffer.append(""... truncated ..."");
        return false;
      }
      return true;
    }
  }
}",class,
"  private static class MyVisitor implements MarkupHandler {
    @NotNull private final StringBuilder myBuffer;
    @NotNull private final String        myRawText;
    private final int myMaxLength;
    private final int myDefaultBackgroundId;
    private final float myFontSize;
    private int myForegroundId = -1;
    private int myFontNameId   = -1;
    private int myFontStyle    = -1;
    MyVisitor(@NotNull StringBuilder buffer, @NotNull String rawText, @NotNull SyntaxInfo syntaxInfo, int maxLength) {
      myBuffer = buffer;
      myRawText = rawText;
      myMaxLength = maxLength;
      myDefaultBackgroundId = syntaxInfo.getDefaultBackground();
      myFontSize = syntaxInfo.getFontSize();
    }
    @Override
    public void handleText(int startOffset, int endOffset) throws Exception {
      myBuffer.append(""\n"");
      for (int i = startOffset; i < endOffset; i++) {
        char c = myRawText.charAt(i);
        if (c > 127) {
          // Escape non-ascii symbols.
          myBuffer.append(String.format(""\\u%04d?"", (int)c));
          continue;
        }
        switch (c) {
          case '\t':
            myBuffer.append(TAB);
            continue;
          case '\n':
            myBuffer.append(NEW_LINE);
            continue;
          case '\\':
          case '{':
          case '}':
            myBuffer.append('\\');
        }
        myBuffer.append(c);
      }
    }
    @Override
    public void handleBackground(int backgroundId) throws Exception {
      if (backgroundId == myDefaultBackgroundId) {
        myBuffer.append(""\\plain""); // we cannot use \chcbpat with default background id, as it doesn't work in MS Word,
                                    // and we cannot use \chcbpat0 as it doesn't work in OpenOffice
        addFontSize(myBuffer, myFontSize);
        if (myFontNameId >= 0) {
          handleFont(myFontNameId);
        }
        if (myForegroundId >= 0) {
          handleForeground(myForegroundId);
        }
        if (myFontStyle >= 0) {
          handleStyle(myFontStyle);
        }
      }
      else {
        myBuffer.append(""\\chcbpat"").append(backgroundId);
      }
      myBuffer.append(""\\cb"").append(backgroundId);
      myBuffer.append('\n');
    }
    @Override
    public void handleForeground(int foregroundId) throws Exception {
      myBuffer.append(""\\cf"").append(foregroundId).append('\n');
      myForegroundId = foregroundId;
    }
    @Override
    public void handleFont(int fontNameId) throws Exception {
      myBuffer.append(""\\f"").append(fontNameId).append('\n');
      myFontNameId = fontNameId;
    }
    @Override
    public void handleStyle(int style) throws Exception {
      myBuffer.append(ITALIC);
      if ((style & Font.ITALIC) == 0) {
        myBuffer.append('0');
      }
      myBuffer.append(BOLD);
      if ((style & Font.BOLD) == 0) {
        myBuffer.append('0');
      }
      myBuffer.append('\n');
      myFontStyle = style;
    }
    @Override
    public boolean canHandleMore() {
      if (myBuffer.length() > myMaxLength) {
        myBuffer.append(""... truncated ..."");
        return false;
      }
      return true;
    }
  }",class,
"  @NotNull private static final String NEW_LINE      = SystemInfo.isMac ? ""\\\n"" : ""\\line\n"";
  @NotNull private static final String BOLD          = ""\\b"";
  @NotNull private static final String ITALIC        = ""\\i"";
  public RtfTransferableData(@NotNull SyntaxInfo syntaxInfo) {
    super(syntaxInfo, FLAVOR);
  }",method,
"  @Override
  protected void build(@NotNull final StringBuilder holder, final int maxLength) {
    holder.append(HEADER_PREFIX);
    holder.append(""{\\colortbl;"");
    ColorRegistry colorRegistry = mySyntaxInfo.getColorRegistry();
    for (int id : colorRegistry.getAllIds()) {
      Color color = colorRegistry.dataById(id);
      int[] components = getAdjustedColorComponents(color);
      holder.append(String.format(""\\red%d\\green%d\\blue%d;"", components[0], components[1], components[2]));
    }
    holder.append(""}\n"");
    holder.append(""{\\fonttbl"");
    FontNameRegistry fontNameRegistry = mySyntaxInfo.getFontNameRegistry();
    for (int id : fontNameRegistry.getAllIds()) {
      String fontName = fontNameRegistry.dataById(id);
      holder.append(String.format(""{\\f%d %s;}"", id, fontName));
    }
    holder.append(""}\n"");
    holder.append(""\n\\s0\\box"")
      .append(""\\cbpat"").append(mySyntaxInfo.getDefaultBackground())
      .append(""\\cb"").append(mySyntaxInfo.getDefaultBackground())
      .append(""\\cf"").append(mySyntaxInfo.getDefaultForeground());
    addFontSize(holder, mySyntaxInfo.getFontSize());
    holder.append('\n');
    mySyntaxInfo.processOutputInfo(new MyVisitor(holder, myRawText, mySyntaxInfo, maxLength));
    holder.append(""\\par"");
    holder.append(HEADER_SUFFIX);
  }",method,
"  private static int[] getAdjustedColorComponents(Color color) {
    if (SystemInfo.isMac) {
      // on Mac OS color components are expected in Apple's 'Generic RGB' color space
      ColorSpace genericRgbSpace = MacOSApplicationProvider.getInstance().getGenericRgbColorSpace();
      if (genericRgbSpace != null) {
        float[] components = genericRgbSpace.fromRGB(color.getRGBColorComponents(null));
        return new int[] {
          colorComponentFloatToInt(components[0]), 
          colorComponentFloatToInt(components[1]), 
          colorComponentFloatToInt(components[2])
        };
      }
    }
    return new int[] {color.getRed(), color.getGreen(), color.getBlue()};
  }",method,
"    if (SystemInfo.isMac) {
      // on Mac OS color components are expected in Apple's 'Generic RGB' color space
      ColorSpace genericRgbSpace = MacOSApplicationProvider.getInstance().getGenericRgbColorSpace();
      if (genericRgbSpace != null) {
        float[] components = genericRgbSpace.fromRGB(color.getRGBColorComponents(null));
        return new int[] {
          colorComponentFloatToInt(components[0]), 
          colorComponentFloatToInt(components[1]), 
          colorComponentFloatToInt(components[2])
        };
      }
    }",method,
"      if (genericRgbSpace != null) {
        float[] components = genericRgbSpace.fromRGB(color.getRGBColorComponents(null));
        return new int[] {
          colorComponentFloatToInt(components[0]), 
          colorComponentFloatToInt(components[1]), 
          colorComponentFloatToInt(components[2])
        };
      }",method,
"  private static int colorComponentFloatToInt(float component) {
    return (int)(component * 255 + 0.5f);
  }",method,
"  @NotNull
  @Override
  protected String getCharset() {
    return ""US-ASCII"";
  }",method,
"  private static void addFontSize(StringBuilder buffer, float fontSize) {
    buffer.append(""\\fs"").append(Math.round(fontSize * 2));
  }",method,
"  @Override
  public int getPriority() {
    return PRIORITY;
  }",method,
"    MyVisitor(@NotNull StringBuilder buffer, @NotNull String rawText, @NotNull SyntaxInfo syntaxInfo, int maxLength) {
      myBuffer = buffer;
      myRawText = rawText;
      myMaxLength = maxLength;
      myDefaultBackgroundId = syntaxInfo.getDefaultBackground();
      myFontSize = syntaxInfo.getFontSize();
    }",method,
"    @Override
    public void handleText(int startOffset, int endOffset) throws Exception {
      myBuffer.append(""\n"");
      for (int i = startOffset; i < endOffset; i++) {
        char c = myRawText.charAt(i);
        if (c > 127) {
          // Escape non-ascii symbols.
          myBuffer.append(String.format(""\\u%04d?"", (int)c));
          continue;
        }
        switch (c) {
          case '\t':
            myBuffer.append(TAB);
            continue;
          case '\n':
            myBuffer.append(NEW_LINE);
            continue;
          case '\\':
          case '{':
          case '}':
            myBuffer.append('\\');
        }
        myBuffer.append(c);
      }
    }",method,
"      for (int i = startOffset; i < endOffset; i++) {
        char c = myRawText.charAt(i);
        if (c > 127) {
          // Escape non-ascii symbols.
          myBuffer.append(String.format(""\\u%04d?"", (int)c));
          continue;
        }
        switch (c) {
          case '\t':
            myBuffer.append(TAB);
            continue;
          case '\n':
            myBuffer.append(NEW_LINE);
            continue;
          case '\\':
          case '{':
          case '}':
            myBuffer.append('\\');
        }
        myBuffer.append(c);
      }",method,
"        if (c > 127) {
          // Escape non-ascii symbols.
          myBuffer.append(String.format(""\\u%04d?"", (int)c));
          continue;
        }",method,
"        switch (c) {
          case '\t':
            myBuffer.append(TAB);
            continue;
          case '\n':
            myBuffer.append(NEW_LINE);
            continue;
          case '\\':
          case '{':
          case '}':
            myBuffer.append('\\');
        }",method,
"    @Override
    public void handleBackground(int backgroundId) throws Exception {
      if (backgroundId == myDefaultBackgroundId) {
        myBuffer.append(""\\plain""); // we cannot use \chcbpat with default background id, as it doesn't work in MS Word,
                                    // and we cannot use \chcbpat0 as it doesn't work in OpenOffice
        addFontSize(myBuffer, myFontSize);
        if (myFontNameId >= 0) {
          handleFont(myFontNameId);
        }
        if (myForegroundId >= 0) {
          handleForeground(myForegroundId);
        }
        if (myFontStyle >= 0) {
          handleStyle(myFontStyle);
        }
      }
      else {
        myBuffer.append(""\\chcbpat"").append(backgroundId);
      }
      myBuffer.append(""\\cb"").append(backgroundId);
      myBuffer.append('\n');
    }",method,
"      if (backgroundId == myDefaultBackgroundId) {
        myBuffer.append(""\\plain""); // we cannot use \chcbpat with default background id, as it doesn't work in MS Word,
                                    // and we cannot use \chcbpat0 as it doesn't work in OpenOffice
        addFontSize(myBuffer, myFontSize);
        if (myFontNameId >= 0) {
          handleFont(myFontNameId);
        }
        if (myForegroundId >= 0) {
          handleForeground(myForegroundId);
        }
        if (myFontStyle >= 0) {
          handleStyle(myFontStyle);
        }
      }",method,
"        if (myFontNameId >= 0) {
          handleFont(myFontNameId);
        }",method,
"        if (myForegroundId >= 0) {
          handleForeground(myForegroundId);
        }",method,
"        if (myFontStyle >= 0) {
          handleStyle(myFontStyle);
        }",method,
"    @Override
    public void handleForeground(int foregroundId) throws Exception {
      myBuffer.append(""\\cf"").append(foregroundId).append('\n');
      myForegroundId = foregroundId;
    }",method,
"    @Override
    public void handleFont(int fontNameId) throws Exception {
      myBuffer.append(""\\f"").append(fontNameId).append('\n');
      myFontNameId = fontNameId;
    }",method,
"    @Override
    public void handleStyle(int style) throws Exception {
      myBuffer.append(ITALIC);
      if ((style & Font.ITALIC) == 0) {
        myBuffer.append('0');
      }
      myBuffer.append(BOLD);
      if ((style & Font.BOLD) == 0) {
        myBuffer.append('0');
      }
      myBuffer.append('\n');
      myFontStyle = style;
    }",method,
"    @Override
    public boolean canHandleMore() {
      if (myBuffer.length() > myMaxLength) {
        myBuffer.append(""... truncated ..."");
        return false;
      }
      return true;
    }",method,
"import org.elasticsearch.common.inject.spi.InjectionPoint;
class ConstructorInjectorStore {
    private final InjectorImpl injector;
    private final FailableCache<TypeLiteral<?>, ConstructorInjector<?>> cache
            = new FailableCache<TypeLiteral<?>, ConstructorInjector<?>>() {
        @Override
        @SuppressWarnings(""unchecked"")
        protected ConstructorInjector<?> create(TypeLiteral<?> type, Errors errors)
                throws ErrorsException {
            return createConstructor(type, errors);
        }
    };
    ConstructorInjectorStore(InjectorImpl injector) {
        this.injector = injector;
    }
    @SuppressWarnings(""unchecked"") // the ConstructorInjector type always agrees with the passed type
    public <T> ConstructorInjector<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException {
        return (ConstructorInjector<T>) cache.get(key, errors);
    }
    private <T> ConstructorInjector<T> createConstructor(TypeLiteral<T> type, Errors errors)
            throws ErrorsException {
        int numErrorsBefore = errors.size();
        InjectionPoint injectionPoint;
        try {
            injectionPoint = InjectionPoint.forConstructorOf(type);
        } catch (ConfigurationException e) {
            errors.merge(e.getErrorMessages());
            throw errors.toException();
        }
        SingleParameterInjector<?>[] constructorParameterInjectors
                = injector.getParametersInjectors(injectionPoint.getDependencies(), errors);
        MembersInjectorImpl<T> membersInjector = injector.membersInjectorStore.get(type, errors);
        ConstructionProxyFactory<T> factory = new DefaultConstructionProxyFactory<>(injectionPoint);
        errors.throwIfNewErrors(numErrorsBefore);
        return new ConstructorInjector<>(membersInjector.getInjectionPoints(), factory.create(),
                constructorParameterInjectors, membersInjector);
    }
}",class,
"        @Override
        @SuppressWarnings(""unchecked"")
        protected ConstructorInjector<?> create(TypeLiteral<?> type, Errors errors)
                throws ErrorsException {
            return createConstructor(type, errors);
        }",method,
"    ConstructorInjectorStore(InjectorImpl injector) {
        this.injector = injector;
    }",method,
"    @SuppressWarnings(""unchecked"") // the ConstructorInjector type always agrees with the passed type
    public <T> ConstructorInjector<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException {
        return (ConstructorInjector<T>) cache.get(key, errors);
    }",method,
"    private <T> ConstructorInjector<T> createConstructor(TypeLiteral<T> type, Errors errors)
            throws ErrorsException {
        int numErrorsBefore = errors.size();
        InjectionPoint injectionPoint;
        try {
            injectionPoint = InjectionPoint.forConstructorOf(type);
        } catch (ConfigurationException e) {
            errors.merge(e.getErrorMessages());
            throw errors.toException();
        }
        SingleParameterInjector<?>[] constructorParameterInjectors
                = injector.getParametersInjectors(injectionPoint.getDependencies(), errors);
        MembersInjectorImpl<T> membersInjector = injector.membersInjectorStore.get(type, errors);
        ConstructionProxyFactory<T> factory = new DefaultConstructionProxyFactory<>(injectionPoint);
        errors.throwIfNewErrors(numErrorsBefore);
        return new ConstructorInjector<>(membersInjector.getInjectionPoints(), factory.create(),
                constructorParameterInjectors, membersInjector);
    }",method,
"public class ParsedURLDataProtocolHandler 
    extends AbstractParsedURLProtocolHandler {
    static final String DATA_PROTOCOL = ""data"";
    static final String BASE64 = ""base64"";
    static final String CHARSET = ""charset"";
    public ParsedURLDataProtocolHandler() {
        super(DATA_PROTOCOL);
    }
    public ParsedURLData parseURL(ParsedURL baseURL, String urlStr) {
        // No relative form...
        return parseURL(urlStr);
    }
    public ParsedURLData parseURL(String urlStr) {
        DataParsedURLData ret = new DataParsedURLData();
        int pidx=0, idx;
        int len = urlStr.length();
        // Pull fragment id off first...
        idx = urlStr.indexOf('#');
        ret.ref = null;
        if (idx != -1) {
            if (idx + 1 < len) {
                ret.ref = urlStr.substring(idx + 1);
            }
            urlStr = urlStr.substring(0, idx);
            len = urlStr.length();
        }
        idx = urlStr.indexOf(':');
        if (idx != -1) {
            // May have a protocol spec...
            ret.protocol = urlStr.substring(pidx, idx);
            if (ret.protocol.indexOf('/') == -1)
                pidx = idx+1;
            else {
                // Got a slash in protocol probably means 
                // no protocol given, (host and port?)
                ret.protocol = null;
                pidx = 0;
            }
        }
        idx = urlStr.indexOf(',',pidx);
        if ((idx != -1) && (idx != pidx)) {
            ret.host = urlStr.substring(pidx, idx);
            pidx = idx+1;
            int aidx = ret.host.lastIndexOf(';');
            if ((aidx == -1) || (aidx==ret.host.length())) {
                ret.contentType = ret.host;
            } else {
                String enc = ret.host.substring(aidx+1);
                idx = enc.indexOf('=');
                if (idx == -1) {
                    // It is an encoding.
                    ret.contentEncoding = enc;
                    ret.contentType = ret.host.substring(0, aidx);
                } else {
                    ret.contentType = ret.host;
                }
                // if theres a charset pull it out.
                aidx = 0;
                idx = ret.contentType.indexOf(';', aidx);
                if (idx != -1) {
                    aidx = idx+1;
                    while (aidx < ret.contentType.length()) {
                        idx = ret.contentType.indexOf(';', aidx);
                        if (idx == -1) idx = ret.contentType.length();
                        String param = ret.contentType.substring(aidx, idx);
                        int eqIdx = param.indexOf('=');
                        if ((eqIdx != -1) &&
                            (CHARSET.equals(param.substring(0,eqIdx)))) 
                            ret.charset = param.substring(eqIdx+1);
                        aidx = idx+1;
                    }
                }
            }
        }
        if (pidx < urlStr.length()) {
            ret.path = urlStr.substring(pidx);
        }
        return ret;
    }
    static class DataParsedURLData extends ParsedURLData {
        String charset;
        public boolean complete() {
            return path != null;
        }
        public String getPortStr() {
            String portStr = ""data:"";
            if (host != null) {
                portStr += host;
            }
            portStr += "","";
            return portStr;
        }
        public String toString() {
            String ret = getPortStr();
            if (path != null) {
                ret += path;
            }
            if (ref != null) {
                ret += '#' + ref;
            }
            return ret;
        }
        public String getContentType(String userAgent) {
            return contentType;
        }
        public String getContentEncoding(String userAgent) {
            return contentEncoding;
        }
        protected InputStream openStreamInternal
            (String userAgent, Iterator mimeTypes, Iterator encodingTypes)
            throws IOException {
            stream = decode(path);
            if (BASE64.equals(contentEncoding)) {
                stream = new Base64DecodeStream(stream);
            }
            return stream;
        }
        public static InputStream decode(String s) {
            int len = s.length();
            byte [] data = new byte[len];
            int j=0;
            for(int i=0; i<len; i++) {
                char c = s.charAt(i);
                switch (c) {
                default : data[j++]= (byte)c;   break;
                case '%': {
                    if (i+2 < len) {
                        i += 2;
                        byte b; 
                        char c1 = s.charAt(i-1);
                        if      (c1 >= '0' && c1 <= '9') b=(byte)(c1-'0');
                        else if (c1 >= 'a' && c1 <= 'z') b=(byte)(c1-'a'+10);
                        else if (c1 >= 'A' && c1 <= 'Z') b=(byte)(c1-'A'+10);
                        else break;
                        b*=16;
                        char c2 = s.charAt(i);
                        if      (c2 >= '0' && c2 <= '9') b+=(byte)(c2-'0');
                        else if (c2 >= 'a' && c2 <= 'z') b+=(byte)(c2-'a'+10);
                        else if (c2 >= 'A' && c2 <= 'Z') b+=(byte)(c2-'A'+10);
                        else break;
                        data[j++] = b;
                    }
                }
                break;
                }
            }
            return new ByteArrayInputStream(data, 0, j);
        }
    }
}",class,
"    static class DataParsedURLData extends ParsedURLData {
        String charset;
        public boolean complete() {
            return path != null;
        }
        public String getPortStr() {
            String portStr = ""data:"";
            if (host != null) {
                portStr += host;
            }
            portStr += "","";
            return portStr;
        }
        public String toString() {
            String ret = getPortStr();
            if (path != null) {
                ret += path;
            }
            if (ref != null) {
                ret += '#' + ref;
            }
            return ret;
        }
        public String getContentType(String userAgent) {
            return contentType;
        }
        public String getContentEncoding(String userAgent) {
            return contentEncoding;
        }
        protected InputStream openStreamInternal
            (String userAgent, Iterator mimeTypes, Iterator encodingTypes)
            throws IOException {
            stream = decode(path);
            if (BASE64.equals(contentEncoding)) {
                stream = new Base64DecodeStream(stream);
            }
            return stream;
        }
        public static InputStream decode(String s) {
            int len = s.length();
            byte [] data = new byte[len];
            int j=0;
            for(int i=0; i<len; i++) {
                char c = s.charAt(i);
                switch (c) {
                default : data[j++]= (byte)c;   break;
                case '%': {
                    if (i+2 < len) {
                        i += 2;
                        byte b; 
                        char c1 = s.charAt(i-1);
                        if      (c1 >= '0' && c1 <= '9') b=(byte)(c1-'0');
                        else if (c1 >= 'a' && c1 <= 'z') b=(byte)(c1-'a'+10);
                        else if (c1 >= 'A' && c1 <= 'Z') b=(byte)(c1-'A'+10);
                        else break;
                        b*=16;
                        char c2 = s.charAt(i);
                        if      (c2 >= '0' && c2 <= '9') b+=(byte)(c2-'0');
                        else if (c2 >= 'a' && c2 <= 'z') b+=(byte)(c2-'a'+10);
                        else if (c2 >= 'A' && c2 <= 'Z') b+=(byte)(c2-'A'+10);
                        else break;
                        data[j++] = b;
                    }
                }
                break;
                }
            }
            return new ByteArrayInputStream(data, 0, j);
        }
    }",class,
"    public ParsedURLDataProtocolHandler() {
        super(DATA_PROTOCOL);
    }",method,
"    public ParsedURLData parseURL(ParsedURL baseURL, String urlStr) {
        // No relative form...
        return parseURL(urlStr);
    }",method,
"    public ParsedURLData parseURL(String urlStr) {
        DataParsedURLData ret = new DataParsedURLData();
        int pidx=0, idx;
        int len = urlStr.length();
        // Pull fragment id off first...
        idx = urlStr.indexOf('#');
        ret.ref = null;
        if (idx != -1) {
            if (idx + 1 < len) {
                ret.ref = urlStr.substring(idx + 1);
            }
            urlStr = urlStr.substring(0, idx);
            len = urlStr.length();
        }
        idx = urlStr.indexOf(':');
        if (idx != -1) {
            // May have a protocol spec...
            ret.protocol = urlStr.substring(pidx, idx);
            if (ret.protocol.indexOf('/') == -1)
                pidx = idx+1;
            else {
                // Got a slash in protocol probably means 
                // no protocol given, (host and port?)
                ret.protocol = null;
                pidx = 0;
            }
        }
        idx = urlStr.indexOf(',',pidx);
        if ((idx != -1) && (idx != pidx)) {
            ret.host = urlStr.substring(pidx, idx);
            pidx = idx+1;
            int aidx = ret.host.lastIndexOf(';');
            if ((aidx == -1) || (aidx==ret.host.length())) {
                ret.contentType = ret.host;
            } else {
                String enc = ret.host.substring(aidx+1);
                idx = enc.indexOf('=');
                if (idx == -1) {
                    // It is an encoding.
                    ret.contentEncoding = enc;
                    ret.contentType = ret.host.substring(0, aidx);
                } else {
                    ret.contentType = ret.host;
                }
                // if theres a charset pull it out.
                aidx = 0;
                idx = ret.contentType.indexOf(';', aidx);
                if (idx != -1) {
                    aidx = idx+1;
                    while (aidx < ret.contentType.length()) {
                        idx = ret.contentType.indexOf(';', aidx);
                        if (idx == -1) idx = ret.contentType.length();
                        String param = ret.contentType.substring(aidx, idx);
                        int eqIdx = param.indexOf('=');
                        if ((eqIdx != -1) &&
                            (CHARSET.equals(param.substring(0,eqIdx)))) 
                            ret.charset = param.substring(eqIdx+1);
                        aidx = idx+1;
                    }
                }
            }
        }
        if (pidx < urlStr.length()) {
            ret.path = urlStr.substring(pidx);
        }
        return ret;
    }",method,
"        if (idx != -1) {
            if (idx + 1 < len) {
                ret.ref = urlStr.substring(idx + 1);
            }
            urlStr = urlStr.substring(0, idx);
            len = urlStr.length();
        }",method,
"            if (idx + 1 < len) {
                ret.ref = urlStr.substring(idx + 1);
            }",method,
"        if (idx != -1) {
            // May have a protocol spec...
            ret.protocol = urlStr.substring(pidx, idx);
            if (ret.protocol.indexOf('/') == -1)
                pidx = idx+1;
            else {
                // Got a slash in protocol probably means 
                // no protocol given, (host and port?)
                ret.protocol = null;
                pidx = 0;
            }
        }",method,
"                if (idx == -1) {
                    // It is an encoding.
                    ret.contentEncoding = enc;
                    ret.contentType = ret.host.substring(0, aidx);
                }",method,
"                if (idx != -1) {
                    aidx = idx+1;
                    while (aidx < ret.contentType.length()) {
                        idx = ret.contentType.indexOf(';', aidx);
                        if (idx == -1) idx = ret.contentType.length();
                        String param = ret.contentType.substring(aidx, idx);
                        int eqIdx = param.indexOf('=');
                        if ((eqIdx != -1) &&
                            (CHARSET.equals(param.substring(0,eqIdx)))) 
                            ret.charset = param.substring(eqIdx+1);
                        aidx = idx+1;
                    }
                }",method,
"        public boolean complete() {
            return path != null;
        }",method,
"        public String getPortStr() {
            String portStr = ""data:"";
            if (host != null) {
                portStr += host;
            }
            portStr += "","";
            return portStr;
        }",method,
"            if (host != null) {
                portStr += host;
            }",method,
"        public String toString() {
            String ret = getPortStr();
            if (path != null) {
                ret += path;
            }
            if (ref != null) {
                ret += '#' + ref;
            }
            return ret;
        }",method,
"            if (path != null) {
                ret += path;
            }",method,
"            if (ref != null) {
                ret += '#' + ref;
            }",method,
"        public String getContentType(String userAgent) {
            return contentType;
        }",method,
"        public String getContentEncoding(String userAgent) {
            return contentEncoding;
        }",method,
"        protected InputStream openStreamInternal
            (String userAgent, Iterator mimeTypes, Iterator encodingTypes)
            throws IOException {
            stream = decode(path);
            if (BASE64.equals(contentEncoding)) {
                stream = new Base64DecodeStream(stream);
            }
            return stream;
        }",method,
"        public static InputStream decode(String s) {
            int len = s.length();
            byte [] data = new byte[len];
            int j=0;
            for(int i=0; i<len; i++) {
                char c = s.charAt(i);
                switch (c) {
                default : data[j++]= (byte)c;   break;
                case '%': {
                    if (i+2 < len) {
                        i += 2;
                        byte b; 
                        char c1 = s.charAt(i-1);
                        if      (c1 >= '0' && c1 <= '9') b=(byte)(c1-'0');
                        else if (c1 >= 'a' && c1 <= 'z') b=(byte)(c1-'a'+10);
                        else if (c1 >= 'A' && c1 <= 'Z') b=(byte)(c1-'A'+10);
                        else break;
                        b*=16;
                        char c2 = s.charAt(i);
                        if      (c2 >= '0' && c2 <= '9') b+=(byte)(c2-'0');
                        else if (c2 >= 'a' && c2 <= 'z') b+=(byte)(c2-'a'+10);
                        else if (c2 >= 'A' && c2 <= 'Z') b+=(byte)(c2-'A'+10);
                        else break;
                        data[j++] = b;
                    }
                }
                break;
                }
            }
            return new ByteArrayInputStream(data, 0, j);
        }",method,
"            for(int i=0; i<len; i++) {
                char c = s.charAt(i);
                switch (c) {
                default : data[j++]= (byte)c;   break;
                case '%': {
                    if (i+2 < len) {
                        i += 2;
                        byte b; 
                        char c1 = s.charAt(i-1);
                        if      (c1 >= '0' && c1 <= '9') b=(byte)(c1-'0');
                        else if (c1 >= 'a' && c1 <= 'z') b=(byte)(c1-'a'+10);
                        else if (c1 >= 'A' && c1 <= 'Z') b=(byte)(c1-'A'+10);
                        else break;
                        b*=16;
                        char c2 = s.charAt(i);
                        if      (c2 >= '0' && c2 <= '9') b+=(byte)(c2-'0');
                        else if (c2 >= 'a' && c2 <= 'z') b+=(byte)(c2-'a'+10);
                        else if (c2 >= 'A' && c2 <= 'Z') b+=(byte)(c2-'A'+10);
                        else break;
                        data[j++] = b;
                    }
                }
                break;
                }
            }",method,
"                switch (c) {
                default : data[j++]= (byte)c;   break;
                case '%': {
                    if (i+2 < len) {
                        i += 2;
                        byte b; 
                        char c1 = s.charAt(i-1);
                        if      (c1 >= '0' && c1 <= '9') b=(byte)(c1-'0');
                        else if (c1 >= 'a' && c1 <= 'z') b=(byte)(c1-'a'+10);
                        else if (c1 >= 'A' && c1 <= 'Z') b=(byte)(c1-'A'+10);
                        else break;
                        b*=16;
                        char c2 = s.charAt(i);
                        if      (c2 >= '0' && c2 <= '9') b+=(byte)(c2-'0');
                        else if (c2 >= 'a' && c2 <= 'z') b+=(byte)(c2-'a'+10);
                        else if (c2 >= 'A' && c2 <= 'Z') b+=(byte)(c2-'A'+10);
                        else break;
                        data[j++] = b;
                    }
                }
                break;
                }",method,
"                    if (i+2 < len) {
                        i += 2;
                        byte b; 
                        char c1 = s.charAt(i-1);
                        if      (c1 >= '0' && c1 <= '9') b=(byte)(c1-'0');
                        else if (c1 >= 'a' && c1 <= 'z') b=(byte)(c1-'a'+10);
                        else if (c1 >= 'A' && c1 <= 'Z') b=(byte)(c1-'A'+10);
                        else break;
                        b*=16;
                        char c2 = s.charAt(i);
                        if      (c2 >= '0' && c2 <= '9') b+=(byte)(c2-'0');
                        else if (c2 >= 'a' && c2 <= 'z') b+=(byte)(c2-'a'+10);
                        else if (c2 >= 'A' && c2 <= 'Z') b+=(byte)(c2-'A'+10);
                        else break;
                        data[j++] = b;
                    }",method,
"public class JavaLinearRegressionSuite implements Serializable {
  private transient JavaSparkContext sc;
  @Before
  public void setUp() {
    sc = new JavaSparkContext(""local"", ""JavaLinearRegressionSuite"");
  }
  @After
  public void tearDown() {
    sc.stop();
    sc = null;
    System.clearProperty(""spark.driver.port"");
  }
  int validatePrediction(List<LabeledPoint> validationData, LinearRegressionModel model) {
    int numAccurate = 0;
    for (LabeledPoint point: validationData) {
        Double prediction = model.predict(point.features());
        // A prediction is off if the prediction is more than 0.5 away from expected value.
        if (Math.abs(prediction - point.label()) <= 0.5) {
            numAccurate++;
        }
    }
    return numAccurate;
  }
  @Test
  public void runLinearRegressionUsingConstructor() {
    int nPoints = 100;
    double A = 3.0;
    double[] weights = {10, 10};
    JavaRDD<LabeledPoint> testRDD = sc.parallelize(
        LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();
    List<LabeledPoint> validationData =
            LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);
    LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD();
    LinearRegressionModel model = linSGDImpl.run(testRDD.rdd());
    int numAccurate = validatePrediction(validationData, model);
    Assert.assertTrue(numAccurate > nPoints * 4.0 / 5.0);
  }
  @Test
  public void runLinearRegressionUsingStaticMethods() {
    int nPoints = 100;
    double A = 3.0;
    double[] weights = {10, 10};
    JavaRDD<LabeledPoint> testRDD = sc.parallelize(
        LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();
    List<LabeledPoint> validationData =
            LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);
    LinearRegressionModel model = LinearRegressionWithSGD.train(testRDD.rdd(), 100);
    int numAccurate = validatePrediction(validationData, model);
    Assert.assertTrue(numAccurate > nPoints * 4.0 / 5.0);
  }
}",class,
"  @Before
  public void setUp() {
    sc = new JavaSparkContext(""local"", ""JavaLinearRegressionSuite"");
  }",method,
"  @After
  public void tearDown() {
    sc.stop();
    sc = null;
    System.clearProperty(""spark.driver.port"");
  }",method,
"  int validatePrediction(List<LabeledPoint> validationData, LinearRegressionModel model) {
    int numAccurate = 0;
    for (LabeledPoint point: validationData) {
        Double prediction = model.predict(point.features());
        // A prediction is off if the prediction is more than 0.5 away from expected value.
        if (Math.abs(prediction - point.label()) <= 0.5) {
            numAccurate++;
        }
    }
    return numAccurate;
  }",method,
"    for (LabeledPoint point: validationData) {
        Double prediction = model.predict(point.features());
        // A prediction is off if the prediction is more than 0.5 away from expected value.
        if (Math.abs(prediction - point.label()) <= 0.5) {
            numAccurate++;
        }
    }",method,
"  @Test
  public void runLinearRegressionUsingConstructor() {
    int nPoints = 100;
    double A = 3.0;
    double[] weights = {10, 10};
    JavaRDD<LabeledPoint> testRDD = sc.parallelize(
        LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();
    List<LabeledPoint> validationData =
            LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);
    LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD();
    LinearRegressionModel model = linSGDImpl.run(testRDD.rdd());
    int numAccurate = validatePrediction(validationData, model);
    Assert.assertTrue(numAccurate > nPoints * 4.0 / 5.0);
  }",method,
"  @Test
  public void runLinearRegressionUsingStaticMethods() {
    int nPoints = 100;
    double A = 3.0;
    double[] weights = {10, 10};
    JavaRDD<LabeledPoint> testRDD = sc.parallelize(
        LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();
    List<LabeledPoint> validationData =
            LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);
    LinearRegressionModel model = LinearRegressionWithSGD.train(testRDD.rdd(), 100);
    int numAccurate = validatePrediction(validationData, model);
    Assert.assertTrue(numAccurate > nPoints * 4.0 / 5.0);
  }",method,
"public class DnsNameResolverClientSubnetTest {
    // See https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html
    // Ignore as this needs to query real DNS servers.
    @Ignore
    @Test
    public void testSubnetQuery() throws Exception {
        EventLoopGroup group = new NioEventLoopGroup(1);
        DnsNameResolver resolver = newResolver(group).build();
        try {
            // Same as:
            // # /.bind-9.9.3-edns/bin/dig @ns1.google.com www.google.es +client=157.88.0.0/24
            Future<List<InetAddress>> future = resolver.resolveAll(""www.google.es"",
                    Collections.<DnsRecord>singleton(
                            // Suggest max payload size of 1024
                            // 157.88.0.0 / 24
                            new DefaultDnsOptEcsRecord(1024, 24,
                                                       SocketUtils.addressByName(""157.88.0.0"").getAddress())));
            for (InetAddress address: future.syncUninterruptibly().getNow()) {
                System.err.println(address);
            }
        } finally {
            resolver.close();
            group.shutdownGracefully(0, 0, TimeUnit.SECONDS);
        }
    }
    private static DnsNameResolverBuilder newResolver(EventLoopGroup group) {
        return new DnsNameResolverBuilder(group.next())
                .channelType(NioDatagramChannel.class)
                .nameServerProvider(
                        new SingletonDnsServerAddressStreamProvider(SocketUtils.socketAddress(""8.8.8.8"", 53)))
                .maxQueriesPerResolve(1)
                .optResourceEnabled(false)
                .ndots(1);
    }
}",class,
"    @Ignore
    @Test
    public void testSubnetQuery() throws Exception {
        EventLoopGroup group = new NioEventLoopGroup(1);
        DnsNameResolver resolver = newResolver(group).build();
        try {
            // Same as:
            // # /.bind-9.9.3-edns/bin/dig @ns1.google.com www.google.es +client=157.88.0.0/24
            Future<List<InetAddress>> future = resolver.resolveAll(""www.google.es"",
                    Collections.<DnsRecord>singleton(
                            // Suggest max payload size of 1024
                            // 157.88.0.0 / 24
                            new DefaultDnsOptEcsRecord(1024, 24,
                                                       SocketUtils.addressByName(""157.88.0.0"").getAddress())));
            for (InetAddress address: future.syncUninterruptibly().getNow()) {
                System.err.println(address);
            }
        } finally {
            resolver.close();
            group.shutdownGracefully(0, 0, TimeUnit.SECONDS);
        }
    }",method,
"    private static DnsNameResolverBuilder newResolver(EventLoopGroup group) {
        return new DnsNameResolverBuilder(group.next())
                .channelType(NioDatagramChannel.class)
                .nameServerProvider(
                        new SingletonDnsServerAddressStreamProvider(SocketUtils.socketAddress(""8.8.8.8"", 53)))
                .maxQueriesPerResolve(1)
                .optResourceEnabled(false)
                .ndots(1);
    }",method,

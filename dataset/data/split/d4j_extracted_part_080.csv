code_snippet,type,score
"  public DoubleVector compute() {
    return new DoubleArrayVector(1,2,3);
  }",method,
"  public List<MyChildBean> getChildBeans() {
    return Arrays.asList(new MyChildBean(), new MyChildBean());
  }",method,
"  public int intVarArg(String dummy, int... toSum) {
    int sum = 0;
    for(int x : toSum) {
      sum += x;
    }
    return sum;
  }",method,
"    for(int x : toSum) {
      sum += x;
    }",method,
"    public int getCount() {
      return 42;
    }",method,
"  public void methodWithContext(@Current Context context, String name) {
    java.lang.System.out.println(context);
  }",method,
"  public void overloadedWithVarArgs(String label, String... sources) {
  }",method,
"  public void overloadedWithVarArgs(String label, Collection<String> sources) {
  }",method,
"  public void overloadedWithVarArgs(Object mapping) {
  }",method,
"  public static double sum(double... values) {
    double sum = 0;
    for(int i=0;i!=values.length;++i) {
      sum += values[i];
    }
    return sum;
  }",method,
"    for(int i=0;i!=values.length;++i) {
      sum += values[i];
    }",method,
"  public static float sum32(float x, float y) {
    return x + y;
  }",method,
"  public static float sumArray32(float[] values) {
    float sum = 0;
    for (int i = 0; i < values.length; i++) {
      sum += values[i];
    }
    return sum;
  }",method,
"    for (int i = 0; i < values.length; i++) {
      sum += values[i];
    }",method,
"  public static long sumArrayLong(long[] values) {
    long sum = 0;
    for (int i = 0; i < values.length; i++) {
      sum += values[i];
    }
    return sum;
  }",method,
"    for (int i = 0; i < values.length; i++) {
      sum += values[i];
    }",method,
"  public static long calculateLong() {
    return LONG_VALUE;
  }",method,
"  public static void useLongValue(long value) {
    if(value != LONG_VALUE) {
      throw new AssertionError(""long has been mangled by R"");
    }
  }",method,
"    if(value != LONG_VALUE) {
      throw new AssertionError(""long has been mangled by R"");
    }",method,
"public class TestVarbinaryType
        extends AbstractTestType
{
    public TestVarbinaryType()
    {
        super(VARBINARY, SqlVarbinary.class, createTestBlock());
    }
    public static Block createTestBlock()
    {
        BlockBuilder blockBuilder = VARBINARY.createBlockBuilder(new BlockBuilderStatus(), 15);
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""apple""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""apple""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""apple""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""cherry""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""cherry""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""date""));
        return blockBuilder.build();
    }
    @Override
    protected Object getGreaterValue(Object value)
    {
        return Slices.utf8Slice(((Slice) value).toStringUtf8() + ""_"");
    }
}",class,
"    public TestVarbinaryType()
    {
        super(VARBINARY, SqlVarbinary.class, createTestBlock());
    }",method,
"    public static Block createTestBlock()
    {
        BlockBuilder blockBuilder = VARBINARY.createBlockBuilder(new BlockBuilderStatus(), 15);
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""apple""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""apple""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""apple""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""banana""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""cherry""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""cherry""));
        VARBINARY.writeSlice(blockBuilder, Slices.utf8Slice(""date""));
        return blockBuilder.build();
    }",method,
"    @Override
    protected Object getGreaterValue(Object value)
    {
        return Slices.utf8Slice(((Slice) value).toStringUtf8() + ""_"");
    }",method,
"public final class IsoDep extends BasicTagTechnology {
    private static final String TAG = ""NFC"";
    public static final String EXTRA_HI_LAYER_RESP = ""hiresp"";
    public static final String EXTRA_HIST_BYTES = ""histbytes"";
    private byte[] mHiLayerResponse = null;
    private byte[] mHistBytes = null;
    public static IsoDep get(Tag tag) {
        if (!tag.hasTech(TagTechnology.ISO_DEP)) return null;
        try {
            return new IsoDep(tag);
        } catch (RemoteException e) {
            return null;
        }
    }
    public IsoDep(Tag tag)
            throws RemoteException {
        super(tag, TagTechnology.ISO_DEP);
        Bundle extras = tag.getTechExtras(TagTechnology.ISO_DEP);
        if (extras != null) {
            mHiLayerResponse = extras.getByteArray(EXTRA_HI_LAYER_RESP);
            mHistBytes = extras.getByteArray(EXTRA_HIST_BYTES);
        }
    }
    public void setTimeout(int timeout) {
        try {
            int err = mTag.getTagService().setTimeout(TagTechnology.ISO_DEP, timeout);
            if (err != ErrorCodes.SUCCESS) {
                throw new IllegalArgumentException(""The supplied timeout is not valid"");
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""NFC service dead"", e);
        }
    }
    public int getTimeout() {
        try {
            return mTag.getTagService().getTimeout(TagTechnology.ISO_DEP);
        } catch (RemoteException e) {
            Log.e(TAG, ""NFC service dead"", e);
            return 0;
        }
    }
    public byte[] getHistoricalBytes() {
        return mHistBytes;
    }
    public byte[] getHiLayerResponse() {
        return mHiLayerResponse;
    }
    public byte[] transceive(byte[] data) throws IOException {
        return transceive(data, true);
    }
    public int getMaxTransceiveLength() {
        return getMaxTransceiveLengthInternal();
    }
    public boolean isExtendedLengthApduSupported() {
        try {
            return mTag.getTagService().getExtendedLengthApdusSupported();
        } catch (RemoteException e) {
            Log.e(TAG, ""NFC service dead"", e);
            return false;
        }
    }
}",class,
"    public static IsoDep get(Tag tag) {
        if (!tag.hasTech(TagTechnology.ISO_DEP)) return null;
        try {
            return new IsoDep(tag);
        } catch (RemoteException e) {
            return null;
        }
    }",method,
"    public IsoDep(Tag tag)
            throws RemoteException {
        super(tag, TagTechnology.ISO_DEP);
        Bundle extras = tag.getTechExtras(TagTechnology.ISO_DEP);
        if (extras != null) {
            mHiLayerResponse = extras.getByteArray(EXTRA_HI_LAYER_RESP);
            mHistBytes = extras.getByteArray(EXTRA_HIST_BYTES);
        }
    }",method,
"        if (extras != null) {
            mHiLayerResponse = extras.getByteArray(EXTRA_HI_LAYER_RESP);
            mHistBytes = extras.getByteArray(EXTRA_HIST_BYTES);
        }",method,
"    public void setTimeout(int timeout) {
        try {
            int err = mTag.getTagService().setTimeout(TagTechnology.ISO_DEP, timeout);
            if (err != ErrorCodes.SUCCESS) {
                throw new IllegalArgumentException(""The supplied timeout is not valid"");
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""NFC service dead"", e);
        }
    }",method,
"            if (err != ErrorCodes.SUCCESS) {
                throw new IllegalArgumentException(""The supplied timeout is not valid"");
            }",method,
"    public int getTimeout() {
        try {
            return mTag.getTagService().getTimeout(TagTechnology.ISO_DEP);
        } catch (RemoteException e) {
            Log.e(TAG, ""NFC service dead"", e);
            return 0;
        }
    }",method,
"    public byte[] getHistoricalBytes() {
        return mHistBytes;
    }",method,
"    public byte[] getHiLayerResponse() {
        return mHiLayerResponse;
    }",method,
"    public byte[] transceive(byte[] data) throws IOException {
        return transceive(data, true);
    }",method,
"    public int getMaxTransceiveLength() {
        return getMaxTransceiveLengthInternal();
    }",method,
"    public boolean isExtendedLengthApduSupported() {
        try {
            return mTag.getTagService().getExtendedLengthApdusSupported();
        } catch (RemoteException e) {
            Log.e(TAG, ""NFC service dead"", e);
            return false;
        }
    }",method,
"public class MavenDependenciesCompletionProvider extends CompletionContributor {
  @Override
  public void fillCompletionVariants(@NotNull CompletionParameters parameters, @NotNull CompletionResultSet result) {
    PsiElement xmlText = parameters.getPosition().getParent();
    if (!(xmlText instanceof XmlText)) return;
    PsiElement eDependencyTag = xmlText.getParent();
    if (!(eDependencyTag instanceof XmlTag)) return;
    XmlTag dependencyTag = (XmlTag)eDependencyTag;
    if (!""dependency"".equals(dependencyTag.getName())) return;
    if (!PsiImplUtil.isLeafElementOfType(xmlText.getPrevSibling(), XmlTokenType.XML_TAG_END)
      || !PsiImplUtil.isLeafElementOfType(xmlText.getNextSibling(), XmlTokenType.XML_END_TAG_START)) {
      return;
    }
    Project project = dependencyTag.getProject();
    DomElement domElement = DomManager.getDomManager(project).getDomElement(dependencyTag);
    if (!(domElement instanceof MavenDomDependency)) {
      return;
    }
    MavenProjectIndicesManager indicesManager = MavenProjectIndicesManager.getInstance(project);
    for (String groupId : indicesManager.getGroupIds()) {
      for (String artifactId : indicesManager.getArtifactIds(groupId)) {
        LookupElement builder = LookupElementBuilder.create(groupId + ':' + artifactId)
          .withIcon(AllIcons.Nodes.PpLib).withInsertHandler(MavenDependencyInsertHandler.INSTANCE);
        result.addElement(builder);
      }
    }
  }
  private static class MavenDependencyInsertHandler implements InsertHandler<LookupElement> {
    public static final InsertHandler<LookupElement> INSTANCE = new MavenDependencyInsertHandler();
    @Override
    public void handleInsert(final InsertionContext context, LookupElement item) {
      String s = item.getLookupString();
      int idx = s.indexOf(':');
      String groupId = s.substring(0, idx);
      String artifactId = s.substring(idx + 1);
      int startOffset = context.getStartOffset();
      PsiFile psiFile = context.getFile();
      DomFileElement<MavenDomProjectModel> domModel = DomManager.getDomManager(context.getProject()).getFileElement((XmlFile)psiFile, MavenDomProjectModel.class);
      if (domModel == null) return;
      boolean shouldInvokeCompletion = false;
      MavenDomDependency managedDependency = MavenDependencyCompletionUtil.findManagedDependency(domModel.getRootElement(),
                                                                                                 context.getProject(), groupId, artifactId);
      if (managedDependency == null) {
        String value = ""<groupId>"" + groupId + ""</groupId>\n"" +
                       ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                       ""<version></version>"";
        context.getDocument().replaceString(startOffset, context.getSelectionEndOffset(), value);
        context.getEditor().getCaretModel().moveToOffset(startOffset + value.length() - 10);
        shouldInvokeCompletion = true;
      }
      else {
        StringBuilder sb = new StringBuilder();
        sb.append(""<groupId>"").append(groupId).append(""</groupId>\n"")
          .append(""<artifactId>"").append(artifactId).append(""</artifactId>\n"");
        String type = managedDependency.getType().getRawText();
        if (type != null && !type.equals(""jar"")) {
          sb.append(""<type>"").append(type).append(""</type>\n"");
        }
        String classifier = managedDependency.getClassifier().getRawText();
        if (StringUtil.isNotEmpty(classifier)) {
          sb.append(""<classifier>"").append(classifier).append(""</classifier>\n"");
        }
        context.getDocument().replaceString(startOffset, context.getSelectionEndOffset(), sb);
      }
      context.commitDocument();
      PsiElement e = psiFile.findElementAt(startOffset);
      while (e != null && (!(e instanceof XmlTag) || !""dependency"".equals(((XmlTag)e).getName()))) {
        e = e.getParent();
      }
      if (e != null) {
        new ReformatCodeProcessor(psiFile.getProject(), psiFile, e.getTextRange(), false).run();
      }
      if (shouldInvokeCompletion) {
        MavenDependencyCompletionUtil.invokeCompletion(context, CompletionType.BASIC);
      }
    }
  }
}",class,
"  private static class MavenDependencyInsertHandler implements InsertHandler<LookupElement> {
    public static final InsertHandler<LookupElement> INSTANCE = new MavenDependencyInsertHandler();
    @Override
    public void handleInsert(final InsertionContext context, LookupElement item) {
      String s = item.getLookupString();
      int idx = s.indexOf(':');
      String groupId = s.substring(0, idx);
      String artifactId = s.substring(idx + 1);
      int startOffset = context.getStartOffset();
      PsiFile psiFile = context.getFile();
      DomFileElement<MavenDomProjectModel> domModel = DomManager.getDomManager(context.getProject()).getFileElement((XmlFile)psiFile, MavenDomProjectModel.class);
      if (domModel == null) return;
      boolean shouldInvokeCompletion = false;
      MavenDomDependency managedDependency = MavenDependencyCompletionUtil.findManagedDependency(domModel.getRootElement(),
                                                                                                 context.getProject(), groupId, artifactId);
      if (managedDependency == null) {
        String value = ""<groupId>"" + groupId + ""</groupId>\n"" +
                       ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                       ""<version></version>"";
        context.getDocument().replaceString(startOffset, context.getSelectionEndOffset(), value);
        context.getEditor().getCaretModel().moveToOffset(startOffset + value.length() - 10);
        shouldInvokeCompletion = true;
      }
      else {
        StringBuilder sb = new StringBuilder();
        sb.append(""<groupId>"").append(groupId).append(""</groupId>\n"")
          .append(""<artifactId>"").append(artifactId).append(""</artifactId>\n"");
        String type = managedDependency.getType().getRawText();
        if (type != null && !type.equals(""jar"")) {
          sb.append(""<type>"").append(type).append(""</type>\n"");
        }
        String classifier = managedDependency.getClassifier().getRawText();
        if (StringUtil.isNotEmpty(classifier)) {
          sb.append(""<classifier>"").append(classifier).append(""</classifier>\n"");
        }
        context.getDocument().replaceString(startOffset, context.getSelectionEndOffset(), sb);
      }
      context.commitDocument();
      PsiElement e = psiFile.findElementAt(startOffset);
      while (e != null && (!(e instanceof XmlTag) || !""dependency"".equals(((XmlTag)e).getName()))) {
        e = e.getParent();
      }
      if (e != null) {
        new ReformatCodeProcessor(psiFile.getProject(), psiFile, e.getTextRange(), false).run();
      }
      if (shouldInvokeCompletion) {
        MavenDependencyCompletionUtil.invokeCompletion(context, CompletionType.BASIC);
      }
    }
  }",class,
"  @Override
  public void fillCompletionVariants(@NotNull CompletionParameters parameters, @NotNull CompletionResultSet result) {
    PsiElement xmlText = parameters.getPosition().getParent();
    if (!(xmlText instanceof XmlText)) return;
    PsiElement eDependencyTag = xmlText.getParent();
    if (!(eDependencyTag instanceof XmlTag)) return;
    XmlTag dependencyTag = (XmlTag)eDependencyTag;
    if (!""dependency"".equals(dependencyTag.getName())) return;
    if (!PsiImplUtil.isLeafElementOfType(xmlText.getPrevSibling(), XmlTokenType.XML_TAG_END)
      || !PsiImplUtil.isLeafElementOfType(xmlText.getNextSibling(), XmlTokenType.XML_END_TAG_START)) {
      return;
    }
    Project project = dependencyTag.getProject();
    DomElement domElement = DomManager.getDomManager(project).getDomElement(dependencyTag);
    if (!(domElement instanceof MavenDomDependency)) {
      return;
    }
    MavenProjectIndicesManager indicesManager = MavenProjectIndicesManager.getInstance(project);
    for (String groupId : indicesManager.getGroupIds()) {
      for (String artifactId : indicesManager.getArtifactIds(groupId)) {
        LookupElement builder = LookupElementBuilder.create(groupId + ':' + artifactId)
          .withIcon(AllIcons.Nodes.PpLib).withInsertHandler(MavenDependencyInsertHandler.INSTANCE);
        result.addElement(builder);
      }
    }
  }",method,
"    @Override
    public void handleInsert(final InsertionContext context, LookupElement item) {
      String s = item.getLookupString();
      int idx = s.indexOf(':');
      String groupId = s.substring(0, idx);
      String artifactId = s.substring(idx + 1);
      int startOffset = context.getStartOffset();
      PsiFile psiFile = context.getFile();
      DomFileElement<MavenDomProjectModel> domModel = DomManager.getDomManager(context.getProject()).getFileElement((XmlFile)psiFile, MavenDomProjectModel.class);
      if (domModel == null) return;
      boolean shouldInvokeCompletion = false;
      MavenDomDependency managedDependency = MavenDependencyCompletionUtil.findManagedDependency(domModel.getRootElement(),
                                                                                                 context.getProject(), groupId, artifactId);
      if (managedDependency == null) {
        String value = ""<groupId>"" + groupId + ""</groupId>\n"" +
                       ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                       ""<version></version>"";
        context.getDocument().replaceString(startOffset, context.getSelectionEndOffset(), value);
        context.getEditor().getCaretModel().moveToOffset(startOffset + value.length() - 10);
        shouldInvokeCompletion = true;
      }
      else {
        StringBuilder sb = new StringBuilder();
        sb.append(""<groupId>"").append(groupId).append(""</groupId>\n"")
          .append(""<artifactId>"").append(artifactId).append(""</artifactId>\n"");
        String type = managedDependency.getType().getRawText();
        if (type != null && !type.equals(""jar"")) {
          sb.append(""<type>"").append(type).append(""</type>\n"");
        }
        String classifier = managedDependency.getClassifier().getRawText();
        if (StringUtil.isNotEmpty(classifier)) {
          sb.append(""<classifier>"").append(classifier).append(""</classifier>\n"");
        }
        context.getDocument().replaceString(startOffset, context.getSelectionEndOffset(), sb);
      }
      context.commitDocument();
      PsiElement e = psiFile.findElementAt(startOffset);
      while (e != null && (!(e instanceof XmlTag) || !""dependency"".equals(((XmlTag)e).getName()))) {
        e = e.getParent();
      }
      if (e != null) {
        new ReformatCodeProcessor(psiFile.getProject(), psiFile, e.getTextRange(), false).run();
      }
      if (shouldInvokeCompletion) {
        MavenDependencyCompletionUtil.invokeCompletion(context, CompletionType.BASIC);
      }
    }",method,
"      if (managedDependency == null) {
        String value = ""<groupId>"" + groupId + ""</groupId>\n"" +
                       ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                       ""<version></version>"";
        context.getDocument().replaceString(startOffset, context.getSelectionEndOffset(), value);
        context.getEditor().getCaretModel().moveToOffset(startOffset + value.length() - 10);
        shouldInvokeCompletion = true;
      }",method,
"      if (e != null) {
        new ReformatCodeProcessor(psiFile.getProject(), psiFile, e.getTextRange(), false).run();
      }",method,
"      if (shouldInvokeCompletion) {
        MavenDependencyCompletionUtil.invokeCompletion(context, CompletionType.BASIC);
      }",method,
"        + ""class Base {}",class,
"        + ""class Foo extends Base implements SomeInterface {\n""
        + ""  @Override\n""
        + ""  public Iterator<String> iterator() { return null; }\n""
        + ""}",class,
"    String source = ""class Base<T> { \n""
        + ""  T someMethod() { return null; }\n""
        + ""}",class,
"        + ""class Foo extends Base<String> {}",class,
"    String source = ""class Base<T> { \n""
        + ""  T someDeadMethod() { return null; }\n""
        + ""}",class,
"        + ""class Foo extends Base<String> {}",class,
"    String source = ""class Base<T> { \n""
        + ""  T someDeadMethod() { return null; }\n""
        + ""}",class,
"        + ""class Foo extends Base<String> {}",class,
"        + "" class A implements I { }",class,
"    // Test dead class
    map = CodeReferenceMap.builder().addClass(""I"").build();
    setDeadCodeMap(map);
    translation = translateSourceFile(source, ""A"", ""A.m"");
    assertNotInTranslation(translation, ""I_foo(self);"");
  }
  public void testDeadMethodShimGenerator() throws IOException {
    String sourceI = ""interface I <T> { ""
        + "" void foo(T t); ""
        + "" void bar(T t); ""
        + "" void baz(T t); }",class,
"    String sourceA = ""class A { ""
        + "" public void foo(String s) { } ""
        + "" public void bar(String s) { } ""
        + "" public void baz(String s) { } }",class,
"    String sourceB = ""class B extends A implements I<String> { }",class,
"  public void testTypeNarrowingMethodsNotShowingInDeadClasses() throws IOException {
    String source = ""class Base<T> { \n""
        + ""  T someMethod() { return null; }\n""
        + ""}",method,
"  public void testDeadMethodInBaseClassNotShowingInChildClasses() throws IOException {
    String source = ""class Base<T> { \n""
        + ""  T someDeadMethod() { return null; }\n""
        + ""}",method,
"  public void testDeadMethodInBaseClassNotShowingInDeadChildClasses() throws IOException {
    String source = ""class Base<T> { \n""
        + ""  T someDeadMethod() { return null; }\n""
        + ""}",method,
"  public void testDeadDefaultInterfaceMethod() throws IOException {
    // Test dead method
    String source = ""interface I { default void foo() { } }",method,
"  public void testDeadMethodShimGenerator() throws IOException {
    String sourceI = ""interface I <T> { ""
        + "" void foo(T t); ""
        + "" void bar(T t); ""
        + "" void baz(T t); }",method,
"public class TemporalLevelEntry extends GroupEntry {
    public static final String TYPE = ""tele"";
    private boolean levelIndependentlyDecodable;
    private short reserved;
    public boolean isLevelIndependentlyDecodable() {
        return levelIndependentlyDecodable;
    }
    public void setLevelIndependentlyDecodable(boolean levelIndependentlyDecodable) {
        this.levelIndependentlyDecodable = levelIndependentlyDecodable;
    }
    @Override
    public void parse(ByteBuffer byteBuffer) {
        final byte b = byteBuffer.get();
        levelIndependentlyDecodable = ((b & 0x80) == 0x80);
    }
    @Override
    public ByteBuffer get() {
        ByteBuffer content = ByteBuffer.allocate(1);
        content.put((byte) (levelIndependentlyDecodable ? 0x80 : 0x00));
        content.rewind();
        return content;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TemporalLevelEntry that = (TemporalLevelEntry) o;
        if (levelIndependentlyDecodable != that.levelIndependentlyDecodable) return false;
        if (reserved != that.reserved) return false;
        return true;
    }
    @Override
    public int hashCode() {
        int result = (levelIndependentlyDecodable ? 1 : 0);
        result = 31 * result + (int) reserved;
        return result;
    }
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append(""TemporalLevelEntry"");
        sb.append(""{levelIndependentlyDecodable="").append(levelIndependentlyDecodable);
        sb.append('}');
        return sb.toString();
    }
}",class,
"    public boolean isLevelIndependentlyDecodable() {
        return levelIndependentlyDecodable;
    }",method,
"    public void setLevelIndependentlyDecodable(boolean levelIndependentlyDecodable) {
        this.levelIndependentlyDecodable = levelIndependentlyDecodable;
    }",method,
"    @Override
    public void parse(ByteBuffer byteBuffer) {
        final byte b = byteBuffer.get();
        levelIndependentlyDecodable = ((b & 0x80) == 0x80);
    }",method,
"    @Override
    public ByteBuffer get() {
        ByteBuffer content = ByteBuffer.allocate(1);
        content.put((byte) (levelIndependentlyDecodable ? 0x80 : 0x00));
        content.rewind();
        return content;
    }",method,
"    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TemporalLevelEntry that = (TemporalLevelEntry) o;
        if (levelIndependentlyDecodable != that.levelIndependentlyDecodable) return false;
        if (reserved != that.reserved) return false;
        return true;
    }",method,
"    @Override
    public int hashCode() {
        int result = (levelIndependentlyDecodable ? 1 : 0);
        result = 31 * result + (int) reserved;
        return result;
    }",method,
"    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append(""TemporalLevelEntry"");
        sb.append(""{levelIndependentlyDecodable="").append(levelIndependentlyDecodable);
        sb.append('}');
        return sb.toString();
    }",method,
"public final class HahaHelper {
  private static final Set<String> WRAPPER_TYPES = new HashSet<>(
      asList(Boolean.class.getName(), Character.class.getName(), Float.class.getName(),
          Double.class.getName(), Byte.class.getName(), Short.class.getName(),
          Integer.class.getName(), Long.class.getName()));
  static String fieldToString(Map.Entry<Field, Object> entry) {
    return fieldToString(entry.getKey(), entry.getValue());
  }
  static String fieldToString(ClassInstance.FieldValue fieldValue) {
    return fieldToString(fieldValue.getField(), fieldValue.getValue());
  }
  static String fieldToString(Field field, Object value) {
    return field.getName() + "" = "" + value;
  }
  static String threadName(Instance holder) {
    List<ClassInstance.FieldValue> values = classInstanceValues(holder);
    Object nameField = fieldValue(values, ""name"");
    if (nameField == null) {
      // Sometimes we can't find the String at the expected memory address in the heap dump.
      // See https://github.com/square/leakcanary/issues/417 .
      return ""Thread name not available"";
    }
    return asString(nameField);
  }
  static boolean extendsThread(ClassObj clazz) {
    boolean extendsThread = false;
    ClassObj parentClass = clazz;
    while (parentClass.getSuperClassObj() != null) {
      if (clazz.getClassName().equals(Thread.class.getName())) {
        extendsThread = true;
        break;
      }
      parentClass = parentClass.getSuperClassObj();
    }
    return extendsThread;
  }
  static String asString(Object stringObject) {
    Instance instance = (Instance) stringObject;
    List<ClassInstance.FieldValue> values = classInstanceValues(instance);
    Integer count = fieldValue(values, ""count"");
    checkNotNull(count, ""count"");
    if (count == 0) {
      return """";
    }
    Object value = fieldValue(values, ""value"");
    checkNotNull(value, ""value"");
    Integer offset;
    ArrayInstance array;
    if (isCharArray(value)) {
      array = (ArrayInstance) value;
      offset = 0;
      // < API 23
      // As of Marshmallow, substrings no longer share their parent strings' char arrays
      // eliminating the need for String.offset
      // https://android-review.googlesource.com/#/c/83611/
      if (hasField(values, ""offset"")) {
        offset = fieldValue(values, ""offset"");
        checkNotNull(offset, ""offset"");
      }
      char[] chars = array.asCharArray(offset, count);
      return new String(chars);
    } else if (isByteArray(value)) {
      // In API 26, Strings are now internally represented as byte arrays.
      array = (ArrayInstance) value;
      // HACK - remove when HAHA's perflib is updated to https://goo.gl/Oe7ZwO.
      try {
        Method asRawByteArray =
            ArrayInstance.class.getDeclaredMethod(""asRawByteArray"", int.class, int.class);
        asRawByteArray.setAccessible(true);
        byte[] rawByteArray = (byte[]) asRawByteArray.invoke(array, 0, count);
        return new String(rawByteArray, Charset.forName(""UTF-8""));
      } catch (NoSuchMethodException e) {
        throw new RuntimeException(e);
      } catch (IllegalAccessException e) {
        throw new RuntimeException(e);
      } catch (InvocationTargetException e) {
        throw new RuntimeException(e);
      }
    } else {
      throw new UnsupportedOperationException(""Could not find char array in "" + instance);
    }
  }
  public static boolean isPrimitiveWrapper(Object value) {
    if (!(value instanceof ClassInstance)) {
      return false;
    }
    return WRAPPER_TYPES.contains(((ClassInstance) value).getClassObj().getClassName());
  }
  public static boolean isPrimitiveOrWrapperArray(Object value) {
    if (!(value instanceof ArrayInstance)) {
      return false;
    }
    ArrayInstance arrayInstance = (ArrayInstance) value;
    if (arrayInstance.getArrayType() != Type.OBJECT) {
      return true;
    }
    return WRAPPER_TYPES.contains(arrayInstance.getClassObj().getClassName());
  }
  private static boolean isCharArray(Object value) {
    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
  }
  private static boolean isByteArray(Object value) {
    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.BYTE;
  }
  static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
    ClassInstance classInstance = (ClassInstance) instance;
    return classInstance.getValues();
  }
  @SuppressWarnings({ ""unchecked"", ""TypeParameterUnusedInFormals"" })
  static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
    for (ClassInstance.FieldValue fieldValue : values) {
      if (fieldValue.getField().getName().equals(fieldName)) {
        return (T) fieldValue.getValue();
      }
    }
    throw new IllegalArgumentException(""Field "" + fieldName + "" does not exists"");
  }
  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
    for (ClassInstance.FieldValue fieldValue : values) {
      if (fieldValue.getField().getName().equals(fieldName)) {
        //noinspection unchecked
        return true;
      }
    }
    return false;
  }
  private HahaHelper() {
    throw new AssertionError();
  }
}",class,
"  static String fieldToString(Map.Entry<Field, Object> entry) {
    return fieldToString(entry.getKey(), entry.getValue());
  }",method,
"  static String fieldToString(ClassInstance.FieldValue fieldValue) {
    return fieldToString(fieldValue.getField(), fieldValue.getValue());
  }",method,
"  static String fieldToString(Field field, Object value) {
    return field.getName() + "" = "" + value;
  }",method,
"  static String threadName(Instance holder) {
    List<ClassInstance.FieldValue> values = classInstanceValues(holder);
    Object nameField = fieldValue(values, ""name"");
    if (nameField == null) {
      // Sometimes we can't find the String at the expected memory address in the heap dump.
      // See https://github.com/square/leakcanary/issues/417 .
      return ""Thread name not available"";
    }
    return asString(nameField);
  }",method,
"    if (nameField == null) {
      // Sometimes we can't find the String at the expected memory address in the heap dump.
      // See https://github.com/square/leakcanary/issues/417 .
      return ""Thread name not available"";
    }",method,
"  static boolean extendsThread(ClassObj clazz) {
    boolean extendsThread = false;
    ClassObj parentClass = clazz;
    while (parentClass.getSuperClassObj() != null) {
      if (clazz.getClassName().equals(Thread.class.getName())) {
        extendsThread = true;
        break;
      }
      parentClass = parentClass.getSuperClassObj();
    }
    return extendsThread;
  }",method,
"  static String asString(Object stringObject) {
    Instance instance = (Instance) stringObject;
    List<ClassInstance.FieldValue> values = classInstanceValues(instance);
    Integer count = fieldValue(values, ""count"");
    checkNotNull(count, ""count"");
    if (count == 0) {
      return """";
    }
    Object value = fieldValue(values, ""value"");
    checkNotNull(value, ""value"");
    Integer offset;
    ArrayInstance array;
    if (isCharArray(value)) {
      array = (ArrayInstance) value;
      offset = 0;
      // < API 23
      // As of Marshmallow, substrings no longer share their parent strings' char arrays
      // eliminating the need for String.offset
      // https://android-review.googlesource.com/#/c/83611/
      if (hasField(values, ""offset"")) {
        offset = fieldValue(values, ""offset"");
        checkNotNull(offset, ""offset"");
      }
      char[] chars = array.asCharArray(offset, count);
      return new String(chars);
    } else if (isByteArray(value)) {
      // In API 26, Strings are now internally represented as byte arrays.
      array = (ArrayInstance) value;
      // HACK - remove when HAHA's perflib is updated to https://goo.gl/Oe7ZwO.
      try {
        Method asRawByteArray =
            ArrayInstance.class.getDeclaredMethod(""asRawByteArray"", int.class, int.class);
        asRawByteArray.setAccessible(true);
        byte[] rawByteArray = (byte[]) asRawByteArray.invoke(array, 0, count);
        return new String(rawByteArray, Charset.forName(""UTF-8""));
      } catch (NoSuchMethodException e) {
        throw new RuntimeException(e);
      } catch (IllegalAccessException e) {
        throw new RuntimeException(e);
      } catch (InvocationTargetException e) {
        throw new RuntimeException(e);
      }
    } else {
      throw new UnsupportedOperationException(""Could not find char array in "" + instance);
    }
  }",method,
"    if (count == 0) {
      return """";
    }",method,
"  public static boolean isPrimitiveWrapper(Object value) {
    if (!(value instanceof ClassInstance)) {
      return false;
    }
    return WRAPPER_TYPES.contains(((ClassInstance) value).getClassObj().getClassName());
  }",method,
"  public static boolean isPrimitiveOrWrapperArray(Object value) {
    if (!(value instanceof ArrayInstance)) {
      return false;
    }
    ArrayInstance arrayInstance = (ArrayInstance) value;
    if (arrayInstance.getArrayType() != Type.OBJECT) {
      return true;
    }
    return WRAPPER_TYPES.contains(arrayInstance.getClassObj().getClassName());
  }",method,
"  private static boolean isCharArray(Object value) {
    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
  }",method,
"  private static boolean isByteArray(Object value) {
    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.BYTE;
  }",method,
"  static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
    ClassInstance classInstance = (ClassInstance) instance;
    return classInstance.getValues();
  }",method,
"  @SuppressWarnings({ ""unchecked"", ""TypeParameterUnusedInFormals"" })
  static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
    for (ClassInstance.FieldValue fieldValue : values) {
      if (fieldValue.getField().getName().equals(fieldName)) {
        return (T) fieldValue.getValue();
      }
    }
    throw new IllegalArgumentException(""Field "" + fieldName + "" does not exists"");
  }",method,
"    for (ClassInstance.FieldValue fieldValue : values) {
      if (fieldValue.getField().getName().equals(fieldName)) {
        return (T) fieldValue.getValue();
      }
    }",method,
"  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
    for (ClassInstance.FieldValue fieldValue : values) {
      if (fieldValue.getField().getName().equals(fieldName)) {
        //noinspection unchecked
        return true;
      }
    }
    return false;
  }",method,
"    for (ClassInstance.FieldValue fieldValue : values) {
      if (fieldValue.getField().getName().equals(fieldName)) {
        //noinspection unchecked
        return true;
      }
    }",method,
"  private HahaHelper() {
    throw new AssertionError();
  }",method,
"public class SaslConfigs {
    public static final String SASL_MECHANISM = ""sasl.mechanism"";
    public static final String SASL_MECHANISM_DOC = ""SASL mechanism used for client connections. This may be any mechanism for which a security provider is available. GSSAPI is the default mechanism."";
    public static final String GSSAPI_MECHANISM = ""GSSAPI"";
    public static final String DEFAULT_SASL_MECHANISM = GSSAPI_MECHANISM;
    @Deprecated
    public static final String SASL_ENABLED_MECHANISMS = BrokerSecurityConfigs.SASL_ENABLED_MECHANISMS_CONFIG;
    @Deprecated
    public static final String SASL_ENABLED_MECHANISMS_DOC = BrokerSecurityConfigs.SASL_ENABLED_MECHANISMS_DOC;
    @Deprecated
    public static final List<String> DEFAULT_SASL_ENABLED_MECHANISMS = BrokerSecurityConfigs.DEFAULT_SASL_ENABLED_MECHANISMS;
    public static final String SASL_JAAS_CONFIG = ""sasl.jaas.config"";
    public static final String SASL_JAAS_CONFIG_DOC = ""JAAS login context parameters for SASL connections in the format used by JAAS configuration files. ""
        + ""JAAS configuration file format is described <a href=\""http://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html\"">here</a>. ""
        + ""The format for the value is: '<loginModuleClass> <controlFlag> (<optionName>=<optionValue>)*;'"";
    public static final String SASL_KERBEROS_SERVICE_NAME = ""sasl.kerberos.service.name"";
    public static final String SASL_KERBEROS_SERVICE_NAME_DOC = ""The Kerberos principal name that Kafka runs as. ""
        + ""This can be defined either in Kafka's JAAS config or in Kafka's config."";
    public static final String SASL_KERBEROS_KINIT_CMD = ""sasl.kerberos.kinit.cmd"";
    public static final String SASL_KERBEROS_KINIT_CMD_DOC = ""Kerberos kinit command path."";
    public static final String DEFAULT_KERBEROS_KINIT_CMD = ""/usr/bin/kinit"";
    public static final String SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR = ""sasl.kerberos.ticket.renew.window.factor"";
    public static final String SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR_DOC = ""Login thread will sleep until the specified window factor of time from last refresh""
        + "" to ticket's expiry has been reached, at which time it will try to renew the ticket."";
    public static final double DEFAULT_KERBEROS_TICKET_RENEW_WINDOW_FACTOR = 0.80;
    public static final String SASL_KERBEROS_TICKET_RENEW_JITTER = ""sasl.kerberos.ticket.renew.jitter"";
    public static final String SASL_KERBEROS_TICKET_RENEW_JITTER_DOC = ""Percentage of random jitter added to the renewal time."";
    public static final double DEFAULT_KERBEROS_TICKET_RENEW_JITTER = 0.05;
    public static final String SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN = ""sasl.kerberos.min.time.before.relogin"";
    public static final String SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN_DOC = ""Login thread sleep time between refresh attempts."";
    public static final long DEFAULT_KERBEROS_MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;
    @Deprecated
    public static final String SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES = BrokerSecurityConfigs.SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_CONFIG;
    @Deprecated
    public static final String SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DOC = BrokerSecurityConfigs.SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DOC;
    @Deprecated
    public static final List<String> DEFAULT_SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES = BrokerSecurityConfigs.DEFAULT_SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES;
    public static void addClientSaslSupport(ConfigDef config) {
        config.define(SaslConfigs.SASL_KERBEROS_SERVICE_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM, SaslConfigs.SASL_KERBEROS_SERVICE_NAME_DOC)
                .define(SaslConfigs.SASL_KERBEROS_KINIT_CMD, ConfigDef.Type.STRING, SaslConfigs.DEFAULT_KERBEROS_KINIT_CMD, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_KINIT_CMD_DOC)
                .define(SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR, ConfigDef.Type.DOUBLE, SaslConfigs.DEFAULT_KERBEROS_TICKET_RENEW_WINDOW_FACTOR, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR_DOC)
                .define(SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER, ConfigDef.Type.DOUBLE, SaslConfigs.DEFAULT_KERBEROS_TICKET_RENEW_JITTER, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER_DOC)
                .define(SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN, ConfigDef.Type.LONG, SaslConfigs.DEFAULT_KERBEROS_MIN_TIME_BEFORE_RELOGIN, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN_DOC)
                .define(SaslConfigs.SASL_MECHANISM, ConfigDef.Type.STRING, SaslConfigs.DEFAULT_SASL_MECHANISM, ConfigDef.Importance.MEDIUM, SaslConfigs.SASL_MECHANISM_DOC)
                .define(SaslConfigs.SASL_JAAS_CONFIG, ConfigDef.Type.PASSWORD, null, ConfigDef.Importance.MEDIUM, SaslConfigs.SASL_JAAS_CONFIG_DOC);
    }
}",class,
"    public static void addClientSaslSupport(ConfigDef config) {
        config.define(SaslConfigs.SASL_KERBEROS_SERVICE_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM, SaslConfigs.SASL_KERBEROS_SERVICE_NAME_DOC)
                .define(SaslConfigs.SASL_KERBEROS_KINIT_CMD, ConfigDef.Type.STRING, SaslConfigs.DEFAULT_KERBEROS_KINIT_CMD, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_KINIT_CMD_DOC)
                .define(SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR, ConfigDef.Type.DOUBLE, SaslConfigs.DEFAULT_KERBEROS_TICKET_RENEW_WINDOW_FACTOR, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR_DOC)
                .define(SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER, ConfigDef.Type.DOUBLE, SaslConfigs.DEFAULT_KERBEROS_TICKET_RENEW_JITTER, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER_DOC)
                .define(SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN, ConfigDef.Type.LONG, SaslConfigs.DEFAULT_KERBEROS_MIN_TIME_BEFORE_RELOGIN, ConfigDef.Importance.LOW, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN_DOC)
                .define(SaslConfigs.SASL_MECHANISM, ConfigDef.Type.STRING, SaslConfigs.DEFAULT_SASL_MECHANISM, ConfigDef.Importance.MEDIUM, SaslConfigs.SASL_MECHANISM_DOC)
                .define(SaslConfigs.SASL_JAAS_CONFIG, ConfigDef.Type.PASSWORD, null, ConfigDef.Importance.MEDIUM, SaslConfigs.SASL_JAAS_CONFIG_DOC);
    }",method,
"public class MapTest {
  @JsonProperty(""map_map_of_string"")
  private Map<String, Map<String, String>> mapMapOfString = null;
  public enum InnerEnum {
    UPPER(""UPPER""),
    LOWER(""lower"");
    private String value;
    InnerEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }
    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static InnerEnum fromValue(String text) {
      for (InnerEnum b : InnerEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
  }
  @JsonProperty(""map_of_enum_string"")
  private Map<String, InnerEnum> mapOfEnumString = null;
  public MapTest mapMapOfString(Map<String, Map<String, String>> mapMapOfString) {
    this.mapMapOfString = mapMapOfString;
    return this;
  }
  public MapTest putMapMapOfStringItem(String key, Map<String, String> mapMapOfStringItem) {
    if (this.mapMapOfString == null) {
      this.mapMapOfString = new HashMap<String, Map<String, String>>();
    }
    this.mapMapOfString.put(key, mapMapOfStringItem);
    return this;
  }
  @ApiModelProperty(value = """")
  public Map<String, Map<String, String>> getMapMapOfString() {
    return mapMapOfString;
  }
  public void setMapMapOfString(Map<String, Map<String, String>> mapMapOfString) {
    this.mapMapOfString = mapMapOfString;
  }
  public MapTest mapOfEnumString(Map<String, InnerEnum> mapOfEnumString) {
    this.mapOfEnumString = mapOfEnumString;
    return this;
  }
  public MapTest putMapOfEnumStringItem(String key, InnerEnum mapOfEnumStringItem) {
    if (this.mapOfEnumString == null) {
      this.mapOfEnumString = new HashMap<String, InnerEnum>();
    }
    this.mapOfEnumString.put(key, mapOfEnumStringItem);
    return this;
  }
  @ApiModelProperty(value = """")
  public Map<String, InnerEnum> getMapOfEnumString() {
    return mapOfEnumString;
  }
  public void setMapOfEnumString(Map<String, InnerEnum> mapOfEnumString) {
    this.mapOfEnumString = mapOfEnumString;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MapTest mapTest = (MapTest) o;
    return Objects.equals(this.mapMapOfString, mapTest.mapMapOfString) &&
        Objects.equals(this.mapOfEnumString, mapTest.mapOfEnumString);
  }
  @Override
  public int hashCode() {
    return Objects.hash(mapMapOfString, mapOfEnumString);
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class MapTest {\n"");
    sb.append(""    mapMapOfString: "").append(toIndentedString(mapMapOfString)).append(""\n"");
    sb.append(""    mapOfEnumString: "").append(toIndentedString(mapOfEnumString)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
}",class,
"    sb.append(""class MapTest {\n"");
    sb.append(""    mapMapOfString: "").append(toIndentedString(mapMapOfString)).append(""\n"");
    sb.append(""    mapOfEnumString: "").append(toIndentedString(mapOfEnumString)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"    InnerEnum(String value) {
      this.value = value;
    }",method,
"    @JsonValue
    public String getValue() {
      return value;
    }",method,
"    @Override
    public String toString() {
      return String.valueOf(value);
    }",method,
"    @JsonCreator
    public static InnerEnum fromValue(String text) {
      for (InnerEnum b : InnerEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }",method,
"  public MapTest mapMapOfString(Map<String, Map<String, String>> mapMapOfString) {
    this.mapMapOfString = mapMapOfString;
    return this;
  }",method,
"  public MapTest putMapMapOfStringItem(String key, Map<String, String> mapMapOfStringItem) {
    if (this.mapMapOfString == null) {
      this.mapMapOfString = new HashMap<String, Map<String, String>>();
    }
    this.mapMapOfString.put(key, mapMapOfStringItem);
    return this;
  }",method,
"    if (this.mapMapOfString == null) {
      this.mapMapOfString = new HashMap<String, Map<String, String>>();
    }",method,
"  @ApiModelProperty(value = """")
  public Map<String, Map<String, String>> getMapMapOfString() {
    return mapMapOfString;
  }",method,
"  public void setMapMapOfString(Map<String, Map<String, String>> mapMapOfString) {
    this.mapMapOfString = mapMapOfString;
  }",method,
"  public MapTest mapOfEnumString(Map<String, InnerEnum> mapOfEnumString) {
    this.mapOfEnumString = mapOfEnumString;
    return this;
  }",method,
"  public MapTest putMapOfEnumStringItem(String key, InnerEnum mapOfEnumStringItem) {
    if (this.mapOfEnumString == null) {
      this.mapOfEnumString = new HashMap<String, InnerEnum>();
    }
    this.mapOfEnumString.put(key, mapOfEnumStringItem);
    return this;
  }",method,

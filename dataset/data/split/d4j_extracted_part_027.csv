code_snippet,type,score
"    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_with_fab, menu);
        return true;
    }",method,
"    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        if (id == R.id.action_settings) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }",method,
"        if (id == R.id.action_settings) {
            return true;
        }",method,
"public class FixEncoding implements Tool {
  Editor editor;
  public String getMenuTitle() {
    return tr(""Fix Encoding & Reload"");
  }
  public void init(Editor editor) {
    this.editor = editor;
  }
  public void run() {
    Sketch sketch = editor.getSketch();
    //SketchCode code = sketch.current;
    if (sketch.isModified()) {
      int result = 
        JOptionPane.showConfirmDialog(editor, 
                                      tr(""Discard all changes and reload sketch?""),
                                      tr(""Fix Encoding & Reload""),
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.QUESTION_MESSAGE);
      if (result == JOptionPane.NO_OPTION) {
        return;
      }
    }
    try {
      for (int i = 0; i < sketch.getCodeCount(); i++) {
        SketchFile file = sketch.getFile(i);
        editor.findTab(file).setText(loadWithLocalEncoding(file.getFile()));
      }
    } catch (IOException e) {
      String msg = 
        tr(""An error occurred while trying to fix the file encoding.\nDo not attempt to save this sketch as it may overwrite\nthe old version. Use Open to re-open the sketch and try again.\n"") +
        e.getMessage();
      Base.showWarning(tr(""Fix Encoding & Reload""), msg, e);
    }
  }
  protected String loadWithLocalEncoding(File file) throws IOException {
    // FileReader uses the default encoding, which is what we want.
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new FileReader(file));
      StringBuffer buffer = new StringBuffer();
      String line;
      while ((line = reader.readLine()) != null) {
        buffer.append(line);
        buffer.append('\n');
      }
      return buffer.toString();
    } finally {
      IOUtils.closeQuietly(reader);
    }
  }
}",class,
"  public String getMenuTitle() {
    return tr(""Fix Encoding & Reload"");
  }",method,
"  public void init(Editor editor) {
    this.editor = editor;
  }",method,
"  public void run() {
    Sketch sketch = editor.getSketch();
    //SketchCode code = sketch.current;
    if (sketch.isModified()) {
      int result = 
        JOptionPane.showConfirmDialog(editor, 
                                      tr(""Discard all changes and reload sketch?""),
                                      tr(""Fix Encoding & Reload""),
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.QUESTION_MESSAGE);
      if (result == JOptionPane.NO_OPTION) {
        return;
      }
    }
    try {
      for (int i = 0; i < sketch.getCodeCount(); i++) {
        SketchFile file = sketch.getFile(i);
        editor.findTab(file).setText(loadWithLocalEncoding(file.getFile()));
      }
    } catch (IOException e) {
      String msg = 
        tr(""An error occurred while trying to fix the file encoding.\nDo not attempt to save this sketch as it may overwrite\nthe old version. Use Open to re-open the sketch and try again.\n"") +
        e.getMessage();
      Base.showWarning(tr(""Fix Encoding & Reload""), msg, e);
    }
  }",method,
"      if (result == JOptionPane.NO_OPTION) {
        return;
      }",method,
"  protected String loadWithLocalEncoding(File file) throws IOException {
    // FileReader uses the default encoding, which is what we want.
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new FileReader(file));
      StringBuffer buffer = new StringBuffer();
      String line;
      while ((line = reader.readLine()) != null) {
        buffer.append(line);
        buffer.append('\n');
      }
      return buffer.toString();
    } finally {
      IOUtils.closeQuietly(reader);
    }
  }",method,
"public final class UnusedStub {
    private UnusedStub() { }
}",class,
    private UnusedStub() { },method,
"public MyService() {
  super(""MyService"");
}",method,
"  public OptimizedFileManager17() throws Throwable {
    super(new Context(), true, null);
    final Field archivesField = com.sun.tools.javac.file.JavacFileManager.class.getDeclaredField(""archives"");
    archivesField.setAccessible(true);
    myArchives = (Map<File, Archive>) archivesField.get(this);
  }",method,
"  @Override
  public Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> files) {
    java.util.List<InputFileObject> result;
    if (files instanceof Collection) {
      result = new ArrayList<InputFileObject>(((Collection)files).size());
    }
    else {
      result = new ArrayList<InputFileObject>();
    }
    for (File f: files) {
      result.add(new InputFileObject(this, f));
    }
    return result;
  }",method,
"    if (files instanceof Collection) {
      result = new ArrayList<InputFileObject>(((Collection)files).size());
    }",method,
"    for (File f: files) {
      result.add(new InputFileObject(this, f));
    }",method,
"  @Override
  public Iterable<JavaFileObject> list(Location location, String packageName, Set<JavaFileObject.Kind> kinds, boolean recurse) throws IOException {
    Iterable<? extends File> locationRoots = getLocation(location);
    if (locationRoots == null) {
      return List.nil();
    }
    RelativePath.RelativeDirectory subdirectory = new RelativePath.RelativeDirectory(packageName.replace('.', '/'));
    ListBuffer<JavaFileObject> results = new ListBuffer<JavaFileObject>();
    for (File root : locationRoots) {
      Archive archive = myArchives.get(root);
      final boolean isFile;
      if (archive != null) {
        isFile = true;
      }
      else {
        isFile = isFile(root);
      }
      if (isFile) {
        // Not a directory; either a file or non-existant, create the archive
        try {
          if (archive == null) {
            archive = openArchive(root);
          }
          listArchive(archive, subdirectory, kinds, recurse, results);
        }
        catch (IOException ex) {
          log.error(""error.reading.file"", root, getMessage(ex));
        }
      }
      else {
        final File dir = subdirectory.getFile(root);
        if (recurse) {
          listDirectoryRecursively(dir, kinds, results, true);
        }
        else {
          listDirectory(dir, kinds, results);
        }
      }
    }
    return results.toList();
  }",method,
"    if (locationRoots == null) {
      return List.nil();
    }",method,
"    for (File root : locationRoots) {
      Archive archive = myArchives.get(root);
      final boolean isFile;
      if (archive != null) {
        isFile = true;
      }
      else {
        isFile = isFile(root);
      }
      if (isFile) {
        // Not a directory; either a file or non-existant, create the archive
        try {
          if (archive == null) {
            archive = openArchive(root);
          }
          listArchive(archive, subdirectory, kinds, recurse, results);
        }
        catch (IOException ex) {
          log.error(""error.reading.file"", root, getMessage(ex));
        }
      }
      else {
        final File dir = subdirectory.getFile(root);
        if (recurse) {
          listDirectoryRecursively(dir, kinds, results, true);
        }
        else {
          listDirectory(dir, kinds, results);
        }
      }
    }",method,
"      if (archive != null) {
        isFile = true;
      }",method,
"      if (isFile) {
        // Not a directory; either a file or non-existant, create the archive
        try {
          if (archive == null) {
            archive = openArchive(root);
          }
          listArchive(archive, subdirectory, kinds, recurse, results);
        }
        catch (IOException ex) {
          log.error(""error.reading.file"", root, getMessage(ex));
        }
      }",method,
"          if (archive == null) {
            archive = openArchive(root);
          }",method,
"        catch (IOException ex) {
          log.error(""error.reading.file"", root, getMessage(ex));
        }",method,
"        if (recurse) {
          listDirectoryRecursively(dir, kinds, results, true);
        }",method,
"  private static void listArchive(Archive archive, RelativePath.RelativeDirectory subdirectory, Set<JavaFileObject.Kind> fileKinds, boolean recurse, ListBuffer<JavaFileObject> resultList) {
    // Get the files directly in the subdir
    List<String> files = archive.getFiles(subdirectory);
    if (files != null) {
      for (; !files.isEmpty(); files = files.tail) {
        String file = files.head;
        if (isValidFile(file, fileKinds)) {
          resultList.append(archive.getFileObject(subdirectory, file));
        }
      }
    }
    if (recurse) {
      for (RelativePath.RelativeDirectory s: archive.getSubdirectories()) {
        if (contains(subdirectory, s)) {
          // Because the archive map is a flat list of directories,
          // the enclosing loop will pick up all child subdirectories.
          // Therefore, there is no need to recurse deeper.
          listArchive(archive, s, fileKinds, false, resultList);
        }
      }
    }
  }",method,
"    if (files != null) {
      for (; !files.isEmpty(); files = files.tail) {
        String file = files.head;
        if (isValidFile(file, fileKinds)) {
          resultList.append(archive.getFileObject(subdirectory, file));
        }
      }
    }",method,
"    if (recurse) {
      for (RelativePath.RelativeDirectory s: archive.getSubdirectories()) {
        if (contains(subdirectory, s)) {
          // Because the archive map is a flat list of directories,
          // the enclosing loop will pick up all child subdirectories.
          // Therefore, there is no need to recurse deeper.
          listArchive(archive, s, fileKinds, false, resultList);
        }
      }
    }",method,
"  private void listDirectory(File directory, Set<JavaFileObject.Kind> fileKinds, ListBuffer<JavaFileObject> resultList) {
    final File[] files = listChildren(directory);
    if (files != null) {
      if (sortFiles != null) {
        Arrays.sort(files, sortFiles);
      }
      final boolean acceptUnknownFiles = fileKinds.contains(JavaFileObject.Kind.OTHER);
      for (File f: files) {
        final String fileName = f.getName();
        if (isValidFile(fileName, fileKinds)) {
          if (acceptUnknownFiles && !isFile(f)) {
            continue;
          }
          final JavaFileObject fe = new InputFileObject(this, f);
          resultList.append(fe);
        }
      }
    }
  }",method,
"    if (files != null) {
      if (sortFiles != null) {
        Arrays.sort(files, sortFiles);
      }
      final boolean acceptUnknownFiles = fileKinds.contains(JavaFileObject.Kind.OTHER);
      for (File f: files) {
        final String fileName = f.getName();
        if (isValidFile(fileName, fileKinds)) {
          if (acceptUnknownFiles && !isFile(f)) {
            continue;
          }
          final JavaFileObject fe = new InputFileObject(this, f);
          resultList.append(fe);
        }
      }
    }",method,
"      if (sortFiles != null) {
        Arrays.sort(files, sortFiles);
      }",method,
"      for (File f: files) {
        final String fileName = f.getName();
        if (isValidFile(fileName, fileKinds)) {
          if (acceptUnknownFiles && !isFile(f)) {
            continue;
          }
          final JavaFileObject fe = new InputFileObject(this, f);
          resultList.append(fe);
        }
      }",method,
"  private void listDirectoryRecursively(File file, Set<JavaFileObject.Kind> fileKinds, ListBuffer<JavaFileObject> resultList, boolean isRootCall) {
    final File[] children = listChildren(file);
    final String fileName = file.getName();
    if (children != null) { // is directory
      if (isRootCall || SourceVersion.isIdentifier(fileName)) {
        if (sortFiles != null) {
          Arrays.sort(children, sortFiles);
        }
        for (File child : children) {
          listDirectoryRecursively(child, fileKinds, resultList, false);
        }
      }
    }
    else {
      if (isValidFile(fileName, fileKinds)) {
        JavaFileObject fe = new InputFileObject(this, file);
        resultList.append(fe);
      }
    }
  }",method,
"    if (children != null) { // is directory
      if (isRootCall || SourceVersion.isIdentifier(fileName)) {
        if (sortFiles != null) {
          Arrays.sort(children, sortFiles);
        }
        for (File child : children) {
          listDirectoryRecursively(child, fileKinds, resultList, false);
        }
      }
    }",method,
"        if (sortFiles != null) {
          Arrays.sort(children, sortFiles);
        }",method,
"        for (File child : children) {
          listDirectoryRecursively(child, fileKinds, resultList, false);
        }",method,
"  private File[] listChildren(File file) {
    File[] cached = myDirectoryCache.get(file);
    if (cached == null) {
      cached = file.listFiles();
      myDirectoryCache.put(file, cached != null? cached : NULL_FILE_ARRAY);
    }
    return cached == NULL_FILE_ARRAY ? null : cached;
  }",method,
"    if (cached == null) {
      cached = file.listFiles();
      myDirectoryCache.put(file, cached != null? cached : NULL_FILE_ARRAY);
    }",method,
"public class SysTrayIcon {
    public static void openWebpage(URI uri) {
        Desktop desktop = Desktop.isDesktopSupported() ? Desktop.getDesktop() : null;
        if (desktop != null && desktop.isSupported(Desktop.Action.BROWSE)) {
            try {
                desktop.browse(uri);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    public SysTrayIcon(final URI uri, final File log) {
        if (SystemTray.isSupported()) {
            try {
                PopupMenu popup = new PopupMenu();
                MenuItem openItem = new MenuItem(""Open"");
                openItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        openWebpage(uri);
                    }
                });
                popup.add(openItem);
                popup.addSeparator();
                MenuItem openLogItem = new MenuItem(""Open log file"");
                openLogItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        openWebpage(log.toURI());
                    }
                });
                popup.add(openLogItem);
                popup.addSeparator();
                MenuItem quitItem = new MenuItem(""Quit"");
                quitItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        System.exit(0);
                    }
                });
                popup.add(quitItem);
                InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(""public/img/hsbox.png"");
                BufferedImage image = ImageIO.read(is);
                TrayIcon trayIcon = new TrayIcon(image, ""HeadshotBox"", popup);
                trayIcon.setImageAutoSize(true);
                SystemTray.getSystemTray().add(trayIcon);
            } catch (IOException e) {
                System.err.println(e);
            } catch (AWTException e) {
                System.err.println(e);
            }
        }
    }
}",class,
"public class Main {
    public static void main(String[] args) {
        System.out.println(""Hello from Java!"");
    }
}",class,
"    public static void openWebpage(URI uri) {
        Desktop desktop = Desktop.isDesktopSupported() ? Desktop.getDesktop() : null;
        if (desktop != null && desktop.isSupported(Desktop.Action.BROWSE)) {
            try {
                desktop.browse(uri);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }",method,
"    public SysTrayIcon(final URI uri, final File log) {
        if (SystemTray.isSupported()) {
            try {
                PopupMenu popup = new PopupMenu();
                MenuItem openItem = new MenuItem(""Open"");
                openItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        openWebpage(uri);
                    }
                });
                popup.add(openItem);
                popup.addSeparator();
                MenuItem openLogItem = new MenuItem(""Open log file"");
                openLogItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        openWebpage(log.toURI());
                    }
                });
                popup.add(openLogItem);
                popup.addSeparator();
                MenuItem quitItem = new MenuItem(""Quit"");
                quitItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        System.exit(0);
                    }
                });
                popup.add(quitItem);
                InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(""public/img/hsbox.png"");
                BufferedImage image = ImageIO.read(is);
                TrayIcon trayIcon = new TrayIcon(image, ""HeadshotBox"", popup);
                trayIcon.setImageAutoSize(true);
                SystemTray.getSystemTray().add(trayIcon);
            } catch (IOException e) {
                System.err.println(e);
            } catch (AWTException e) {
                System.err.println(e);
            }
        }
    }",method,
"                openItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        openWebpage(uri);
                    }
                }",method,
"                    public void actionPerformed(ActionEvent e) {
                        openWebpage(uri);
                    }",method,
"                openLogItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        openWebpage(log.toURI());
                    }
                }",method,
"                    public void actionPerformed(ActionEvent e) {
                        openWebpage(log.toURI());
                    }",method,
"                quitItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        System.exit(0);
                    }
                }",method,
"                    public void actionPerformed(ActionEvent e) {
                        System.exit(0);
                    }",method,
"    public static void main(String[] args) {
        System.out.println(""Hello from Java!"");
    }",method,
"public class PyCCRunTestsConfigurationProducer extends RunConfigurationProducer<PyCCRunTestConfiguration> {
  protected PyCCRunTestsConfigurationProducer() {
    super(PyCCRunTestsConfigurationType.getInstance());
  }
  @Override
  protected boolean setupConfigurationFromContext(PyCCRunTestConfiguration configuration,
                                                  ConfigurationContext context,
                                                  Ref<PsiElement> sourceElement) {
    Project project = context.getProject();
    if (!CCUtils.isCourseCreator(project)) {
      return false;
    }
    String testsPath = getTestPath(context);
    if (testsPath == null) {
      return false;
    }
    VirtualFile testsFile = LocalFileSystem.getInstance().findFileByPath(testsPath);
    if (testsFile == null) {
      return false;
    }
    String generatedName = generateName(testsFile, project);
    if (generatedName == null) {
      return false;
    }
    configuration.setPathToTest(testsPath);
    configuration.setName(generatedName);
    return true;
  }
  @Nullable
  private static String generateName(@NotNull VirtualFile testsFile, @NotNull Project project) {
    VirtualFile taskDir = StudyUtils.getTaskDir(testsFile);
    if (taskDir == null) {
      return null;
    }
    Task task = StudyUtils.getTask(project, taskDir);
    if (task == null) {
      return null;
    }
    String generatedName = task.getLesson().getName() + ""/"" + task.getName();
    if (task instanceof TaskWithSubtasks) {
      int index = ((TaskWithSubtasks)task).getActiveSubtaskIndex() + 1;
      generatedName += "" "" + index;
    }
    return generatedName;
  }
  @Nullable
  private static String getTestPath(@NotNull ConfigurationContext context) {
    Location location = context.getLocation();
    if (location == null) {
      return null;
    }
    VirtualFile file = location.getVirtualFile();
    if (file == null) {
      return null;
    }
    VirtualFile taskDir = StudyUtils.getTaskDir(file);
    if (taskDir == null) {
      return null;
    }
    Task task = StudyUtils.getTask(location.getProject(), taskDir);
    if (task == null) {
      return null;
    }
    String testsFileName = PyEduPluginConfigurator.getSubtaskTestsFileName(task instanceof TaskWithSubtasks ?
                                                                       ((TaskWithSubtasks)task).getActiveSubtaskIndex() : 0);
    String taskDirPath = FileUtil.toSystemDependentName(taskDir.getPath());
    String testsPath = taskDir.findChild(EduNames.SRC) != null ?
                       FileUtil.join(taskDirPath, EduNames.SRC, testsFileName) :
                       FileUtil.join(taskDirPath, testsFileName);
    String filePath = FileUtil.toSystemDependentName(file.getPath());
    return filePath.equals(testsPath) ? testsPath : null;
  }
  @Override
  public boolean isConfigurationFromContext(PyCCRunTestConfiguration configuration, ConfigurationContext context) {
    String path = getTestPath(context);
    return path != null && path.equals(configuration.getPathToTest());
  }
}",class,
"  protected PyCCRunTestsConfigurationProducer() {
    super(PyCCRunTestsConfigurationType.getInstance());
  }",method,
"  @Override
  protected boolean setupConfigurationFromContext(PyCCRunTestConfiguration configuration,
                                                  ConfigurationContext context,
                                                  Ref<PsiElement> sourceElement) {
    Project project = context.getProject();
    if (!CCUtils.isCourseCreator(project)) {
      return false;
    }
    String testsPath = getTestPath(context);
    if (testsPath == null) {
      return false;
    }
    VirtualFile testsFile = LocalFileSystem.getInstance().findFileByPath(testsPath);
    if (testsFile == null) {
      return false;
    }
    String generatedName = generateName(testsFile, project);
    if (generatedName == null) {
      return false;
    }
    configuration.setPathToTest(testsPath);
    configuration.setName(generatedName);
    return true;
  }",method,
"    if (testsPath == null) {
      return false;
    }",method,
"    if (testsFile == null) {
      return false;
    }",method,
"    if (generatedName == null) {
      return false;
    }",method,
"  @Nullable
  private static String generateName(@NotNull VirtualFile testsFile, @NotNull Project project) {
    VirtualFile taskDir = StudyUtils.getTaskDir(testsFile);
    if (taskDir == null) {
      return null;
    }
    Task task = StudyUtils.getTask(project, taskDir);
    if (task == null) {
      return null;
    }
    String generatedName = task.getLesson().getName() + ""/"" + task.getName();
    if (task instanceof TaskWithSubtasks) {
      int index = ((TaskWithSubtasks)task).getActiveSubtaskIndex() + 1;
      generatedName += "" "" + index;
    }
    return generatedName;
  }",method,
"    if (taskDir == null) {
      return null;
    }",method,
"    if (task == null) {
      return null;
    }",method,
"    if (task instanceof TaskWithSubtasks) {
      int index = ((TaskWithSubtasks)task).getActiveSubtaskIndex() + 1;
      generatedName += "" "" + index;
    }",method,
"  @Nullable
  private static String getTestPath(@NotNull ConfigurationContext context) {
    Location location = context.getLocation();
    if (location == null) {
      return null;
    }
    VirtualFile file = location.getVirtualFile();
    if (file == null) {
      return null;
    }
    VirtualFile taskDir = StudyUtils.getTaskDir(file);
    if (taskDir == null) {
      return null;
    }
    Task task = StudyUtils.getTask(location.getProject(), taskDir);
    if (task == null) {
      return null;
    }
    String testsFileName = PyEduPluginConfigurator.getSubtaskTestsFileName(task instanceof TaskWithSubtasks ?
                                                                       ((TaskWithSubtasks)task).getActiveSubtaskIndex() : 0);
    String taskDirPath = FileUtil.toSystemDependentName(taskDir.getPath());
    String testsPath = taskDir.findChild(EduNames.SRC) != null ?
                       FileUtil.join(taskDirPath, EduNames.SRC, testsFileName) :
                       FileUtil.join(taskDirPath, testsFileName);
    String filePath = FileUtil.toSystemDependentName(file.getPath());
    return filePath.equals(testsPath) ? testsPath : null;
  }",method,
"    if (location == null) {
      return null;
    }",method,
"    if (file == null) {
      return null;
    }",method,
"    if (taskDir == null) {
      return null;
    }",method,
"    if (task == null) {
      return null;
    }",method,
"  @Override
  public boolean isConfigurationFromContext(PyCCRunTestConfiguration configuration, ConfigurationContext context) {
    String path = getTestPath(context);
    return path != null && path.equals(configuration.getPathToTest());
  }",method,
"public class GzipResourceResolver extends AbstractResourceResolver {
	@Override
	protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,
			List<? extends Resource> locations, ResourceResolverChain chain) {
		Resource resource = chain.resolveResource(request, requestPath, locations);
		if (resource == null || (request != null && !isGzipAccepted(request))) {
			return resource;
		}
		try {
			Resource gzipped = new GzippedResource(resource);
			if (gzipped.exists()) {
				return gzipped;
			}
		}
		catch (IOException ex) {
			logger.trace(""No gzipped resource for ["" + resource.getFilename() + ""]"", ex);
		}
		return resource;
	}
	private boolean isGzipAccepted(HttpServletRequest request) {
		String value = request.getHeader(""Accept-Encoding"");
		return (value != null && value.toLowerCase().contains(""gzip""));
	}
	@Override
	protected String resolveUrlPathInternal(String resourceUrlPath,
			List<? extends Resource> locations, ResourceResolverChain chain) {
		return chain.resolveUrlPath(resourceUrlPath, locations);
	}
	static final class GzippedResource extends AbstractResource implements HttpResource {
		private final Resource original;
		private final Resource gzipped;
		public GzippedResource(Resource original) throws IOException {
			this.original = original;
			this.gzipped = original.createRelative(original.getFilename() + "".gz"");
		}
		@Override
		public InputStream getInputStream() throws IOException {
			return this.gzipped.getInputStream();
		}
		@Override
		public boolean exists() {
			return this.gzipped.exists();
		}
		@Override
		public boolean isReadable() {
			return this.gzipped.isReadable();
		}
		@Override
		public boolean isOpen() {
			return this.gzipped.isOpen();
		}
		@Override
		public boolean isFile() {
			return this.gzipped.isFile();
		}
		@Override
		public URL getURL() throws IOException {
			return this.gzipped.getURL();
		}
		@Override
		public URI getURI() throws IOException {
			return this.gzipped.getURI();
		}
		@Override
		public File getFile() throws IOException {
			return this.gzipped.getFile();
		}
		@Override
		public long contentLength() throws IOException {
			return this.gzipped.contentLength();
		}
		@Override
		public long lastModified() throws IOException {
			return this.gzipped.lastModified();
		}
		@Override
		public Resource createRelative(String relativePath) throws IOException {
			return this.gzipped.createRelative(relativePath);
		}
		@Override
		@Nullable
		public String getFilename() {
			return this.original.getFilename();
		}
		@Override
		public String getDescription() {
			return this.gzipped.getDescription();
		}
		@Override
		public HttpHeaders getResponseHeaders() {
			HttpHeaders headers;
			if(this.original instanceof HttpResource) {
				headers = ((HttpResource) this.original).getResponseHeaders();
			}
			else {
				headers = new HttpHeaders();
			}
			headers.add(HttpHeaders.CONTENT_ENCODING, ""gzip"");
			return headers;
		}
	}
}",class,
"	static final class GzippedResource extends AbstractResource implements HttpResource {
		private final Resource original;
		private final Resource gzipped;
		public GzippedResource(Resource original) throws IOException {
			this.original = original;
			this.gzipped = original.createRelative(original.getFilename() + "".gz"");
		}
		@Override
		public InputStream getInputStream() throws IOException {
			return this.gzipped.getInputStream();
		}
		@Override
		public boolean exists() {
			return this.gzipped.exists();
		}
		@Override
		public boolean isReadable() {
			return this.gzipped.isReadable();
		}
		@Override
		public boolean isOpen() {
			return this.gzipped.isOpen();
		}
		@Override
		public boolean isFile() {
			return this.gzipped.isFile();
		}
		@Override
		public URL getURL() throws IOException {
			return this.gzipped.getURL();
		}
		@Override
		public URI getURI() throws IOException {
			return this.gzipped.getURI();
		}
		@Override
		public File getFile() throws IOException {
			return this.gzipped.getFile();
		}
		@Override
		public long contentLength() throws IOException {
			return this.gzipped.contentLength();
		}
		@Override
		public long lastModified() throws IOException {
			return this.gzipped.lastModified();
		}
		@Override
		public Resource createRelative(String relativePath) throws IOException {
			return this.gzipped.createRelative(relativePath);
		}
		@Override
		@Nullable
		public String getFilename() {
			return this.original.getFilename();
		}
		@Override
		public String getDescription() {
			return this.gzipped.getDescription();
		}
		@Override
		public HttpHeaders getResponseHeaders() {
			HttpHeaders headers;
			if(this.original instanceof HttpResource) {
				headers = ((HttpResource) this.original).getResponseHeaders();
			}
			else {
				headers = new HttpHeaders();
			}
			headers.add(HttpHeaders.CONTENT_ENCODING, ""gzip"");
			return headers;
		}
	}",class,
"	@Override
	protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,
			List<? extends Resource> locations, ResourceResolverChain chain) {
		Resource resource = chain.resolveResource(request, requestPath, locations);
		if (resource == null || (request != null && !isGzipAccepted(request))) {
			return resource;
		}
		try {
			Resource gzipped = new GzippedResource(resource);
			if (gzipped.exists()) {
				return gzipped;
			}
		}
		catch (IOException ex) {
			logger.trace(""No gzipped resource for ["" + resource.getFilename() + ""]"", ex);
		}
		return resource;
	}",method,
"		catch (IOException ex) {
			logger.trace(""No gzipped resource for ["" + resource.getFilename() + ""]"", ex);
		}",method,
"	private boolean isGzipAccepted(HttpServletRequest request) {
		String value = request.getHeader(""Accept-Encoding"");
		return (value != null && value.toLowerCase().contains(""gzip""));
	}",method,
"	@Override
	protected String resolveUrlPathInternal(String resourceUrlPath,
			List<? extends Resource> locations, ResourceResolverChain chain) {
		return chain.resolveUrlPath(resourceUrlPath, locations);
	}",method,
"		public GzippedResource(Resource original) throws IOException {
			this.original = original;
			this.gzipped = original.createRelative(original.getFilename() + "".gz"");
		}",method,
"		@Override
		public InputStream getInputStream() throws IOException {
			return this.gzipped.getInputStream();
		}",method,
"		@Override
		public boolean exists() {
			return this.gzipped.exists();
		}",method,
"		@Override
		public boolean isReadable() {
			return this.gzipped.isReadable();
		}",method,
"		@Override
		public boolean isOpen() {
			return this.gzipped.isOpen();
		}",method,
"		@Override
		public boolean isFile() {
			return this.gzipped.isFile();
		}",method,
"		@Override
		public URL getURL() throws IOException {
			return this.gzipped.getURL();
		}",method,
"		@Override
		public URI getURI() throws IOException {
			return this.gzipped.getURI();
		}",method,
"		@Override
		public File getFile() throws IOException {
			return this.gzipped.getFile();
		}",method,
"		@Override
		public long contentLength() throws IOException {
			return this.gzipped.contentLength();
		}",method,
"		@Override
		public long lastModified() throws IOException {
			return this.gzipped.lastModified();
		}",method,
"		@Override
		public Resource createRelative(String relativePath) throws IOException {
			return this.gzipped.createRelative(relativePath);
		}",method,
"		@Override
		@Nullable
		public String getFilename() {
			return this.original.getFilename();
		}",method,
"		@Override
		public String getDescription() {
			return this.gzipped.getDescription();
		}",method,
"		@Override
		public HttpHeaders getResponseHeaders() {
			HttpHeaders headers;
			if(this.original instanceof HttpResource) {
				headers = ((HttpResource) this.original).getResponseHeaders();
			}
			else {
				headers = new HttpHeaders();
			}
			headers.add(HttpHeaders.CONTENT_ENCODING, ""gzip"");
			return headers;
		}",method,
"			if(this.original instanceof HttpResource) {
				headers = ((HttpResource) this.original).getResponseHeaders();
			}",method,
"public class MainReactPackage extends LazyReactPackage {
  private MainPackageConfig mConfig;
  public MainReactPackage() {
  }
  public MainReactPackage(MainPackageConfig config) {
    mConfig = config;
  }
  @Override
  public List<ModuleSpec> getNativeModules(final ReactApplicationContext context) {
    return Arrays.asList(
      new ModuleSpec(AccessibilityInfoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AccessibilityInfoModule(context);
        }
      }),
      new ModuleSpec(AppStateModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AppStateModule(context);
        }
      }),
      new ModuleSpec(AsyncStorageModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AsyncStorageModule(context);
        }
      }),
      new ModuleSpec(CameraRollManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new CameraRollManager(context);
        }
      }),
      new ModuleSpec(ClipboardModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ClipboardModule(context);
        }
      }),
      new ModuleSpec(DatePickerDialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new DatePickerDialogModule(context);
        }
      }),
      new ModuleSpec(DialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new DialogModule(context);
        }
      }),
      new ModuleSpec(FrescoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new FrescoModule(context, true, mConfig != null ? mConfig.getFrescoConfig() : null);
        }
      }),
      new ModuleSpec(I18nManagerModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new I18nManagerModule(context);
        }
      }),
      new ModuleSpec(ImageEditingManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageEditingManager(context);
        }
      }),
      new ModuleSpec(ImageLoaderModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageLoaderModule(context);
        }
      }),
      new ModuleSpec(ImageStoreManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageStoreManager(context);
        }
      }),
      new ModuleSpec(IntentModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new IntentModule(context);
        }
      }),
      new ModuleSpec(LocationModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new LocationModule(context);
        }
      }),
      new ModuleSpec(NativeAnimatedModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NativeAnimatedModule(context);
        }
      }),
      new ModuleSpec(NetworkingModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NetworkingModule(context);
        }
      }),
      new ModuleSpec(NetInfoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NetInfoModule(context);
        }
      }),
      new ModuleSpec(PermissionsModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new PermissionsModule(context);
        }
      }),
      new ModuleSpec(ShareModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ShareModule(context);
        }
      }),
      new ModuleSpec(StatusBarModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new StatusBarModule(context);
        }
      }),
      new ModuleSpec(TimePickerDialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new TimePickerDialogModule(context);
        }
      }),
      new ModuleSpec(ToastModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ToastModule(context);
        }
      }),
      new ModuleSpec(VibrationModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new VibrationModule(context);
        }
      }),
      new ModuleSpec(WebSocketModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new WebSocketModule(context);
        }
      }));
  }
  @Override
  public List<Class<? extends JavaScriptModule>> createJSModules() {
    return Collections.emptyList();
  }
  @Override
  public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
    List<ViewManager> viewManagers = new ArrayList<>();
    viewManagers.add(ARTRenderableViewManager.createARTGroupViewManager());
    viewManagers.add(ARTRenderableViewManager.createARTShapeViewManager());
    viewManagers.add(ARTRenderableViewManager.createARTTextViewManager());
    viewManagers.add(new ReactDialogPickerManager());
    viewManagers.add(new ReactDrawerLayoutManager());
    viewManagers.add(new ReactDropdownPickerManager());
    viewManagers.add(new ReactHorizontalScrollViewManager());
    viewManagers.add(new ReactProgressBarViewManager());
    viewManagers.add(new ReactScrollViewManager());
    viewManagers.add(new ReactSliderManager());
    viewManagers.add(new ReactSwitchManager());
    viewManagers.add(new ReactToolbarManager());
    viewManagers.add(new ReactWebViewManager());
    viewManagers.add(new SwipeRefreshLayoutManager());
    SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(reactContext);
    boolean useFlatUi = preferences.getBoolean(""flat_uiimplementation"", false);
    if (useFlatUi) {
      // Flat managers
      viewManagers.add(new FlatARTSurfaceViewManager());
      viewManagers.add(new RCTTextInlineImageManager());
      viewManagers.add(new RCTImageViewManager());
      viewManagers.add(new RCTModalHostManager());
      viewManagers.add(new RCTRawTextManager());
      viewManagers.add(new RCTTextInputManager());
      viewManagers.add(new RCTTextManager());
      viewManagers.add(new RCTViewManager());
      viewManagers.add(new RCTViewPagerManager());
      viewManagers.add(new RCTVirtualTextManager());
    } else {
      // Native equivalents
      viewManagers.add(new ARTSurfaceViewManager());
      viewManagers.add(new FrescoBasedReactTextInlineImageViewManager());
      viewManagers.add(new ReactImageManager());
      viewManagers.add(new ReactModalHostManager());
      viewManagers.add(new ReactRawTextManager());
      viewManagers.add(new ReactTextInputManager());
      viewManagers.add(new ReactTextViewManager());
      viewManagers.add(new ReactViewManager());
      viewManagers.add(new ReactViewPagerManager());
      viewManagers.add(new ReactVirtualTextViewManager());
    }
    return viewManagers;
  }
  @Override
  public ReactModuleInfoProvider getReactModuleInfoProvider() {
    // This has to be done via reflection or we break open source.
    return LazyReactPackage.getReactModuleInfoProviderViaReflection(this);
  }
}",class,
"  public MainReactPackage() {
  }",method,
"  public MainReactPackage(MainPackageConfig config) {
    mConfig = config;
  }",method,
"  @Override
  public List<ModuleSpec> getNativeModules(final ReactApplicationContext context) {
    return Arrays.asList(
      new ModuleSpec(AccessibilityInfoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AccessibilityInfoModule(context);
        }
      }),
      new ModuleSpec(AppStateModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AppStateModule(context);
        }
      }),
      new ModuleSpec(AsyncStorageModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AsyncStorageModule(context);
        }
      }),
      new ModuleSpec(CameraRollManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new CameraRollManager(context);
        }
      }),
      new ModuleSpec(ClipboardModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ClipboardModule(context);
        }
      }),
      new ModuleSpec(DatePickerDialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new DatePickerDialogModule(context);
        }
      }),
      new ModuleSpec(DialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new DialogModule(context);
        }
      }),
      new ModuleSpec(FrescoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new FrescoModule(context, true, mConfig != null ? mConfig.getFrescoConfig() : null);
        }
      }),
      new ModuleSpec(I18nManagerModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new I18nManagerModule(context);
        }
      }),
      new ModuleSpec(ImageEditingManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageEditingManager(context);
        }
      }),
      new ModuleSpec(ImageLoaderModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageLoaderModule(context);
        }
      }),
      new ModuleSpec(ImageStoreManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ImageStoreManager(context);
        }
      }),
      new ModuleSpec(IntentModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new IntentModule(context);
        }
      }),
      new ModuleSpec(LocationModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new LocationModule(context);
        }
      }),
      new ModuleSpec(NativeAnimatedModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NativeAnimatedModule(context);
        }
      }),
      new ModuleSpec(NetworkingModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NetworkingModule(context);
        }
      }),
      new ModuleSpec(NetInfoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new NetInfoModule(context);
        }
      }),
      new ModuleSpec(PermissionsModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new PermissionsModule(context);
        }
      }),
      new ModuleSpec(ShareModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ShareModule(context);
        }
      }),
      new ModuleSpec(StatusBarModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new StatusBarModule(context);
        }
      }),
      new ModuleSpec(TimePickerDialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new TimePickerDialogModule(context);
        }
      }),
      new ModuleSpec(ToastModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ToastModule(context);
        }
      }),
      new ModuleSpec(VibrationModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new VibrationModule(context);
        }
      }),
      new ModuleSpec(WebSocketModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new WebSocketModule(context);
        }
      }));
  }",method,
"    return Arrays.asList(
      new ModuleSpec(AccessibilityInfoModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AccessibilityInfoModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new AccessibilityInfoModule(context);
        }",method,
"      new ModuleSpec(AppStateModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AppStateModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new AppStateModule(context);
        }",method,
"      new ModuleSpec(AsyncStorageModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new AsyncStorageModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new AsyncStorageModule(context);
        }",method,
"      new ModuleSpec(CameraRollManager.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new CameraRollManager(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new CameraRollManager(context);
        }",method,
"      new ModuleSpec(ClipboardModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new ClipboardModule(context);
        }
      }",method,
"        @Override
        public NativeModule get() {
          return new ClipboardModule(context);
        }",method,
"      new ModuleSpec(DatePickerDialogModule.class, new Provider<NativeModule>() {
        @Override
        public NativeModule get() {
          return new DatePickerDialogModule(context);
        }
      }",method,

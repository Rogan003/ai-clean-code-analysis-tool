code_snippet,type,score
"    public void configure(Map<String, ?> configs) {}",method,
"    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
        List<PartitionInfo> partitions = cluster.partitionsForTopic(topic);
        int numPartitions = partitions.size();
        if (keyBytes == null) {
            int nextValue = nextValue(topic);
            List<PartitionInfo> availablePartitions = cluster.availablePartitionsForTopic(topic);
            if (availablePartitions.size() > 0) {
                int part = Utils.toPositive(nextValue) % availablePartitions.size();
                return availablePartitions.get(part).partition();
            } else {
                // no partitions are available, give a non-available partition
                return Utils.toPositive(nextValue) % numPartitions;
            }
        } else {
            // hash the keyBytes to choose a partition
            return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;
        }
    }",method,
"        if (keyBytes == null) {
            int nextValue = nextValue(topic);
            List<PartitionInfo> availablePartitions = cluster.availablePartitionsForTopic(topic);
            if (availablePartitions.size() > 0) {
                int part = Utils.toPositive(nextValue) % availablePartitions.size();
                return availablePartitions.get(part).partition();
            } else {
                // no partitions are available, give a non-available partition
                return Utils.toPositive(nextValue) % numPartitions;
            }
        }",method,
"    private int nextValue(String topic) {
        AtomicInteger counter = topicCounterMap.get(topic);
        if (null == counter) {
            counter = new AtomicInteger(ThreadLocalRandom.current().nextInt());
            AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);
            if (currentCounter != null) {
                counter = currentCounter;
            }
        }
        return counter.getAndIncrement();
    }",method,
"        if (null == counter) {
            counter = new AtomicInteger(ThreadLocalRandom.current().nextInt());
            AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);
            if (currentCounter != null) {
                counter = currentCounter;
            }
        }",method,
"            if (currentCounter != null) {
                counter = currentCounter;
            }",method,
    public void close() {},method,
"public final class InputFileConfiguredTarget extends FileConfiguredTarget implements SkylarkValue {
  private final Artifact artifact;
  private final NestedSet<TargetLicense> licenses;
  public InputFileConfiguredTarget(TargetContext targetContext, InputFile inputFile,
      Artifact artifact) {
    super(targetContext, artifact);
    Preconditions.checkArgument(targetContext.getTarget() == inputFile, getLabel());
    Preconditions.checkArgument(getConfiguration() == null, getLabel());
    this.artifact = artifact;
    if (inputFile.getLicense() != License.NO_LICENSE) {
      licenses = NestedSetBuilder.create(Order.LINK_ORDER,
          new TargetLicense(getLabel(), inputFile.getLicense()));
    } else {
      licenses = NestedSetBuilder.emptySet(Order.LINK_ORDER);
    }
  }
  @Override
  public InputFile getTarget() {
    return (InputFile) super.getTarget();
  }
  @Override
  public Artifact getArtifact() {
    return artifact;
  }
  @Override
  public String toString() {
    return ""InputFileConfiguredTarget("" + getTarget().getLabel() + "")"";
  }
  @Override
  public final NestedSet<TargetLicense> getTransitiveLicenses() {
    return licenses;
  }
  @Override
  public TargetLicense getOutputLicenses() {
    return null;
  }
  @Override
  public boolean hasOutputLicenses() {
    return false;
  }
  @Override
  public void repr(SkylarkPrinter printer) {
    printer.append(""<input file target "" + getTarget().getLabel() + "">"");
  }
}",class,
"  public InputFileConfiguredTarget(TargetContext targetContext, InputFile inputFile,
      Artifact artifact) {
    super(targetContext, artifact);
    Preconditions.checkArgument(targetContext.getTarget() == inputFile, getLabel());
    Preconditions.checkArgument(getConfiguration() == null, getLabel());
    this.artifact = artifact;
    if (inputFile.getLicense() != License.NO_LICENSE) {
      licenses = NestedSetBuilder.create(Order.LINK_ORDER,
          new TargetLicense(getLabel(), inputFile.getLicense()));
    } else {
      licenses = NestedSetBuilder.emptySet(Order.LINK_ORDER);
    }
  }",method,
"  @Override
  public InputFile getTarget() {
    return (InputFile) super.getTarget();
  }",method,
"  @Override
  public Artifact getArtifact() {
    return artifact;
  }",method,
"  @Override
  public String toString() {
    return ""InputFileConfiguredTarget("" + getTarget().getLabel() + "")"";
  }",method,
"  @Override
  public final NestedSet<TargetLicense> getTransitiveLicenses() {
    return licenses;
  }",method,
"  @Override
  public TargetLicense getOutputLicenses() {
    return null;
  }",method,
"  @Override
  public boolean hasOutputLicenses() {
    return false;
  }",method,
"  @Override
  public void repr(SkylarkPrinter printer) {
    printer.append(""<input file target "" + getTarget().getLabel() + "">"");
  }",method,
" public final class DTMXRTreeFrag {
  private DTM m_dtm;
  private int m_dtmIdentity = DTM.NULL;
  private XPathContext m_xctxt;
  public DTMXRTreeFrag(int dtmIdentity, XPathContext xctxt){
      m_xctxt = xctxt;
      m_dtmIdentity = dtmIdentity;
      m_dtm = xctxt.getDTM(dtmIdentity); 
    }
  public final void destruct(){
    m_dtm = null;         
    m_xctxt = null; 
 }
final  DTM getDTM(){return m_dtm;}
public final  int getDTMIdentity(){return m_dtmIdentity;}
final  XPathContext getXPathContext(){return m_xctxt;}
public final int hashCode() { return m_dtmIdentity; }
public final boolean equals(Object obj) {
   if (obj instanceof DTMXRTreeFrag) {
       return (m_dtmIdentity == ((DTMXRTreeFrag)obj).getDTMIdentity());
   }
   return false;
 }
}",class,
"public class XBoolean extends XObject
{
    static final long serialVersionUID = -2964933058866100881L;
  public static final XBoolean S_TRUE = new XBooleanStatic(true);
  public static final XBoolean S_FALSE = new XBooleanStatic(false);
  private final boolean m_val;
  public XBoolean(boolean b)
  {
    super();
    m_val = b;
  }
  public XBoolean(Boolean b)
  {
    super();
    m_val = b.booleanValue();
    setObject(b);
  }
  public int getType()
  {
    return CLASS_BOOLEAN;
  }
  public String getTypeString()
  {
    return ""#BOOLEAN"";
  }
  public double num()
  {
    return m_val ? 1.0 : 0.0;
  }
  public boolean bool()
  {
    return m_val;
  }
  public String str()
  {
    return m_val ? ""true"" : ""false"";
  }
  public Object object()
  {
    if(null == m_obj)
      setObject(new Boolean(m_val));
    return m_obj;
  }
  public boolean equals(XObject obj2)
  {
    // In order to handle the 'all' semantics of 
    // nodeset comparisons, we always call the 
    // nodeset function.
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.equals(this);
    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }
}",class,
"public class XBooleanStatic extends XBoolean
{
    static final long serialVersionUID = -8064147275772687409L;
  private final boolean m_val;
  public XBooleanStatic(boolean b)
  {
    super(b);
    m_val = b;
  }
  public boolean equals(XObject obj2)
  {
    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }
}",class,
"  public DTMXRTreeFrag(int dtmIdentity, XPathContext xctxt){
      m_xctxt = xctxt;
      m_dtmIdentity = dtmIdentity;
      m_dtm = xctxt.getDTM(dtmIdentity); 
    }",method,
"  public final void destruct(){
    m_dtm = null;         
    m_xctxt = null; 
 }",method,
final  DTM getDTM(){return m_dtm;},method,
public final  int getDTMIdentity(){return m_dtmIdentity;},method,
final  XPathContext getXPathContext(){return m_xctxt;},method,
public final int hashCode() { return m_dtmIdentity; },method,
"public final boolean equals(Object obj) {
   if (obj instanceof DTMXRTreeFrag) {
       return (m_dtmIdentity == ((DTMXRTreeFrag)obj).getDTMIdentity());
   }
   return false;
 }",method,
"   if (obj instanceof DTMXRTreeFrag) {
       return (m_dtmIdentity == ((DTMXRTreeFrag)obj).getDTMIdentity());
   }",method,
"  public XBoolean(boolean b)
  {
    super();
    m_val = b;
  }",method,
"  public XBoolean(Boolean b)
  {
    super();
    m_val = b.booleanValue();
    setObject(b);
  }",method,
"  public int getType()
  {
    return CLASS_BOOLEAN;
  }",method,
"  public String getTypeString()
  {
    return ""#BOOLEAN"";
  }",method,
"  public double num()
  {
    return m_val ? 1.0 : 0.0;
  }",method,
"  public boolean bool()
  {
    return m_val;
  }",method,
"  public String str()
  {
    return m_val ? ""true"" : ""false"";
  }",method,
"  public Object object()
  {
    if(null == m_obj)
      setObject(new Boolean(m_val));
    return m_obj;
  }",method,
"  public boolean equals(XObject obj2)
  {
    // In order to handle the 'all' semantics of 
    // nodeset comparisons, we always call the 
    // nodeset function.
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.equals(this);
    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }",method,
"    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }",method,
"  public XBooleanStatic(boolean b)
  {
    super(b);
    m_val = b;
  }",method,
"  public boolean equals(XObject obj2)
  {
    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }",method,
"    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }",method,
"public class MoteInterfaceViewer extends VisPlugin implements HasQuickHelp, MotePlugin {
  private static final long serialVersionUID = 1L;
  private Mote mote;
  private MoteInterface selectedMoteInterface = null;
  private JPanel currentInterfaceVisualizer = null;
  private JComboBox selectInterfaceComboBox = null;
  private JScrollPane mainScrollPane;
  public MoteInterfaceViewer(Mote moteToView, Simulation simulation, Cooja gui) {
    super(""Mote Interface Viewer ("" + moteToView + "")"", gui);
    mote = moteToView;
    JLabel label;
    JPanel mainPane = new JPanel(new BorderLayout());
    JPanel smallPane;
    // Select interface combo box
    smallPane = new JPanel(new BorderLayout());
    smallPane.add(new JSeparator(), BorderLayout.SOUTH);
    label = new JLabel(""Select interface:"");
    selectInterfaceComboBox = new JComboBox();
    final JPanel interfacePanel = new JPanel(new BorderLayout());
    Collection<MoteInterface> intfs = mote.getInterfaces().getInterfaces();
    for (MoteInterface intf : intfs) {
      selectInterfaceComboBox.addItem(Cooja.getDescriptionOf(intf));
    }
    selectInterfaceComboBox.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        // Release old interface visualizer if any
        if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
          selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
        }
        // View selected interface if any
        interfacePanel.removeAll();
        String interfaceDescription = (String) selectInterfaceComboBox.getSelectedItem();
        selectedMoteInterface = null;
        Collection<MoteInterface> intfs = mote.getInterfaces().getInterfaces();
        for (MoteInterface intf : intfs) {
          if (Cooja.getDescriptionOf(intf).equals(interfaceDescription)) {
            selectedMoteInterface = intf;
            mote.getSimulation().getCooja().loadQuickHelp(MoteInterfaceViewer.this);
            break;
          }
        }
        currentInterfaceVisualizer = selectedMoteInterface.getInterfaceVisualizer();
        if (currentInterfaceVisualizer != null) {
          interfacePanel.add(BorderLayout.CENTER, currentInterfaceVisualizer);
          currentInterfaceVisualizer.setVisible(true);
        } else {
          interfacePanel.add(new JLabel(""No interface visualizer"", JLabel.CENTER));
          currentInterfaceVisualizer = null;
        }
        setSize(getSize());
      }
    });
    selectInterfaceComboBox.setSelectedIndex(0);
    smallPane.add(BorderLayout.WEST, label);
    smallPane.add(BorderLayout.EAST, selectInterfaceComboBox);
    mainPane.add(BorderLayout.NORTH, smallPane);
    // Add selected interface
    if (selectInterfaceComboBox.getItemCount() > 0) {
      selectInterfaceComboBox.setSelectedIndex(0);
      selectInterfaceComboBox.dispatchEvent(new ActionEvent(selectInterfaceComboBox, ActionEvent.ACTION_PERFORMED, """"));
    }
    mainPane.add(BorderLayout.CENTER, interfacePanel);
    mainScrollPane = new JScrollPane(mainPane,
        JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
        JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
    mainScrollPane.setBorder(BorderFactory.createEmptyBorder(0,2,0,2));
    this.setContentPane(mainScrollPane);
    pack();
    setPreferredSize(new Dimension(350,300));
    setSize(new Dimension(350,300));
    try {
      setSelected(true);
    } catch (java.beans.PropertyVetoException e) {
      // Could not select
    }
  }
  public boolean setSelectedInterface(String description) {
    for (int i=0; i < selectInterfaceComboBox.getItemCount(); i++) {
      if (selectInterfaceComboBox.getItemAt(i).equals(description)) {
        selectInterfaceComboBox.setSelectedIndex(i);
        return true;
      }
    }
    return false;
  }
  public void closePlugin() {
    // Release old interface visualizer if any
    if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
      selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
    }
  }
  public Collection<Element> getConfigXML() {
    Vector<Element> config = new Vector<Element>();
    Element element;
    // Selected variable name
    element = new Element(""interface"");
    element.setText((String) selectInterfaceComboBox.getSelectedItem());
    config.add(element);
    Point pos = mainScrollPane.getViewport().getViewPosition();
    element = new Element(""scrollpos"");
    element.setText(pos.x + "","" + pos.y);
    config.add(element);
    return config;
  }
  public boolean setConfigXML(Collection<Element> configXML, boolean visAvailable) {
    for (Element element : configXML) {
      if (element.getName().equals(""interface"")) {
        setSelectedInterface(element.getText());
      } else if (element.getName().equals(""scrollpos"")) {
        String[] scrollPos = element.getText().split("","");
        final Point pos = new Point(Integer.parseInt(scrollPos[0]), Integer.parseInt(scrollPos[1]));
        EventQueue.invokeLater(new Runnable() {
          public void run()  {
            mainScrollPane.getViewport().setViewPosition(pos);
          }
        });
      }
    }
    return true;
  }
  public String getQuickHelp() {
    String help = ""<b>"" + Cooja.getDescriptionOf(this) + ""</b>"";
    help += ""<p>Lists mote interfaces, and allows mote inspection and interaction via mote interface visualizers."";
    MoteInterface intf = selectedMoteInterface;
    if (intf != null) {
      if (intf instanceof HasQuickHelp) {
        help += ""<p>"" + ((HasQuickHelp)intf).getQuickHelp();
      } else {
        help += ""<p><b>"" + Cooja.getDescriptionOf(intf) + ""</b>"";
        help += ""<p>No help available"";
      }
    }
    return help;
  }
  public Mote getMote() {
    return mote;
  }
}",class,
"  public MoteInterfaceViewer(Mote moteToView, Simulation simulation, Cooja gui) {
    super(""Mote Interface Viewer ("" + moteToView + "")"", gui);
    mote = moteToView;
    JLabel label;
    JPanel mainPane = new JPanel(new BorderLayout());
    JPanel smallPane;
    // Select interface combo box
    smallPane = new JPanel(new BorderLayout());
    smallPane.add(new JSeparator(), BorderLayout.SOUTH);
    label = new JLabel(""Select interface:"");
    selectInterfaceComboBox = new JComboBox();
    final JPanel interfacePanel = new JPanel(new BorderLayout());
    Collection<MoteInterface> intfs = mote.getInterfaces().getInterfaces();
    for (MoteInterface intf : intfs) {
      selectInterfaceComboBox.addItem(Cooja.getDescriptionOf(intf));
    }
    selectInterfaceComboBox.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        // Release old interface visualizer if any
        if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
          selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
        }
        // View selected interface if any
        interfacePanel.removeAll();
        String interfaceDescription = (String) selectInterfaceComboBox.getSelectedItem();
        selectedMoteInterface = null;
        Collection<MoteInterface> intfs = mote.getInterfaces().getInterfaces();
        for (MoteInterface intf : intfs) {
          if (Cooja.getDescriptionOf(intf).equals(interfaceDescription)) {
            selectedMoteInterface = intf;
            mote.getSimulation().getCooja().loadQuickHelp(MoteInterfaceViewer.this);
            break;
          }
        }
        currentInterfaceVisualizer = selectedMoteInterface.getInterfaceVisualizer();
        if (currentInterfaceVisualizer != null) {
          interfacePanel.add(BorderLayout.CENTER, currentInterfaceVisualizer);
          currentInterfaceVisualizer.setVisible(true);
        } else {
          interfacePanel.add(new JLabel(""No interface visualizer"", JLabel.CENTER));
          currentInterfaceVisualizer = null;
        }
        setSize(getSize());
      }
    });
    selectInterfaceComboBox.setSelectedIndex(0);
    smallPane.add(BorderLayout.WEST, label);
    smallPane.add(BorderLayout.EAST, selectInterfaceComboBox);
    mainPane.add(BorderLayout.NORTH, smallPane);
    // Add selected interface
    if (selectInterfaceComboBox.getItemCount() > 0) {
      selectInterfaceComboBox.setSelectedIndex(0);
      selectInterfaceComboBox.dispatchEvent(new ActionEvent(selectInterfaceComboBox, ActionEvent.ACTION_PERFORMED, """"));
    }
    mainPane.add(BorderLayout.CENTER, interfacePanel);
    mainScrollPane = new JScrollPane(mainPane,
        JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
        JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
    mainScrollPane.setBorder(BorderFactory.createEmptyBorder(0,2,0,2));
    this.setContentPane(mainScrollPane);
    pack();
    setPreferredSize(new Dimension(350,300));
    setSize(new Dimension(350,300));
    try {
      setSelected(true);
    } catch (java.beans.PropertyVetoException e) {
      // Could not select
    }
  }",method,
"    for (MoteInterface intf : intfs) {
      selectInterfaceComboBox.addItem(Cooja.getDescriptionOf(intf));
    }",method,
"    selectInterfaceComboBox.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        // Release old interface visualizer if any
        if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
          selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
        }
        // View selected interface if any
        interfacePanel.removeAll();
        String interfaceDescription = (String) selectInterfaceComboBox.getSelectedItem();
        selectedMoteInterface = null;
        Collection<MoteInterface> intfs = mote.getInterfaces().getInterfaces();
        for (MoteInterface intf : intfs) {
          if (Cooja.getDescriptionOf(intf).equals(interfaceDescription)) {
            selectedMoteInterface = intf;
            mote.getSimulation().getCooja().loadQuickHelp(MoteInterfaceViewer.this);
            break;
          }
        }
        currentInterfaceVisualizer = selectedMoteInterface.getInterfaceVisualizer();
        if (currentInterfaceVisualizer != null) {
          interfacePanel.add(BorderLayout.CENTER, currentInterfaceVisualizer);
          currentInterfaceVisualizer.setVisible(true);
        } else {
          interfacePanel.add(new JLabel(""No interface visualizer"", JLabel.CENTER));
          currentInterfaceVisualizer = null;
        }
        setSize(getSize());
      }
    }",method,
"      public void actionPerformed(ActionEvent e) {
        // Release old interface visualizer if any
        if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
          selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
        }
        // View selected interface if any
        interfacePanel.removeAll();
        String interfaceDescription = (String) selectInterfaceComboBox.getSelectedItem();
        selectedMoteInterface = null;
        Collection<MoteInterface> intfs = mote.getInterfaces().getInterfaces();
        for (MoteInterface intf : intfs) {
          if (Cooja.getDescriptionOf(intf).equals(interfaceDescription)) {
            selectedMoteInterface = intf;
            mote.getSimulation().getCooja().loadQuickHelp(MoteInterfaceViewer.this);
            break;
          }
        }
        currentInterfaceVisualizer = selectedMoteInterface.getInterfaceVisualizer();
        if (currentInterfaceVisualizer != null) {
          interfacePanel.add(BorderLayout.CENTER, currentInterfaceVisualizer);
          currentInterfaceVisualizer.setVisible(true);
        } else {
          interfacePanel.add(new JLabel(""No interface visualizer"", JLabel.CENTER));
          currentInterfaceVisualizer = null;
        }
        setSize(getSize());
      }",method,
"        if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
          selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
        }",method,
"        for (MoteInterface intf : intfs) {
          if (Cooja.getDescriptionOf(intf).equals(interfaceDescription)) {
            selectedMoteInterface = intf;
            mote.getSimulation().getCooja().loadQuickHelp(MoteInterfaceViewer.this);
            break;
          }
        }",method,
"        if (currentInterfaceVisualizer != null) {
          interfacePanel.add(BorderLayout.CENTER, currentInterfaceVisualizer);
          currentInterfaceVisualizer.setVisible(true);
        }",method,
"  public boolean setSelectedInterface(String description) {
    for (int i=0; i < selectInterfaceComboBox.getItemCount(); i++) {
      if (selectInterfaceComboBox.getItemAt(i).equals(description)) {
        selectInterfaceComboBox.setSelectedIndex(i);
        return true;
      }
    }
    return false;
  }",method,
"  public void closePlugin() {
    // Release old interface visualizer if any
    if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
      selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
    }
  }",method,
"    if (selectedMoteInterface != null && currentInterfaceVisualizer != null) {
      selectedMoteInterface.releaseInterfaceVisualizer(currentInterfaceVisualizer);
    }",method,
"  public Collection<Element> getConfigXML() {
    Vector<Element> config = new Vector<Element>();
    Element element;
    // Selected variable name
    element = new Element(""interface"");
    element.setText((String) selectInterfaceComboBox.getSelectedItem());
    config.add(element);
    Point pos = mainScrollPane.getViewport().getViewPosition();
    element = new Element(""scrollpos"");
    element.setText(pos.x + "","" + pos.y);
    config.add(element);
    return config;
  }",method,
"  public boolean setConfigXML(Collection<Element> configXML, boolean visAvailable) {
    for (Element element : configXML) {
      if (element.getName().equals(""interface"")) {
        setSelectedInterface(element.getText());
      } else if (element.getName().equals(""scrollpos"")) {
        String[] scrollPos = element.getText().split("","");
        final Point pos = new Point(Integer.parseInt(scrollPos[0]), Integer.parseInt(scrollPos[1]));
        EventQueue.invokeLater(new Runnable() {
          public void run()  {
            mainScrollPane.getViewport().setViewPosition(pos);
          }
        });
      }
    }
    return true;
  }",method,
"    for (Element element : configXML) {
      if (element.getName().equals(""interface"")) {
        setSelectedInterface(element.getText());
      } else if (element.getName().equals(""scrollpos"")) {
        String[] scrollPos = element.getText().split("","");
        final Point pos = new Point(Integer.parseInt(scrollPos[0]), Integer.parseInt(scrollPos[1]));
        EventQueue.invokeLater(new Runnable() {
          public void run()  {
            mainScrollPane.getViewport().setViewPosition(pos);
          }
        });
      }
    }",method,
"        EventQueue.invokeLater(new Runnable() {
          public void run()  {
            mainScrollPane.getViewport().setViewPosition(pos);
          }
        }",method,
"          public void run()  {
            mainScrollPane.getViewport().setViewPosition(pos);
          }",method,
"  public String getQuickHelp() {
    String help = ""<b>"" + Cooja.getDescriptionOf(this) + ""</b>"";
    help += ""<p>Lists mote interfaces, and allows mote inspection and interaction via mote interface visualizers."";
    MoteInterface intf = selectedMoteInterface;
    if (intf != null) {
      if (intf instanceof HasQuickHelp) {
        help += ""<p>"" + ((HasQuickHelp)intf).getQuickHelp();
      } else {
        help += ""<p><b>"" + Cooja.getDescriptionOf(intf) + ""</b>"";
        help += ""<p>No help available"";
      }
    }
    return help;
  }",method,
"    if (intf != null) {
      if (intf instanceof HasQuickHelp) {
        help += ""<p>"" + ((HasQuickHelp)intf).getQuickHelp();
      } else {
        help += ""<p><b>"" + Cooja.getDescriptionOf(intf) + ""</b>"";
        help += ""<p>No help available"";
      }
    }",method,
"      if (intf instanceof HasQuickHelp) {
        help += ""<p>"" + ((HasQuickHelp)intf).getQuickHelp();
      }",method,
"  public Mote getMote() {
    return mote;
  }",method,
"public class TypesJdbcTable
        extends JdbcTable
{
    public static final SchemaTableName NAME = new SchemaTableName(""jdbc"", ""types"");
    public static final ConnectorTableMetadata METADATA = tableMetadataBuilder(NAME)
            .column(""type_name"", createUnboundedVarcharType())
            .column(""data_type"", BIGINT)
            .column(""precision"", BIGINT)
            .column(""literal_prefix"", createUnboundedVarcharType())
            .column(""literal_suffix"", createUnboundedVarcharType())
            .column(""create_params"", createUnboundedVarcharType())
            .column(""nullable"", BIGINT)
            .column(""case_sensitive"", BOOLEAN)
            .column(""searchable"", BIGINT)
            .column(""unsigned_attribute"", BOOLEAN)
            .column(""fixed_prec_scale"", BOOLEAN)
            .column(""auto_increment"", BOOLEAN)
            .column(""local_type_name"", createUnboundedVarcharType())
            .column(""minimum_scale"", BIGINT)
            .column(""maximum_scale"", BIGINT)
            .column(""sql_data_type"", BIGINT)
            .column(""sql_datetime_sub"", BIGINT)
            .column(""num_prec_radix"", BIGINT)
            .build();
    private final TypeManager typeManager;
    @Inject
    public TypesJdbcTable(TypeManager typeManager)
    {
        this.typeManager = requireNonNull(typeManager, ""typeManager is null"");
    }
    @Override
    public ConnectorTableMetadata getTableMetadata()
    {
        return METADATA;
    }
    @Override
    public RecordCursor cursor(ConnectorTransactionHandle transactionHandle, ConnectorSession connectorSession, TupleDomain<Integer> constraint)
    {
        Builder table = InMemoryRecordSet.builder(METADATA);
        for (Type type : typeManager.getTypes()) {
            addTypeRow(table, type);
        }
        addParametricTypeRows(table, typeManager.getParametricTypes());
        return table.build().cursor();
    }
    private static void addTypeRow(Builder builder, Type type)
    {
        builder.addRow(
                type.getDisplayName(),
                jdbcDataType(type),
                columnSize(type),
                null,
                null,
                null,
                DatabaseMetaData.typeNullable,
                false,
                type.isComparable() ? DatabaseMetaData.typeSearchable : DatabaseMetaData.typePredNone,
                null,
                false,
                null,
                null,
                0,
                0,
                null,
                null,
                numPrecRadix(type));
    }
    private static void addParametricTypeRows(Builder builder, Collection<ParametricType> types)
    {
        for (ParametricType type : types) {
            String typeName = type.getName();
            builder.addRow(
                    typeName,
                    typeName.equalsIgnoreCase(""array"") ? Types.ARRAY : Types.JAVA_OBJECT,
                    null,
                    null,
                    null,
                    null,
                    DatabaseMetaData.typeNullable,
                    false,
                    DatabaseMetaData.typePredNone,
                    null,
                    false,
                    null,
                    null,
                    0,
                    0,
                    null,
                    null,
                    null);
        }
    }
}",class,
"    @Inject
    public TypesJdbcTable(TypeManager typeManager)
    {
        this.typeManager = requireNonNull(typeManager, ""typeManager is null"");
    }",method,
"    @Override
    public ConnectorTableMetadata getTableMetadata()
    {
        return METADATA;
    }",method,
"    @Override
    public RecordCursor cursor(ConnectorTransactionHandle transactionHandle, ConnectorSession connectorSession, TupleDomain<Integer> constraint)
    {
        Builder table = InMemoryRecordSet.builder(METADATA);
        for (Type type : typeManager.getTypes()) {
            addTypeRow(table, type);
        }
        addParametricTypeRows(table, typeManager.getParametricTypes());
        return table.build().cursor();
    }",method,
"    private static void addTypeRow(Builder builder, Type type)
    {
        builder.addRow(
                type.getDisplayName(),
                jdbcDataType(type),
                columnSize(type),
                null,
                null,
                null,
                DatabaseMetaData.typeNullable,
                false,
                type.isComparable() ? DatabaseMetaData.typeSearchable : DatabaseMetaData.typePredNone,
                null,
                false,
                null,
                null,
                0,
                0,
                null,
                null,
                numPrecRadix(type));
    }",method,
"    private static void addParametricTypeRows(Builder builder, Collection<ParametricType> types)
    {
        for (ParametricType type : types) {
            String typeName = type.getName();
            builder.addRow(
                    typeName,
                    typeName.equalsIgnoreCase(""array"") ? Types.ARRAY : Types.JAVA_OBJECT,
                    null,
                    null,
                    null,
                    null,
                    DatabaseMetaData.typeNullable,
                    false,
                    DatabaseMetaData.typePredNone,
                    null,
                    false,
                    null,
                    null,
                    0,
                    0,
                    null,
                    null,
                    null);
        }
    }",method,
"        for (ParametricType type : types) {
            String typeName = type.getName();
            builder.addRow(
                    typeName,
                    typeName.equalsIgnoreCase(""array"") ? Types.ARRAY : Types.JAVA_OBJECT,
                    null,
                    null,
                    null,
                    null,
                    DatabaseMetaData.typeNullable,
                    false,
                    DatabaseMetaData.typePredNone,
                    null,
                    false,
                    null,
                    null,
                    0,
                    0,
                    null,
                    null,
                    null);
        }",method,
"public abstract class AbstractRegistryEntry
    implements RegistryEntry, ErrorConstants {
    String name;
    float  priority;
    List   exts;
    List   mimeTypes;
    public AbstractRegistryEntry(String    name,
                                 float     priority,
                                 String [] exts,
                                 String [] mimeTypes) {
        this.name     = name;
        this.priority = priority;
        this.exts     = new ArrayList(exts.length);
        for (int i=0; i<exts.length; i++)
            this.exts.add(exts[i]);
        this.exts = Collections.unmodifiableList(this.exts);
        this.mimeTypes     = new ArrayList(mimeTypes.length);
        for (int i=0; i<mimeTypes.length; i++)
            this.mimeTypes.add(mimeTypes[i]);
        this.mimeTypes = Collections.unmodifiableList(this.mimeTypes);
    }
    public AbstractRegistryEntry(String name,
                                 float  priority,
                                 String ext,
                                 String mimeType) {
        this.name = name;
        this.priority = priority;
        this.exts = new ArrayList(1);
        this.exts.add(ext);
        this.exts = Collections.unmodifiableList(exts);
        this.mimeTypes = new ArrayList(1);
        this.mimeTypes.add(mimeType);
        this.mimeTypes = Collections.unmodifiableList(mimeTypes);
    }
    public String getFormatName() {
        return name;
    }
    public List   getStandardExtensions() {
        return exts;
    }
    public List   getMimeTypes() {
        return mimeTypes;
    }
    public float  getPriority() {
        return priority;
    }
}",class,
"    public AbstractRegistryEntry(String    name,
                                 float     priority,
                                 String [] exts,
                                 String [] mimeTypes) {
        this.name     = name;
        this.priority = priority;
        this.exts     = new ArrayList(exts.length);
        for (int i=0; i<exts.length; i++)
            this.exts.add(exts[i]);
        this.exts = Collections.unmodifiableList(this.exts);
        this.mimeTypes     = new ArrayList(mimeTypes.length);
        for (int i=0; i<mimeTypes.length; i++)
            this.mimeTypes.add(mimeTypes[i]);
        this.mimeTypes = Collections.unmodifiableList(this.mimeTypes);
    }",method,
"    public AbstractRegistryEntry(String name,
                                 float  priority,
                                 String ext,
                                 String mimeType) {
        this.name = name;
        this.priority = priority;
        this.exts = new ArrayList(1);
        this.exts.add(ext);
        this.exts = Collections.unmodifiableList(exts);
        this.mimeTypes = new ArrayList(1);
        this.mimeTypes.add(mimeType);
        this.mimeTypes = Collections.unmodifiableList(mimeTypes);
    }",method,
"    public String getFormatName() {
        return name;
    }",method,
"    public List   getStandardExtensions() {
        return exts;
    }",method,
"    public List   getMimeTypes() {
        return mimeTypes;
    }",method,
"    public float  getPriority() {
        return priority;
    }",method,
"public class GrReassignedInClosureLocalVarInspection extends BaseInspection {
  @Override
  @Nls
  @NotNull
  public String getDisplayName() {
    return ""Local variable is reassigned in closure or anonymous class"";
  }
  @Override
  public boolean isEnabledByDefault() {
    return true;
  }
  @NotNull
  @Override
  protected BaseInspectionVisitor buildVisitor() {
    return new BaseInspectionVisitor() {
      @Override
      public void visitReferenceExpression(@NotNull GrReferenceExpression referenceExpression) {
        super.visitReferenceExpression(referenceExpression);
        if (!PsiUtil.isLValue(referenceExpression)) return;
        final PsiElement resolved = referenceExpression.resolve();
        if (!PsiUtil.isLocalVariable(resolved)) return;
        final PsiType checked = GrReassignedLocalVarsChecker.getReassignedVarType(referenceExpression, false);
        if (checked == null) return;
        final GrControlFlowOwner varFlowOwner = ControlFlowUtils.findControlFlowOwner(resolved);
        final GrControlFlowOwner refFlorOwner = ControlFlowUtils.findControlFlowOwner(referenceExpression);
        if (isOtherScopeAndType(referenceExpression, checked, varFlowOwner, refFlorOwner)) {
          String flowDescription = getFlowDescription(refFlorOwner);
          final String message = GroovyInspectionBundle
            .message(""local.var.0.is.reassigned"", ((GrNamedElement)resolved).getName(), flowDescription);
          registerError(referenceExpression, message, LocalQuickFix.EMPTY_ARRAY, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
        }
      }
    };
  }
  private static boolean isOtherScopeAndType(GrReferenceExpression referenceExpression,
                                             PsiType checked,
                                             GrControlFlowOwner varFlowOwner,
                                             GrControlFlowOwner refFlorOwner) {
    return varFlowOwner != refFlorOwner && !TypesUtil.isAssignable(referenceExpression.getType(), checked, referenceExpression);
  }
  private static String getFlowDescription(GrControlFlowOwner refFlorOwner) {
    String flowDescription;
    if (refFlorOwner instanceof GrClosableBlock) {
      flowDescription = GroovyInspectionBundle.message(""closure"");
    }
    else if (refFlorOwner instanceof GrAnonymousClassDefinition) {
      flowDescription = GroovyInspectionBundle.message(""anonymous.class"");
    }
    else {
      flowDescription = GroovyInspectionBundle.message(""other.scope"");
    }
    return flowDescription;
  }
}",class,
"  @Override
  @Nls
  @NotNull
  public String getDisplayName() {
    return ""Local variable is reassigned in closure or anonymous class"";
  }",method,
"  @Override
  public boolean isEnabledByDefault() {
    return true;
  }",method,
"  @NotNull
  @Override
  protected BaseInspectionVisitor buildVisitor() {
    return new BaseInspectionVisitor() {
      @Override
      public void visitReferenceExpression(@NotNull GrReferenceExpression referenceExpression) {
        super.visitReferenceExpression(referenceExpression);
        if (!PsiUtil.isLValue(referenceExpression)) return;
        final PsiElement resolved = referenceExpression.resolve();
        if (!PsiUtil.isLocalVariable(resolved)) return;
        final PsiType checked = GrReassignedLocalVarsChecker.getReassignedVarType(referenceExpression, false);
        if (checked == null) return;
        final GrControlFlowOwner varFlowOwner = ControlFlowUtils.findControlFlowOwner(resolved);
        final GrControlFlowOwner refFlorOwner = ControlFlowUtils.findControlFlowOwner(referenceExpression);
        if (isOtherScopeAndType(referenceExpression, checked, varFlowOwner, refFlorOwner)) {
          String flowDescription = getFlowDescription(refFlorOwner);
          final String message = GroovyInspectionBundle
            .message(""local.var.0.is.reassigned"", ((GrNamedElement)resolved).getName(), flowDescription);
          registerError(referenceExpression, message, LocalQuickFix.EMPTY_ARRAY, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
        }
      }
    };
  }",method,
"    return new BaseInspectionVisitor() {
      @Override
      public void visitReferenceExpression(@NotNull GrReferenceExpression referenceExpression) {
        super.visitReferenceExpression(referenceExpression);
        if (!PsiUtil.isLValue(referenceExpression)) return;
        final PsiElement resolved = referenceExpression.resolve();
        if (!PsiUtil.isLocalVariable(resolved)) return;
        final PsiType checked = GrReassignedLocalVarsChecker.getReassignedVarType(referenceExpression, false);
        if (checked == null) return;
        final GrControlFlowOwner varFlowOwner = ControlFlowUtils.findControlFlowOwner(resolved);
        final GrControlFlowOwner refFlorOwner = ControlFlowUtils.findControlFlowOwner(referenceExpression);
        if (isOtherScopeAndType(referenceExpression, checked, varFlowOwner, refFlorOwner)) {
          String flowDescription = getFlowDescription(refFlorOwner);
          final String message = GroovyInspectionBundle
            .message(""local.var.0.is.reassigned"", ((GrNamedElement)resolved).getName(), flowDescription);
          registerError(referenceExpression, message, LocalQuickFix.EMPTY_ARRAY, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
        }
      }
    }",method,
"      @Override
      public void visitReferenceExpression(@NotNull GrReferenceExpression referenceExpression) {
        super.visitReferenceExpression(referenceExpression);
        if (!PsiUtil.isLValue(referenceExpression)) return;
        final PsiElement resolved = referenceExpression.resolve();
        if (!PsiUtil.isLocalVariable(resolved)) return;
        final PsiType checked = GrReassignedLocalVarsChecker.getReassignedVarType(referenceExpression, false);
        if (checked == null) return;
        final GrControlFlowOwner varFlowOwner = ControlFlowUtils.findControlFlowOwner(resolved);
        final GrControlFlowOwner refFlorOwner = ControlFlowUtils.findControlFlowOwner(referenceExpression);
        if (isOtherScopeAndType(referenceExpression, checked, varFlowOwner, refFlorOwner)) {
          String flowDescription = getFlowDescription(refFlorOwner);
          final String message = GroovyInspectionBundle
            .message(""local.var.0.is.reassigned"", ((GrNamedElement)resolved).getName(), flowDescription);
          registerError(referenceExpression, message, LocalQuickFix.EMPTY_ARRAY, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
        }
      }",method,
"  private static boolean isOtherScopeAndType(GrReferenceExpression referenceExpression,
                                             PsiType checked,
                                             GrControlFlowOwner varFlowOwner,
                                             GrControlFlowOwner refFlorOwner) {
    return varFlowOwner != refFlorOwner && !TypesUtil.isAssignable(referenceExpression.getType(), checked, referenceExpression);
  }",method,
"  private static String getFlowDescription(GrControlFlowOwner refFlorOwner) {
    String flowDescription;
    if (refFlorOwner instanceof GrClosableBlock) {
      flowDescription = GroovyInspectionBundle.message(""closure"");
    }
    else if (refFlorOwner instanceof GrAnonymousClassDefinition) {
      flowDescription = GroovyInspectionBundle.message(""anonymous.class"");
    }
    else {
      flowDescription = GroovyInspectionBundle.message(""other.scope"");
    }
    return flowDescription;
  }",method,
"    if (refFlorOwner instanceof GrClosableBlock) {
      flowDescription = GroovyInspectionBundle.message(""closure"");
    }",method,
"    else if (refFlorOwner instanceof GrAnonymousClassDefinition) {
      flowDescription = GroovyInspectionBundle.message(""anonymous.class"");
    }",method,
"public class AddressableSimplifier implements FunctionBodyTransformer {
  public static final AddressableSimplifier INSTANCE = new AddressableSimplifier();
  private AddressableSimplifier() {
  }
  @Override
  public boolean transform(TreeLogger logger, GimpleCompilationUnit unit, GimpleFunction fn) {
    boolean updated = false;
    for (GimpleBasicBlock basicBlock : fn.getBasicBlocks()) {
      for (GimpleStatement statement : basicBlock.getStatements()) {
        if(statement instanceof GimpleAssignment) {
          if(fixAssignment((GimpleAssignment) statement)) {
            updated = true;
          }
        } else if(statement instanceof GimpleCall) {
          if(fixCallArguments((GimpleCall) statement)) {
            updated = true;
          }
        }
      }
    }
    return updated;
  }
  private boolean fixAssignment(GimpleAssignment assignment) {
    boolean updated = false;
    // Simplify &*x to x
    if(assignment.getOperator() == GimpleOp.ADDR_EXPR) {
      GimpleAddressOf addressOf = (GimpleAddressOf) assignment.getOperands().get(0);
      if(addressOf.getValue() instanceof GimpleMemRef) {
        GimpleMemRef memRef = (GimpleMemRef) addressOf.getValue();
        if(memRef.isOffsetZero()) {
          // &*x => x
          assignment.setOperator(GimpleOp.NOP_EXPR);
          assignment.getOperands().set(0, memRef.getPointer());
        } else {
          // &*(x+8) => x+8
          GimpleExpr offset = memRef.getOffset();
          offset.setType(memRef.getPointer().getType());
          assignment.setOperator(GimpleOp.POINTER_PLUS_EXPR);
          assignment.getOperands().set(0, memRef.getPointer());
          assignment.getOperands().add(offset);
        }
        updated = true;
      }
    }
    // Fix types in *a = *b
    // which sometimes have types (int8[] = int8[])
    if( assignment.getLHS() instanceof GimpleMemRef &&
        assignment.getOperator() == GimpleOp.MEM_REF) {
      GimpleMemRef lhs = (GimpleMemRef) assignment.getLHS();
      GimpleMemRef rhs = (GimpleMemRef) assignment.getOperands().get(0);
      if( isByteArray(lhs.getType()) &&
          isByteArray(rhs.getType())) {
        if (lhs.isOffsetZero() && rhs.isOffsetZero()) {
          GimpleIndirectType lhsType = (GimpleIndirectType) lhs.getPointer().getType();
          GimpleIndirectType rhsType = (GimpleIndirectType) rhs.getPointer().getType();
          lhs.setType(lhsType.getBaseType());
          rhs.setType(rhsType.getBaseType());
        }
      }
    }
    return updated;
  }
  private boolean fixCallArguments(GimpleCall statement) {
    boolean updated = false;
    List<GimpleExpr> operands = statement.getOperands();
    for (int i = 0; i < operands.size(); i++) {
      GimpleExpr op = operands.get(i);
      if (op instanceof GimpleAddressOf) {
        GimpleAddressOf addressOf = (GimpleAddressOf) op;
        if (addressOf.getValue() instanceof GimpleMemRef) {
          GimpleMemRef memRef = (GimpleMemRef) addressOf.getValue();
          if (memRef.isOffsetZero()) {
            statement.setOperand(i, memRef.getPointer());
          } else {
            statement.setOperand(i, new GimplePointerPlus(memRef.getPointer(), memRef.getOffset()));
          }
          updated = true;
        }
      }
    }
    return updated;
  }
  private boolean isByteArray(GimpleType type) {
    if(type instanceof GimpleArrayType) {
      GimpleArrayType arrayType = (GimpleArrayType) type;
      if(arrayType.getComponentType() instanceof GimpleIntegerType) {
        GimpleIntegerType integerType = (GimpleIntegerType) arrayType.getComponentType();
        if(integerType.getPrecision() == 8) {
          return true;
        }
      }
    }
    return false;
  }
}",class,
"  private AddressableSimplifier() {
  }",method,
"  @Override
  public boolean transform(TreeLogger logger, GimpleCompilationUnit unit, GimpleFunction fn) {
    boolean updated = false;
    for (GimpleBasicBlock basicBlock : fn.getBasicBlocks()) {
      for (GimpleStatement statement : basicBlock.getStatements()) {
        if(statement instanceof GimpleAssignment) {
          if(fixAssignment((GimpleAssignment) statement)) {
            updated = true;
          }
        } else if(statement instanceof GimpleCall) {
          if(fixCallArguments((GimpleCall) statement)) {
            updated = true;
          }
        }
      }
    }
    return updated;
  }",method,
"        if(statement instanceof GimpleAssignment) {
          if(fixAssignment((GimpleAssignment) statement)) {
            updated = true;
          }
        }",method,
"  private boolean fixAssignment(GimpleAssignment assignment) {
    boolean updated = false;
    // Simplify &*x to x
    if(assignment.getOperator() == GimpleOp.ADDR_EXPR) {
      GimpleAddressOf addressOf = (GimpleAddressOf) assignment.getOperands().get(0);
      if(addressOf.getValue() instanceof GimpleMemRef) {
        GimpleMemRef memRef = (GimpleMemRef) addressOf.getValue();
        if(memRef.isOffsetZero()) {
          // &*x => x
          assignment.setOperator(GimpleOp.NOP_EXPR);
          assignment.getOperands().set(0, memRef.getPointer());
        } else {
          // &*(x+8) => x+8
          GimpleExpr offset = memRef.getOffset();
          offset.setType(memRef.getPointer().getType());
          assignment.setOperator(GimpleOp.POINTER_PLUS_EXPR);
          assignment.getOperands().set(0, memRef.getPointer());
          assignment.getOperands().add(offset);
        }
        updated = true;
      }
    }
    // Fix types in *a = *b
    // which sometimes have types (int8[] = int8[])
    if( assignment.getLHS() instanceof GimpleMemRef &&
        assignment.getOperator() == GimpleOp.MEM_REF) {
      GimpleMemRef lhs = (GimpleMemRef) assignment.getLHS();
      GimpleMemRef rhs = (GimpleMemRef) assignment.getOperands().get(0);
      if( isByteArray(lhs.getType()) &&
          isByteArray(rhs.getType())) {
        if (lhs.isOffsetZero() && rhs.isOffsetZero()) {
          GimpleIndirectType lhsType = (GimpleIndirectType) lhs.getPointer().getType();
          GimpleIndirectType rhsType = (GimpleIndirectType) rhs.getPointer().getType();
          lhs.setType(lhsType.getBaseType());
          rhs.setType(rhsType.getBaseType());
        }
      }
    }
    return updated;
  }",method,
"  private boolean fixCallArguments(GimpleCall statement) {
    boolean updated = false;
    List<GimpleExpr> operands = statement.getOperands();
    for (int i = 0; i < operands.size(); i++) {
      GimpleExpr op = operands.get(i);
      if (op instanceof GimpleAddressOf) {
        GimpleAddressOf addressOf = (GimpleAddressOf) op;
        if (addressOf.getValue() instanceof GimpleMemRef) {
          GimpleMemRef memRef = (GimpleMemRef) addressOf.getValue();
          if (memRef.isOffsetZero()) {
            statement.setOperand(i, memRef.getPointer());
          } else {
            statement.setOperand(i, new GimplePointerPlus(memRef.getPointer(), memRef.getOffset()));
          }
          updated = true;
        }
      }
    }
    return updated;
  }",method,
"      if (op instanceof GimpleAddressOf) {
        GimpleAddressOf addressOf = (GimpleAddressOf) op;
        if (addressOf.getValue() instanceof GimpleMemRef) {
          GimpleMemRef memRef = (GimpleMemRef) addressOf.getValue();
          if (memRef.isOffsetZero()) {
            statement.setOperand(i, memRef.getPointer());
          } else {
            statement.setOperand(i, new GimplePointerPlus(memRef.getPointer(), memRef.getOffset()));
          }
          updated = true;
        }
      }",method,
"  private boolean isByteArray(GimpleType type) {
    if(type instanceof GimpleArrayType) {
      GimpleArrayType arrayType = (GimpleArrayType) type;
      if(arrayType.getComponentType() instanceof GimpleIntegerType) {
        GimpleIntegerType integerType = (GimpleIntegerType) arrayType.getComponentType();
        if(integerType.getPrecision() == 8) {
          return true;
        }
      }
    }
    return false;
  }",method,
"    if(type instanceof GimpleArrayType) {
      GimpleArrayType arrayType = (GimpleArrayType) type;
      if(arrayType.getComponentType() instanceof GimpleIntegerType) {
        GimpleIntegerType integerType = (GimpleIntegerType) arrayType.getComponentType();
        if(integerType.getPrecision() == 8) {
          return true;
        }
      }
    }",method,
"public class RecentsImplProxy extends IRecentsNonSystemUserCallbacks.Stub {
    private static final int MSG_PRELOAD_RECENTS = 1;
    private static final int MSG_CANCEL_PRELOADING_RECENTS = 2;
    private static final int MSG_SHOW_RECENTS = 3;
    private static final int MSG_HIDE_RECENTS = 4;
    private static final int MSG_TOGGLE_RECENTS = 5;
    private static final int MSG_ON_CONFIGURATION_CHANGED = 6;
    private static final int MSG_DOCK_TOP_TASK = 7;
    private static final int MSG_ON_DRAGGING_IN_RECENTS = 8;
    private static final int MSG_ON_DRAGGING_IN_RECENTS_ENDED = 9;
    private static final int MSG_SHOW_USER_TOAST = 10;
    private RecentsImpl mImpl;
    public RecentsImplProxy(RecentsImpl recentsImpl) {
        mImpl = recentsImpl;
    }
    @Override
    public void preloadRecents() throws RemoteException {
        mHandler.sendEmptyMessage(MSG_PRELOAD_RECENTS);
    }
    @Override
    public void cancelPreloadingRecents() throws RemoteException {
        mHandler.sendEmptyMessage(MSG_CANCEL_PRELOADING_RECENTS);
    }
    @Override
    public void showRecents(boolean triggeredFromAltTab, boolean draggingInRecents, boolean animate,
            boolean reloadTasks, boolean fromHome, int growTarget)
            throws RemoteException {
        SomeArgs args = SomeArgs.obtain();
        args.argi1 = triggeredFromAltTab ? 1 : 0;
        args.argi2 = draggingInRecents ? 1 : 0;
        args.argi3 = animate ? 1 : 0;
        args.argi4 = reloadTasks ? 1 : 0;
        args.argi5 = fromHome ? 1 : 0;
        args.argi6 = growTarget;
        mHandler.sendMessage(mHandler.obtainMessage(MSG_SHOW_RECENTS, args));
    }
    @Override
    public void hideRecents(boolean triggeredFromAltTab, boolean triggeredFromHomeKey)
            throws RemoteException {
        mHandler.sendMessage(mHandler.obtainMessage(MSG_HIDE_RECENTS, triggeredFromAltTab ? 1 :0,
                triggeredFromHomeKey ? 1 : 0));
    }
    @Override
    public void toggleRecents(int growTarget) throws RemoteException {
        SomeArgs args = SomeArgs.obtain();
        args.argi1 = growTarget;
        mHandler.sendMessage(mHandler.obtainMessage(MSG_TOGGLE_RECENTS, args));
    }
    @Override
    public void onConfigurationChanged() throws RemoteException {
        mHandler.sendEmptyMessage(MSG_ON_CONFIGURATION_CHANGED);
    }
    @Override
    public void dockTopTask(int topTaskId, int dragMode, int stackCreateMode,
            Rect initialBounds) throws RemoteException {
        SomeArgs args = SomeArgs.obtain();
        args.argi1 = topTaskId;
        args.argi2 = dragMode;
        args.argi3 = stackCreateMode;
        args.arg1 = initialBounds;
        mHandler.sendMessage(mHandler.obtainMessage(MSG_DOCK_TOP_TASK, args));
    }
    @Override
    public void onDraggingInRecents(float distanceFromTop) throws RemoteException {
        mHandler.sendMessage(mHandler.obtainMessage(MSG_ON_DRAGGING_IN_RECENTS, distanceFromTop));
    }
    @Override
    public void onDraggingInRecentsEnded(float velocity) throws RemoteException {
        mHandler.sendMessage(mHandler.obtainMessage(MSG_ON_DRAGGING_IN_RECENTS_ENDED, velocity));
    }
    @Override
    public void showCurrentUserToast(int msgResId, int msgLength) {
        mHandler.sendMessage(mHandler.obtainMessage(MSG_SHOW_USER_TOAST, msgResId, msgLength));
    }
    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            SomeArgs args;
            switch (msg.what) {
                case MSG_PRELOAD_RECENTS:
                    mImpl.preloadRecents();
                    break;
                case MSG_CANCEL_PRELOADING_RECENTS:
                    mImpl.cancelPreloadingRecents();
                    break;
                case MSG_SHOW_RECENTS:
                    args = (SomeArgs) msg.obj;
                    mImpl.showRecents(args.argi1 != 0, args.argi2 != 0, args.argi3 != 0,
                            args.argi4 != 0, args.argi5 != 0, args.argi6);
                    break;
                case MSG_HIDE_RECENTS:
                    mImpl.hideRecents(msg.arg1 != 0, msg.arg2 != 0);
                    break;
                case MSG_TOGGLE_RECENTS:
                    args = (SomeArgs) msg.obj;
                    mImpl.toggleRecents(args.argi1);
                    break;
                case MSG_ON_CONFIGURATION_CHANGED:
                    mImpl.onConfigurationChanged();
                    break;
                case MSG_DOCK_TOP_TASK:
                    args = (SomeArgs) msg.obj;
                    mImpl.dockTopTask(args.argi1, args.argi2, args.argi3 = 0,
                            (Rect) args.arg1);
                    break;
                case MSG_ON_DRAGGING_IN_RECENTS:
                    mImpl.onDraggingInRecents((Float) msg.obj);
                    break;
                case MSG_ON_DRAGGING_IN_RECENTS_ENDED:
                    mImpl.onDraggingInRecentsEnded((Float) msg.obj);
                    break;
                case MSG_SHOW_USER_TOAST:
                    mImpl.onShowCurrentUserToast(msg.arg1, msg.arg2);
                    break;
                default:
                    super.handleMessage(msg);
            }
            super.handleMessage(msg);
        }
    };
}",class,
"    public RecentsImplProxy(RecentsImpl recentsImpl) {
        mImpl = recentsImpl;
    }",method,
"    @Override
    public void preloadRecents() throws RemoteException {
        mHandler.sendEmptyMessage(MSG_PRELOAD_RECENTS);
    }",method,
"    @Override
    public void cancelPreloadingRecents() throws RemoteException {
        mHandler.sendEmptyMessage(MSG_CANCEL_PRELOADING_RECENTS);
    }",method,
"    @Override
    public void showRecents(boolean triggeredFromAltTab, boolean draggingInRecents, boolean animate,
            boolean reloadTasks, boolean fromHome, int growTarget)
            throws RemoteException {
        SomeArgs args = SomeArgs.obtain();
        args.argi1 = triggeredFromAltTab ? 1 : 0;
        args.argi2 = draggingInRecents ? 1 : 0;
        args.argi3 = animate ? 1 : 0;
        args.argi4 = reloadTasks ? 1 : 0;
        args.argi5 = fromHome ? 1 : 0;
        args.argi6 = growTarget;
        mHandler.sendMessage(mHandler.obtainMessage(MSG_SHOW_RECENTS, args));
    }",method,
"    @Override
    public void hideRecents(boolean triggeredFromAltTab, boolean triggeredFromHomeKey)
            throws RemoteException {
        mHandler.sendMessage(mHandler.obtainMessage(MSG_HIDE_RECENTS, triggeredFromAltTab ? 1 :0,
                triggeredFromHomeKey ? 1 : 0));
    }",method,
"    @Override
    public void toggleRecents(int growTarget) throws RemoteException {
        SomeArgs args = SomeArgs.obtain();
        args.argi1 = growTarget;
        mHandler.sendMessage(mHandler.obtainMessage(MSG_TOGGLE_RECENTS, args));
    }",method,
"    @Override
    public void onConfigurationChanged() throws RemoteException {
        mHandler.sendEmptyMessage(MSG_ON_CONFIGURATION_CHANGED);
    }",method,

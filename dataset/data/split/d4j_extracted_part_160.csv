code_snippet,type,score
"    public static void main(String[] args) throws NoSuchAlgorithmException {
        String input = ""admin"";
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        md.update(input.getBytes(), 0, input.length());
        String output = new BigInteger(1, md.digest()).toString(16);
        System.out.println(""MD5 : "" + output);
    }",method,
"    public ArrayListQueue(int capacity){
        data = (T[]) new Object[capacity];
    }",method,
"    private void resize(int capacity){
        T[] copy = (T[]) new Object[capacity];
        for(int i = 0; i<data.length;i++){
            copy[i] = data[i];
        }
        data = copy;
    }",method,
"        for(int i = 0; i<data.length;i++){
            copy[i] = data[i];
        }",method,
"    public void enqueue(T t){
        if (tail==data.length) resize(data.length*2);
        data[tail++] = t;
    }",method,
"    public T dequeue(){
        T t = data[head];
        data[head++] = null;
        return t;
    }",method,
"    public ArrayListStack(int capacity){
        data = (T[]) new Object[capacity];
    }",method,
"    private void resize(int capacity){
        T[] copy = (T[])new Object[capacity];
        for (int i=0;i<n;i++){
            copy[i] = data[i];
        }
        data = copy;
    }",method,
"        for (int i=0;i<n;i++){
            copy[i] = data[i];
        }",method,
"    @Override
    public void push(T t) {
        if (data.length==n) resize(n*2);
        data[n++] = t;
    }",method,
"    @Override
    public T pop() {
        T itm = data[--n];
        data[n] = null;
        if (n>0 && n==data.length/4) resize(data.length/2);
        return itm;
    }",method,
"public class AVTPartXPath extends AVTPart
{
    static final long serialVersionUID = -4460373807550527675L;
  private XPath m_xpath;
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_xpath.fixupVariables(vars, globalsSize);
  }
   public boolean canTraverseOutsideSubtree()
   {
    return m_xpath.getExpression().canTraverseOutsideSubtree();
   }
  public AVTPartXPath(XPath xpath)
  {
    m_xpath = xpath;
  }
  public AVTPartXPath(
          String val, org.apache.xml.utils.PrefixResolver nsNode, 
          XPathParser xpathProcessor, XPathFactory factory, 
          XPathContext liaison)
            throws javax.xml.transform.TransformerException
  {
    m_xpath = new XPath(val, null, nsNode, XPath.SELECT, liaison.getErrorListener());
  }
  public String getSimpleString()
  {
    return ""{"" + m_xpath.getPatternString() + ""}"";
  }
  public void evaluate(
          XPathContext xctxt, FastStringBuffer buf, int context, org.apache.xml.utils.PrefixResolver nsNode)
            throws javax.xml.transform.TransformerException
  {
    XObject xobj = m_xpath.execute(xctxt, context, nsNode);
    if (null != xobj)
    {
      xobj.appendToFsb(buf);
    }
  }
  public void callVisitors(XSLTVisitor visitor)
  {
  	m_xpath.getExpression().callVisitors(m_xpath, visitor);
  }
}",class,
"  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_xpath.fixupVariables(vars, globalsSize);
  }",method,
"   public boolean canTraverseOutsideSubtree()
   {
    return m_xpath.getExpression().canTraverseOutsideSubtree();
   }",method,
"  public AVTPartXPath(XPath xpath)
  {
    m_xpath = xpath;
  }",method,
"  public AVTPartXPath(
          String val, org.apache.xml.utils.PrefixResolver nsNode, 
          XPathParser xpathProcessor, XPathFactory factory, 
          XPathContext liaison)
            throws javax.xml.transform.TransformerException
  {
    m_xpath = new XPath(val, null, nsNode, XPath.SELECT, liaison.getErrorListener());
  }",method,
"  public String getSimpleString()
  {
    return ""{"" + m_xpath.getPatternString() + ""}"";
  }",method,
"  public void evaluate(
          XPathContext xctxt, FastStringBuffer buf, int context, org.apache.xml.utils.PrefixResolver nsNode)
            throws javax.xml.transform.TransformerException
  {
    XObject xobj = m_xpath.execute(xctxt, context, nsNode);
    if (null != xobj)
    {
      xobj.appendToFsb(buf);
    }
  }",method,
"    if (null != xobj)
    {
      xobj.appendToFsb(buf);
    }",method,
"  public void callVisitors(XSLTVisitor visitor)
  {
  	m_xpath.getExpression().callVisitors(m_xpath, visitor);
  }",method,
"public class QueryStasticsRecorderImplTest {
  private static QueryStatisticsRecorderImpl queryStasticsRecorderImpl = null;
  private static QueryStatistic queryStatistic = null;
  private static QueryStatistic queryStatisticWithLOAD_BLOCKS_EXECUTOR = null;
  private static QueryStatistic queryStatisticWithSCAN_BLOCKS_TIME = null;
  private static QueryStatistic queryStatisticWithSCAN_BLOCKS_NUM = null;
  private static QueryStatistic queryStatisticWithLOAD_DICTIONARY = null;
  private static QueryStatistic queryStatisticWithRESULT_SIZE = null;
  private static QueryStatistic queryStatisticWithEXECUTOR_PART = null;
  private static QueryStatistic queryStatisticWithTOTAL_BLOCKLET_NUM = null;
  private static QueryStatistic queryStatisticWithVALID_SCAN_BLOCKLET_NUM = null;
  @BeforeClass public static void setUp() {
    queryStatisticWithLOAD_BLOCKS_EXECUTOR = new QueryStatistic();
    queryStasticsRecorderImpl = new QueryStatisticsRecorderImpl(System.nanoTime() + """");
    queryStasticsRecorderImpl.logStatisticsAsTableDriver();
    queryStatisticWithLOAD_BLOCKS_EXECUTOR
        .addStatistics(QueryStatisticsConstants.LOAD_BLOCKS_EXECUTOR, 5L);
    queryStatisticWithLOAD_BLOCKS_EXECUTOR
        .addCountStatistic(QueryStatisticsConstants.LOAD_BLOCKS_EXECUTOR, 5L);
    queryStatisticWithLOAD_BLOCKS_EXECUTOR
        .addStatistics(QueryStatisticsConstants.LOAD_BLOCKS_EXECUTOR, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithLOAD_BLOCKS_EXECUTOR);
    queryStatisticWithSCAN_BLOCKS_TIME = new QueryStatistic();
    queryStatisticWithSCAN_BLOCKS_TIME.addStatistics(QueryStatisticsConstants.SCAN_BLOCKlET_TIME, 5L);
    queryStatisticWithSCAN_BLOCKS_TIME
        .addCountStatistic(QueryStatisticsConstants.SCAN_BLOCKlET_TIME, 5L);
    queryStatisticWithSCAN_BLOCKS_TIME.addStatistics(QueryStatisticsConstants.SCAN_BLOCKlET_TIME, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithSCAN_BLOCKS_TIME);
    queryStatisticWithSCAN_BLOCKS_NUM = new QueryStatistic();
    queryStatisticWithSCAN_BLOCKS_NUM.addStatistics(QueryStatisticsConstants.SCAN_BLOCKS_NUM, 5L);
    queryStatisticWithSCAN_BLOCKS_NUM
        .addCountStatistic(QueryStatisticsConstants.SCAN_BLOCKS_NUM, 5L);
    queryStatisticWithSCAN_BLOCKS_NUM.addStatistics(QueryStatisticsConstants.SCAN_BLOCKS_NUM, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithSCAN_BLOCKS_NUM);
    queryStatisticWithLOAD_DICTIONARY = new QueryStatistic();
    queryStatisticWithLOAD_DICTIONARY.addStatistics(QueryStatisticsConstants.LOAD_DICTIONARY, 5L);
    queryStatisticWithLOAD_DICTIONARY
        .addCountStatistic(QueryStatisticsConstants.LOAD_DICTIONARY, 5L);
    queryStatisticWithLOAD_DICTIONARY.addStatistics(QueryStatisticsConstants.LOAD_DICTIONARY, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithLOAD_DICTIONARY);
    queryStatisticWithRESULT_SIZE = new QueryStatistic();
    queryStatisticWithRESULT_SIZE.addStatistics(QueryStatisticsConstants.RESULT_SIZE, 5L);
    queryStatisticWithRESULT_SIZE.addCountStatistic(QueryStatisticsConstants.RESULT_SIZE, 5L);
    queryStatisticWithRESULT_SIZE.addStatistics(QueryStatisticsConstants.RESULT_SIZE, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithRESULT_SIZE);
    queryStatisticWithEXECUTOR_PART = new QueryStatistic();
    queryStatisticWithEXECUTOR_PART.addStatistics(QueryStatisticsConstants.EXECUTOR_PART, 5L);
    queryStatisticWithEXECUTOR_PART.addCountStatistic(QueryStatisticsConstants.EXECUTOR_PART, 5L);
    queryStatisticWithEXECUTOR_PART.addStatistics(QueryStatisticsConstants.EXECUTOR_PART, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithEXECUTOR_PART);
    queryStatisticWithTOTAL_BLOCKLET_NUM = new QueryStatistic();
    queryStatisticWithTOTAL_BLOCKLET_NUM
        .addStatistics(QueryStatisticsConstants.TOTAL_BLOCKLET_NUM, 5L);
    queryStatisticWithTOTAL_BLOCKLET_NUM
        .addCountStatistic(QueryStatisticsConstants.TOTAL_BLOCKLET_NUM, 5L);
    queryStatisticWithTOTAL_BLOCKLET_NUM
        .addStatistics(QueryStatisticsConstants.TOTAL_BLOCKLET_NUM, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithTOTAL_BLOCKLET_NUM);
    queryStatisticWithVALID_SCAN_BLOCKLET_NUM = new QueryStatistic();
    queryStatisticWithVALID_SCAN_BLOCKLET_NUM
        .addStatistics(QueryStatisticsConstants.VALID_SCAN_BLOCKLET_NUM, 5L);
    queryStatisticWithVALID_SCAN_BLOCKLET_NUM
        .addCountStatistic(QueryStatisticsConstants.VALID_SCAN_BLOCKLET_NUM, 5L);
    queryStatisticWithVALID_SCAN_BLOCKLET_NUM
        .addStatistics(QueryStatisticsConstants.VALID_SCAN_BLOCKLET_NUM, 5L);
    queryStasticsRecorderImpl.logStatistics();
    queryStasticsRecorderImpl.recordStatistics(queryStatisticWithVALID_SCAN_BLOCKLET_NUM);
    queryStasticsRecorderImpl.logStatisticsAsTableExecutor();
  }
  @Test public void testcollectExecutorStatistics() {
    assertNotNull(queryStasticsRecorderImpl.collectExecutorStatistics());
  }
}",class,
"public class MethodParametersAttribute extends Attribute
{
    public int             u1parametersCount;
    public ParameterInfo[] parameters;
    public MethodParametersAttribute()
    {
    }
    public MethodParametersAttribute(int             u2attributeNameIndex,
                                     int             u1parametersCount,
                                     ParameterInfo[] parameters)
    {
        super(u2attributeNameIndex);
        this.u1parametersCount = u1parametersCount;
        this.parameters        = parameters;
    }
    // Implementations for Attribute.
    public void accept(Clazz clazz, Method method, AttributeVisitor attributeVisitor)
    {
        attributeVisitor.visitMethodParametersAttribute(clazz, method, this);
    }
    public void parametersAccept(Clazz clazz, Method method, ParameterInfoVisitor parameterInfoVisitor)
    {
        // Loop over all parameters.
        for (int index = 0; index < u1parametersCount; index++)
        {
            // We don't need double dispatching here, since there is only one
            // type of ParameterInfo.
            parameterInfoVisitor.visitParameterInfo(clazz, method, index, parameters[index]);
        }
    }
}",class,
"    public MethodParametersAttribute()
    {
    }",method,
"    public MethodParametersAttribute(int             u2attributeNameIndex,
                                     int             u1parametersCount,
                                     ParameterInfo[] parameters)
    {
        super(u2attributeNameIndex);
        this.u1parametersCount = u1parametersCount;
        this.parameters        = parameters;
    }",method,
"    public void accept(Clazz clazz, Method method, AttributeVisitor attributeVisitor)
    {
        attributeVisitor.visitMethodParametersAttribute(clazz, method, this);
    }",method,
"    public void parametersAccept(Clazz clazz, Method method, ParameterInfoVisitor parameterInfoVisitor)
    {
        // Loop over all parameters.
        for (int index = 0; index < u1parametersCount; index++)
        {
            // We don't need double dispatching here, since there is only one
            // type of ParameterInfo.
            parameterInfoVisitor.visitParameterInfo(clazz, method, index, parameters[index]);
        }
    }",method,
"        for (int index = 0; index < u1parametersCount; index++)
        {
            // We don't need double dispatching here, since there is only one
            // type of ParameterInfo.
            parameterInfoVisitor.visitParameterInfo(clazz, method, index, parameters[index]);
        }",method,
"public class MocksCreationTest extends TestBase {
    private class HasPrivateConstructor {}
    @Test
    public void shouldCreateMockWhenConstructorIsPrivate() {
        assertNotNull(Mockito.mock(HasPrivateConstructor.class));
    }
    @Test
    public void shouldCombineMockNameAndSmartNulls() {
        //given
        IMethods mock = mock(IMethods.class, withSettings()
            .defaultAnswer(RETURNS_SMART_NULLS)
            .name(""great mockie""));
        //when
        IMethods smartNull = mock.iMethodsReturningMethod();
        String name = mock.toString();
        //then
        assertThat(name).contains(""great mockie"");
        //and
        try {
            smartNull.simpleMethod();
            fail();
        } catch(SmartNullPointerException e) {}
    }
    @Test
    public void shouldCombineMockNameAndExtraInterfaces() {
        //given
        IMethods mock = mock(IMethods.class, withSettings()
                .extraInterfaces(List.class)
                .name(""great mockie""));
        //when
        String name = mock.toString();
        //then
        assertThat(name).contains(""great mockie"");
        //and
        assertTrue(mock instanceof List);
    }
    @Test
    public void shouldSpecifyMockNameViaSettings() {
        //given
        IMethods mock = mock(IMethods.class, withSettings().name(""great mockie""));
        //when
        String name = mock.toString();
        //then
        assertThat(name).contains(""great mockie"");
    }
    @Test
    public void shouldScreamWhenSpyCreatedWithWrongType() {
        //given
        List list = new LinkedList();
        try {
            //when
            mock(List.class, withSettings().spiedInstance(list));
            fail();
            //then
        } catch (MockitoException e) {}
    }
    @Test
    public void shouldAllowCreatingSpiesWithCorrectType() {
        List list = new LinkedList();
        mock(LinkedList.class, withSettings().spiedInstance(list));
    }
    @Test
    public void shouldAllowInlineMockCreation() throws Exception {
        when(mock(Set.class).isEmpty()).thenReturn(false);
    }
}",class,
    private class HasPrivateConstructor {},class,
"    @Test
    public void shouldCreateMockWhenConstructorIsPrivate() {
        assertNotNull(Mockito.mock(HasPrivateConstructor.class));
    }",method,
"    @Test
    public void shouldCombineMockNameAndSmartNulls() {
        //given
        IMethods mock = mock(IMethods.class, withSettings()
            .defaultAnswer(RETURNS_SMART_NULLS)
            .name(""great mockie""));
        //when
        IMethods smartNull = mock.iMethodsReturningMethod();
        String name = mock.toString();
        //then
        assertThat(name).contains(""great mockie"");
        //and
        try {
            smartNull.simpleMethod();
            fail();
        } catch(SmartNullPointerException e) {}
    }",method,
"    @Test
    public void shouldCombineMockNameAndExtraInterfaces() {
        //given
        IMethods mock = mock(IMethods.class, withSettings()
                .extraInterfaces(List.class)
                .name(""great mockie""));
        //when
        String name = mock.toString();
        //then
        assertThat(name).contains(""great mockie"");
        //and
        assertTrue(mock instanceof List);
    }",method,
"    @Test
    public void shouldSpecifyMockNameViaSettings() {
        //given
        IMethods mock = mock(IMethods.class, withSettings().name(""great mockie""));
        //when
        String name = mock.toString();
        //then
        assertThat(name).contains(""great mockie"");
    }",method,
"    @Test
    public void shouldScreamWhenSpyCreatedWithWrongType() {
        //given
        List list = new LinkedList();
        try {
            //when
            mock(List.class, withSettings().spiedInstance(list));
            fail();
            //then
        } catch (MockitoException e) {}
    }",method,
"    @Test
    public void shouldAllowCreatingSpiesWithCorrectType() {
        List list = new LinkedList();
        mock(LinkedList.class, withSettings().spiedInstance(list));
    }",method,
"    @Test
    public void shouldAllowInlineMockCreation() throws Exception {
        when(mock(Set.class).isEmpty()).thenReturn(false);
    }",method,
"public class AsyncCloseTest1 extends TestCase {
    protected DruidDataSource dataSource;
    private ExecutorService   connExecutor;
    private ExecutorService   closeExecutor;
    final AtomicInteger       errorCount = new AtomicInteger();
    private Logger            log4jLog;
    private Level             log4jOldLevel;
    private NoLoggingImpl     noLoggingImpl;
    protected void setUp() throws Exception {
        Field logField = DruidDataSource.class.getDeclaredField(""LOG"");
        logField.setAccessible(true);
        Log dataSourceLog = (Log) logField.get(null);
        if (dataSourceLog instanceof Log4jImpl) {
            this.log4jLog = ((Log4jImpl) dataSourceLog).getLog();
            this.log4jOldLevel = this.log4jLog.getLevel();
            this.log4jLog.setLevel(Level.FATAL);
        } else if (dataSourceLog instanceof NoLoggingImpl) {
            noLoggingImpl =  (NoLoggingImpl) dataSourceLog;
            noLoggingImpl.setErrorEnabled(false);
        }
        dataSource = new DruidDataSource();
        dataSource.setUrl(""jdbc:mock:"");
//        dataSource.setAsyncCloseConnectionEnable(true);
        dataSource.setTestOnBorrow(false);
        dataSource.setMaxActive(16);
        connExecutor = Executors.newFixedThreadPool(128);
        closeExecutor = Executors.newFixedThreadPool(128);
    }
    protected void tearDown() throws Exception {
        dataSource.close();
        if (log4jLog != null) {
            log4jLog.setLevel(log4jOldLevel);
        } else if (noLoggingImpl != null) {
            noLoggingImpl.setErrorEnabled(true);
        }
    }
    public void test_0() throws Exception {
        for (int i = 0; i < 16; ++i) {
            loop();
            System.out.println(""loop "" + i + "" done."");
        }
    }
    class CloseTask implements Runnable {
        private Connection     conn;
        private CountDownLatch latch;
        public CloseTask(Connection conn, CountDownLatch latch){
            this.conn = conn;
            this.latch = latch;
        }
        @Override
        public void run() {
            try {
                conn.close();
            } catch (SQLException e) {
                errorCount.incrementAndGet();
            } finally {
                latch.countDown();
            }
        }
    }
    protected void loop() throws InterruptedException {
        dataSource.shrink();
        Assert.assertEquals(0, dataSource.getActiveCount());
        Assert.assertEquals(0, dataSource.getPoolingCount());
        final int COUNT = 1024 * 128;
        final CountDownLatch closeLatch = new CountDownLatch(COUNT * 2);
        Runnable connTask = new Runnable() {
            @Override
            public void run() {
                try {
                    Connection conn = dataSource.getConnection();
                    CloseTask closeTask = new CloseTask(conn, closeLatch);
                    closeExecutor.submit(closeTask);
                    closeExecutor.submit(closeTask); // dup close
                } catch (SQLException e) {
                    errorCount.incrementAndGet();
                }
            }
        };
        for (int i = 0; i < COUNT; ++i) {
            connExecutor.submit(connTask);
        }
        closeLatch.await();
        Assert.assertEquals(0, dataSource.getActiveCount());
        Assert.assertEquals(16, dataSource.getPoolingCount());
    }
}",class,
"    class CloseTask implements Runnable {
        private Connection     conn;
        private CountDownLatch latch;
        public CloseTask(Connection conn, CountDownLatch latch){
            this.conn = conn;
            this.latch = latch;
        }
        @Override
        public void run() {
            try {
                conn.close();
            } catch (SQLException e) {
                errorCount.incrementAndGet();
            } finally {
                latch.countDown();
            }
        }
    }",class,
"    protected void setUp() throws Exception {
        Field logField = DruidDataSource.class.getDeclaredField(""LOG"");
        logField.setAccessible(true);
        Log dataSourceLog = (Log) logField.get(null);
        if (dataSourceLog instanceof Log4jImpl) {
            this.log4jLog = ((Log4jImpl) dataSourceLog).getLog();
            this.log4jOldLevel = this.log4jLog.getLevel();
            this.log4jLog.setLevel(Level.FATAL);
        } else if (dataSourceLog instanceof NoLoggingImpl) {
            noLoggingImpl =  (NoLoggingImpl) dataSourceLog;
            noLoggingImpl.setErrorEnabled(false);
        }
        dataSource = new DruidDataSource();
        dataSource.setUrl(""jdbc:mock:"");
//        dataSource.setAsyncCloseConnectionEnable(true);
        dataSource.setTestOnBorrow(false);
        dataSource.setMaxActive(16);
        connExecutor = Executors.newFixedThreadPool(128);
        closeExecutor = Executors.newFixedThreadPool(128);
    }",method,
"        if (dataSourceLog instanceof Log4jImpl) {
            this.log4jLog = ((Log4jImpl) dataSourceLog).getLog();
            this.log4jOldLevel = this.log4jLog.getLevel();
            this.log4jLog.setLevel(Level.FATAL);
        }",method,
"    protected void tearDown() throws Exception {
        dataSource.close();
        if (log4jLog != null) {
            log4jLog.setLevel(log4jOldLevel);
        } else if (noLoggingImpl != null) {
            noLoggingImpl.setErrorEnabled(true);
        }
    }",method,
"        if (log4jLog != null) {
            log4jLog.setLevel(log4jOldLevel);
        }",method,
"    public void test_0() throws Exception {
        for (int i = 0; i < 16; ++i) {
            loop();
            System.out.println(""loop "" + i + "" done."");
        }
    }",method,
"        for (int i = 0; i < 16; ++i) {
            loop();
            System.out.println(""loop "" + i + "" done."");
        }",method,
"        public CloseTask(Connection conn, CountDownLatch latch){
            this.conn = conn;
            this.latch = latch;
        }",method,
"        @Override
        public void run() {
            try {
                conn.close();
            } catch (SQLException e) {
                errorCount.incrementAndGet();
            } finally {
                latch.countDown();
            }
        }",method,
"    protected void loop() throws InterruptedException {
        dataSource.shrink();
        Assert.assertEquals(0, dataSource.getActiveCount());
        Assert.assertEquals(0, dataSource.getPoolingCount());
        final int COUNT = 1024 * 128;
        final CountDownLatch closeLatch = new CountDownLatch(COUNT * 2);
        Runnable connTask = new Runnable() {
            @Override
            public void run() {
                try {
                    Connection conn = dataSource.getConnection();
                    CloseTask closeTask = new CloseTask(conn, closeLatch);
                    closeExecutor.submit(closeTask);
                    closeExecutor.submit(closeTask); // dup close
                } catch (SQLException e) {
                    errorCount.incrementAndGet();
                }
            }
        };
        for (int i = 0; i < COUNT; ++i) {
            connExecutor.submit(connTask);
        }
        closeLatch.await();
        Assert.assertEquals(0, dataSource.getActiveCount());
        Assert.assertEquals(16, dataSource.getPoolingCount());
    }",method,
"            @Override
            public void run() {
                try {
                    Connection conn = dataSource.getConnection();
                    CloseTask closeTask = new CloseTask(conn, closeLatch);
                    closeExecutor.submit(closeTask);
                    closeExecutor.submit(closeTask); // dup close
                } catch (SQLException e) {
                    errorCount.incrementAndGet();
                }
            }",method,
"        for (int i = 0; i < COUNT; ++i) {
            connExecutor.submit(connTask);
        }",method,
"public class DefaultModuleArtifactsCache implements ModuleArtifactsCache {
    private final BuildCommencedTimeProvider timeProvider;
    private final CacheLockingManager cacheLockingManager;
    private PersistentIndexedCache<ModuleArtifactsKey, ModuleArtifactsCacheEntry> cache;
    public DefaultModuleArtifactsCache(BuildCommencedTimeProvider timeProvider, CacheLockingManager cacheLockingManager) {
        this.timeProvider = timeProvider;
        this.cacheLockingManager = cacheLockingManager;
    }
    private PersistentIndexedCache<ModuleArtifactsKey, ModuleArtifactsCacheEntry> getCache() {
        if (cache == null) {
            cache = initCache();
        }
        return cache;
    }
    private PersistentIndexedCache<ModuleArtifactsKey, ModuleArtifactsCacheEntry> initCache() {
        return cacheLockingManager.createCache(""module-artifacts"", new ModuleArtifactsKeySerializer(), new ModuleArtifactsCacheEntrySerializer());
    }
    public CachedArtifacts cacheArtifacts(ModuleComponentRepository repository, ComponentIdentifier componentId, String context, BigInteger descriptorHash, Set<? extends ComponentArtifactMetadata> artifacts) {
        ModuleArtifactsKey key = new ModuleArtifactsKey(repository.getId(), componentId, context);
        ModuleArtifactsCacheEntry entry = new ModuleArtifactsCacheEntry(artifacts, timeProvider.getCurrentTime(), descriptorHash);
        getCache().put(key, entry);
        return createCacheArtifacts(entry);
    }
    public CachedArtifacts getCachedArtifacts(ModuleComponentRepository repository, ComponentIdentifier componentId, String context) {
        ModuleArtifactsKey key = new ModuleArtifactsKey(repository.getId(), componentId, context);
        ModuleArtifactsCacheEntry entry = getCache().get(key);
        if (entry == null) {
            return null;
        }
        return createCacheArtifacts(entry);
    }
    private CachedArtifacts createCacheArtifacts(ModuleArtifactsCacheEntry entry) {
        long entryAge = timeProvider.getCurrentTime() - entry.createTimestamp;
        return new DefaultCachedArtifacts(entry.artifacts, entry.moduleDescriptorHash, entryAge);
    }
    private static class ModuleArtifactsKey {
        private final String repositoryId;
        private final ComponentIdentifier componentId;
        private final String context;
        private ModuleArtifactsKey(String repositoryId, ComponentIdentifier componentId, String context) {
            this.repositoryId = repositoryId;
            this.componentId = componentId;
            this.context = context;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof ModuleArtifactsKey)) {
                return false;
            }
            ModuleArtifactsKey that = (ModuleArtifactsKey) o;
            return repositoryId.equals(that.repositoryId) && componentId.equals(that.componentId) && context.equals(that.context);
        }
        @Override
        public int hashCode() {
            int result = repositoryId.hashCode();
            result = 31 * result + componentId.hashCode();
            result = 31 * result + context.hashCode();
            return result;
        }
    }
    private static class ModuleArtifactsKeySerializer extends AbstractSerializer<ModuleArtifactsKey> {
        private final ComponentIdentifierSerializer identifierSerializer = new ComponentIdentifierSerializer();
        public void write(Encoder encoder, ModuleArtifactsKey value) throws Exception {
            encoder.writeString(value.repositoryId);
            identifierSerializer.write(encoder, value.componentId);
            encoder.writeString(value.context);
        }
        public ModuleArtifactsKey read(Decoder decoder) throws Exception {
            String resolverId = decoder.readString();
            ComponentIdentifier componentId = identifierSerializer.read(decoder);
            String context = decoder.readString();
            return new ModuleArtifactsKey(resolverId, componentId, context);
        }
        @Override
        public boolean equals(Object obj) {
            if (!super.equals(obj)) {
                return false;
            }
            ModuleArtifactsKeySerializer rhs = (ModuleArtifactsKeySerializer) obj;
            return Objects.equal(identifierSerializer, rhs.identifierSerializer);
        }
        @Override
        public int hashCode() {
            return Objects.hashCode(super.hashCode(), identifierSerializer);
        }
    }
    private static class ModuleArtifactsCacheEntry {
        private final Set<ComponentArtifactMetadata> artifacts;
        private final BigInteger moduleDescriptorHash;
        private final long createTimestamp;
        ModuleArtifactsCacheEntry(Set<? extends ComponentArtifactMetadata> artifacts, long createTimestamp, BigInteger moduleDescriptorHash) {
            this.artifacts = new LinkedHashSet<ComponentArtifactMetadata>(artifacts);
            this.createTimestamp = createTimestamp;
            this.moduleDescriptorHash = moduleDescriptorHash;
        }
    }
    private static class ModuleArtifactsCacheEntrySerializer extends AbstractSerializer<ModuleArtifactsCacheEntry> {
        private final Serializer<Set<ComponentArtifactMetadata>> artifactsSerializer =
                new SetSerializer<ComponentArtifactMetadata>(new ComponentArtifactMetadataSerializer());
        public void write(Encoder encoder, ModuleArtifactsCacheEntry value) throws Exception {
            encoder.writeLong(value.createTimestamp);
            byte[] hash = value.moduleDescriptorHash.toByteArray();
            encoder.writeBinary(hash);
            artifactsSerializer.write(encoder, value.artifacts);
        }
        public ModuleArtifactsCacheEntry read(Decoder decoder) throws Exception {
            long createTimestamp = decoder.readLong();
            byte[] encodedHash = decoder.readBinary();
            BigInteger hash = new BigInteger(encodedHash);
            Set<ComponentArtifactMetadata> artifacts = artifactsSerializer.read(decoder);
            return new ModuleArtifactsCacheEntry(artifacts, createTimestamp, hash);
        }
        @Override
        public boolean equals(Object obj) {
            if (!super.equals(obj)) {
                return false;
            }
            ModuleArtifactsCacheEntrySerializer rhs = (ModuleArtifactsCacheEntrySerializer) obj;
            return Objects.equal(artifactsSerializer, rhs.artifactsSerializer);
        }
        @Override
        public int hashCode() {
            return Objects.hashCode(super.hashCode(), artifactsSerializer);
        }
    }
    private static class DefaultCachedArtifacts implements ModuleArtifactsCache.CachedArtifacts {
        private final Set<ComponentArtifactMetadata> artifacts;
        private final BigInteger descriptorHash;
        private final long ageMillis;
        private DefaultCachedArtifacts(Set<ComponentArtifactMetadata> artifacts, BigInteger descriptorHash, long ageMillis) {
            this.ageMillis = ageMillis;
            this.artifacts = artifacts;
            this.descriptorHash = descriptorHash;
        }
        public Set<ComponentArtifactMetadata> getArtifacts() {
            return artifacts;
        }
        public BigInteger getDescriptorHash() {
            return descriptorHash;
        }
        public long getAgeMillis() {
            return ageMillis;
        }
    }
}",class,
"    private static class ModuleArtifactsKey {
        private final String repositoryId;
        private final ComponentIdentifier componentId;
        private final String context;
        private ModuleArtifactsKey(String repositoryId, ComponentIdentifier componentId, String context) {
            this.repositoryId = repositoryId;
            this.componentId = componentId;
            this.context = context;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof ModuleArtifactsKey)) {
                return false;
            }
            ModuleArtifactsKey that = (ModuleArtifactsKey) o;
            return repositoryId.equals(that.repositoryId) && componentId.equals(that.componentId) && context.equals(that.context);
        }
        @Override
        public int hashCode() {
            int result = repositoryId.hashCode();
            result = 31 * result + componentId.hashCode();
            result = 31 * result + context.hashCode();
            return result;
        }
    }",class,
"    private static class ModuleArtifactsKeySerializer extends AbstractSerializer<ModuleArtifactsKey> {
        private final ComponentIdentifierSerializer identifierSerializer = new ComponentIdentifierSerializer();
        public void write(Encoder encoder, ModuleArtifactsKey value) throws Exception {
            encoder.writeString(value.repositoryId);
            identifierSerializer.write(encoder, value.componentId);
            encoder.writeString(value.context);
        }
        public ModuleArtifactsKey read(Decoder decoder) throws Exception {
            String resolverId = decoder.readString();
            ComponentIdentifier componentId = identifierSerializer.read(decoder);
            String context = decoder.readString();
            return new ModuleArtifactsKey(resolverId, componentId, context);
        }
        @Override
        public boolean equals(Object obj) {
            if (!super.equals(obj)) {
                return false;
            }
            ModuleArtifactsKeySerializer rhs = (ModuleArtifactsKeySerializer) obj;
            return Objects.equal(identifierSerializer, rhs.identifierSerializer);
        }
        @Override
        public int hashCode() {
            return Objects.hashCode(super.hashCode(), identifierSerializer);
        }
    }",class,
"    private static class ModuleArtifactsCacheEntry {
        private final Set<ComponentArtifactMetadata> artifacts;
        private final BigInteger moduleDescriptorHash;
        private final long createTimestamp;
        ModuleArtifactsCacheEntry(Set<? extends ComponentArtifactMetadata> artifacts, long createTimestamp, BigInteger moduleDescriptorHash) {
            this.artifacts = new LinkedHashSet<ComponentArtifactMetadata>(artifacts);
            this.createTimestamp = createTimestamp;
            this.moduleDescriptorHash = moduleDescriptorHash;
        }
    }",class,
"    private static class ModuleArtifactsCacheEntrySerializer extends AbstractSerializer<ModuleArtifactsCacheEntry> {
        private final Serializer<Set<ComponentArtifactMetadata>> artifactsSerializer =
                new SetSerializer<ComponentArtifactMetadata>(new ComponentArtifactMetadataSerializer());
        public void write(Encoder encoder, ModuleArtifactsCacheEntry value) throws Exception {
            encoder.writeLong(value.createTimestamp);
            byte[] hash = value.moduleDescriptorHash.toByteArray();
            encoder.writeBinary(hash);
            artifactsSerializer.write(encoder, value.artifacts);
        }
        public ModuleArtifactsCacheEntry read(Decoder decoder) throws Exception {
            long createTimestamp = decoder.readLong();
            byte[] encodedHash = decoder.readBinary();
            BigInteger hash = new BigInteger(encodedHash);
            Set<ComponentArtifactMetadata> artifacts = artifactsSerializer.read(decoder);
            return new ModuleArtifactsCacheEntry(artifacts, createTimestamp, hash);
        }
        @Override
        public boolean equals(Object obj) {
            if (!super.equals(obj)) {
                return false;
            }
            ModuleArtifactsCacheEntrySerializer rhs = (ModuleArtifactsCacheEntrySerializer) obj;
            return Objects.equal(artifactsSerializer, rhs.artifactsSerializer);
        }
        @Override
        public int hashCode() {
            return Objects.hashCode(super.hashCode(), artifactsSerializer);
        }
    }",class,
"    private static class DefaultCachedArtifacts implements ModuleArtifactsCache.CachedArtifacts {
        private final Set<ComponentArtifactMetadata> artifacts;
        private final BigInteger descriptorHash;
        private final long ageMillis;
        private DefaultCachedArtifacts(Set<ComponentArtifactMetadata> artifacts, BigInteger descriptorHash, long ageMillis) {
            this.ageMillis = ageMillis;
            this.artifacts = artifacts;
            this.descriptorHash = descriptorHash;
        }
        public Set<ComponentArtifactMetadata> getArtifacts() {
            return artifacts;
        }
        public BigInteger getDescriptorHash() {
            return descriptorHash;
        }
        public long getAgeMillis() {
            return ageMillis;
        }
    }",class,
"    public DefaultModuleArtifactsCache(BuildCommencedTimeProvider timeProvider, CacheLockingManager cacheLockingManager) {
        this.timeProvider = timeProvider;
        this.cacheLockingManager = cacheLockingManager;
    }",method,
"    private PersistentIndexedCache<ModuleArtifactsKey, ModuleArtifactsCacheEntry> getCache() {
        if (cache == null) {
            cache = initCache();
        }
        return cache;
    }",method,
"        if (cache == null) {
            cache = initCache();
        }",method,
"    private PersistentIndexedCache<ModuleArtifactsKey, ModuleArtifactsCacheEntry> initCache() {
        return cacheLockingManager.createCache(""module-artifacts"", new ModuleArtifactsKeySerializer(), new ModuleArtifactsCacheEntrySerializer());
    }",method,
"    public CachedArtifacts cacheArtifacts(ModuleComponentRepository repository, ComponentIdentifier componentId, String context, BigInteger descriptorHash, Set<? extends ComponentArtifactMetadata> artifacts) {
        ModuleArtifactsKey key = new ModuleArtifactsKey(repository.getId(), componentId, context);
        ModuleArtifactsCacheEntry entry = new ModuleArtifactsCacheEntry(artifacts, timeProvider.getCurrentTime(), descriptorHash);
        getCache().put(key, entry);
        return createCacheArtifacts(entry);
    }",method,
"    public CachedArtifacts getCachedArtifacts(ModuleComponentRepository repository, ComponentIdentifier componentId, String context) {
        ModuleArtifactsKey key = new ModuleArtifactsKey(repository.getId(), componentId, context);
        ModuleArtifactsCacheEntry entry = getCache().get(key);
        if (entry == null) {
            return null;
        }
        return createCacheArtifacts(entry);
    }",method,
"        if (entry == null) {
            return null;
        }",method,
"    private CachedArtifacts createCacheArtifacts(ModuleArtifactsCacheEntry entry) {
        long entryAge = timeProvider.getCurrentTime() - entry.createTimestamp;
        return new DefaultCachedArtifacts(entry.artifacts, entry.moduleDescriptorHash, entryAge);
    }",method,
"        private ModuleArtifactsKey(String repositoryId, ComponentIdentifier componentId, String context) {
            this.repositoryId = repositoryId;
            this.componentId = componentId;
            this.context = context;
        }",method,
"        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof ModuleArtifactsKey)) {
                return false;
            }
            ModuleArtifactsKey that = (ModuleArtifactsKey) o;
            return repositoryId.equals(that.repositoryId) && componentId.equals(that.componentId) && context.equals(that.context);
        }",method,
"            if (this == o) {
                return true;
            }",method,
"        @Override
        public int hashCode() {
            int result = repositoryId.hashCode();
            result = 31 * result + componentId.hashCode();
            result = 31 * result + context.hashCode();
            return result;
        }",method,
"        public void write(Encoder encoder, ModuleArtifactsKey value) throws Exception {
            encoder.writeString(value.repositoryId);
            identifierSerializer.write(encoder, value.componentId);
            encoder.writeString(value.context);
        }",method,
"        public ModuleArtifactsKey read(Decoder decoder) throws Exception {
            String resolverId = decoder.readString();
            ComponentIdentifier componentId = identifierSerializer.read(decoder);
            String context = decoder.readString();
            return new ModuleArtifactsKey(resolverId, componentId, context);
        }",method,
"        @Override
        public boolean equals(Object obj) {
            if (!super.equals(obj)) {
                return false;
            }
            ModuleArtifactsKeySerializer rhs = (ModuleArtifactsKeySerializer) obj;
            return Objects.equal(identifierSerializer, rhs.identifierSerializer);
        }",method,
"        @Override
        public int hashCode() {
            return Objects.hashCode(super.hashCode(), identifierSerializer);
        }",method,
"        ModuleArtifactsCacheEntry(Set<? extends ComponentArtifactMetadata> artifacts, long createTimestamp, BigInteger moduleDescriptorHash) {
            this.artifacts = new LinkedHashSet<ComponentArtifactMetadata>(artifacts);
            this.createTimestamp = createTimestamp;
            this.moduleDescriptorHash = moduleDescriptorHash;
        }",method,
"        public void write(Encoder encoder, ModuleArtifactsCacheEntry value) throws Exception {
            encoder.writeLong(value.createTimestamp);
            byte[] hash = value.moduleDescriptorHash.toByteArray();
            encoder.writeBinary(hash);
            artifactsSerializer.write(encoder, value.artifacts);
        }",method,
"        public ModuleArtifactsCacheEntry read(Decoder decoder) throws Exception {
            long createTimestamp = decoder.readLong();
            byte[] encodedHash = decoder.readBinary();
            BigInteger hash = new BigInteger(encodedHash);
            Set<ComponentArtifactMetadata> artifacts = artifactsSerializer.read(decoder);
            return new ModuleArtifactsCacheEntry(artifacts, createTimestamp, hash);
        }",method,
"        @Override
        public boolean equals(Object obj) {
            if (!super.equals(obj)) {
                return false;
            }
            ModuleArtifactsCacheEntrySerializer rhs = (ModuleArtifactsCacheEntrySerializer) obj;
            return Objects.equal(artifactsSerializer, rhs.artifactsSerializer);
        }",method,
"        @Override
        public int hashCode() {
            return Objects.hashCode(super.hashCode(), artifactsSerializer);
        }",method,
"        private DefaultCachedArtifacts(Set<ComponentArtifactMetadata> artifacts, BigInteger descriptorHash, long ageMillis) {
            this.ageMillis = ageMillis;
            this.artifacts = artifacts;
            this.descriptorHash = descriptorHash;
        }",method,
"        public Set<ComponentArtifactMetadata> getArtifacts() {
            return artifacts;
        }",method,
"        public BigInteger getDescriptorHash() {
            return descriptorHash;
        }",method,
"        public long getAgeMillis() {
            return ageMillis;
        }",method,
"public class Pet {
  @JsonProperty(""id"")
  private Long id = null;
  @JsonProperty(""category"")
  private Category category = null;
  @JsonProperty(""name"")
  private String name = null;
  @JsonProperty(""photoUrls"")
  private List<String> photoUrls = new ArrayList<String>();
  @JsonProperty(""tags"")
  private List<Tag> tags = null;
  public enum StatusEnum {
    AVAILABLE(""available""),
    PENDING(""pending""),
    SOLD(""sold"");
    private String value;
    StatusEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }
    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
  }
  @JsonProperty(""status"")
  private StatusEnum status = null;
  public Pet id(Long id) {
    this.id = id;
    return this;
  }
  @ApiModelProperty(value = """")
  public Long getId() {
    return id;
  }
  public void setId(Long id) {
    this.id = id;
  }
  public Pet category(Category category) {
    this.category = category;
    return this;
  }
  @Valid
  @ApiModelProperty(value = """")
  public Category getCategory() {
    return category;
  }
  public void setCategory(Category category) {
    this.category = category;
  }
  public Pet name(String name) {
    this.name = name;
    return this;
  }
  @NotNull
  @ApiModelProperty(example = ""doggie"", required = true, value = """")
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public Pet photoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
    return this;
  }
  public Pet addPhotoUrlsItem(String photoUrlsItem) {
    this.photoUrls.add(photoUrlsItem);
    return this;
  }
  @NotNull
  @ApiModelProperty(required = true, value = """")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }
  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }
  public Pet tags(List<Tag> tags) {
    this.tags = tags;
    return this;
  }
  public Pet addTagsItem(Tag tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<Tag>();
    }
    this.tags.add(tagsItem);
    return this;
  }
  @Valid
  @ApiModelProperty(value = """")
  public List<Tag> getTags() {
    return tags;
  }
  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }
  public Pet status(StatusEnum status) {
    this.status = status;
    return this;
  }
  @ApiModelProperty(value = ""pet status in the store"")
  public StatusEnum getStatus() {
    return status;
  }
  public void setStatus(StatusEnum status) {
    this.status = status;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Pet pet = (Pet) o;
    return Objects.equals(this.id, pet.id) &&
        Objects.equals(this.category, pet.category) &&
        Objects.equals(this.name, pet.name) &&
        Objects.equals(this.photoUrls, pet.photoUrls) &&
        Objects.equals(this.tags, pet.tags) &&
        Objects.equals(this.status, pet.status);
  }
  @Override
  public int hashCode() {
    return Objects.hash(id, category, name, photoUrls, tags, status);
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class Pet {\n"");
    sb.append(""    id: "").append(toIndentedString(id)).append(""\n"");
    sb.append(""    category: "").append(toIndentedString(category)).append(""\n"");
    sb.append(""    name: "").append(toIndentedString(name)).append(""\n"");
    sb.append(""    photoUrls: "").append(toIndentedString(photoUrls)).append(""\n"");
    sb.append(""    tags: "").append(toIndentedString(tags)).append(""\n"");
    sb.append(""    status: "").append(toIndentedString(status)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
}",class,
"    sb.append(""class Pet {\n"");
    sb.append(""    id: "").append(toIndentedString(id)).append(""\n"");
    sb.append(""    category: "").append(toIndentedString(category)).append(""\n"");
    sb.append(""    name: "").append(toIndentedString(name)).append(""\n"");
    sb.append(""    photoUrls: "").append(toIndentedString(photoUrls)).append(""\n"");
    sb.append(""    tags: "").append(toIndentedString(tags)).append(""\n"");
    sb.append(""    status: "").append(toIndentedString(status)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"    StatusEnum(String value) {
      this.value = value;
    }",method,
"    @JsonValue
    public String getValue() {
      return value;
    }",method,
"    @Override
    public String toString() {
      return String.valueOf(value);
    }",method,
"    @JsonCreator
    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }",method,
"  public Pet id(Long id) {
    this.id = id;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public Long getId() {
    return id;
  }",method,
"  public void setId(Long id) {
    this.id = id;
  }",method,
"  public Pet category(Category category) {
    this.category = category;
    return this;
  }",method,
"  @Valid
  @ApiModelProperty(value = """")
  public Category getCategory() {
    return category;
  }",method,
"  public void setCategory(Category category) {
    this.category = category;
  }",method,
"  public Pet name(String name) {
    this.name = name;
    return this;
  }",method,
"  @NotNull
  @ApiModelProperty(example = ""doggie"", required = true, value = """")
  public String getName() {
    return name;
  }",method,
"  public void setName(String name) {
    this.name = name;
  }",method,
"  public Pet photoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
    return this;
  }",method,
"  public Pet addPhotoUrlsItem(String photoUrlsItem) {
    this.photoUrls.add(photoUrlsItem);
    return this;
  }",method,
"  @NotNull
  @ApiModelProperty(required = true, value = """")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }",method,
"  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }",method,
"  public Pet tags(List<Tag> tags) {
    this.tags = tags;
    return this;
  }",method,
"  public Pet addTagsItem(Tag tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<Tag>();
    }
    this.tags.add(tagsItem);
    return this;
  }",method,

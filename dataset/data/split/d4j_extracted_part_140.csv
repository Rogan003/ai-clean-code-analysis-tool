code_snippet,type,score
"      if (roots.length == 1) {
        if (directory) {
          return VcsBundle.message(""update.directory.scope.name"");
        }
        else {
          return VcsBundle.message(""update.file.scope.name"");
        }
      }",method,
"        if (directory) {
          return VcsBundle.message(""update.directory.scope.name"");
        }",method,
"        if (directory) {
          return VcsBundle.message(""update.directories.scope.name"");
        }",method,
"    public boolean filterExistsInVcs() {
      return true;
    }",method,
"    public FilePath[] getRoots(VcsContext context, final ActionInfo actionInfo) {
      return context.getSelectedFilePaths();
    }",method,
"public class RemappingScriptSource extends DelegatingScriptSource {
    public final static String MAPPED_SCRIPT = ""_BuildScript_"";
    public RemappingScriptSource(ScriptSource source) {
        super(source);
    }
    @Override
    public String getClassName() {
        return MAPPED_SCRIPT;
    }
}",class,
"package org.gradle.groovy.scripts.internal;
class ScriptCacheKey {
    private final String className;
    private final ClassLoader classLoader;
    private final String dslId;
    public ScriptCacheKey(String className, ClassLoader classLoader, String dslId) {
        this.className = className;
        this.classLoader = classLoader;
        this.dslId = dslId;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ScriptCacheKey key = (ScriptCacheKey) o;
        return classLoader.equals(key.classLoader)
            && className.equals(key.className)
            && dslId.equals(key.dslId);
    }
    @Override
    public int hashCode() {
        int result = className.hashCode();
        result = 31 * result + classLoader.hashCode();
        result = 31 * result + dslId.hashCode();
        return result;
    }
}",class,
"    public RemappingScriptSource(ScriptSource source) {
        super(source);
    }",method,
"    @Override
    public String getClassName() {
        return MAPPED_SCRIPT;
    }",method,
"    public ScriptCacheKey(String className, ClassLoader classLoader, String dslId) {
        this.className = className;
        this.classLoader = classLoader;
        this.dslId = dslId;
    }",method,
"    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ScriptCacheKey key = (ScriptCacheKey) o;
        return classLoader.equals(key.classLoader)
            && className.equals(key.className)
            && dslId.equals(key.dslId);
    }",method,
"        if (this == o) {
            return true;
        }",method,
"    @Override
    public int hashCode() {
        int result = className.hashCode();
        result = 31 * result + classLoader.hashCode();
        result = 31 * result + dslId.hashCode();
        return result;
    }",method,
"public final class ArraysOverlapFunction
{
    private int[] leftPositions;
    private int[] rightPositions;
    private long[] leftLongArray;
    private long[] rightLongArray;
    @TypeParameter(""E"")
    public ArraysOverlapFunction(@TypeParameter(""E"") Type elementType) {}
    public ArraysOverlapFunction() {}
    private static IntComparator intBlockCompare(Type type, Block block)
    {
        return new AbstractIntComparator()
        {
            @Override
            public int compare(int left, int right)
            {
                if (block.isNull(left) && block.isNull(right)) {
                    return 0;
                }
                if (block.isNull(left)) {
                    return 1;
                }
                if (block.isNull(right)) {
                    return -1;
                }
                return type.compareTo(block, left, block, right);
            }
        };
    }
    @SqlNullable
    @SqlType(StandardTypes.BOOLEAN)
    public Boolean arraysOverlapInt(
            @OperatorDependency(operator = LESS_THAN, returnType = StandardTypes.BOOLEAN, argumentTypes = {""integer"", ""integer""}) MethodHandle lessThanFunction,
            @SqlType(""array(integer)"") Block leftArray,
            @SqlType(""array(integer)"") Block rightArray)
    {
        return genericArraysOverlap(leftArray, rightArray, INTEGER);
    }
    @SqlNullable
    @SqlType(StandardTypes.BOOLEAN)
    public Boolean arraysOverlapBigInt(
            @OperatorDependency(operator = LESS_THAN, returnType = StandardTypes.BOOLEAN, argumentTypes = {""bigint"", ""bigint""}) MethodHandle lessThanFunction,
            @SqlType(""array(bigint)"") Block leftArray,
            @SqlType(""array(bigint)"") Block rightArray)
    {
        return genericArraysOverlap(leftArray, rightArray, BIGINT);
    }
    @SqlNullable
    @TypeParameter(""E"")
    @SqlType(StandardTypes.BOOLEAN)
    public Boolean arraysOverlap(
            @OperatorDependency(operator = LESS_THAN, returnType = StandardTypes.BOOLEAN, argumentTypes = {""E"", ""E""}) MethodHandle lessThanFunction,
            @TypeParameter(""E"") Type type,
            @SqlType(""array(E)"") Block leftArray,
            @SqlType(""array(E)"") Block rightArray)
    {
        int leftPositionCount = leftArray.getPositionCount();
        int rightPositionCount = rightArray.getPositionCount();
        if (leftPositionCount == 0 || rightPositionCount == 0) {
            return false;
        }
        if (leftPositions == null || leftPositions.length < leftPositionCount) {
            leftPositions = new int[leftPositionCount * 2];
        }
        if (rightPositions == null || rightPositions.length < rightPositionCount) {
            rightPositions = new int[rightPositionCount * 2];
        }
        for (int i = 0; i < leftPositionCount; i++) {
            leftPositions[i] = i;
        }
        for (int i = 0; i < rightPositionCount; i++) {
            rightPositions[i] = i;
        }
        IntArrays.quickSort(leftPositions, 0, leftPositionCount, intBlockCompare(type, leftArray));
        IntArrays.quickSort(rightPositions, 0, rightPositionCount, intBlockCompare(type, rightArray));
        int leftCurrentPosition = 0;
        int rightCurrentPosition = 0;
        while (leftCurrentPosition < leftPositionCount && rightCurrentPosition < rightPositionCount) {
            if (leftArray.isNull(leftPositions[leftCurrentPosition]) || rightArray.isNull(rightPositions[rightCurrentPosition])) {
                // Nulls are in the end of the array. Non-null elements do not overlap.
                return null;
            }
            int compareValue = type.compareTo(leftArray, leftPositions[leftCurrentPosition], rightArray, rightPositions[rightCurrentPosition]);
            if (compareValue > 0) {
                rightCurrentPosition++;
            }
            else if (compareValue < 0) {
                leftCurrentPosition++;
            }
            else {
                return true;
            }
        }
        return leftArray.isNull(leftPositions[leftPositionCount - 1]) || rightArray.isNull(rightPositions[rightPositionCount - 1]) ? null : false;
    }
    public Boolean genericArraysOverlap(Block leftArray, Block rightArray, AbstractType type)
    {
        int leftSize = leftArray.getPositionCount();
        int rightSize = rightArray.getPositionCount();
        if (leftSize == 0 || rightSize == 0) {
            return false;
        }
        if (leftLongArray == null || leftLongArray.length < leftSize) {
            leftLongArray = new long[leftSize * 2];
        }
        if (rightLongArray == null || rightLongArray.length < rightSize) {
            rightLongArray = new long[rightSize * 2];
        }
        int leftNonNullSize = sortAbstractLongArray(leftArray, leftLongArray, type);
        int rightNonNullSize = sortAbstractLongArray(rightArray, rightLongArray, type);
        int leftPosition = 0;
        int rightPosition = 0;
        while (leftPosition < leftNonNullSize && rightPosition < rightNonNullSize) {
            if (leftLongArray[leftPosition] < rightLongArray[rightPosition]) {
                leftPosition++;
            }
            else if (rightLongArray[rightPosition] < leftLongArray[leftPosition]) {
                rightPosition++;
            }
            else {
                return true;
            }
        }
        return (leftNonNullSize < leftSize) || (rightNonNullSize < rightSize) ? null : false;
    }
    // Assumes buffer is long enough, returns count of non-null elements.
    private static int sortAbstractLongArray(Block array, long[] buffer, AbstractType type)
    {
        int arraySize = array.getPositionCount();
        int nonNullSize = 0;
        for (int i = 0; i < arraySize; i++) {
            if (!array.isNull(i)) {
                buffer[nonNullSize++] = type.getLong(array, i);
            }
        }
        for (int i = 1; i < nonNullSize; i++) {
            if (buffer[i - 1] > buffer[i]) {
                Arrays.sort(buffer, 0, nonNullSize);
                break;
            }
        }
        return nonNullSize;
    }
}",class,
    public ArraysOverlapFunction() {},method,
"    private static IntComparator intBlockCompare(Type type, Block block)
    {
        return new AbstractIntComparator()
        {
            @Override
            public int compare(int left, int right)
            {
                if (block.isNull(left) && block.isNull(right)) {
                    return 0;
                }
                if (block.isNull(left)) {
                    return 1;
                }
                if (block.isNull(right)) {
                    return -1;
                }
                return type.compareTo(block, left, block, right);
            }
        };
    }",method,
"        return new AbstractIntComparator()
        {
            @Override
            public int compare(int left, int right)
            {
                if (block.isNull(left) && block.isNull(right)) {
                    return 0;
                }
                if (block.isNull(left)) {
                    return 1;
                }
                if (block.isNull(right)) {
                    return -1;
                }
                return type.compareTo(block, left, block, right);
            }
        }",method,
"            @Override
            public int compare(int left, int right)
            {
                if (block.isNull(left) && block.isNull(right)) {
                    return 0;
                }
                if (block.isNull(left)) {
                    return 1;
                }
                if (block.isNull(right)) {
                    return -1;
                }
                return type.compareTo(block, left, block, right);
            }",method,
"        if (leftPositionCount == 0 || rightPositionCount == 0) {
            return false;
        }",method,
"        if (leftPositions == null || leftPositions.length < leftPositionCount) {
            leftPositions = new int[leftPositionCount * 2];
        }",method,
"        if (rightPositions == null || rightPositions.length < rightPositionCount) {
            rightPositions = new int[rightPositionCount * 2];
        }",method,
"        for (int i = 0; i < leftPositionCount; i++) {
            leftPositions[i] = i;
        }",method,
"        for (int i = 0; i < rightPositionCount; i++) {
            rightPositions[i] = i;
        }",method,
"        while (leftCurrentPosition < leftPositionCount && rightCurrentPosition < rightPositionCount) {
            if (leftArray.isNull(leftPositions[leftCurrentPosition]) || rightArray.isNull(rightPositions[rightCurrentPosition])) {
                // Nulls are in the end of the array. Non-null elements do not overlap.
                return null;
            }
            int compareValue = type.compareTo(leftArray, leftPositions[leftCurrentPosition], rightArray, rightPositions[rightCurrentPosition]);
            if (compareValue > 0) {
                rightCurrentPosition++;
            }
            else if (compareValue < 0) {
                leftCurrentPosition++;
            }
            else {
                return true;
            }
        }",method,
"            if (compareValue > 0) {
                rightCurrentPosition++;
            }",method,
"            else if (compareValue < 0) {
                leftCurrentPosition++;
            }",method,
"    public Boolean genericArraysOverlap(Block leftArray, Block rightArray, AbstractType type)
    {
        int leftSize = leftArray.getPositionCount();
        int rightSize = rightArray.getPositionCount();
        if (leftSize == 0 || rightSize == 0) {
            return false;
        }
        if (leftLongArray == null || leftLongArray.length < leftSize) {
            leftLongArray = new long[leftSize * 2];
        }
        if (rightLongArray == null || rightLongArray.length < rightSize) {
            rightLongArray = new long[rightSize * 2];
        }
        int leftNonNullSize = sortAbstractLongArray(leftArray, leftLongArray, type);
        int rightNonNullSize = sortAbstractLongArray(rightArray, rightLongArray, type);
        int leftPosition = 0;
        int rightPosition = 0;
        while (leftPosition < leftNonNullSize && rightPosition < rightNonNullSize) {
            if (leftLongArray[leftPosition] < rightLongArray[rightPosition]) {
                leftPosition++;
            }
            else if (rightLongArray[rightPosition] < leftLongArray[leftPosition]) {
                rightPosition++;
            }
            else {
                return true;
            }
        }
        return (leftNonNullSize < leftSize) || (rightNonNullSize < rightSize) ? null : false;
    }",method,
"        if (leftSize == 0 || rightSize == 0) {
            return false;
        }",method,
"        if (leftLongArray == null || leftLongArray.length < leftSize) {
            leftLongArray = new long[leftSize * 2];
        }",method,
"        if (rightLongArray == null || rightLongArray.length < rightSize) {
            rightLongArray = new long[rightSize * 2];
        }",method,
"        while (leftPosition < leftNonNullSize && rightPosition < rightNonNullSize) {
            if (leftLongArray[leftPosition] < rightLongArray[rightPosition]) {
                leftPosition++;
            }
            else if (rightLongArray[rightPosition] < leftLongArray[leftPosition]) {
                rightPosition++;
            }
            else {
                return true;
            }
        }",method,
"            if (leftLongArray[leftPosition] < rightLongArray[rightPosition]) {
                leftPosition++;
            }",method,
"            else if (rightLongArray[rightPosition] < leftLongArray[leftPosition]) {
                rightPosition++;
            }",method,
"    private static int sortAbstractLongArray(Block array, long[] buffer, AbstractType type)
    {
        int arraySize = array.getPositionCount();
        int nonNullSize = 0;
        for (int i = 0; i < arraySize; i++) {
            if (!array.isNull(i)) {
                buffer[nonNullSize++] = type.getLong(array, i);
            }
        }
        for (int i = 1; i < nonNullSize; i++) {
            if (buffer[i - 1] > buffer[i]) {
                Arrays.sort(buffer, 0, nonNullSize);
                break;
            }
        }
        return nonNullSize;
    }",method,
"        for (int i = 0; i < arraySize; i++) {
            if (!array.isNull(i)) {
                buffer[nonNullSize++] = type.getLong(array, i);
            }
        }",method,
"        for (int i = 1; i < nonNullSize; i++) {
            if (buffer[i - 1] > buffer[i]) {
                Arrays.sort(buffer, 0, nonNullSize);
                break;
            }
        }",method,
"            if (buffer[i - 1] > buffer[i]) {
                Arrays.sort(buffer, 0, nonNullSize);
                break;
            }",method,
"public class UnixPythonSdkFlavor extends CPythonSdkFlavor {
  private UnixPythonSdkFlavor() {
  }
  private final static String[] NAMES = new String[]{""jython"", ""pypy""};
  public static final UnixPythonSdkFlavor INSTANCE = new UnixPythonSdkFlavor();
  @Override
  public Collection<String> suggestHomePaths() {
    Set<String> candidates = new HashSet<>();
    collectUnixPythons(""/usr/bin"", candidates);
    return candidates;
  }
  public static void collectUnixPythons(String path, Set<String> candidates) {
    VirtualFile rootDir = LocalFileSystem.getInstance().findFileByPath(path);
    if (rootDir != null) {
      if (rootDir instanceof NewVirtualFile) {
        ((NewVirtualFile)rootDir).markDirty();
      }
      rootDir.refresh(true, false);
      VirtualFile[] suspects = rootDir.getChildren();
      for (VirtualFile child : suspects) {
        if (!child.isDirectory()) {
          final String childName = child.getName().toLowerCase(Locale.US);
          for (String name : NAMES) {
            if (childName.startsWith(name) || PYTHON_RE.matcher(childName).matches()) {
              final String childPath = child.getPath();
              if (!childName.endsWith(""-config"") &&
                  !childName.startsWith(""pythonw"") &&
                  !childName.endsWith(""m"") &&
                  !candidates.contains(childPath)) {
                candidates.add(childPath);
              }
              break;
            }
          }
        }
      }
    }
  }
}",class,
"  private UnixPythonSdkFlavor() {
  }",method,
"  @Override
  public Collection<String> suggestHomePaths() {
    Set<String> candidates = new HashSet<>();
    collectUnixPythons(""/usr/bin"", candidates);
    return candidates;
  }",method,
"  public static void collectUnixPythons(String path, Set<String> candidates) {
    VirtualFile rootDir = LocalFileSystem.getInstance().findFileByPath(path);
    if (rootDir != null) {
      if (rootDir instanceof NewVirtualFile) {
        ((NewVirtualFile)rootDir).markDirty();
      }
      rootDir.refresh(true, false);
      VirtualFile[] suspects = rootDir.getChildren();
      for (VirtualFile child : suspects) {
        if (!child.isDirectory()) {
          final String childName = child.getName().toLowerCase(Locale.US);
          for (String name : NAMES) {
            if (childName.startsWith(name) || PYTHON_RE.matcher(childName).matches()) {
              final String childPath = child.getPath();
              if (!childName.endsWith(""-config"") &&
                  !childName.startsWith(""pythonw"") &&
                  !childName.endsWith(""m"") &&
                  !candidates.contains(childPath)) {
                candidates.add(childPath);
              }
              break;
            }
          }
        }
      }
    }
  }",method,
"    if (rootDir != null) {
      if (rootDir instanceof NewVirtualFile) {
        ((NewVirtualFile)rootDir).markDirty();
      }
      rootDir.refresh(true, false);
      VirtualFile[] suspects = rootDir.getChildren();
      for (VirtualFile child : suspects) {
        if (!child.isDirectory()) {
          final String childName = child.getName().toLowerCase(Locale.US);
          for (String name : NAMES) {
            if (childName.startsWith(name) || PYTHON_RE.matcher(childName).matches()) {
              final String childPath = child.getPath();
              if (!childName.endsWith(""-config"") &&
                  !childName.startsWith(""pythonw"") &&
                  !childName.endsWith(""m"") &&
                  !candidates.contains(childPath)) {
                candidates.add(childPath);
              }
              break;
            }
          }
        }
      }
    }",method,
"      if (rootDir instanceof NewVirtualFile) {
        ((NewVirtualFile)rootDir).markDirty();
      }",method,
"      for (VirtualFile child : suspects) {
        if (!child.isDirectory()) {
          final String childName = child.getName().toLowerCase(Locale.US);
          for (String name : NAMES) {
            if (childName.startsWith(name) || PYTHON_RE.matcher(childName).matches()) {
              final String childPath = child.getPath();
              if (!childName.endsWith(""-config"") &&
                  !childName.startsWith(""pythonw"") &&
                  !childName.endsWith(""m"") &&
                  !candidates.contains(childPath)) {
                candidates.add(childPath);
              }
              break;
            }
          }
        }
      }",method,
"          for (String name : NAMES) {
            if (childName.startsWith(name) || PYTHON_RE.matcher(childName).matches()) {
              final String childPath = child.getPath();
              if (!childName.endsWith(""-config"") &&
                  !childName.startsWith(""pythonw"") &&
                  !childName.endsWith(""m"") &&
                  !candidates.contains(childPath)) {
                candidates.add(childPath);
              }
              break;
            }
          }",method,
"public class AuthUtil {
    public static Authenticator<BasicCredentials, Principal> getBasicAuthenticator(final List<String> validUsers) {
        return credentials -> {
            if (validUsers.contains(credentials.getUsername()) && ""secret"".equals(credentials.getPassword())) {
                return Optional.of(new PrincipalImpl(credentials.getUsername()));
            }
            if (""bad-guy"".equals(credentials.getUsername())) {
                throw new AuthenticationException(""CRAP"");
            }
            return Optional.empty();
        };
    }
    public static Authenticator<String, Principal> getSingleUserOAuthAuthenticator(final String presented,
                                                                                   final String returned) {
        return user -> {
            if (presented.equals(user)) {
                return Optional.of(new PrincipalImpl(returned));
            }
            if (""bad-guy"".equals(user)) {
                throw new AuthenticationException(""CRAP"");
            }
            return Optional.empty();
        };
    }
    public static Authenticator<String, Principal> getMultiplyUsersOAuthAuthenticator(final List<String> validUsers) {
        return credentials -> {
            if (validUsers.contains(credentials)) {
                return Optional.of(new PrincipalImpl(credentials));
            }
            if (""bad-guy"".equals(credentials)) {
                throw new AuthenticationException(""CRAP"");
            }
            return Optional.empty();
        };
    }
    public static Authorizer<Principal> getTestAuthorizer(final String validUser,
                                                          final String validRole) {
        return (principal, role) -> principal != null
            && validUser.equals(principal.getName())
            && validRole.equals(role);
    }
}",class,
"    public static Authenticator<BasicCredentials, Principal> getBasicAuthenticator(final List<String> validUsers) {
        return credentials -> {
            if (validUsers.contains(credentials.getUsername()) && ""secret"".equals(credentials.getPassword())) {
                return Optional.of(new PrincipalImpl(credentials.getUsername()));
            }
            if (""bad-guy"".equals(credentials.getUsername())) {
                throw new AuthenticationException(""CRAP"");
            }
            return Optional.empty();
        };
    }",method,
"    public static Authenticator<String, Principal> getSingleUserOAuthAuthenticator(final String presented,
                                                                                   final String returned) {
        return user -> {
            if (presented.equals(user)) {
                return Optional.of(new PrincipalImpl(returned));
            }
            if (""bad-guy"".equals(user)) {
                throw new AuthenticationException(""CRAP"");
            }
            return Optional.empty();
        };
    }",method,
"    public static Authenticator<String, Principal> getMultiplyUsersOAuthAuthenticator(final List<String> validUsers) {
        return credentials -> {
            if (validUsers.contains(credentials)) {
                return Optional.of(new PrincipalImpl(credentials));
            }
            if (""bad-guy"".equals(credentials)) {
                throw new AuthenticationException(""CRAP"");
            }
            return Optional.empty();
        };
    }",method,
"    public static Authorizer<Principal> getTestAuthorizer(final String validUser,
                                                          final String validRole) {
        return (principal, role) -> principal != null
            && validUser.equals(principal.getName())
            && validRole.equals(role);
    }",method,
"public class PushReader {
  private final Reader mySource;
  private final TIntArrayList myReadAhead = new TIntArrayList();
  @NonNls
  protected static final String INTERNAL_ERROR_UNEXPECTED_END_OF_PIPE = ""Unexpected end of pipe"";
  public PushReader(final Reader source) {
    mySource = source;
  }
  public int next() throws IOException {
    return myReadAhead.isEmpty() ? mySource.read() : myReadAhead.remove(myReadAhead.size() - 1);
  }
  public void pushBack(final char[] chars) {
    for (int i = chars.length - 1; i >= 0; i--) {
      final char aChar = chars[i];
      myReadAhead.add(aChar);
    }
  }
  public void close() throws IOException {
    mySource.close();
  }
  public boolean ready() throws IOException {
    return !myReadAhead.isEmpty() || mySource.ready();
  }
  public void pushBack(final int aChar) {
    myReadAhead.add(aChar);
  }
  public char[] next(final int charCount) throws IOException {
    final char[] chars = new char[charCount];
    int offset = 0;
    for (; offset < chars.length && offset < myReadAhead.size(); offset++)
      chars[offset] = (char)myReadAhead.remove(myReadAhead.size() - 1);
    while (offset < chars.length) {
      int bytesRead = mySource.read(chars, offset, chars.length - offset);
      if (bytesRead == -1)
        throw new IOException (INTERNAL_ERROR_UNEXPECTED_END_OF_PIPE);
      offset += bytesRead;
    }
    return chars;
  }
}",class,
"  public PushReader(final Reader source) {
    mySource = source;
  }",method,
"  public int next() throws IOException {
    return myReadAhead.isEmpty() ? mySource.read() : myReadAhead.remove(myReadAhead.size() - 1);
  }",method,
"  public void pushBack(final char[] chars) {
    for (int i = chars.length - 1; i >= 0; i--) {
      final char aChar = chars[i];
      myReadAhead.add(aChar);
    }
  }",method,
"    for (int i = chars.length - 1; i >= 0; i--) {
      final char aChar = chars[i];
      myReadAhead.add(aChar);
    }",method,
"  public void close() throws IOException {
    mySource.close();
  }",method,
"  public boolean ready() throws IOException {
    return !myReadAhead.isEmpty() || mySource.ready();
  }",method,
"  public void pushBack(final int aChar) {
    myReadAhead.add(aChar);
  }",method,
"  public char[] next(final int charCount) throws IOException {
    final char[] chars = new char[charCount];
    int offset = 0;
    for (; offset < chars.length && offset < myReadAhead.size(); offset++)
      chars[offset] = (char)myReadAhead.remove(myReadAhead.size() - 1);
    while (offset < chars.length) {
      int bytesRead = mySource.read(chars, offset, chars.length - offset);
      if (bytesRead == -1)
        throw new IOException (INTERNAL_ERROR_UNEXPECTED_END_OF_PIPE);
      offset += bytesRead;
    }
    return chars;
  }",method,
"    while (offset < chars.length) {
      int bytesRead = mySource.read(chars, offset, chars.length - offset);
      if (bytesRead == -1)
        throw new IOException (INTERNAL_ERROR_UNEXPECTED_END_OF_PIPE);
      offset += bytesRead;
    }",method,
"public class TextLabelInSwitchStatementInspection extends BaseInspection {
  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""text.label.in.switch.statement.display.name"");
  }
  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(
      ""text.label.in.switch.statement.problem.descriptor"");
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new TextLabelInSwitchStatementVisitor();
  }
  private static class TextLabelInSwitchStatementVisitor
    extends BaseInspectionVisitor {
    @Override
    public void visitSwitchStatement(
      @NotNull PsiSwitchStatement statement) {
      super.visitSwitchStatement(statement);
      final PsiCodeBlock body = statement.getBody();
      if (body == null) {
        return;
      }
      final PsiStatement[] statements = body.getStatements();
      for (PsiStatement statement1 : statements) {
        checkForLabel(statement1);
      }
    }
    private void checkForLabel(PsiStatement statement) {
      if (!(statement instanceof PsiLabeledStatement)) {
        return;
      }
      final PsiLabeledStatement labeledStatement =
        (PsiLabeledStatement)statement;
      final PsiIdentifier label = labeledStatement.getLabelIdentifier();
      registerError(label);
    }
  }
}",class,
"  private static class TextLabelInSwitchStatementVisitor
    extends BaseInspectionVisitor {
    @Override
    public void visitSwitchStatement(
      @NotNull PsiSwitchStatement statement) {
      super.visitSwitchStatement(statement);
      final PsiCodeBlock body = statement.getBody();
      if (body == null) {
        return;
      }
      final PsiStatement[] statements = body.getStatements();
      for (PsiStatement statement1 : statements) {
        checkForLabel(statement1);
      }
    }
    private void checkForLabel(PsiStatement statement) {
      if (!(statement instanceof PsiLabeledStatement)) {
        return;
      }
      final PsiLabeledStatement labeledStatement =
        (PsiLabeledStatement)statement;
      final PsiIdentifier label = labeledStatement.getLabelIdentifier();
      registerError(label);
    }
  }",class,
"  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""text.label.in.switch.statement.display.name"");
  }",method,
"  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(
      ""text.label.in.switch.statement.problem.descriptor"");
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new TextLabelInSwitchStatementVisitor();
  }",method,
"    @Override
    public void visitSwitchStatement(
      @NotNull PsiSwitchStatement statement) {
      super.visitSwitchStatement(statement);
      final PsiCodeBlock body = statement.getBody();
      if (body == null) {
        return;
      }
      final PsiStatement[] statements = body.getStatements();
      for (PsiStatement statement1 : statements) {
        checkForLabel(statement1);
      }
    }",method,
"      if (body == null) {
        return;
      }",method,
"      for (PsiStatement statement1 : statements) {
        checkForLabel(statement1);
      }",method,
"    private void checkForLabel(PsiStatement statement) {
      if (!(statement instanceof PsiLabeledStatement)) {
        return;
      }
      final PsiLabeledStatement labeledStatement =
        (PsiLabeledStatement)statement;
      final PsiIdentifier label = labeledStatement.getLabelIdentifier();
      registerError(label);
    }",method,
"public class LoopModifier<T> extends BaseModifier<T> implements IModifierListener<T> {
	// ===========================================================
	// Constants
	// ===========================================================
	public static final int LOOP_CONTINUOUS = -1;
	// ===========================================================
	// Fields
	// ===========================================================
	private float mSecondsElapsed;
	private final float mDuration;
	private final IModifier<T> mModifier;
	private ILoopModifierListener<T> mLoopModifierListener;
	private final int mLoopCount;
	private int mLoop;
	private boolean mModifierStartedCalled;
	private boolean mFinishedCached;
	// ===========================================================
	// Constructors
	// ===========================================================
	public LoopModifier(final IModifier<T> pModifier) {
		this(pModifier, LoopModifier.LOOP_CONTINUOUS);
	}
	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount) {
		this(pModifier, pLoopCount, null, (IModifierListener<T>)null);
	}
	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount, final IModifierListener<T> pModifierListener) {
		this(pModifier, pLoopCount, null, pModifierListener);
	}
	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount, final ILoopModifierListener<T> pLoopModifierListener) {
		this(pModifier, pLoopCount, pLoopModifierListener, (IModifierListener<T>)null);
	}
	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount, final ILoopModifierListener<T> pLoopModifierListener, final IModifierListener<T> pModifierListener) {
		super(pModifierListener);
		BaseModifier.assertNoNullModifier(pModifier);
		this.mModifier = pModifier;
		this.mLoopCount = pLoopCount;
		this.mLoopModifierListener = pLoopModifierListener;
		this.mLoop = 0;
		this.mDuration = (pLoopCount == LoopModifier.LOOP_CONTINUOUS) ? Float.POSITIVE_INFINITY : pModifier.getDuration() * pLoopCount; // TODO Check if POSITIVE_INFINITY works correct with i.e. SequenceModifier
		this.mModifier.addModifierListener(this);
	}
	protected LoopModifier(final LoopModifier<T> pLoopModifier) throws DeepCopyNotSupportedException {
		this(pLoopModifier.mModifier.deepCopy(), pLoopModifier.mLoopCount);
	}
	@Override
	public LoopModifier<T> deepCopy() throws DeepCopyNotSupportedException {
		return new LoopModifier<T>(this);
	}
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	public ILoopModifierListener<T> getLoopModifierListener() {
		return this.mLoopModifierListener;
	}
	public void setLoopModifierListener(final ILoopModifierListener<T> pLoopModifierListener) {
		this.mLoopModifierListener = pLoopModifierListener;
	}
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	@Override
	public float getSecondsElapsed() {
		return this.mSecondsElapsed;
	}
	@Override
	public float getDuration() {
		return this.mDuration;
	}
	@Override
	public float onUpdate(final float pSecondsElapsed, final T pItem) {
		if(this.mFinished){
			return 0;
		} else {
			float secondsElapsedRemaining = pSecondsElapsed;
			this.mFinishedCached = false;
			while((secondsElapsedRemaining > 0) && !this.mFinishedCached) {
				secondsElapsedRemaining -= this.mModifier.onUpdate(secondsElapsedRemaining, pItem);
			}
			this.mFinishedCached = false;
			final float secondsElapsedUsed = pSecondsElapsed - secondsElapsedRemaining;
			this.mSecondsElapsed += secondsElapsedUsed;
			return secondsElapsedUsed;
		}
	}
	@Override
	public void reset() {
		this.mFinished = false;
		this.mLoop = 0;
		this.mSecondsElapsed = 0;
		this.mModifierStartedCalled = false;
		this.mModifier.reset();
	}
	// ===========================================================
	// Methods
	// ===========================================================
	@Override
	public void onModifierStarted(final IModifier<T> pModifier, final T pItem) {
		if(!this.mModifierStartedCalled) {
			this.mModifierStartedCalled = true;
			this.onModifierStarted(pItem);
		}
		if(this.mLoopModifierListener != null) {
			this.mLoopModifierListener.onLoopStarted(this, this.mLoop, this.mLoopCount);
		}
	}
	@Override
	public void onModifierFinished(final IModifier<T> pModifier, final T pItem) {
		if(this.mLoopModifierListener != null) {
			this.mLoopModifierListener.onLoopFinished(this, this.mLoop, this.mLoopCount);
		}
		if(this.mLoopCount == LoopModifier.LOOP_CONTINUOUS) {
			this.mSecondsElapsed = 0;
			this.mModifier.reset();
		} else {
			this.mLoop++;
			if(this.mLoop >= this.mLoopCount) {
				this.mFinished = true;
				this.mFinishedCached = true;
				this.onModifierFinished(pItem);
			} else {
				this.mSecondsElapsed = 0;
				this.mModifier.reset();
			}
		}
	}
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
	public interface ILoopModifierListener<T> {
		public void onLoopStarted(final LoopModifier<T> pLoopModifier, final int pLoop, final int pLoopCount);
		public void onLoopFinished(final LoopModifier<T> pLoopModifier, final int pLoop, final int pLoopCount);
	}
}",class,
"	public LoopModifier(final IModifier<T> pModifier) {
		this(pModifier, LoopModifier.LOOP_CONTINUOUS);
	}",method,
"	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount) {
		this(pModifier, pLoopCount, null, (IModifierListener<T>)null);
	}",method,
"	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount, final IModifierListener<T> pModifierListener) {
		this(pModifier, pLoopCount, null, pModifierListener);
	}",method,
"	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount, final ILoopModifierListener<T> pLoopModifierListener) {
		this(pModifier, pLoopCount, pLoopModifierListener, (IModifierListener<T>)null);
	}",method,
"	public LoopModifier(final IModifier<T> pModifier, final int pLoopCount, final ILoopModifierListener<T> pLoopModifierListener, final IModifierListener<T> pModifierListener) {
		super(pModifierListener);
		BaseModifier.assertNoNullModifier(pModifier);
		this.mModifier = pModifier;
		this.mLoopCount = pLoopCount;
		this.mLoopModifierListener = pLoopModifierListener;
		this.mLoop = 0;
		this.mDuration = (pLoopCount == LoopModifier.LOOP_CONTINUOUS) ? Float.POSITIVE_INFINITY : pModifier.getDuration() * pLoopCount; // TODO Check if POSITIVE_INFINITY works correct with i.e. SequenceModifier
		this.mModifier.addModifierListener(this);
	}",method,
"	protected LoopModifier(final LoopModifier<T> pLoopModifier) throws DeepCopyNotSupportedException {
		this(pLoopModifier.mModifier.deepCopy(), pLoopModifier.mLoopCount);
	}",method,
"	@Override
	public LoopModifier<T> deepCopy() throws DeepCopyNotSupportedException {
		return new LoopModifier<T>(this);
	}",method,
"	public ILoopModifierListener<T> getLoopModifierListener() {
		return this.mLoopModifierListener;
	}",method,
"	public void setLoopModifierListener(final ILoopModifierListener<T> pLoopModifierListener) {
		this.mLoopModifierListener = pLoopModifierListener;
	}",method,
"	@Override
	public float getSecondsElapsed() {
		return this.mSecondsElapsed;
	}",method,
"	@Override
	public float getDuration() {
		return this.mDuration;
	}",method,
"	@Override
	public float onUpdate(final float pSecondsElapsed, final T pItem) {
		if(this.mFinished){
			return 0;
		} else {
			float secondsElapsedRemaining = pSecondsElapsed;
			this.mFinishedCached = false;
			while((secondsElapsedRemaining > 0) && !this.mFinishedCached) {
				secondsElapsedRemaining -= this.mModifier.onUpdate(secondsElapsedRemaining, pItem);
			}
			this.mFinishedCached = false;
			final float secondsElapsedUsed = pSecondsElapsed - secondsElapsedRemaining;
			this.mSecondsElapsed += secondsElapsedUsed;
			return secondsElapsedUsed;
		}
	}",method,
"		if(this.mFinished){
			return 0;
		}",method,
"	@Override
	public void reset() {
		this.mFinished = false;
		this.mLoop = 0;
		this.mSecondsElapsed = 0;
		this.mModifierStartedCalled = false;
		this.mModifier.reset();
	}",method,
"	@Override
	public void onModifierStarted(final IModifier<T> pModifier, final T pItem) {
		if(!this.mModifierStartedCalled) {
			this.mModifierStartedCalled = true;
			this.onModifierStarted(pItem);
		}
		if(this.mLoopModifierListener != null) {
			this.mLoopModifierListener.onLoopStarted(this, this.mLoop, this.mLoopCount);
		}
	}",method,
"		if(!this.mModifierStartedCalled) {
			this.mModifierStartedCalled = true;
			this.onModifierStarted(pItem);
		}",method,
"		if(this.mLoopModifierListener != null) {
			this.mLoopModifierListener.onLoopStarted(this, this.mLoop, this.mLoopCount);
		}",method,
"	@Override
	public void onModifierFinished(final IModifier<T> pModifier, final T pItem) {
		if(this.mLoopModifierListener != null) {
			this.mLoopModifierListener.onLoopFinished(this, this.mLoop, this.mLoopCount);
		}
		if(this.mLoopCount == LoopModifier.LOOP_CONTINUOUS) {
			this.mSecondsElapsed = 0;
			this.mModifier.reset();
		} else {
			this.mLoop++;
			if(this.mLoop >= this.mLoopCount) {
				this.mFinished = true;
				this.mFinishedCached = true;
				this.onModifierFinished(pItem);
			} else {
				this.mSecondsElapsed = 0;
				this.mModifier.reset();
			}
		}
	}",method,
"		if(this.mLoopModifierListener != null) {
			this.mLoopModifierListener.onLoopFinished(this, this.mLoop, this.mLoopCount);
		}",method,
"		if(this.mLoopCount == LoopModifier.LOOP_CONTINUOUS) {
			this.mSecondsElapsed = 0;
			this.mModifier.reset();
		}",method,
"			if(this.mLoop >= this.mLoopCount) {
				this.mFinished = true;
				this.mFinishedCached = true;
				this.onModifierFinished(pItem);
			}",method,
"public class DefaultProjectRegistryTest {
    public static final String CHILD_NAME = ""child"";
    public static final String CHILD_CHILD_NAME = ""childchild"";
    private ProjectInternal rootMock;
    private ProjectInternal childMock;
    private ProjectInternal childChildMock;
    private DefaultProjectRegistry<ProjectInternal> projectRegistry;
    @Rule
    public TestNameTestDirectoryProvider temporaryFolder = new TestNameTestDirectoryProvider();
    @Before
    public void setUp() {
        projectRegistry = new DefaultProjectRegistry<ProjectInternal>();
        rootMock = TestUtil.create(temporaryFolder).rootProject();
        childMock = TestUtil.createChildProject(rootMock, CHILD_NAME);
        childChildMock = TestUtil.createChildProject(childMock, CHILD_CHILD_NAME);
        projectRegistry.addProject(rootMock);
        projectRegistry.addProject(childMock);
        projectRegistry.addProject(childChildMock);
    }
    @Test
    public void rootProject() {
        assertSame(rootMock, projectRegistry.getRootProject());
    }
    @Test
    public void addProject() {
        checkAccessMethods(rootMock, toSortedSet(rootMock, childMock, childChildMock), toSortedSet(childMock,
                childChildMock), rootMock);
        checkAccessMethods(childMock, toSortedSet(childMock, childChildMock), toSortedSet(childChildMock), childMock);
        checkAccessMethods(childChildMock, toSortedSet(childChildMock), new TreeSet(), childChildMock);
    }
    private void checkAccessMethods(Project project, SortedSet<ProjectInternal> expectedAllProjects,
                                    SortedSet<ProjectInternal> expectedSubProjects, Project expectedGetProject) {
        assertSame(expectedGetProject, projectRegistry.getProject(project.getPath()));
        assertEquals(expectedAllProjects, projectRegistry.getAllProjects(project.getPath()));
        assertEquals(expectedSubProjects, projectRegistry.getSubProjects(project.getPath()));
        assertSame(expectedGetProject, projectRegistry.getProject(project.getProjectDir()));
        assertTrue(projectRegistry.getAllProjects().contains(project));
    }
    @Test
    public void cannotLocateProjectsWithAmbiguousProjectDir() {
        ProjectInternal duplicateProjectDirProject = TestUtil.createChildProject(childMock, ""childchild2"", childMock.getProjectDir());
        projectRegistry.addProject(duplicateProjectDirProject);
        try {
            projectRegistry.getProject(childMock.getProjectDir());
            fail();
        } catch (InvalidUserDataException e) {
            assertThat(e.getMessage(), startsWith(""Found multiple projects with project directory ""));
        }
    }
    @Test
    public void accessMethodsForNonExistingsPaths() {
        projectRegistry = new DefaultProjectRegistry<ProjectInternal>();
        Project otherRoot = TestUtil.create(temporaryFolder.getTestDirectory()).rootProject();
        assertNull(projectRegistry.getProject(otherRoot.getPath()));
        assertEquals(new TreeSet<ProjectInternal>(), projectRegistry.getAllProjects(otherRoot.getPath()));
        assertEquals(new TreeSet<ProjectInternal>(), projectRegistry.getSubProjects(otherRoot.getPath()));
        assertNull(projectRegistry.getProject(otherRoot.getProjectDir()));
    }
    @Test
    public void canLocalAllProjects() {
        assertThat(projectRegistry.getAllProjects(), equalTo(toSet((ProjectInternal) rootMock, childMock,
                childChildMock)));
    }
    @Test
    public void canLocateAllProjectsWhichMatchSpec() {
        Spec<Project> spec = new Spec<Project>() {
            public boolean isSatisfiedBy(Project element) {
                return element.getName().contains(""child"");
            }
        };
        assertThat(projectRegistry.findAll(spec), equalTo(toSet((ProjectInternal) childMock, childChildMock)));
    }
    @Test
    public void canRemoveProject() {
        String path = childChildMock.getPath();
        assertThat(projectRegistry.removeProject(path), sameInstance((ProjectInternal) childChildMock));
        assertThat(projectRegistry.getProject(path), nullValue());
        assertThat(projectRegistry.getProject(childChildMock.getProjectDir()), nullValue());
        assertTrue(projectRegistry.getAllProjects(path).isEmpty());
        assertTrue(projectRegistry.getSubProjects(path).isEmpty());
        assertFalse(projectRegistry.getAllProjects().contains(childChildMock));
        assertFalse(projectRegistry.getAllProjects("":"").contains(childChildMock));
        assertFalse(projectRegistry.getSubProjects("":"").contains(childChildMock));
    }
}",class,
"    @Before
    public void setUp() {
        projectRegistry = new DefaultProjectRegistry<ProjectInternal>();
        rootMock = TestUtil.create(temporaryFolder).rootProject();
        childMock = TestUtil.createChildProject(rootMock, CHILD_NAME);
        childChildMock = TestUtil.createChildProject(childMock, CHILD_CHILD_NAME);
        projectRegistry.addProject(rootMock);
        projectRegistry.addProject(childMock);
        projectRegistry.addProject(childChildMock);
    }",method,
"    @Test
    public void rootProject() {
        assertSame(rootMock, projectRegistry.getRootProject());
    }",method,
"    @Test
    public void addProject() {
        checkAccessMethods(rootMock, toSortedSet(rootMock, childMock, childChildMock), toSortedSet(childMock,
                childChildMock), rootMock);
        checkAccessMethods(childMock, toSortedSet(childMock, childChildMock), toSortedSet(childChildMock), childMock);
        checkAccessMethods(childChildMock, toSortedSet(childChildMock), new TreeSet(), childChildMock);
    }",method,
"    private void checkAccessMethods(Project project, SortedSet<ProjectInternal> expectedAllProjects,
                                    SortedSet<ProjectInternal> expectedSubProjects, Project expectedGetProject) {
        assertSame(expectedGetProject, projectRegistry.getProject(project.getPath()));
        assertEquals(expectedAllProjects, projectRegistry.getAllProjects(project.getPath()));
        assertEquals(expectedSubProjects, projectRegistry.getSubProjects(project.getPath()));
        assertSame(expectedGetProject, projectRegistry.getProject(project.getProjectDir()));
        assertTrue(projectRegistry.getAllProjects().contains(project));
    }",method,
"    @Test
    public void cannotLocateProjectsWithAmbiguousProjectDir() {
        ProjectInternal duplicateProjectDirProject = TestUtil.createChildProject(childMock, ""childchild2"", childMock.getProjectDir());
        projectRegistry.addProject(duplicateProjectDirProject);
        try {
            projectRegistry.getProject(childMock.getProjectDir());
            fail();
        } catch (InvalidUserDataException e) {
            assertThat(e.getMessage(), startsWith(""Found multiple projects with project directory ""));
        }
    }",method,
"    @Test
    public void accessMethodsForNonExistingsPaths() {
        projectRegistry = new DefaultProjectRegistry<ProjectInternal>();
        Project otherRoot = TestUtil.create(temporaryFolder.getTestDirectory()).rootProject();
        assertNull(projectRegistry.getProject(otherRoot.getPath()));
        assertEquals(new TreeSet<ProjectInternal>(), projectRegistry.getAllProjects(otherRoot.getPath()));
        assertEquals(new TreeSet<ProjectInternal>(), projectRegistry.getSubProjects(otherRoot.getPath()));
        assertNull(projectRegistry.getProject(otherRoot.getProjectDir()));
    }",method,
"    @Test
    public void canLocalAllProjects() {
        assertThat(projectRegistry.getAllProjects(), equalTo(toSet((ProjectInternal) rootMock, childMock,
                childChildMock)));
    }",method,
"    @Test
    public void canLocateAllProjectsWhichMatchSpec() {
        Spec<Project> spec = new Spec<Project>() {
            public boolean isSatisfiedBy(Project element) {
                return element.getName().contains(""child"");
            }
        };
        assertThat(projectRegistry.findAll(spec), equalTo(toSet((ProjectInternal) childMock, childChildMock)));
    }",method,
"            public boolean isSatisfiedBy(Project element) {
                return element.getName().contains(""child"");
            }",method,

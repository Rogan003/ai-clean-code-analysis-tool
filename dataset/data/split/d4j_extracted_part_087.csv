code_snippet,type,score
"public class AppGraphCreator {
	@Inject
	private AppDataService m_AppDataService;
	@Inject
	private AppConfigManager m_appConfigManager;
	public LineChart buildChartData(final List<Double[]> datas, String type) {
		LineChart lineChart = new LineChart();
		lineChart.setId(""app"");
		lineChart.setUnit("""");
		lineChart.setHtmlTitle(queryType(type));
		if (AppDataService.SUCCESS.equals(type)) {
			lineChart.setMinYlable(lineChart.queryMinYlable(datas));
			lineChart.setMaxYlabel(100D);
		}
		for (int i = 0; i < datas.size(); i++) {
			Double[] data = datas.get(i);
			if (i == 0) {
				lineChart.add(""当前值"", data);
			} else if (i == 1) {
				lineChart.add(""对比值"", data);
			}
		}
		return lineChart;
	}
	public LineChart buildLineChart(CommandQueryEntity queryEntity1, CommandQueryEntity queryEntity2, String type) {
		List<Double[]> datas = new LinkedList<Double[]>();
		if (queryEntity1 != null) {
			Double[] data1 = m_AppDataService.queryValue(queryEntity1, type);
			datas.add(data1);
		}
		if (queryEntity2 != null) {
			Double[] values2 = m_AppDataService.queryValue(queryEntity2, type);
			datas.add(values2);
		}
		return buildChartData(datas, type);
	}
	public Pair<PieChart, List<PieChartDetailInfo>> buildPieChart(CommandQueryEntity entity, AppDataField field) {
		List<PieChartDetailInfo> infos = new LinkedList<PieChartDetailInfo>();
		PieChart pieChart = new PieChart().setMaxSize(Integer.MAX_VALUE);
		List<Item> items = new ArrayList<Item>();
		List<AppCommandData> datas = m_AppDataService.queryByField(entity, field);
		for (AppCommandData data : datas) {
			Pair<Integer, Item> pair = buildPieChartItem(entity.getId(), data, field);
			Item item = pair.getValue();
			PieChartDetailInfo info = new PieChartDetailInfo();
			info.setId(pair.getKey()).setTitle(item.getTitle()).setRequestSum(item.getNumber());
			infos.add(info);
			items.add(item);
		}
		pieChart.setTitle(field.getName() + ""访问情况"");
		pieChart.addItems(items);
		updatePieChartDetailInfo(infos);
		return new Pair<PieChart, List<PieChartDetailInfo>>(pieChart, infos);
	}
	private Pair<Integer, String> buildPieChartFieldTitlePair(int command, AppCommandData data, AppDataField field) {
		String title = ""Unknown"";
		int keyValue = -1;
		switch (field) {
		case OPERATOR:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> operators = m_appConfigManager
			      .queryConfigItem(AppConfigManager.OPERATOR);
			com.dianping.cat.configuration.app.entity.Item operator = null;
			keyValue = data.getOperator();
			if (operators != null && (operator = operators.get(keyValue)) != null) {
				title = operator.getName();
			}
			break;
		case APP_VERSION:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> appVersions = m_appConfigManager
			      .queryConfigItem(AppConfigManager.VERSION);
			com.dianping.cat.configuration.app.entity.Item appVersion = null;
			keyValue = data.getAppVersion();
			if (appVersions != null && (appVersion = appVersions.get(keyValue)) != null) {
				title = appVersion.getName();
			}
			break;
		case CITY:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> cities = m_appConfigManager
			      .queryConfigItem(AppConfigManager.CITY);
			com.dianping.cat.configuration.app.entity.Item city = null;
			keyValue = data.getCity();
			if (cities != null && (city = cities.get(keyValue)) != null) {
				title = city.getName();
			}
			break;
		case CONNECT_TYPE:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> connectTypes = m_appConfigManager
			      .queryConfigItem(AppConfigManager.CONNECT_TYPE);
			com.dianping.cat.configuration.app.entity.Item connectType = null;
			keyValue = data.getConnectType();
			if (connectTypes != null && (connectType = connectTypes.get(keyValue)) != null) {
				title = connectType.getName();
			}
			break;
		case NETWORK:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> networks = m_appConfigManager
			      .queryConfigItem(AppConfigManager.NETWORK);
			com.dianping.cat.configuration.app.entity.Item network = null;
			keyValue = data.getNetwork();
			if (networks != null && (network = networks.get(keyValue)) != null) {
				title = network.getName();
			}
			break;
		case PLATFORM:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> platforms = m_appConfigManager
			      .queryConfigItem(AppConfigManager.PLATFORM);
			com.dianping.cat.configuration.app.entity.Item platform = null;
			keyValue = data.getPlatform();
			if (platforms != null && (platform = platforms.get(keyValue)) != null) {
				title = platform.getName();
			}
			break;
		case CODE:
			Map<Integer, Code> codes = m_appConfigManager.queryCodeByCommand(command);
			Code code = null;
			keyValue = data.getCode();
			if (codes != null && (code = codes.get(keyValue)) != null) {
				title = code.getName();
				int status = code.getStatus();
				if (status == 0) {
					title = ""<span class='text-success'>【成功】</span>"" + title;
				} else {
					title = ""<span class='text-error'>【失败】</span>"" + title;
				}
			}
			break;
		default:
			throw new RuntimeException(""Unrecognized groupby field: "" + field);
		}
		if (""Unknown"".equals(title)) {
			title += "" [ "" + keyValue + "" ]"";
		}
		return new Pair<Integer, String>(keyValue, title);
	}
	private Pair<Integer, Item> buildPieChartItem(int command, AppCommandData data, AppDataField field) {
		Item item = new Item();
		Pair<Integer, String> pair = buildPieChartFieldTitlePair(command, data, field);
		item.setTitle(pair.getValue());
		item.setId(pair.getKey());
		item.setNumber(data.getAccessNumberSum());
		return new Pair<Integer, Item>(pair.getKey(), item);
	}
	private String queryType(String type) {
		if (AppDataService.SUCCESS.equals(type)) {
			return ""成功率（%/5分钟）"";
		} else if (AppDataService.REQUEST.equals(type)) {
			return ""请求数（个/5分钟）"";
		} else if (AppDataService.DELAY.equals(type)) {
			return ""延时平均值（毫秒/5分钟）"";
		} else {
			throw new RuntimeException(""unexpected query type, type:"" + type);
		}
	}
	private void updatePieChartDetailInfo(List<PieChartDetailInfo> items) {
		double sum = 0;
		for (PieChartDetailInfo item : items) {
			sum += item.getRequestSum();
		}
		if (sum > 0) {
			for (PieChartDetailInfo item : items) {
				item.setSuccessRatio(item.getRequestSum() / sum);
			}
		}
	}
}",class,
"	public LineChart buildChartData(final List<Double[]> datas, String type) {
		LineChart lineChart = new LineChart();
		lineChart.setId(""app"");
		lineChart.setUnit("""");
		lineChart.setHtmlTitle(queryType(type));
		if (AppDataService.SUCCESS.equals(type)) {
			lineChart.setMinYlable(lineChart.queryMinYlable(datas));
			lineChart.setMaxYlabel(100D);
		}
		for (int i = 0; i < datas.size(); i++) {
			Double[] data = datas.get(i);
			if (i == 0) {
				lineChart.add(""当前值"", data);
			} else if (i == 1) {
				lineChart.add(""对比值"", data);
			}
		}
		return lineChart;
	}",method,
"			if (i == 0) {
				lineChart.add(""当前值"", data);
			}",method,
"	public LineChart buildLineChart(CommandQueryEntity queryEntity1, CommandQueryEntity queryEntity2, String type) {
		List<Double[]> datas = new LinkedList<Double[]>();
		if (queryEntity1 != null) {
			Double[] data1 = m_AppDataService.queryValue(queryEntity1, type);
			datas.add(data1);
		}
		if (queryEntity2 != null) {
			Double[] values2 = m_AppDataService.queryValue(queryEntity2, type);
			datas.add(values2);
		}
		return buildChartData(datas, type);
	}",method,
"		if (queryEntity1 != null) {
			Double[] data1 = m_AppDataService.queryValue(queryEntity1, type);
			datas.add(data1);
		}",method,
"		if (queryEntity2 != null) {
			Double[] values2 = m_AppDataService.queryValue(queryEntity2, type);
			datas.add(values2);
		}",method,
"	public Pair<PieChart, List<PieChartDetailInfo>> buildPieChart(CommandQueryEntity entity, AppDataField field) {
		List<PieChartDetailInfo> infos = new LinkedList<PieChartDetailInfo>();
		PieChart pieChart = new PieChart().setMaxSize(Integer.MAX_VALUE);
		List<Item> items = new ArrayList<Item>();
		List<AppCommandData> datas = m_AppDataService.queryByField(entity, field);
		for (AppCommandData data : datas) {
			Pair<Integer, Item> pair = buildPieChartItem(entity.getId(), data, field);
			Item item = pair.getValue();
			PieChartDetailInfo info = new PieChartDetailInfo();
			info.setId(pair.getKey()).setTitle(item.getTitle()).setRequestSum(item.getNumber());
			infos.add(info);
			items.add(item);
		}
		pieChart.setTitle(field.getName() + ""访问情况"");
		pieChart.addItems(items);
		updatePieChartDetailInfo(infos);
		return new Pair<PieChart, List<PieChartDetailInfo>>(pieChart, infos);
	}",method,
"		for (AppCommandData data : datas) {
			Pair<Integer, Item> pair = buildPieChartItem(entity.getId(), data, field);
			Item item = pair.getValue();
			PieChartDetailInfo info = new PieChartDetailInfo();
			info.setId(pair.getKey()).setTitle(item.getTitle()).setRequestSum(item.getNumber());
			infos.add(info);
			items.add(item);
		}",method,
"	private Pair<Integer, String> buildPieChartFieldTitlePair(int command, AppCommandData data, AppDataField field) {
		String title = ""Unknown"";
		int keyValue = -1;
		switch (field) {
		case OPERATOR:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> operators = m_appConfigManager
			      .queryConfigItem(AppConfigManager.OPERATOR);
			com.dianping.cat.configuration.app.entity.Item operator = null;
			keyValue = data.getOperator();
			if (operators != null && (operator = operators.get(keyValue)) != null) {
				title = operator.getName();
			}
			break;
		case APP_VERSION:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> appVersions = m_appConfigManager
			      .queryConfigItem(AppConfigManager.VERSION);
			com.dianping.cat.configuration.app.entity.Item appVersion = null;
			keyValue = data.getAppVersion();
			if (appVersions != null && (appVersion = appVersions.get(keyValue)) != null) {
				title = appVersion.getName();
			}
			break;
		case CITY:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> cities = m_appConfigManager
			      .queryConfigItem(AppConfigManager.CITY);
			com.dianping.cat.configuration.app.entity.Item city = null;
			keyValue = data.getCity();
			if (cities != null && (city = cities.get(keyValue)) != null) {
				title = city.getName();
			}
			break;
		case CONNECT_TYPE:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> connectTypes = m_appConfigManager
			      .queryConfigItem(AppConfigManager.CONNECT_TYPE);
			com.dianping.cat.configuration.app.entity.Item connectType = null;
			keyValue = data.getConnectType();
			if (connectTypes != null && (connectType = connectTypes.get(keyValue)) != null) {
				title = connectType.getName();
			}
			break;
		case NETWORK:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> networks = m_appConfigManager
			      .queryConfigItem(AppConfigManager.NETWORK);
			com.dianping.cat.configuration.app.entity.Item network = null;
			keyValue = data.getNetwork();
			if (networks != null && (network = networks.get(keyValue)) != null) {
				title = network.getName();
			}
			break;
		case PLATFORM:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> platforms = m_appConfigManager
			      .queryConfigItem(AppConfigManager.PLATFORM);
			com.dianping.cat.configuration.app.entity.Item platform = null;
			keyValue = data.getPlatform();
			if (platforms != null && (platform = platforms.get(keyValue)) != null) {
				title = platform.getName();
			}
			break;
		case CODE:
			Map<Integer, Code> codes = m_appConfigManager.queryCodeByCommand(command);
			Code code = null;
			keyValue = data.getCode();
			if (codes != null && (code = codes.get(keyValue)) != null) {
				title = code.getName();
				int status = code.getStatus();
				if (status == 0) {
					title = ""<span class='text-success'>【成功】</span>"" + title;
				} else {
					title = ""<span class='text-error'>【失败】</span>"" + title;
				}
			}
			break;
		default:
			throw new RuntimeException(""Unrecognized groupby field: "" + field);
		}
		if (""Unknown"".equals(title)) {
			title += "" [ "" + keyValue + "" ]"";
		}
		return new Pair<Integer, String>(keyValue, title);
	}",method,
"		switch (field) {
		case OPERATOR:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> operators = m_appConfigManager
			      .queryConfigItem(AppConfigManager.OPERATOR);
			com.dianping.cat.configuration.app.entity.Item operator = null;
			keyValue = data.getOperator();
			if (operators != null && (operator = operators.get(keyValue)) != null) {
				title = operator.getName();
			}
			break;
		case APP_VERSION:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> appVersions = m_appConfigManager
			      .queryConfigItem(AppConfigManager.VERSION);
			com.dianping.cat.configuration.app.entity.Item appVersion = null;
			keyValue = data.getAppVersion();
			if (appVersions != null && (appVersion = appVersions.get(keyValue)) != null) {
				title = appVersion.getName();
			}
			break;
		case CITY:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> cities = m_appConfigManager
			      .queryConfigItem(AppConfigManager.CITY);
			com.dianping.cat.configuration.app.entity.Item city = null;
			keyValue = data.getCity();
			if (cities != null && (city = cities.get(keyValue)) != null) {
				title = city.getName();
			}
			break;
		case CONNECT_TYPE:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> connectTypes = m_appConfigManager
			      .queryConfigItem(AppConfigManager.CONNECT_TYPE);
			com.dianping.cat.configuration.app.entity.Item connectType = null;
			keyValue = data.getConnectType();
			if (connectTypes != null && (connectType = connectTypes.get(keyValue)) != null) {
				title = connectType.getName();
			}
			break;
		case NETWORK:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> networks = m_appConfigManager
			      .queryConfigItem(AppConfigManager.NETWORK);
			com.dianping.cat.configuration.app.entity.Item network = null;
			keyValue = data.getNetwork();
			if (networks != null && (network = networks.get(keyValue)) != null) {
				title = network.getName();
			}
			break;
		case PLATFORM:
			Map<Integer, com.dianping.cat.configuration.app.entity.Item> platforms = m_appConfigManager
			      .queryConfigItem(AppConfigManager.PLATFORM);
			com.dianping.cat.configuration.app.entity.Item platform = null;
			keyValue = data.getPlatform();
			if (platforms != null && (platform = platforms.get(keyValue)) != null) {
				title = platform.getName();
			}
			break;
		case CODE:
			Map<Integer, Code> codes = m_appConfigManager.queryCodeByCommand(command);
			Code code = null;
			keyValue = data.getCode();
			if (codes != null && (code = codes.get(keyValue)) != null) {
				title = code.getName();
				int status = code.getStatus();
				if (status == 0) {
					title = ""<span class='text-success'>【成功】</span>"" + title;
				} else {
					title = ""<span class='text-error'>【失败】</span>"" + title;
				}
			}
			break;
		default:
			throw new RuntimeException(""Unrecognized groupby field: "" + field);
		}",method,
"				if (status == 0) {
					title = ""<span class='text-success'>【成功】</span>"" + title;
				}",method,
"	private Pair<Integer, Item> buildPieChartItem(int command, AppCommandData data, AppDataField field) {
		Item item = new Item();
		Pair<Integer, String> pair = buildPieChartFieldTitlePair(command, data, field);
		item.setTitle(pair.getValue());
		item.setId(pair.getKey());
		item.setNumber(data.getAccessNumberSum());
		return new Pair<Integer, Item>(pair.getKey(), item);
	}",method,
"	private String queryType(String type) {
		if (AppDataService.SUCCESS.equals(type)) {
			return ""成功率（%/5分钟）"";
		} else if (AppDataService.REQUEST.equals(type)) {
			return ""请求数（个/5分钟）"";
		} else if (AppDataService.DELAY.equals(type)) {
			return ""延时平均值（毫秒/5分钟）"";
		} else {
			throw new RuntimeException(""unexpected query type, type:"" + type);
		}
	}",method,
"	private void updatePieChartDetailInfo(List<PieChartDetailInfo> items) {
		double sum = 0;
		for (PieChartDetailInfo item : items) {
			sum += item.getRequestSum();
		}
		if (sum > 0) {
			for (PieChartDetailInfo item : items) {
				item.setSuccessRatio(item.getRequestSum() / sum);
			}
		}
	}",method,
"		for (PieChartDetailInfo item : items) {
			sum += item.getRequestSum();
		}",method,
"		if (sum > 0) {
			for (PieChartDetailInfo item : items) {
				item.setSuccessRatio(item.getRequestSum() / sum);
			}
		}",method,
"			for (PieChartDetailInfo item : items) {
				item.setSuccessRatio(item.getRequestSum() / sum);
			}",method,
"public class ForwardingQueueTest extends TestCase {
  static final class StandardImplForwardingQueue<T>
      extends ForwardingQueue<T> {
    private final Queue<T> backingQueue;
    StandardImplForwardingQueue(Queue<T> backingQueue) {
      this.backingQueue = backingQueue;
    }
    @Override protected Queue<T> delegate() {
      return backingQueue;
    }
    @Override public boolean addAll(Collection<? extends T> collection) {
      return standardAddAll(collection);
    }
    @Override public void clear() {
      standardClear();
    }
    @Override public boolean contains(Object object) {
      return standardContains(object);
    }
    @Override public boolean containsAll(Collection<?> collection) {
      return standardContainsAll(collection);
    }
    @Override public boolean remove(Object object) {
      return standardRemove(object);
    }
    @Override public boolean removeAll(Collection<?> collection) {
      return standardRemoveAll(collection);
    }
    @Override public boolean retainAll(Collection<?> collection) {
      return standardRetainAll(collection);
    }
    @Override public Object[] toArray() {
      return standardToArray();
    }
    @Override public <T> T[] toArray(T[] array) {
      return standardToArray(array);
    }
    @Override public String toString() {
      return standardToString();
    }
    @Override public boolean offer(T o) {
      return standardOffer(o);
    }
    @Override public T peek() {
      return standardPeek();
    }
    @Override public T poll() {
      return standardPoll();
    }
  }
  public static Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTestSuite(ForwardingQueueTest.class);
    suite.addTest(
        QueueTestSuiteBuilder.using(
                new TestStringQueueGenerator() {
                  @Override
                  protected Queue<String> create(String[] elements) {
                    return new StandardImplForwardingQueue<>(Lists.newLinkedList(asList(elements)));
                  }
                })
            .named(""ForwardingQueue[LinkedList] with standard implementations"")
            .withFeatures(
                CollectionSize.ANY,
                CollectionFeature.ALLOWS_NULL_VALUES,
                CollectionFeature.GENERAL_PURPOSE)
            .createTestSuite());
    return suite;
  }
  @SuppressWarnings({""rawtypes"", ""unchecked""})
  public void testForwarding() {
    new ForwardingWrapperTester()
        .testForwarding(Queue.class, new Function<Queue, Queue>() {
          @Override public Queue apply(Queue delegate) {
            return wrap(delegate);
          }
        });
  }
  private static <T> Queue<T> wrap(final Queue<T> delegate) {
    return new ForwardingQueue<T>() {
      @Override protected Queue<T> delegate() {
        return delegate;
      }
    };
  }
}",class,
"  static final class StandardImplForwardingQueue<T>
      extends ForwardingQueue<T> {
    private final Queue<T> backingQueue;
    StandardImplForwardingQueue(Queue<T> backingQueue) {
      this.backingQueue = backingQueue;
    }
    @Override protected Queue<T> delegate() {
      return backingQueue;
    }
    @Override public boolean addAll(Collection<? extends T> collection) {
      return standardAddAll(collection);
    }
    @Override public void clear() {
      standardClear();
    }
    @Override public boolean contains(Object object) {
      return standardContains(object);
    }
    @Override public boolean containsAll(Collection<?> collection) {
      return standardContainsAll(collection);
    }
    @Override public boolean remove(Object object) {
      return standardRemove(object);
    }
    @Override public boolean removeAll(Collection<?> collection) {
      return standardRemoveAll(collection);
    }
    @Override public boolean retainAll(Collection<?> collection) {
      return standardRetainAll(collection);
    }
    @Override public Object[] toArray() {
      return standardToArray();
    }
    @Override public <T> T[] toArray(T[] array) {
      return standardToArray(array);
    }
    @Override public String toString() {
      return standardToString();
    }
    @Override public boolean offer(T o) {
      return standardOffer(o);
    }
    @Override public T peek() {
      return standardPeek();
    }
    @Override public T poll() {
      return standardPoll();
    }
  }",class,
"    StandardImplForwardingQueue(Queue<T> backingQueue) {
      this.backingQueue = backingQueue;
    }",method,
"  public static Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTestSuite(ForwardingQueueTest.class);
    suite.addTest(
        QueueTestSuiteBuilder.using(
                new TestStringQueueGenerator() {
                  @Override
                  protected Queue<String> create(String[] elements) {
                    return new StandardImplForwardingQueue<>(Lists.newLinkedList(asList(elements)));
                  }
                })
            .named(""ForwardingQueue[LinkedList] with standard implementations"")
            .withFeatures(
                CollectionSize.ANY,
                CollectionFeature.ALLOWS_NULL_VALUES,
                CollectionFeature.GENERAL_PURPOSE)
            .createTestSuite());
    return suite;
  }",method,
"    suite.addTest(
        QueueTestSuiteBuilder.using(
                new TestStringQueueGenerator() {
                  @Override
                  protected Queue<String> create(String[] elements) {
                    return new StandardImplForwardingQueue<>(Lists.newLinkedList(asList(elements)));
                  }
                }",method,
"                  @Override
                  protected Queue<String> create(String[] elements) {
                    return new StandardImplForwardingQueue<>(Lists.newLinkedList(asList(elements)));
                  }",method,
"  @SuppressWarnings({""rawtypes"", ""unchecked""})
  public void testForwarding() {
    new ForwardingWrapperTester()
        .testForwarding(Queue.class, new Function<Queue, Queue>() {
          @Override public Queue apply(Queue delegate) {
            return wrap(delegate);
          }
        });
  }",method,
"        .testForwarding(Queue.class, new Function<Queue, Queue>() {
          @Override public Queue apply(Queue delegate) {
            return wrap(delegate);
          }
        }",method,
"  private static <T> Queue<T> wrap(final Queue<T> delegate) {
    return new ForwardingQueue<T>() {
      @Override protected Queue<T> delegate() {
        return delegate;
      }
    };
  }",method,
"public class MatOfDMatch extends Mat {
    // 32FC4
    private static final int _depth = CvType.CV_32F;
    private static final int _channels = 4;
    public MatOfDMatch() {
        super();
    }
    protected MatOfDMatch(long addr) {
        super(addr);
        if( !empty() && checkVector(_channels, _depth) < 0 )
            throw new IllegalArgumentException(""Incompatible Mat: "" + toString());
        //FIXME: do we need release() here?
    }
    public static MatOfDMatch fromNativeAddr(long addr) {
        return new MatOfDMatch(addr);
    }
    public MatOfDMatch(Mat m) {
        super(m, Range.all());
        if( !empty() && checkVector(_channels, _depth) < 0 )
            throw new IllegalArgumentException(""Incompatible Mat: "" + toString());
        //FIXME: do we need release() here?
    }
    public MatOfDMatch(DMatch...ap) {
        super();
        fromArray(ap);
    }
    public void alloc(int elemNumber) {
        if(elemNumber>0)
            super.create(elemNumber, 1, CvType.makeType(_depth, _channels));
    }
    public void fromArray(DMatch...a) {
        if(a==null || a.length==0)
            return;
        int num = a.length;
        alloc(num);
        float buff[] = new float[num * _channels];
        for(int i=0; i<num; i++) {
            DMatch m = a[i];
            buff[_channels*i+0] = m.queryIdx;
            buff[_channels*i+1] = m.trainIdx;
            buff[_channels*i+2] = m.imgIdx;
            buff[_channels*i+3] = m.distance;
        }
        put(0, 0, buff); //TODO: check ret val!
    }
    public DMatch[] toArray() {
        int num = (int) total();
        DMatch[] a = new DMatch[num];
        if(num == 0)
            return a;
        float buff[] = new float[num * _channels];
        get(0, 0, buff); //TODO: check ret val!
        for(int i=0; i<num; i++)
            a[i] = new DMatch((int) buff[_channels*i+0], (int) buff[_channels*i+1], (int) buff[_channels*i+2], buff[_channels*i+3]);
        return a;
    }
    public void fromList(List<DMatch> ldm) {
        DMatch adm[] = ldm.toArray(new DMatch[0]);
        fromArray(adm);
    }
    public List<DMatch> toList() {
        DMatch[] adm = toArray();
        return Arrays.asList(adm);
    }
}",class,
"    public MatOfDMatch() {
        super();
    }",method,
"    protected MatOfDMatch(long addr) {
        super(addr);
        if( !empty() && checkVector(_channels, _depth) < 0 )
            throw new IllegalArgumentException(""Incompatible Mat: "" + toString());
        //FIXME: do we need release() here?
    }",method,
"    public static MatOfDMatch fromNativeAddr(long addr) {
        return new MatOfDMatch(addr);
    }",method,
"    public MatOfDMatch(Mat m) {
        super(m, Range.all());
        if( !empty() && checkVector(_channels, _depth) < 0 )
            throw new IllegalArgumentException(""Incompatible Mat: "" + toString());
        //FIXME: do we need release() here?
    }",method,
"    public MatOfDMatch(DMatch...ap) {
        super();
        fromArray(ap);
    }",method,
"    public void alloc(int elemNumber) {
        if(elemNumber>0)
            super.create(elemNumber, 1, CvType.makeType(_depth, _channels));
    }",method,
"    public void fromArray(DMatch...a) {
        if(a==null || a.length==0)
            return;
        int num = a.length;
        alloc(num);
        float buff[] = new float[num * _channels];
        for(int i=0; i<num; i++) {
            DMatch m = a[i];
            buff[_channels*i+0] = m.queryIdx;
            buff[_channels*i+1] = m.trainIdx;
            buff[_channels*i+2] = m.imgIdx;
            buff[_channels*i+3] = m.distance;
        }
        put(0, 0, buff); //TODO: check ret val!
    }",method,
"        for(int i=0; i<num; i++) {
            DMatch m = a[i];
            buff[_channels*i+0] = m.queryIdx;
            buff[_channels*i+1] = m.trainIdx;
            buff[_channels*i+2] = m.imgIdx;
            buff[_channels*i+3] = m.distance;
        }",method,
"    public DMatch[] toArray() {
        int num = (int) total();
        DMatch[] a = new DMatch[num];
        if(num == 0)
            return a;
        float buff[] = new float[num * _channels];
        get(0, 0, buff); //TODO: check ret val!
        for(int i=0; i<num; i++)
            a[i] = new DMatch((int) buff[_channels*i+0], (int) buff[_channels*i+1], (int) buff[_channels*i+2], buff[_channels*i+3]);
        return a;
    }",method,
"    public void fromList(List<DMatch> ldm) {
        DMatch adm[] = ldm.toArray(new DMatch[0]);
        fromArray(adm);
    }",method,
"    public List<DMatch> toList() {
        DMatch[] adm = toArray();
        return Arrays.asList(adm);
    }",method,
"public class RunnableHandler implements IUpdateHandler {
	// ===========================================================
	// Constants
	// ===========================================================
	// ===========================================================
	// Fields
	// ===========================================================
	private final ArrayList<Runnable> mRunnables = new ArrayList<Runnable>();
	// ===========================================================
	// Constructors
	// ===========================================================
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	@Override
	public synchronized void onUpdate(final float pSecondsElapsed) {
		final ArrayList<Runnable> runnables = this.mRunnables;
		final int runnableCount = runnables.size();
		for(int i = runnableCount - 1; i >= 0; i--) {
			runnables.remove(i).run();
		}
	}
	@Override
	public synchronized void reset() {
		this.mRunnables.clear();
	}
	// ===========================================================
	// Methods
	// ===========================================================
	public synchronized void postRunnable(final Runnable pRunnable) {
		this.mRunnables.add(pRunnable);
	}
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	@Override
	public synchronized void onUpdate(final float pSecondsElapsed) {
		final ArrayList<Runnable> runnables = this.mRunnables;
		final int runnableCount = runnables.size();
		for(int i = runnableCount - 1; i >= 0; i--) {
			runnables.remove(i).run();
		}
	}",method,
"		for(int i = runnableCount - 1; i >= 0; i--) {
			runnables.remove(i).run();
		}",method,
"	@Override
	public synchronized void reset() {
		this.mRunnables.clear();
	}",method,
"	public synchronized void postRunnable(final Runnable pRunnable) {
		this.mRunnables.add(pRunnable);
	}",method,
"public class SVGOMAnimatedPreserveAspectRatio
        extends AbstractSVGAnimatedValue
        implements SVGAnimatedPreserveAspectRatio {
    protected BaseSVGPARValue baseVal;
    protected AnimSVGPARValue animVal;
    protected boolean changing;
    public SVGOMAnimatedPreserveAspectRatio(AbstractElement elt) {
        super(elt, null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE);
    }
    public SVGPreserveAspectRatio getBaseVal() {
        if (baseVal == null) {
            baseVal = new BaseSVGPARValue();
        }
        return baseVal;
    }
    public SVGPreserveAspectRatio getAnimVal() {
        if (animVal == null) {
            animVal = new AnimSVGPARValue();
        }
        return animVal;
    }
    public void check() {
        if (!hasAnimVal) {
            if (baseVal == null) {
                baseVal = new BaseSVGPARValue();
            }
            if (baseVal.malformed) {
                throw new LiveAttributeException
                    (element, localName,
                     LiveAttributeException.ERR_ATTRIBUTE_MALFORMED,
                     baseVal.getValueAsString());
            }
        }
    }
    public AnimatableValue getUnderlyingValue(AnimationTarget target) {
        SVGPreserveAspectRatio par = getBaseVal();
        return new AnimatablePreserveAspectRatioValue(target, par.getAlign(),
                                                      par.getMeetOrSlice());
    }
    protected void updateAnimatedValue(AnimatableValue val) {
        if (val == null) {
            hasAnimVal = false;
        } else {
            hasAnimVal = true;
            if (animVal == null) {
                animVal = new AnimSVGPARValue();
            }
            AnimatablePreserveAspectRatioValue animPAR =
                (AnimatablePreserveAspectRatioValue) val;
            animVal.setAnimatedValue(animPAR.getAlign(),
                                     animPAR.getMeetOrSlice());
        }
        fireAnimatedAttributeListeners();
    }
    public void attrAdded(Attr node, String newv) {
        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }
        fireBaseAttributeListeners();
        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }
    }
    public void attrModified(Attr node, String oldv, String newv) {
        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }
        fireBaseAttributeListeners();
        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }
    }
    public void attrRemoved(Attr node, String oldv) {
        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }
        fireBaseAttributeListeners();
        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }
    }
    public class BaseSVGPARValue extends AbstractSVGPreserveAspectRatio {
        protected boolean malformed;
        public BaseSVGPARValue() {
            invalidate();
        }
        protected DOMException createDOMException(short type, String key,
                                                  Object[] args) {
            return element.createDOMException(type, key, args);
        }
        protected void setAttributeValue(String value) throws DOMException {
            try {
                changing = true;
                element.setAttributeNS
                    (null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE,
                     value);
                malformed = false;
            } finally {
                changing = false;
            }
        }
        protected void invalidate() {
            String s = element.getAttributeNS
                (null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE);
            setValueAsString(s);
        }
    }
    public class AnimSVGPARValue extends AbstractSVGPreserveAspectRatio {
        protected DOMException createDOMException(short type, String key,
                                                  Object[] args) {
            return element.createDOMException(type, key, args);
        }
        protected void setAttributeValue(String value) throws DOMException {
        }
        public short getAlign() {
            if (hasAnimVal) {
                return super.getAlign();
            }
            return getBaseVal().getAlign();
        }
        public short getMeetOrSlice() {
            if (hasAnimVal) {
                return super.getMeetOrSlice();
            }
            return getBaseVal().getMeetOrSlice();
        }
        public void setAlign(short align) {
            throw element.createDOMException
                (DOMException.NO_MODIFICATION_ALLOWED_ERR,
                 ""readonly.preserve.aspect.ratio"", null);
        }
        public void setMeetOrSlice(short meetOrSlice) {
            throw element.createDOMException
                (DOMException.NO_MODIFICATION_ALLOWED_ERR,
                 ""readonly.preserve.aspect.ratio"", null);
        }
        protected void setAnimatedValue(short align, short meetOrSlice) {
            this.align = align;
            this.meetOrSlice = meetOrSlice;
        }
    }
}",class,
"    public class BaseSVGPARValue extends AbstractSVGPreserveAspectRatio {
        protected boolean malformed;
        public BaseSVGPARValue() {
            invalidate();
        }
        protected DOMException createDOMException(short type, String key,
                                                  Object[] args) {
            return element.createDOMException(type, key, args);
        }
        protected void setAttributeValue(String value) throws DOMException {
            try {
                changing = true;
                element.setAttributeNS
                    (null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE,
                     value);
                malformed = false;
            } finally {
                changing = false;
            }
        }
        protected void invalidate() {
            String s = element.getAttributeNS
                (null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE);
            setValueAsString(s);
        }
    }",class,
"    public class AnimSVGPARValue extends AbstractSVGPreserveAspectRatio {
        protected DOMException createDOMException(short type, String key,
                                                  Object[] args) {
            return element.createDOMException(type, key, args);
        }
        protected void setAttributeValue(String value) throws DOMException {
        }
        public short getAlign() {
            if (hasAnimVal) {
                return super.getAlign();
            }
            return getBaseVal().getAlign();
        }
        public short getMeetOrSlice() {
            if (hasAnimVal) {
                return super.getMeetOrSlice();
            }
            return getBaseVal().getMeetOrSlice();
        }
        public void setAlign(short align) {
            throw element.createDOMException
                (DOMException.NO_MODIFICATION_ALLOWED_ERR,
                 ""readonly.preserve.aspect.ratio"", null);
        }
        public void setMeetOrSlice(short meetOrSlice) {
            throw element.createDOMException
                (DOMException.NO_MODIFICATION_ALLOWED_ERR,
                 ""readonly.preserve.aspect.ratio"", null);
        }
        protected void setAnimatedValue(short align, short meetOrSlice) {
            this.align = align;
            this.meetOrSlice = meetOrSlice;
        }
    }",class,
"    public SVGOMAnimatedPreserveAspectRatio(AbstractElement elt) {
        super(elt, null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE);
    }",method,
"    public SVGPreserveAspectRatio getBaseVal() {
        if (baseVal == null) {
            baseVal = new BaseSVGPARValue();
        }
        return baseVal;
    }",method,
"        if (baseVal == null) {
            baseVal = new BaseSVGPARValue();
        }",method,
"    public SVGPreserveAspectRatio getAnimVal() {
        if (animVal == null) {
            animVal = new AnimSVGPARValue();
        }
        return animVal;
    }",method,
"        if (animVal == null) {
            animVal = new AnimSVGPARValue();
        }",method,
"    public void check() {
        if (!hasAnimVal) {
            if (baseVal == null) {
                baseVal = new BaseSVGPARValue();
            }
            if (baseVal.malformed) {
                throw new LiveAttributeException
                    (element, localName,
                     LiveAttributeException.ERR_ATTRIBUTE_MALFORMED,
                     baseVal.getValueAsString());
            }
        }
    }",method,
"        if (!hasAnimVal) {
            if (baseVal == null) {
                baseVal = new BaseSVGPARValue();
            }
            if (baseVal.malformed) {
                throw new LiveAttributeException
                    (element, localName,
                     LiveAttributeException.ERR_ATTRIBUTE_MALFORMED,
                     baseVal.getValueAsString());
            }
        }",method,
"            if (baseVal == null) {
                baseVal = new BaseSVGPARValue();
            }",method,
"            if (baseVal.malformed) {
                throw new LiveAttributeException
                    (element, localName,
                     LiveAttributeException.ERR_ATTRIBUTE_MALFORMED,
                     baseVal.getValueAsString());
            }",method,
"    public AnimatableValue getUnderlyingValue(AnimationTarget target) {
        SVGPreserveAspectRatio par = getBaseVal();
        return new AnimatablePreserveAspectRatioValue(target, par.getAlign(),
                                                      par.getMeetOrSlice());
    }",method,
"    protected void updateAnimatedValue(AnimatableValue val) {
        if (val == null) {
            hasAnimVal = false;
        } else {
            hasAnimVal = true;
            if (animVal == null) {
                animVal = new AnimSVGPARValue();
            }
            AnimatablePreserveAspectRatioValue animPAR =
                (AnimatablePreserveAspectRatioValue) val;
            animVal.setAnimatedValue(animPAR.getAlign(),
                                     animPAR.getMeetOrSlice());
        }
        fireAnimatedAttributeListeners();
    }",method,
"        if (val == null) {
            hasAnimVal = false;
        }",method,
"            if (animVal == null) {
                animVal = new AnimSVGPARValue();
            }",method,
"    public void attrAdded(Attr node, String newv) {
        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }
        fireBaseAttributeListeners();
        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }
    }",method,
"        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }",method,
"        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }",method,
"    public void attrModified(Attr node, String oldv, String newv) {
        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }
        fireBaseAttributeListeners();
        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }
    }",method,
"        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }",method,
"        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }",method,
"    public void attrRemoved(Attr node, String oldv) {
        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }
        fireBaseAttributeListeners();
        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }
    }",method,
"        if (!changing && baseVal != null) {
            baseVal.invalidate();
        }",method,
"        if (!hasAnimVal) {
            fireAnimatedAttributeListeners();
        }",method,
"        public BaseSVGPARValue() {
            invalidate();
        }",method,
"        protected DOMException createDOMException(short type, String key,
                                                  Object[] args) {
            return element.createDOMException(type, key, args);
        }",method,
"        protected void setAttributeValue(String value) throws DOMException {
            try {
                changing = true;
                element.setAttributeNS
                    (null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE,
                     value);
                malformed = false;
            } finally {
                changing = false;
            }
        }",method,
"        protected void invalidate() {
            String s = element.getAttributeNS
                (null, SVGConstants.SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE);
            setValueAsString(s);
        }",method,
"        protected DOMException createDOMException(short type, String key,
                                                  Object[] args) {
            return element.createDOMException(type, key, args);
        }",method,
"        protected void setAttributeValue(String value) throws DOMException {
        }",method,
"        public short getAlign() {
            if (hasAnimVal) {
                return super.getAlign();
            }
            return getBaseVal().getAlign();
        }",method,
"            if (hasAnimVal) {
                return super.getAlign();
            }",method,
"        public short getMeetOrSlice() {
            if (hasAnimVal) {
                return super.getMeetOrSlice();
            }
            return getBaseVal().getMeetOrSlice();
        }",method,
"            if (hasAnimVal) {
                return super.getMeetOrSlice();
            }",method,
"        public void setAlign(short align) {
            throw element.createDOMException
                (DOMException.NO_MODIFICATION_ALLOWED_ERR,
                 ""readonly.preserve.aspect.ratio"", null);
        }",method,
"        public void setMeetOrSlice(short meetOrSlice) {
            throw element.createDOMException
                (DOMException.NO_MODIFICATION_ALLOWED_ERR,
                 ""readonly.preserve.aspect.ratio"", null);
        }",method,
"        protected void setAnimatedValue(short align, short meetOrSlice) {
            this.align = align;
            this.meetOrSlice = meetOrSlice;
        }",method,
"public class PropertiesActivity extends BaseActivity {
	public PropertiesActivity() {
		super(R.string.properties);
	}
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setSlidingActionBarEnabled(true);
		setContentView(R.layout.properties);
		// left and right modes
		RadioGroup mode = (RadioGroup) findViewById(R.id.mode);
		mode.check(R.id.left);
		mode.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				SlidingMenu sm = getSlidingMenu();
				switch (checkedId) {
				case R.id.left:
					sm.setMode(SlidingMenu.LEFT);
					sm.setShadowDrawable(R.drawable.shadow);
					break;
				case R.id.right:
					sm.setMode(SlidingMenu.RIGHT);
					sm.setShadowDrawable(R.drawable.shadowright);
					break;
				case R.id.left_right:
					sm.setMode(SlidingMenu.LEFT_RIGHT);
					sm.setSecondaryMenu(R.layout.menu_frame_two);
					getSupportFragmentManager()
					.beginTransaction()
					.replace(R.id.menu_frame_two, new SampleListFragment())
					.commit();					
					sm.setSecondaryShadowDrawable(R.drawable.shadowright);
					sm.setShadowDrawable(R.drawable.shadow);
				}
			}			
		});
		// touch mode stuff
		RadioGroup touchAbove = (RadioGroup) findViewById(R.id.touch_above);
		touchAbove.check(R.id.touch_above_full);
		touchAbove.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				switch (checkedId) {
				case R.id.touch_above_full:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
					break;
				case R.id.touch_above_margin:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_MARGIN);
					break;
				case R.id.touch_above_none:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);
					break;
				}
			}
		});
		// scroll scale stuff
		SeekBar scrollScale = (SeekBar) findViewById(R.id.scroll_scale);
		scrollScale.setMax(1000);
		scrollScale.setProgress(333);
		scrollScale.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setBehindScrollScale((float) seekBar.getProgress()/seekBar.getMax());
			}
		});
		// behind width stuff
		SeekBar behindWidth = (SeekBar) findViewById(R.id.behind_width);
		behindWidth.setMax(1000);
		behindWidth.setProgress(750);
		behindWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/seekBar.getMax();
				getSlidingMenu().setBehindWidth((int) (percent * getSlidingMenu().getWidth()));
				getSlidingMenu().requestLayout();
			}
		});
		// shadow stuff
		CheckBox shadowEnabled = (CheckBox) findViewById(R.id.shadow_enabled);
		shadowEnabled.setChecked(true);
		shadowEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				if (isChecked)
					getSlidingMenu().setShadowDrawable(
							getSlidingMenu().getMode() == SlidingMenu.LEFT ? 
									R.drawable.shadow : R.drawable.shadowright);
				else
					getSlidingMenu().setShadowDrawable(null);
			}
		});
		SeekBar shadowWidth = (SeekBar) findViewById(R.id.shadow_width);
		shadowWidth.setMax(1000);
		shadowWidth.setProgress(75);
		shadowWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/ (float) seekBar.getMax();
				int width = (int) (percent * (float) getSlidingMenu().getWidth());
				getSlidingMenu().setShadowWidth(width);
				getSlidingMenu().invalidate();
			}
		});
		// fading stuff
		CheckBox fadeEnabled = (CheckBox) findViewById(R.id.fade_enabled);
		fadeEnabled.setChecked(true);
		fadeEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				getSlidingMenu().setFadeEnabled(isChecked);
			}			
		});
		SeekBar fadeDeg = (SeekBar) findViewById(R.id.fade_degree);
		fadeDeg.setMax(1000);
		fadeDeg.setProgress(666);
		fadeDeg.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setFadeDegree((float) seekBar.getProgress()/seekBar.getMax());
			}			
		});
	}
}",class,
"	public PropertiesActivity() {
		super(R.string.properties);
	}",method,
"	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setSlidingActionBarEnabled(true);
		setContentView(R.layout.properties);
		// left and right modes
		RadioGroup mode = (RadioGroup) findViewById(R.id.mode);
		mode.check(R.id.left);
		mode.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				SlidingMenu sm = getSlidingMenu();
				switch (checkedId) {
				case R.id.left:
					sm.setMode(SlidingMenu.LEFT);
					sm.setShadowDrawable(R.drawable.shadow);
					break;
				case R.id.right:
					sm.setMode(SlidingMenu.RIGHT);
					sm.setShadowDrawable(R.drawable.shadowright);
					break;
				case R.id.left_right:
					sm.setMode(SlidingMenu.LEFT_RIGHT);
					sm.setSecondaryMenu(R.layout.menu_frame_two);
					getSupportFragmentManager()
					.beginTransaction()
					.replace(R.id.menu_frame_two, new SampleListFragment())
					.commit();					
					sm.setSecondaryShadowDrawable(R.drawable.shadowright);
					sm.setShadowDrawable(R.drawable.shadow);
				}
			}			
		});
		// touch mode stuff
		RadioGroup touchAbove = (RadioGroup) findViewById(R.id.touch_above);
		touchAbove.check(R.id.touch_above_full);
		touchAbove.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				switch (checkedId) {
				case R.id.touch_above_full:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
					break;
				case R.id.touch_above_margin:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_MARGIN);
					break;
				case R.id.touch_above_none:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);
					break;
				}
			}
		});
		// scroll scale stuff
		SeekBar scrollScale = (SeekBar) findViewById(R.id.scroll_scale);
		scrollScale.setMax(1000);
		scrollScale.setProgress(333);
		scrollScale.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setBehindScrollScale((float) seekBar.getProgress()/seekBar.getMax());
			}
		});
		// behind width stuff
		SeekBar behindWidth = (SeekBar) findViewById(R.id.behind_width);
		behindWidth.setMax(1000);
		behindWidth.setProgress(750);
		behindWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/seekBar.getMax();
				getSlidingMenu().setBehindWidth((int) (percent * getSlidingMenu().getWidth()));
				getSlidingMenu().requestLayout();
			}
		});
		// shadow stuff
		CheckBox shadowEnabled = (CheckBox) findViewById(R.id.shadow_enabled);
		shadowEnabled.setChecked(true);
		shadowEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				if (isChecked)
					getSlidingMenu().setShadowDrawable(
							getSlidingMenu().getMode() == SlidingMenu.LEFT ? 
									R.drawable.shadow : R.drawable.shadowright);
				else
					getSlidingMenu().setShadowDrawable(null);
			}
		});
		SeekBar shadowWidth = (SeekBar) findViewById(R.id.shadow_width);
		shadowWidth.setMax(1000);
		shadowWidth.setProgress(75);
		shadowWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/ (float) seekBar.getMax();
				int width = (int) (percent * (float) getSlidingMenu().getWidth());
				getSlidingMenu().setShadowWidth(width);
				getSlidingMenu().invalidate();
			}
		});
		// fading stuff
		CheckBox fadeEnabled = (CheckBox) findViewById(R.id.fade_enabled);
		fadeEnabled.setChecked(true);
		fadeEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				getSlidingMenu().setFadeEnabled(isChecked);
			}			
		});
		SeekBar fadeDeg = (SeekBar) findViewById(R.id.fade_degree);
		fadeDeg.setMax(1000);
		fadeDeg.setProgress(666);
		fadeDeg.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setFadeDegree((float) seekBar.getProgress()/seekBar.getMax());
			}			
		});
	}",method,
"		mode.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				SlidingMenu sm = getSlidingMenu();
				switch (checkedId) {
				case R.id.left:
					sm.setMode(SlidingMenu.LEFT);
					sm.setShadowDrawable(R.drawable.shadow);
					break;
				case R.id.right:
					sm.setMode(SlidingMenu.RIGHT);
					sm.setShadowDrawable(R.drawable.shadowright);
					break;
				case R.id.left_right:
					sm.setMode(SlidingMenu.LEFT_RIGHT);
					sm.setSecondaryMenu(R.layout.menu_frame_two);
					getSupportFragmentManager()
					.beginTransaction()
					.replace(R.id.menu_frame_two, new SampleListFragment())
					.commit();					
					sm.setSecondaryShadowDrawable(R.drawable.shadowright);
					sm.setShadowDrawable(R.drawable.shadow);
				}
			}			
		}",method,
"			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				SlidingMenu sm = getSlidingMenu();
				switch (checkedId) {
				case R.id.left:
					sm.setMode(SlidingMenu.LEFT);
					sm.setShadowDrawable(R.drawable.shadow);
					break;
				case R.id.right:
					sm.setMode(SlidingMenu.RIGHT);
					sm.setShadowDrawable(R.drawable.shadowright);
					break;
				case R.id.left_right:
					sm.setMode(SlidingMenu.LEFT_RIGHT);
					sm.setSecondaryMenu(R.layout.menu_frame_two);
					getSupportFragmentManager()
					.beginTransaction()
					.replace(R.id.menu_frame_two, new SampleListFragment())
					.commit();					
					sm.setSecondaryShadowDrawable(R.drawable.shadowright);
					sm.setShadowDrawable(R.drawable.shadow);
				}
			}",method,
"				switch (checkedId) {
				case R.id.left:
					sm.setMode(SlidingMenu.LEFT);
					sm.setShadowDrawable(R.drawable.shadow);
					break;
				case R.id.right:
					sm.setMode(SlidingMenu.RIGHT);
					sm.setShadowDrawable(R.drawable.shadowright);
					break;
				case R.id.left_right:
					sm.setMode(SlidingMenu.LEFT_RIGHT);
					sm.setSecondaryMenu(R.layout.menu_frame_two);
					getSupportFragmentManager()
					.beginTransaction()
					.replace(R.id.menu_frame_two, new SampleListFragment())
					.commit();					
					sm.setSecondaryShadowDrawable(R.drawable.shadowright);
					sm.setShadowDrawable(R.drawable.shadow);
				}",method,
"		touchAbove.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				switch (checkedId) {
				case R.id.touch_above_full:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
					break;
				case R.id.touch_above_margin:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_MARGIN);
					break;
				case R.id.touch_above_none:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);
					break;
				}
			}
		}",method,
"			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				switch (checkedId) {
				case R.id.touch_above_full:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
					break;
				case R.id.touch_above_margin:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_MARGIN);
					break;
				case R.id.touch_above_none:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);
					break;
				}
			}",method,
"				switch (checkedId) {
				case R.id.touch_above_full:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
					break;
				case R.id.touch_above_margin:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_MARGIN);
					break;
				case R.id.touch_above_none:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);
					break;
				}",method,
"		scrollScale.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setBehindScrollScale((float) seekBar.getProgress()/seekBar.getMax());
			}
		}",method,
"			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }",method,
"			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }",method,
"			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setBehindScrollScale((float) seekBar.getProgress()/seekBar.getMax());
			}",method,
"		behindWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/seekBar.getMax();
				getSlidingMenu().setBehindWidth((int) (percent * getSlidingMenu().getWidth()));
				getSlidingMenu().requestLayout();
			}
		}",method,
"			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }",method,
"			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }",method,
"			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/seekBar.getMax();
				getSlidingMenu().setBehindWidth((int) (percent * getSlidingMenu().getWidth()));
				getSlidingMenu().requestLayout();
			}",method,
"		shadowEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				if (isChecked)
					getSlidingMenu().setShadowDrawable(
							getSlidingMenu().getMode() == SlidingMenu.LEFT ? 
									R.drawable.shadow : R.drawable.shadowright);
				else
					getSlidingMenu().setShadowDrawable(null);
			}
		}",method,
"			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				if (isChecked)
					getSlidingMenu().setShadowDrawable(
							getSlidingMenu().getMode() == SlidingMenu.LEFT ? 
									R.drawable.shadow : R.drawable.shadowright);
				else
					getSlidingMenu().setShadowDrawable(null);
			}",method,
"		shadowWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/ (float) seekBar.getMax();
				int width = (int) (percent * (float) getSlidingMenu().getWidth());
				getSlidingMenu().setShadowWidth(width);
				getSlidingMenu().invalidate();
			}
		}",method,

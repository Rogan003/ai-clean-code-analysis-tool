code_snippet,type,score
"    private boolean isProvider(Type type) {
        return type instanceof ParameterizedType
                && ((ParameterizedType) type).getRawType() == Provider.class;
    }",method,
"    private Key<?> getBindingForType(Type type) {
        return bindingAnnotation != null
                ? Key.get(type, bindingAnnotation)
                : Key.get(type);
    }",method,
"    private Annotation getBindingAnnotation(Annotation[] annotations) {
        Annotation bindingAnnotation = null;
        for (Annotation a : annotations) {
            if (a.annotationType().getAnnotation(BindingAnnotation.class) != null) {
                if (bindingAnnotation != null) {
                    throw new IllegalArgumentException(""Parameter has multiple binding annotations: "" + bindingAnnotation + "" and "" + a);
                }
                bindingAnnotation = a;
            }
        }
        return bindingAnnotation;
    }",method,
"        for (Annotation a : annotations) {
            if (a.annotationType().getAnnotation(BindingAnnotation.class) != null) {
                if (bindingAnnotation != null) {
                    throw new IllegalArgumentException(""Parameter has multiple binding annotations: "" + bindingAnnotation + "" and "" + a);
                }
                bindingAnnotation = a;
            }
        }",method,
"                if (bindingAnnotation != null) {
                    throw new IllegalArgumentException(""Parameter has multiple binding annotations: "" + bindingAnnotation + "" and "" + a);
                }",method,
"public class KerasConvolution1DTest {
    private final String ACTIVATION_KERAS = ""linear"";
    private final String ACTIVATION_DL4J = ""identity"";
    private final String LAYER_NAME = ""test_layer"";
    private final String INIT_KERAS = ""glorot_normal"";
    private final WeightInit INIT_DL4J = WeightInit.XAVIER;
    private final double L1_REGULARIZATION = 0.01;
    private final double L2_REGULARIZATION = 0.02;
    private final double DROPOUT_KERAS = 0.3;
    private final double DROPOUT_DL4J = 1 - DROPOUT_KERAS;
    private final int[] KERNEL_SIZE = new int[]{1, 2};
    private final int[] DILATION = new int[]{2, 2};
    private final int[] INPUT_SHAPE = new int[]{100, 20};
    private final int[] STRIDE = new int[]{3, 4};
    private final PoolingType POOLING_TYPE = PoolingType.MAX;
    private final int N_OUT = 13;
    private final String BORDER_MODE_VALID = ""valid"";
    private final int[] VALID_PADDING = new int[]{0, 0};
    private Integer keras1 = 1;
    private Integer keras2 = 2;
    private Keras1LayerConfiguration conf1 = new Keras1LayerConfiguration();
    private Keras2LayerConfiguration conf2 = new Keras2LayerConfiguration();
    @Test
    public void testConvolution1DLayer() throws Exception {
        buildConvolution1DLayer(conf1, keras1, false);
        buildConvolution1DLayer(conf2, keras2, false);
        buildConvolution1DLayer(conf2, keras2, true);
    }
    public void buildConvolution1DLayer(KerasLayerConfiguration conf, Integer kerasVersion, boolean withDilation)
            throws Exception {
        Map<String, Object> layerConfig = new HashMap<String, Object>();
        layerConfig.put(conf.getLAYER_FIELD_CLASS_NAME(), conf.getLAYER_CLASS_NAME_CONVOLUTION_1D());
        Map<String, Object> config = new HashMap<String, Object>();
        config.put(conf.getLAYER_FIELD_ACTIVATION(), ACTIVATION_KERAS);
        config.put(conf.getLAYER_FIELD_NAME(), LAYER_NAME);
        layerConfig.put(conf.getLAYER_FIELD_KERAS_VERSION(), kerasVersion);
        if (kerasVersion == 1) {
            config.put(conf.getLAYER_FIELD_INIT(), INIT_KERAS);
        } else {
            Map<String, Object> init = new HashMap<String, Object>();
            init.put(""class_name"", conf.getINIT_GLOROT_NORMAL());
            config.put(conf.getLAYER_FIELD_INIT(), init);
        }
        if (withDilation) {
            config.put(conf.getLAYER_FIELD_DILATION_RATE(), DILATION[0]);
        }
        Map<String, Object> W_reg = new HashMap<String, Object>();
        W_reg.put(conf.getREGULARIZATION_TYPE_L1(), L1_REGULARIZATION);
        W_reg.put(conf.getREGULARIZATION_TYPE_L2(), L2_REGULARIZATION);
        config.put(conf.getLAYER_FIELD_W_REGULARIZER(), W_reg);
        config.put(conf.getLAYER_FIELD_DROPOUT(), DROPOUT_KERAS);
        config.put(conf.getLAYER_FIELD_FILTER_LENGTH(), KERNEL_SIZE[0]);
        config.put(conf.getLAYER_FIELD_SUBSAMPLE_LENGTH(), STRIDE[0]);
        config.put(conf.getLAYER_FIELD_NB_FILTER(), N_OUT);
        config.put(conf.getLAYER_FIELD_BORDER_MODE(), BORDER_MODE_VALID);
        layerConfig.put(conf.getLAYER_FIELD_CONFIG(), config);
        Convolution1DLayer layer = new KerasConvolution1D(layerConfig).getConvolution1DLayer();
        assertEquals(ACTIVATION_DL4J, layer.getActivationFn().toString());
        assertEquals(LAYER_NAME, layer.getLayerName());
        assertEquals(INIT_DL4J, layer.getWeightInit());
        assertEquals(L1_REGULARIZATION, layer.getL1(), 0.0);
        assertEquals(L2_REGULARIZATION, layer.getL2(), 0.0);
        assertEquals(new Dropout(DROPOUT_DL4J), layer.getIDropout());
        assertEquals(KERNEL_SIZE[0], layer.getKernelSize()[0]);
        assertEquals(STRIDE[0], layer.getStride()[0]);
        assertEquals(N_OUT, layer.getNOut());
        assertEquals(ConvolutionMode.Truncate, layer.getConvolutionMode());
        assertEquals(VALID_PADDING[0], layer.getPadding()[0]);
        if (withDilation) {
            assertEquals(DILATION[0], layer.getDilation()[0]);
        }
    }
}",class,
"    @Test
    public void testConvolution1DLayer() throws Exception {
        buildConvolution1DLayer(conf1, keras1, false);
        buildConvolution1DLayer(conf2, keras2, false);
        buildConvolution1DLayer(conf2, keras2, true);
    }",method,
"    public void buildConvolution1DLayer(KerasLayerConfiguration conf, Integer kerasVersion, boolean withDilation)
            throws Exception {
        Map<String, Object> layerConfig = new HashMap<String, Object>();
        layerConfig.put(conf.getLAYER_FIELD_CLASS_NAME(), conf.getLAYER_CLASS_NAME_CONVOLUTION_1D());
        Map<String, Object> config = new HashMap<String, Object>();
        config.put(conf.getLAYER_FIELD_ACTIVATION(), ACTIVATION_KERAS);
        config.put(conf.getLAYER_FIELD_NAME(), LAYER_NAME);
        layerConfig.put(conf.getLAYER_FIELD_KERAS_VERSION(), kerasVersion);
        if (kerasVersion == 1) {
            config.put(conf.getLAYER_FIELD_INIT(), INIT_KERAS);
        } else {
            Map<String, Object> init = new HashMap<String, Object>();
            init.put(""class_name"", conf.getINIT_GLOROT_NORMAL());
            config.put(conf.getLAYER_FIELD_INIT(), init);
        }
        if (withDilation) {
            config.put(conf.getLAYER_FIELD_DILATION_RATE(), DILATION[0]);
        }
        Map<String, Object> W_reg = new HashMap<String, Object>();
        W_reg.put(conf.getREGULARIZATION_TYPE_L1(), L1_REGULARIZATION);
        W_reg.put(conf.getREGULARIZATION_TYPE_L2(), L2_REGULARIZATION);
        config.put(conf.getLAYER_FIELD_W_REGULARIZER(), W_reg);
        config.put(conf.getLAYER_FIELD_DROPOUT(), DROPOUT_KERAS);
        config.put(conf.getLAYER_FIELD_FILTER_LENGTH(), KERNEL_SIZE[0]);
        config.put(conf.getLAYER_FIELD_SUBSAMPLE_LENGTH(), STRIDE[0]);
        config.put(conf.getLAYER_FIELD_NB_FILTER(), N_OUT);
        config.put(conf.getLAYER_FIELD_BORDER_MODE(), BORDER_MODE_VALID);
        layerConfig.put(conf.getLAYER_FIELD_CONFIG(), config);
        Convolution1DLayer layer = new KerasConvolution1D(layerConfig).getConvolution1DLayer();
        assertEquals(ACTIVATION_DL4J, layer.getActivationFn().toString());
        assertEquals(LAYER_NAME, layer.getLayerName());
        assertEquals(INIT_DL4J, layer.getWeightInit());
        assertEquals(L1_REGULARIZATION, layer.getL1(), 0.0);
        assertEquals(L2_REGULARIZATION, layer.getL2(), 0.0);
        assertEquals(new Dropout(DROPOUT_DL4J), layer.getIDropout());
        assertEquals(KERNEL_SIZE[0], layer.getKernelSize()[0]);
        assertEquals(STRIDE[0], layer.getStride()[0]);
        assertEquals(N_OUT, layer.getNOut());
        assertEquals(ConvolutionMode.Truncate, layer.getConvolutionMode());
        assertEquals(VALID_PADDING[0], layer.getPadding()[0]);
        if (withDilation) {
            assertEquals(DILATION[0], layer.getDilation()[0]);
        }
    }",method,
"        if (kerasVersion == 1) {
            config.put(conf.getLAYER_FIELD_INIT(), INIT_KERAS);
        }",method,
"        if (withDilation) {
            config.put(conf.getLAYER_FIELD_DILATION_RATE(), DILATION[0]);
        }",method,
"        if (withDilation) {
            assertEquals(DILATION[0], layer.getDilation()[0]);
        }",method,
"public class DataChunk implements Serializable {
  private static final long serialVersionUID = 1L;
  private boolean isRowMajor;
  private long dataPageOffset;
  private int dataPageLength;
  private BitSet nullValueIndexForColumn;
  private long rowIdPageOffset;
  private int rowIdPageLength;
  private long rlePageOffset;
  private int rlePageLength;
  private List<Encoding> encodingList;
  private List<ValueEncoderMeta> valueEncoderMetaList;
  public boolean isRowMajor() {
    return isRowMajor;
  }
  public void setRowMajor(boolean isRowMajor) {
    this.isRowMajor = isRowMajor;
  }
  public long getDataPageOffset() {
    return dataPageOffset;
  }
  public void setDataPageOffset(long dataPageOffset) {
    this.dataPageOffset = dataPageOffset;
  }
  public int getDataPageLength() {
    return dataPageLength;
  }
  public void setDataPageLength(int dataPageLength) {
    this.dataPageLength = dataPageLength;
  }
  public BitSet getNullValueIndexForColumn() {
    return nullValueIndexForColumn;
  }
  public void setNullValueIndexForColumn(BitSet nullValueIndexForColumn) {
    this.nullValueIndexForColumn = nullValueIndexForColumn;
  }
  public long getRowIdPageOffset() {
    return rowIdPageOffset;
  }
  public void setRowIdPageOffset(long rowIdPageOffset) {
    this.rowIdPageOffset = rowIdPageOffset;
  }
  public int getRowIdPageLength() {
    return rowIdPageLength;
  }
  public void setRowIdPageLength(int rowIdPageLength) {
    this.rowIdPageLength = rowIdPageLength;
  }
  public long getRlePageOffset() {
    return rlePageOffset;
  }
  public void setRlePageOffset(long rlePageOffset) {
    this.rlePageOffset = rlePageOffset;
  }
  public int getRlePageLength() {
    return rlePageLength;
  }
  public void setRlePageLength(int rlePageLength) {
    this.rlePageLength = rlePageLength;
  }
  public List<Encoding> getEncodingList() {
    return encodingList;
  }
  public void setEncodingList(List<Encoding> encodingList) {
    this.encodingList = encodingList;
  }
  public List<ValueEncoderMeta> getValueEncoderMeta() {
    return valueEncoderMetaList;
  }
  public void setValueEncoderMeta(List<ValueEncoderMeta> valueEncoderMetaList) {
    this.valueEncoderMetaList = valueEncoderMetaList;
  }
}",class,
"  public boolean isRowMajor() {
    return isRowMajor;
  }",method,
"  public void setRowMajor(boolean isRowMajor) {
    this.isRowMajor = isRowMajor;
  }",method,
"  public long getDataPageOffset() {
    return dataPageOffset;
  }",method,
"  public void setDataPageOffset(long dataPageOffset) {
    this.dataPageOffset = dataPageOffset;
  }",method,
"  public int getDataPageLength() {
    return dataPageLength;
  }",method,
"  public void setDataPageLength(int dataPageLength) {
    this.dataPageLength = dataPageLength;
  }",method,
"  public BitSet getNullValueIndexForColumn() {
    return nullValueIndexForColumn;
  }",method,
"  public void setNullValueIndexForColumn(BitSet nullValueIndexForColumn) {
    this.nullValueIndexForColumn = nullValueIndexForColumn;
  }",method,
"  public long getRowIdPageOffset() {
    return rowIdPageOffset;
  }",method,
"  public void setRowIdPageOffset(long rowIdPageOffset) {
    this.rowIdPageOffset = rowIdPageOffset;
  }",method,
"  public int getRowIdPageLength() {
    return rowIdPageLength;
  }",method,
"  public void setRowIdPageLength(int rowIdPageLength) {
    this.rowIdPageLength = rowIdPageLength;
  }",method,
"  public long getRlePageOffset() {
    return rlePageOffset;
  }",method,
"  public void setRlePageOffset(long rlePageOffset) {
    this.rlePageOffset = rlePageOffset;
  }",method,
"  public int getRlePageLength() {
    return rlePageLength;
  }",method,
"  public void setRlePageLength(int rlePageLength) {
    this.rlePageLength = rlePageLength;
  }",method,
"  public List<Encoding> getEncodingList() {
    return encodingList;
  }",method,
"  public void setEncodingList(List<Encoding> encodingList) {
    this.encodingList = encodingList;
  }",method,
"  public List<ValueEncoderMeta> getValueEncoderMeta() {
    return valueEncoderMetaList;
  }",method,
"  public void setValueEncoderMeta(List<ValueEncoderMeta> valueEncoderMetaList) {
    this.valueEncoderMetaList = valueEncoderMetaList;
  }",method,
"public class ThrownExceptionsPerMethodInspection
  extends MethodMetricInspection {
  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""thrown.exceptions.per.method.display.name"");
  }
  @Override
  @NotNull
  public String getID() {
    return ""MethodWithTooExceptionsDeclared"";
  }
  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    final Integer exceptionCount = (Integer)infos[0];
    return InspectionGadgetsBundle.message(
      ""thrown.exceptions.per.method.problem.descriptor"",
      exceptionCount);
  }
  @Override
  protected int getDefaultLimit() {
    return 3;
  }
  @Override
  protected String getConfigurationLabel() {
    return InspectionGadgetsBundle.message(
      ""thrown.exceptions.per.method.limit.option"");
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new ThrownExceptionsPerMethodVisitor();
  }
  private class ThrownExceptionsPerMethodVisitor
    extends BaseInspectionVisitor {
    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      // note: no call to super
      if (method.getNameIdentifier() == null) {
        return;
      }
      final PsiReferenceList throwList = method.getThrowsList();
      final PsiJavaCodeReferenceElement[] thrownExceptions =
        throwList.getReferenceElements();
      final int exceptionCount = thrownExceptions.length;
      if (exceptionCount <= getLimit()) {
        return;
      }
      registerMethodError(method, Integer.valueOf(exceptionCount));
    }
  }
}",class,
"  private class ThrownExceptionsPerMethodVisitor
    extends BaseInspectionVisitor {
    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      // note: no call to super
      if (method.getNameIdentifier() == null) {
        return;
      }
      final PsiReferenceList throwList = method.getThrowsList();
      final PsiJavaCodeReferenceElement[] thrownExceptions =
        throwList.getReferenceElements();
      final int exceptionCount = thrownExceptions.length;
      if (exceptionCount <= getLimit()) {
        return;
      }
      registerMethodError(method, Integer.valueOf(exceptionCount));
    }
  }",class,
"  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""thrown.exceptions.per.method.display.name"");
  }",method,
"  @Override
  @NotNull
  public String getID() {
    return ""MethodWithTooExceptionsDeclared"";
  }",method,
"  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    final Integer exceptionCount = (Integer)infos[0];
    return InspectionGadgetsBundle.message(
      ""thrown.exceptions.per.method.problem.descriptor"",
      exceptionCount);
  }",method,
"  @Override
  protected int getDefaultLimit() {
    return 3;
  }",method,
"  @Override
  protected String getConfigurationLabel() {
    return InspectionGadgetsBundle.message(
      ""thrown.exceptions.per.method.limit.option"");
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new ThrownExceptionsPerMethodVisitor();
  }",method,
"    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      // note: no call to super
      if (method.getNameIdentifier() == null) {
        return;
      }
      final PsiReferenceList throwList = method.getThrowsList();
      final PsiJavaCodeReferenceElement[] thrownExceptions =
        throwList.getReferenceElements();
      final int exceptionCount = thrownExceptions.length;
      if (exceptionCount <= getLimit()) {
        return;
      }
      registerMethodError(method, Integer.valueOf(exceptionCount));
    }",method,
"public class ETC1TextureData implements TextureData {
	public ETC1TextureData (FileHandle file) {
		throw new GdxRuntimeException(""ETC1TextureData not supported in GWT backend"");
	}
	public ETC1TextureData (FileHandle file, boolean useMipMaps) {
		throw new GdxRuntimeException(""ETC1TextureData not supported in GWT backend"");
	}
	@Override
	public TextureDataType getType () {
		return null;
	}
	@Override
	public boolean isPrepared () {
		return false;
	}
	@Override
	public void prepare () {
	}
	@Override
	public Pixmap consumePixmap () {
		// TODO Auto-generated method stub
		return null;
	}
	@Override
	public boolean disposePixmap () {
		// TODO Auto-generated method stub
		return false;
	}
	@Override
	public void consumeCustomData (int target) {
		// TODO Auto-generated method stub
	}
	@Override
	public int getWidth () {
		// TODO Auto-generated method stub
		return 0;
	}
	@Override
	public int getHeight () {
		// TODO Auto-generated method stub
		return 0;
	}
	@Override
	public Format getFormat () {
		// TODO Auto-generated method stub
		return null;
	}
	@Override
	public boolean useMipMaps () {
		// TODO Auto-generated method stub
		return false;
	}
	@Override
	public boolean isManaged () {
		// TODO Auto-generated method stub
		return false;
	}
}",class,
"	public ETC1TextureData (FileHandle file) {
		throw new GdxRuntimeException(""ETC1TextureData not supported in GWT backend"");
	}",method,
"	public ETC1TextureData (FileHandle file, boolean useMipMaps) {
		throw new GdxRuntimeException(""ETC1TextureData not supported in GWT backend"");
	}",method,
"	@Override
	public TextureDataType getType () {
		return null;
	}",method,
"	@Override
	public boolean isPrepared () {
		return false;
	}",method,
"	@Override
	public void prepare () {
	}",method,
"	@Override
	public Pixmap consumePixmap () {
		// TODO Auto-generated method stub
		return null;
	}",method,
"	@Override
	public boolean disposePixmap () {
		// TODO Auto-generated method stub
		return false;
	}",method,
"	@Override
	public void consumeCustomData (int target) {
		// TODO Auto-generated method stub
	}",method,
"	@Override
	public int getWidth () {
		// TODO Auto-generated method stub
		return 0;
	}",method,
"	@Override
	public int getHeight () {
		// TODO Auto-generated method stub
		return 0;
	}",method,
"	@Override
	public Format getFormat () {
		// TODO Auto-generated method stub
		return null;
	}",method,
"	@Override
	public boolean useMipMaps () {
		// TODO Auto-generated method stub
		return false;
	}",method,
"	@Override
	public boolean isManaged () {
		// TODO Auto-generated method stub
		return false;
	}",method,
"public class SearchTimeoutIT extends ESIntegTestCase {
    @Override
    protected Collection<Class<? extends Plugin>> nodePlugins() {
        return Collections.singleton(ScriptedTimeoutPlugin.class);
    }
    @Override
    protected Settings nodeSettings(int nodeOrdinal) {
        return Settings.builder().put(super.nodeSettings(nodeOrdinal)).build();
    }
    public void testSimpleTimeout() throws Exception {
        client().prepareIndex(""test"", ""type"", ""1"").setSource(""field"", ""value"").setRefreshPolicy(IMMEDIATE).get();
        SearchResponse searchResponse = client().prepareSearch(""test"").setTimeout(new TimeValue(10, TimeUnit.MILLISECONDS))
                .setQuery(scriptQuery(
                    new Script(ScriptType.INLINE, ""mockscript"", SCRIPT_NAME, Collections.emptyMap())))
                .execute().actionGet();
        assertThat(searchResponse.isTimedOut(), equalTo(true));
    }
    public static class ScriptedTimeoutPlugin extends MockScriptPlugin {
        static final String SCRIPT_NAME = ""search_timeout"";
        @Override
        public Map<String, Function<Map<String, Object>, Object>> pluginScripts() {
            return Collections.singletonMap(SCRIPT_NAME, params -> {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                return true;
            });
        }
    }
}",class,
"    public static class ScriptedTimeoutPlugin extends MockScriptPlugin {
        static final String SCRIPT_NAME = ""search_timeout"";
        @Override
        public Map<String, Function<Map<String, Object>, Object>> pluginScripts() {
            return Collections.singletonMap(SCRIPT_NAME, params -> {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                return true;
            });
        }
    }",class,
"    @Override
    protected Collection<Class<? extends Plugin>> nodePlugins() {
        return Collections.singleton(ScriptedTimeoutPlugin.class);
    }",method,
"    @Override
    protected Settings nodeSettings(int nodeOrdinal) {
        return Settings.builder().put(super.nodeSettings(nodeOrdinal)).build();
    }",method,
"    public void testSimpleTimeout() throws Exception {
        client().prepareIndex(""test"", ""type"", ""1"").setSource(""field"", ""value"").setRefreshPolicy(IMMEDIATE).get();
        SearchResponse searchResponse = client().prepareSearch(""test"").setTimeout(new TimeValue(10, TimeUnit.MILLISECONDS))
                .setQuery(scriptQuery(
                    new Script(ScriptType.INLINE, ""mockscript"", SCRIPT_NAME, Collections.emptyMap())))
                .execute().actionGet();
        assertThat(searchResponse.isTimedOut(), equalTo(true));
    }",method,
"        @Override
        public Map<String, Function<Map<String, Object>, Object>> pluginScripts() {
            return Collections.singletonMap(SCRIPT_NAME, params -> {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                return true;
            });
        }",method,
"public class AsyncSupportConfigurer {
	@Nullable
	private AsyncTaskExecutor taskExecutor;
	@Nullable
	private Long timeout;
	private final List<CallableProcessingInterceptor> callableInterceptors = new ArrayList<>();
	private final List<DeferredResultProcessingInterceptor> deferredResultInterceptors = new ArrayList<>();
	public AsyncSupportConfigurer setTaskExecutor(AsyncTaskExecutor taskExecutor) {
		this.taskExecutor = taskExecutor;
		return this;
	}
	public AsyncSupportConfigurer setDefaultTimeout(long timeout) {
		this.timeout = timeout;
		return this;
	}
	public AsyncSupportConfigurer registerCallableInterceptors(CallableProcessingInterceptor... interceptors) {
		this.callableInterceptors.addAll(Arrays.asList(interceptors));
		return this;
	}
	public AsyncSupportConfigurer registerDeferredResultInterceptors(
			DeferredResultProcessingInterceptor... interceptors) {
		this.deferredResultInterceptors.addAll(Arrays.asList(interceptors));
		return this;
	}
	@Nullable
	protected AsyncTaskExecutor getTaskExecutor() {
		return this.taskExecutor;
	}
	@Nullable
	protected Long getTimeout() {
		return this.timeout;
	}
	protected List<CallableProcessingInterceptor> getCallableInterceptors() {
		return this.callableInterceptors;
	}
	protected List<DeferredResultProcessingInterceptor> getDeferredResultInterceptors() {
		return this.deferredResultInterceptors;
	}
}",class,
"	public AsyncSupportConfigurer setTaskExecutor(AsyncTaskExecutor taskExecutor) {
		this.taskExecutor = taskExecutor;
		return this;
	}",method,
"	public AsyncSupportConfigurer setDefaultTimeout(long timeout) {
		this.timeout = timeout;
		return this;
	}",method,
"	public AsyncSupportConfigurer registerCallableInterceptors(CallableProcessingInterceptor... interceptors) {
		this.callableInterceptors.addAll(Arrays.asList(interceptors));
		return this;
	}",method,
"	public AsyncSupportConfigurer registerDeferredResultInterceptors(
			DeferredResultProcessingInterceptor... interceptors) {
		this.deferredResultInterceptors.addAll(Arrays.asList(interceptors));
		return this;
	}",method,
"	@Nullable
	protected AsyncTaskExecutor getTaskExecutor() {
		return this.taskExecutor;
	}",method,
"	@Nullable
	protected Long getTimeout() {
		return this.timeout;
	}",method,
"	protected List<CallableProcessingInterceptor> getCallableInterceptors() {
		return this.callableInterceptors;
	}",method,
"	protected List<DeferredResultProcessingInterceptor> getDeferredResultInterceptors() {
		return this.deferredResultInterceptors;
	}",method,
"public final class RxAndroidPluginsTest {
    @Before @After
    public void setUpAndTearDown() {
        RxAndroidPlugins.reset();
    }
    @Test
    public void mainThreadHandlerCalled() {
        final AtomicReference<Scheduler> schedulerRef = new AtomicReference<>();
        final Scheduler newScheduler = new EmptyScheduler();
        RxAndroidPlugins.setMainThreadSchedulerHandler(new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                schedulerRef.set(scheduler);
                return newScheduler;
            }
        });
        Scheduler scheduler = new EmptyScheduler();
        Scheduler actual = RxAndroidPlugins.onMainThreadScheduler(scheduler);
        assertSame(newScheduler, actual);
        assertSame(scheduler, schedulerRef.get());
    }
    @Test
    public void resetClearsMainThreadHandler() {
        RxAndroidPlugins.setMainThreadSchedulerHandler(new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                throw new AssertionError();
            }
        });
        RxAndroidPlugins.reset();
        Scheduler scheduler = new EmptyScheduler();
        Scheduler actual = RxAndroidPlugins.onMainThreadScheduler(scheduler);
        assertSame(scheduler, actual);
    }
    @Test
    public void initMainThreadHandlerCalled() {
        final AtomicReference<Callable<Scheduler>> schedulerRef = new AtomicReference<>();
        final Scheduler newScheduler = new EmptyScheduler();
        RxAndroidPlugins
                .setInitMainThreadSchedulerHandler(new Function<Callable<Scheduler>, Scheduler>() {
                    @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                        schedulerRef.set(scheduler);
                        return newScheduler;
                    }
                });
        Callable<Scheduler> scheduler = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                throw new AssertionError();
            }
        };
        Scheduler actual = RxAndroidPlugins.initMainThreadScheduler(scheduler);
        assertSame(newScheduler, actual);
        assertSame(scheduler, schedulerRef.get());
    }
    @Test
    public void resetClearsInitMainThreadHandler() throws Exception {
        RxAndroidPlugins
                .setInitMainThreadSchedulerHandler(new Function<Callable<Scheduler>, Scheduler>() {
                    @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                        throw new AssertionError();
                    }
                });
        final Scheduler scheduler = new EmptyScheduler();
        Callable<Scheduler> schedulerCallable = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                return scheduler;
            }
        };
        RxAndroidPlugins.reset();
        Scheduler actual = RxAndroidPlugins.initMainThreadScheduler(schedulerCallable);
        assertSame(schedulerCallable.call(), actual);
    }
    @Test
    public void defaultMainThreadSchedulerIsInitializedLazily() {
        Function<Callable<Scheduler>, Scheduler> safeOverride =
                new Function<Callable<Scheduler>, Scheduler>() {
            @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                return new EmptyScheduler();
            }
        };
        Callable<Scheduler> unsafeDefault = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                throw new AssertionError();
            }
        };
       RxAndroidPlugins.setInitMainThreadSchedulerHandler(safeOverride);
       RxAndroidPlugins.initMainThreadScheduler(unsafeDefault);
    }
    @Test
    public void overrideInitMainSchedulerThrowsWhenSchedulerCallableIsNull() {
        try {
            RxAndroidPlugins.initMainThreadScheduler(null);
            fail();
        } catch (NullPointerException e) {
            assertEquals(""scheduler == null"", e.getMessage());
        }
    }
    @Test
    public void overrideInitMainSchedulerThrowsWhenSchedulerCallableReturnsNull() {
        Callable<Scheduler> nullResultCallable = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                return null;
            }
        };
        try {
            RxAndroidPlugins.initMainThreadScheduler(nullResultCallable);
            fail();
        } catch (NullPointerException e) {
            assertEquals(""Scheduler Callable returned null"", e.getMessage());
        }
    }
    @Test
    public void getInitMainThreadSchedulerHandlerReturnsHandler() {
        Function<Callable<Scheduler>, Scheduler> handler = new Function<Callable<Scheduler>, Scheduler>() {
            @Override public Scheduler apply(Callable<Scheduler> schedulerCallable) throws Exception {
                return Schedulers.trampoline();
            }
        };
        RxAndroidPlugins.setInitMainThreadSchedulerHandler(handler);
        assertSame(handler, RxAndroidPlugins.getInitMainThreadSchedulerHandler());
    }
    @Test
    public void getMainThreadSchedulerHandlerReturnsHandler() {
        Function<Scheduler, Scheduler> handler = new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                return Schedulers.trampoline();
            }
        };
        RxAndroidPlugins.setMainThreadSchedulerHandler(handler);
        assertSame(handler, RxAndroidPlugins.getOnMainThreadSchedulerHandler());
    }
    @Test
    public void getInitMainThreadSchedulerHandlerReturnsNullIfNotSet() {
        RxAndroidPlugins.reset();
        assertNull(RxAndroidPlugins.getInitMainThreadSchedulerHandler());
    }
    @Test
    public void getMainThreadSchedulerHandlerReturnsNullIfNotSet() {
        RxAndroidPlugins.reset();
        assertNull(RxAndroidPlugins.getOnMainThreadSchedulerHandler());
    }
}",class,
"    @Before @After
    public void setUpAndTearDown() {
        RxAndroidPlugins.reset();
    }",method,
"    @Test
    public void mainThreadHandlerCalled() {
        final AtomicReference<Scheduler> schedulerRef = new AtomicReference<>();
        final Scheduler newScheduler = new EmptyScheduler();
        RxAndroidPlugins.setMainThreadSchedulerHandler(new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                schedulerRef.set(scheduler);
                return newScheduler;
            }
        });
        Scheduler scheduler = new EmptyScheduler();
        Scheduler actual = RxAndroidPlugins.onMainThreadScheduler(scheduler);
        assertSame(newScheduler, actual);
        assertSame(scheduler, schedulerRef.get());
    }",method,
"        RxAndroidPlugins.setMainThreadSchedulerHandler(new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                schedulerRef.set(scheduler);
                return newScheduler;
            }
        }",method,
"    @Test
    public void resetClearsMainThreadHandler() {
        RxAndroidPlugins.setMainThreadSchedulerHandler(new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                throw new AssertionError();
            }
        });
        RxAndroidPlugins.reset();
        Scheduler scheduler = new EmptyScheduler();
        Scheduler actual = RxAndroidPlugins.onMainThreadScheduler(scheduler);
        assertSame(scheduler, actual);
    }",method,
"        RxAndroidPlugins.setMainThreadSchedulerHandler(new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                throw new AssertionError();
            }
        }",method,
"    @Test
    public void initMainThreadHandlerCalled() {
        final AtomicReference<Callable<Scheduler>> schedulerRef = new AtomicReference<>();
        final Scheduler newScheduler = new EmptyScheduler();
        RxAndroidPlugins
                .setInitMainThreadSchedulerHandler(new Function<Callable<Scheduler>, Scheduler>() {
                    @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                        schedulerRef.set(scheduler);
                        return newScheduler;
                    }
                });
        Callable<Scheduler> scheduler = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                throw new AssertionError();
            }
        };
        Scheduler actual = RxAndroidPlugins.initMainThreadScheduler(scheduler);
        assertSame(newScheduler, actual);
        assertSame(scheduler, schedulerRef.get());
    }",method,
"        RxAndroidPlugins
                .setInitMainThreadSchedulerHandler(new Function<Callable<Scheduler>, Scheduler>() {
                    @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                        schedulerRef.set(scheduler);
                        return newScheduler;
                    }
                }",method,
"    @Test
    public void resetClearsInitMainThreadHandler() throws Exception {
        RxAndroidPlugins
                .setInitMainThreadSchedulerHandler(new Function<Callable<Scheduler>, Scheduler>() {
                    @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                        throw new AssertionError();
                    }
                });
        final Scheduler scheduler = new EmptyScheduler();
        Callable<Scheduler> schedulerCallable = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                return scheduler;
            }
        };
        RxAndroidPlugins.reset();
        Scheduler actual = RxAndroidPlugins.initMainThreadScheduler(schedulerCallable);
        assertSame(schedulerCallable.call(), actual);
    }",method,
"        RxAndroidPlugins
                .setInitMainThreadSchedulerHandler(new Function<Callable<Scheduler>, Scheduler>() {
                    @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                        throw new AssertionError();
                    }
                }",method,
"    @Test
    public void defaultMainThreadSchedulerIsInitializedLazily() {
        Function<Callable<Scheduler>, Scheduler> safeOverride =
                new Function<Callable<Scheduler>, Scheduler>() {
            @Override public Scheduler apply(Callable<Scheduler> scheduler) {
                return new EmptyScheduler();
            }
        };
        Callable<Scheduler> unsafeDefault = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                throw new AssertionError();
            }
        };
       RxAndroidPlugins.setInitMainThreadSchedulerHandler(safeOverride);
       RxAndroidPlugins.initMainThreadScheduler(unsafeDefault);
    }",method,
"    @Test
    public void overrideInitMainSchedulerThrowsWhenSchedulerCallableIsNull() {
        try {
            RxAndroidPlugins.initMainThreadScheduler(null);
            fail();
        } catch (NullPointerException e) {
            assertEquals(""scheduler == null"", e.getMessage());
        }
    }",method,
"    @Test
    public void overrideInitMainSchedulerThrowsWhenSchedulerCallableReturnsNull() {
        Callable<Scheduler> nullResultCallable = new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                return null;
            }
        };
        try {
            RxAndroidPlugins.initMainThreadScheduler(nullResultCallable);
            fail();
        } catch (NullPointerException e) {
            assertEquals(""Scheduler Callable returned null"", e.getMessage());
        }
    }",method,
"    @Test
    public void getInitMainThreadSchedulerHandlerReturnsHandler() {
        Function<Callable<Scheduler>, Scheduler> handler = new Function<Callable<Scheduler>, Scheduler>() {
            @Override public Scheduler apply(Callable<Scheduler> schedulerCallable) throws Exception {
                return Schedulers.trampoline();
            }
        };
        RxAndroidPlugins.setInitMainThreadSchedulerHandler(handler);
        assertSame(handler, RxAndroidPlugins.getInitMainThreadSchedulerHandler());
    }",method,
"    @Test
    public void getMainThreadSchedulerHandlerReturnsHandler() {
        Function<Scheduler, Scheduler> handler = new Function<Scheduler, Scheduler>() {
            @Override public Scheduler apply(Scheduler scheduler) {
                return Schedulers.trampoline();
            }
        };
        RxAndroidPlugins.setMainThreadSchedulerHandler(handler);
        assertSame(handler, RxAndroidPlugins.getOnMainThreadSchedulerHandler());
    }",method,
"    @Test
    public void getInitMainThreadSchedulerHandlerReturnsNullIfNotSet() {
        RxAndroidPlugins.reset();
        assertNull(RxAndroidPlugins.getInitMainThreadSchedulerHandler());
    }",method,
"    @Test
    public void getMainThreadSchedulerHandlerReturnsNullIfNotSet() {
        RxAndroidPlugins.reset();
        assertNull(RxAndroidPlugins.getOnMainThreadSchedulerHandler());
    }",method,
"public class PexStepTest {
  private static final Path PYTHON_PATH = Paths.get(""/usr/local/bin/python"");
  private static final PythonVersion PYTHON_VERSION = PythonVersion.of(""CPython"", ""2.6"");
  private static final ImmutableMap<String, String> PEX_ENVIRONMENT = ImmutableMap.of();
  private static final ImmutableList<String> PEX_COMMAND = ImmutableList.of();
  private static final Path TEMP_PATH = Paths.get(""/tmp/"");
  private static final Path DEST_PATH = Paths.get(""/dest"");
  private static final String ENTRY_POINT = ""entry_point.main"";
  private static final ImmutableMap<Path, Path> MODULES =
      ImmutableMap.of(Paths.get(""m""), Paths.get(""/src/m""));
  private static final ImmutableMap<Path, Path> RESOURCES =
      ImmutableMap.of(Paths.get(""r""), Paths.get(""/src/r""));
  private static final ImmutableMap<Path, Path> NATIVE_LIBRARIES =
      ImmutableMap.of(Paths.get(""n.so""), Paths.get(""/src/n.so""));
  private static final ImmutableSet<Path> PREBUILT_LIBRARIES =
      ImmutableSet.of(Paths.get(""/src/p.egg""));
  private static final ImmutableSortedSet<String> PRELOAD_LIBRARIES = ImmutableSortedSet.of();
  @Test
  public void testCommandLine() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    String command =
        Joiner.on("" "").join(step.getShellCommandInternal(TestExecutionContext.newInstance()));
    assertThat(command, startsWith(Joiner.on("" "").join(PEX_COMMAND)));
    assertThat(command, containsString(""--python "" + PYTHON_PATH));
    assertThat(command, containsString(""--python-version "" + PYTHON_VERSION));
    assertThat(command, containsString(""--entry-point "" + ENTRY_POINT));
    assertThat(command, endsWith("" "" + DEST_PATH));
  }
  @Test
  public void testCommandLineNoZipSafe() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             false);
    String command =
        Joiner.on("" "").join(step.getShellCommandInternal(TestExecutionContext.newInstance()));
    assertThat(command, containsString(""--no-zip-safe""));
  }
  @Test
  @SuppressWarnings(""unchecked"")
  public void testCommandStdin() throws InterruptedException, IOException {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    Map<String, Object> args =
        ObjectMappers.readValue(step.getStdin(TestExecutionContext.newInstance()).get(), Map.class);
    assertThat(
        (Map<String, String>) args.get(""modules""),
        hasEntry(Paths.get(""m"").toString(), Paths.get(""/src/m"").toString()));
    assertThat(
        (Map<String, String>) args.get(""resources""),
        hasEntry(Paths.get(""r"").toString(), Paths.get(""/src/r"").toString()));
    assertThat(
        (Map<String, String>) args.get(""nativeLibraries""),
        hasEntry(Paths.get(""n.so"").toString(), Paths.get(""/src/n.so"").toString()));
    assertThat(
        (List<String>) args.get(""prebuiltLibraries""), hasItem(Paths.get(""/src/p.egg"").toString()));
  }
  @Test
  public void testArgs() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            ImmutableList.<String>builder().add(""build"").add(""--some"", ""--args"").build(),
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    assertThat(
        step.getShellCommandInternal(TestExecutionContext.newInstance()),
        hasItems(""--some"", ""--args""));
  }
}",class,
"  @Test
  public void testCommandLine() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    String command =
        Joiner.on("" "").join(step.getShellCommandInternal(TestExecutionContext.newInstance()));
    assertThat(command, startsWith(Joiner.on("" "").join(PEX_COMMAND)));
    assertThat(command, containsString(""--python "" + PYTHON_PATH));
    assertThat(command, containsString(""--python-version "" + PYTHON_VERSION));
    assertThat(command, containsString(""--entry-point "" + ENTRY_POINT));
    assertThat(command, endsWith("" "" + DEST_PATH));
  }
  @Test
  public void testCommandLineNoZipSafe() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             false);
    String command =
        Joiner.on("" "").join(step.getShellCommandInternal(TestExecutionContext.newInstance()));
    assertThat(command, containsString(""--no-zip-safe""));
  }",method,
"  @Test
  public void testCommandLineNoZipSafe() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             false);
    String command =
        Joiner.on("" "").join(step.getShellCommandInternal(TestExecutionContext.newInstance()));
    assertThat(command, containsString(""--no-zip-safe""));
  }
  @Test
  @SuppressWarnings(""unchecked"")
  public void testCommandStdin() throws InterruptedException, IOException {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    Map<String, Object> args =
        ObjectMappers.readValue(step.getStdin(TestExecutionContext.newInstance()).get(), Map.class);
    assertThat(
        (Map<String, String>) args.get(""modules""),
        hasEntry(Paths.get(""m"").toString(), Paths.get(""/src/m"").toString()));
    assertThat(
        (Map<String, String>) args.get(""resources""),
        hasEntry(Paths.get(""r"").toString(), Paths.get(""/src/r"").toString()));
    assertThat(
        (Map<String, String>) args.get(""nativeLibraries""),
        hasEntry(Paths.get(""n.so"").toString(), Paths.get(""/src/n.so"").toString()));
    assertThat(
        (List<String>) args.get(""prebuiltLibraries""), hasItem(Paths.get(""/src/p.egg"").toString()));
  }
  @Test
  public void testArgs() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            ImmutableList.<String>builder().add(""build"").add(""--some"", ""--args"").build(),
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    assertThat(
        step.getShellCommandInternal(TestExecutionContext.newInstance()),
        hasItems(""--some"", ""--args""));
  }",method,
"  @Test
  @SuppressWarnings(""unchecked"")
  public void testCommandStdin() throws InterruptedException, IOException {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            PEX_COMMAND,
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    Map<String, Object> args =
        ObjectMappers.readValue(step.getStdin(TestExecutionContext.newInstance()).get(), Map.class);
    assertThat(
        (Map<String, String>) args.get(""modules""),
        hasEntry(Paths.get(""m"").toString(), Paths.get(""/src/m"").toString()));
    assertThat(
        (Map<String, String>) args.get(""resources""),
        hasEntry(Paths.get(""r"").toString(), Paths.get(""/src/r"").toString()));
    assertThat(
        (Map<String, String>) args.get(""nativeLibraries""),
        hasEntry(Paths.get(""n.so"").toString(), Paths.get(""/src/n.so"").toString()));
    assertThat(
        (List<String>) args.get(""prebuiltLibraries""), hasItem(Paths.get(""/src/p.egg"").toString()));
  }
  @Test
  public void testArgs() {
    PexStep step =
        new PexStep(
            BuildTargetFactory.newInstance(""//dummy:target""),
            new FakeProjectFilesystem(),
            PEX_ENVIRONMENT,
            ImmutableList.<String>builder().add(""build"").add(""--some"", ""--args"").build(),
            PYTHON_PATH,
            PYTHON_VERSION,
            TEMP_PATH,
            DEST_PATH,
            ENTRY_POINT,
            MODULES,
            RESOURCES,
            NATIVE_LIBRARIES,
            PREBUILT_LIBRARIES,
            PRELOAD_LIBRARIES,
             true);
    assertThat(
        step.getShellCommandInternal(TestExecutionContext.newInstance()),
        hasItems(""--some"", ""--args""));
  }",method,
"public class MavenProjectProblem implements Serializable {
  public enum ProblemType {
    SYNTAX, STRUCTURE, DEPENDENCY, PARENT, SETTINGS_OR_PROFILES
  }
  private final String myPath;
  private final String myDescription;
  private final ProblemType myType;
  public static MavenProjectProblem createStructureProblem(String path, String description) {
    return createProblem(path, description, MavenProjectProblem.ProblemType.STRUCTURE);
  }
  public static MavenProjectProblem createSyntaxProblem(String path, MavenProjectProblem.ProblemType type) {
    return createProblem(path, MessageFormat.format(""''{0}'' has syntax errors"", new File(path).getName()) , type);
  }
  public static MavenProjectProblem createProblem(String path, String description, MavenProjectProblem.ProblemType type) {
    return new MavenProjectProblem(path, description, type);
  }
  public static Collection<MavenProjectProblem> createProblemsList() {
    return createProblemsList(Collections.<MavenProjectProblem>emptySet());
  }
  public static Collection<MavenProjectProblem> createProblemsList(Collection<MavenProjectProblem> copyThis) {
    return new LinkedHashSet<MavenProjectProblem>(copyThis);
  }
  public MavenProjectProblem(String path, String description, ProblemType type) {
    myPath = path;
    myDescription = description;
    myType = type;
  }
  public String getPath() {
    return myPath;
  }
  public String getDescription() {
    return myDescription;
  }
  public ProblemType getType() {
    return myType;
  }
  @Override
  public String toString() {
    return myType + "":"" + myDescription + "":"" + myPath;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    MavenProjectProblem that = (MavenProjectProblem)o;
    if (myDescription != null ? !myDescription.equals(that.myDescription) : that.myDescription != null) return false;
    if (myType != that.myType) return false;
    if (myPath != null ? !myPath.equals(that.myPath) : that.myPath != null) return false;
    return true;
  }
  @Override
  public int hashCode() {
    int result = myPath != null ? myPath.hashCode() : 0;
    result = 31 * result + (myDescription != null ? myDescription.hashCode() : 0);
    result = 31 * result + (myType != null ? myType.hashCode() : 0);
    return result;
  }
}",class,
"  public static MavenProjectProblem createStructureProblem(String path, String description) {
    return createProblem(path, description, MavenProjectProblem.ProblemType.STRUCTURE);
  }",method,
"  public static MavenProjectProblem createSyntaxProblem(String path, MavenProjectProblem.ProblemType type) {
    return createProblem(path, MessageFormat.format(""''{0}'' has syntax errors"", new File(path).getName()) , type);
  }",method,
"  public static MavenProjectProblem createProblem(String path, String description, MavenProjectProblem.ProblemType type) {
    return new MavenProjectProblem(path, description, type);
  }",method,
"  public static Collection<MavenProjectProblem> createProblemsList() {
    return createProblemsList(Collections.<MavenProjectProblem>emptySet());
  }",method,
"  public static Collection<MavenProjectProblem> createProblemsList(Collection<MavenProjectProblem> copyThis) {
    return new LinkedHashSet<MavenProjectProblem>(copyThis);
  }",method,
"  public MavenProjectProblem(String path, String description, ProblemType type) {
    myPath = path;
    myDescription = description;
    myType = type;
  }",method,
"  public String getPath() {
    return myPath;
  }",method,
"  public String getDescription() {
    return myDescription;
  }",method,
"  public ProblemType getType() {
    return myType;
  }",method,

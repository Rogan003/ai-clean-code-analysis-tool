code_snippet,type,score
"    if (node instanceof NamedLibraryElementNode) {
      final NamedLibraryElement value = ((NamedLibraryElementNode)node).getValue();
      if (value != null) {
        final LibraryOrSdkOrderEntry entry = value.getOrderEntry();
        if (entry instanceof JdkOrderEntry) {
          final Sdk sdk = ((JdkOrderEntry)entry).getJdk();
          final SdkTypeId type = sdk.getSdkType();
          if (type instanceof PythonSdkType) {
            return sdk;
          }
        }
      }
    }",method,
"      if (value != null) {
        final LibraryOrSdkOrderEntry entry = value.getOrderEntry();
        if (entry instanceof JdkOrderEntry) {
          final Sdk sdk = ((JdkOrderEntry)entry).getJdk();
          final SdkTypeId type = sdk.getSdkType();
          if (type instanceof PythonSdkType) {
            return sdk;
          }
        }
      }",method,
"        if (entry instanceof JdkOrderEntry) {
          final Sdk sdk = ((JdkOrderEntry)entry).getJdk();
          final SdkTypeId type = sdk.getSdkType();
          if (type instanceof PythonSdkType) {
            return sdk;
          }
        }",method,
"          if (type instanceof PythonSdkType) {
            return sdk;
          }",method,
"  @NotNull
  private static Collection<AbstractTreeNode> hideSkeletons(@NotNull Collection<AbstractTreeNode> children) {
    List<AbstractTreeNode> newChildren = new ArrayList<>();
    for (AbstractTreeNode child : children) {
      if (child instanceof PsiDirectoryNode) {
        PsiDirectory directory = ((PsiDirectoryNode)child).getValue();
        if (directory == null) {
          continue;
        }
        VirtualFile dir = directory.getVirtualFile();
        if (dir.equals(PyUserSkeletonsUtil.getUserSkeletonsDirectory())) {
          continue;
        }
        if (dir.getFileSystem() instanceof JarFileSystem) {
          dir = ((JarFileSystem)dir.getFileSystem()).getLocalByEntry(dir);
        }
        if (dir == null) {
          continue;
        }
        if (PyTypeShed.INSTANCE.isInside(dir)) {
          continue;
        }
        VirtualFile dirParent = dir.getParent();
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.SKELETON_DIR_NAME)) {
          continue;
        }
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
          continue;
        }
        if (dirParent != null) {
          VirtualFile grandParent = dirParent.getParent();
          if (grandParent != null && grandParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
            continue;
          }
        }
      }
      newChildren.add(child);
    }
    return newChildren;
  }",method,
"    for (AbstractTreeNode child : children) {
      if (child instanceof PsiDirectoryNode) {
        PsiDirectory directory = ((PsiDirectoryNode)child).getValue();
        if (directory == null) {
          continue;
        }
        VirtualFile dir = directory.getVirtualFile();
        if (dir.equals(PyUserSkeletonsUtil.getUserSkeletonsDirectory())) {
          continue;
        }
        if (dir.getFileSystem() instanceof JarFileSystem) {
          dir = ((JarFileSystem)dir.getFileSystem()).getLocalByEntry(dir);
        }
        if (dir == null) {
          continue;
        }
        if (PyTypeShed.INSTANCE.isInside(dir)) {
          continue;
        }
        VirtualFile dirParent = dir.getParent();
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.SKELETON_DIR_NAME)) {
          continue;
        }
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
          continue;
        }
        if (dirParent != null) {
          VirtualFile grandParent = dirParent.getParent();
          if (grandParent != null && grandParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
            continue;
          }
        }
      }
      newChildren.add(child);
    }",method,
"      if (child instanceof PsiDirectoryNode) {
        PsiDirectory directory = ((PsiDirectoryNode)child).getValue();
        if (directory == null) {
          continue;
        }
        VirtualFile dir = directory.getVirtualFile();
        if (dir.equals(PyUserSkeletonsUtil.getUserSkeletonsDirectory())) {
          continue;
        }
        if (dir.getFileSystem() instanceof JarFileSystem) {
          dir = ((JarFileSystem)dir.getFileSystem()).getLocalByEntry(dir);
        }
        if (dir == null) {
          continue;
        }
        if (PyTypeShed.INSTANCE.isInside(dir)) {
          continue;
        }
        VirtualFile dirParent = dir.getParent();
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.SKELETON_DIR_NAME)) {
          continue;
        }
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
          continue;
        }
        if (dirParent != null) {
          VirtualFile grandParent = dirParent.getParent();
          if (grandParent != null && grandParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
            continue;
          }
        }
      }",method,
"        if (directory == null) {
          continue;
        }",method,
"        if (dir == null) {
          continue;
        }",method,
"        if (dirParent != null) {
          VirtualFile grandParent = dirParent.getParent();
          if (grandParent != null && grandParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
            continue;
          }
        }",method,
"  @Override
  public PsiElement getTopLevelElement(PsiElement element) {
    PyPsiUtils.assertValid(element);
    final Ref<PsiFile> containingFileRef = Ref.create();
    ApplicationManager.getApplication().runReadAction(() -> containingFileRef.set(element.getContainingFile()));
    final PsiFile containingFile = containingFileRef.get();
    if (!(containingFile instanceof PyFile)) {
      return null;
    }
    List<PsiElement> parents = new ArrayList<>();
    PyDocStringOwner container = PsiTreeUtil.getParentOfType(element, PyDocStringOwner.class);
    while (container != null) {
      if (container instanceof PyFile) {
        break;
      }
      parents.add(0, container);
      container = PsiTreeUtil.getParentOfType(container, PyDocStringOwner.class);
    }
    for (PsiElement parent : parents) {
      if (parent instanceof PyFunction) {
        return parent;     // we don't display any nodes under functions
      }
    }
    if (parents.size() > 0) {
      return parents.get(parents.size() - 1);
    }
    return element.getContainingFile();
  }",method,
"    while (container != null) {
      if (container instanceof PyFile) {
        break;
      }
      parents.add(0, container);
      container = PsiTreeUtil.getParentOfType(container, PyDocStringOwner.class);
    }",method,
"      if (container instanceof PyFile) {
        break;
      }",method,
"    for (PsiElement parent : parents) {
      if (parent instanceof PyFunction) {
        return parent;     // we don't display any nodes under functions
      }
    }",method,
"      if (parent instanceof PyFunction) {
        return parent;     // we don't display any nodes under functions
      }",method,
"public class GuavaPredicatesUtil {
  private static final Logger LOG = Logger.getInstance(GuavaPredicatesUtil.class);
  static final Set<String> PREDICATES_AND_OR = ContainerUtil.newHashSet(""or"", ""and"");
  static final String PREDICATES_NOT = ""not"";
  public static final Set<String> PREDICATES_METHOD_NAMES =
    ContainerUtil.newHashSet(""alwaysTrue"", ""alwaysFalse"", ""isNull"", ""notNull"", ""equalTo"", ""not"", ""or"", ""and"");
  @Nullable
  static TypeConversionDescriptorBase tryConvertIfPredicates(PsiMethod method, PsiExpression context) {
    final String name = method.getName();
    if (name.equals(""alwaysTrue"") || name.equals(""alwaysFalse"")) {
      return createConstantPredicate(name, name.contains(""True""));
    }
    else if (name.equals(""isNull"") || name.equals(""notNull"")) {
      final String operation = name.equals(""isNull"") ? ""=="" : ""!="";
      return new TypeConversionDescriptorWithLocalVariable(name, ""$x$ -> $x$"" + operation + "" null"");
    }
    else if (name.equals(""equalTo"")) {
      return new TypeConversionDescriptorWithLocalVariable(""equalTo"", ""$x$ -> java.util.Objects.equals($x$, $v$)"");
    }
    if (!isConvertablePredicatesMethod(method, (PsiMethodCallExpression)context)) return null;
    if (((PsiMethodCallExpression)context).getArgumentList().getExpressions().length == 0) {
      return createConstantPredicate(name, name.equals(""and""));
    }
    if (PREDICATES_AND_OR.contains(name) && canMigrateAndOrOr((PsiMethodCallExpression)context)) {
      return new AndOrOrConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaLambda.PREDICATE.getJavaAnalogueClassQName(), context.getType(), context));
    }
    else if (PREDICATES_NOT.equals(name)) {
      return new NotConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaLambda.PREDICATE.getJavaAnalogueClassQName(), context.getType(), context));
    }
    return null;
  }
  @NotNull
  private static TypeConversionDescriptorWithLocalVariable createConstantPredicate(String methodName, boolean value) {
    return new TypeConversionDescriptorWithLocalVariable(methodName, ""$x$ -> "" + value);
  }
  private static class TypeConversionDescriptorWithLocalVariable extends TypeConversionDescriptor {
    private final String myReplaceByStringTemplate;
    TypeConversionDescriptorWithLocalVariable(String methodName, String replaceByString) {
      super(""'Predicates*."" + methodName + ""("" + (methodName.equals(""equalTo"") ? ""$v$"" : """") + "")"", null);
      myReplaceByStringTemplate = replaceByString;
    }
    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) {
      final String chosenName = FluentIterableConversionUtil.chooseName(expression, getIntroducedVariableType(expression));
      setReplaceByString(StringUtil.replace(myReplaceByStringTemplate, ""$x$"", chosenName));
      return super.replace(expression, evaluator);
    }
    private static PsiType getIntroducedVariableType(PsiExpression expression) {
      final PsiType type = expression.getType();
      if (type instanceof PsiClassType) {
        final PsiType[] parameters = ((PsiClassType)type).getParameters();
        if (parameters.length == 1) {
          final PsiType parameter = parameters[0];
          if (parameter instanceof PsiClassType) {
            return parameter;
          }
        }
      }
      return null;
    }
  }
  public static boolean isConvertablePredicatesMethod(@NotNull PsiMethod method, PsiMethodCallExpression context) {
    if (method.getParameterList().getParametersCount() == 1) {
      final PsiParameter parameter = method.getParameterList().getParameters()[0];
      final PsiClass psiClass = PsiTypesUtil.getPsiClass(parameter.getType().getDeepComponentType());
      if (psiClass == null || CommonClassNames.JAVA_LANG_ITERABLE.equals(psiClass.getQualifiedName())) {
        return false;
      }
    }
    final PsiExpression[] expressions = context.getArgumentList().getExpressions();
    return !(expressions.length == 1 && expressions[0].getType() instanceof PsiArrayType);
  }
  private static boolean canMigrateAndOrOr(PsiMethodCallExpression expr) {
    final PsiMethod method = expr.resolveMethod();
    if (method == null) return false;
    final PsiParameterList parameters = method.getParameterList();
    if (parameters.getParametersCount() != 1) {
      return parameters.getParametersCount() != 0;
    }
    final PsiParameter parameter = parameters.getParameters()[0];
    final PsiType type = parameter.getType();
    return type instanceof PsiEllipsisType;
  }
  private static class NotConversionDescriptor extends TypeConversionDescriptorBase {
    private final PsiType myTargetType;
    public NotConversionDescriptor(PsiType targetType) {
      myTargetType = targetType;
    }
    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {
      String newExpressionString =
        GuavaConversionUtil.adjustLambdaContainingExpression(((PsiMethodCallExpression)expression).getArgumentList().getExpressions()[0], true, myTargetType, evaluator).getText() + "".negate()"";
      final PsiElement parent = expression.getParent();
      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }
      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {
        newExpressionString += ""::test"";
      }
      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());
      PsiExpression convertedExpression =
        (PsiExpression)expression.replace(elementFactory.createExpressionFromText(newExpressionString, expression));
      convertedExpression = convertedExpression.getParent() instanceof PsiMethodReferenceExpression
                            ? (PsiExpression)convertedExpression.getParent().replace(convertedExpression)
                            : convertedExpression;
      final PsiElement maybeTypeCast = convertedExpression.getParent();
      if (maybeTypeCast instanceof PsiTypeCastExpression && RedundantCastUtil.isCastRedundant((PsiTypeCastExpression)maybeTypeCast)) {
        convertedExpression = (PsiExpression)maybeTypeCast.replace(((PsiTypeCastExpression)maybeTypeCast).getOperand());
      }
      return convertedExpression;
    }
  }
  private static class AndOrOrConversionDescriptor extends TypeConversionDescriptorBase {
    private final PsiType myTargetType;
    public AndOrOrConversionDescriptor(PsiType targetType) {
      myTargetType = targetType;
    }
    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {
      final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression;
      final String methodName = methodCall.getMethodExpression().getReferenceName();
      final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();
      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());
      if (arguments.length == 1) {
        return (PsiExpression)expression.replace(GuavaConversionUtil.adjustLambdaContainingExpression(arguments[0], true, myTargetType, evaluator));
      }
      LOG.assertTrue(arguments.length != 0);
      StringBuilder replaceBy = new StringBuilder();
      for (int i = 1; i < arguments.length; i++) {
        PsiExpression argument = arguments[i];
        replaceBy.append(""."").append(methodName).append(""("").append(GuavaConversionUtil.adjustLambdaContainingExpression(argument, false, myTargetType, evaluator).getText()).append("")"");
      }
      replaceBy.insert(0, GuavaConversionUtil.adjustLambdaContainingExpression(arguments[0], true, myTargetType, evaluator).getText());
      final PsiElement parent = expression.getParent();
      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }
      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {
        replaceBy.append(""::test"");
      }
      return (PsiExpression)expression.replace(elementFactory.createExpressionFromText(replaceBy.toString(), expression));
    }
  }
  private static PsiExpression replaceTypeCast(PsiExpression expression, PsiElement parent) {
    final PsiElement parParent = parent.getParent();
    if (parParent instanceof PsiTypeCastExpression) {
      final PsiTypeElement typeElement = ((PsiTypeCastExpression)parParent).getCastType();
      if (typeElement != null) {
        final PsiType type = typeElement.getType();
        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);
        if (aClass != null && GuavaLambda.PREDICATE.getClassQName().equals(aClass.getQualifiedName())) {
          expression = (PsiExpression)parParent.replace(expression);
        }
      }
    }
    return expression;
  }
}",class,
"  private static class TypeConversionDescriptorWithLocalVariable extends TypeConversionDescriptor {
    private final String myReplaceByStringTemplate;
    TypeConversionDescriptorWithLocalVariable(String methodName, String replaceByString) {
      super(""'Predicates*."" + methodName + ""("" + (methodName.equals(""equalTo"") ? ""$v$"" : """") + "")"", null);
      myReplaceByStringTemplate = replaceByString;
    }
    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) {
      final String chosenName = FluentIterableConversionUtil.chooseName(expression, getIntroducedVariableType(expression));
      setReplaceByString(StringUtil.replace(myReplaceByStringTemplate, ""$x$"", chosenName));
      return super.replace(expression, evaluator);
    }
    private static PsiType getIntroducedVariableType(PsiExpression expression) {
      final PsiType type = expression.getType();
      if (type instanceof PsiClassType) {
        final PsiType[] parameters = ((PsiClassType)type).getParameters();
        if (parameters.length == 1) {
          final PsiType parameter = parameters[0];
          if (parameter instanceof PsiClassType) {
            return parameter;
          }
        }
      }
      return null;
    }
  }",class,
"  private static class NotConversionDescriptor extends TypeConversionDescriptorBase {
    private final PsiType myTargetType;
    public NotConversionDescriptor(PsiType targetType) {
      myTargetType = targetType;
    }
    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {
      String newExpressionString =
        GuavaConversionUtil.adjustLambdaContainingExpression(((PsiMethodCallExpression)expression).getArgumentList().getExpressions()[0], true, myTargetType, evaluator).getText() + "".negate()"";
      final PsiElement parent = expression.getParent();
      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }
      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {
        newExpressionString += ""::test"";
      }
      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());
      PsiExpression convertedExpression =
        (PsiExpression)expression.replace(elementFactory.createExpressionFromText(newExpressionString, expression));
      convertedExpression = convertedExpression.getParent() instanceof PsiMethodReferenceExpression
                            ? (PsiExpression)convertedExpression.getParent().replace(convertedExpression)
                            : convertedExpression;
      final PsiElement maybeTypeCast = convertedExpression.getParent();
      if (maybeTypeCast instanceof PsiTypeCastExpression && RedundantCastUtil.isCastRedundant((PsiTypeCastExpression)maybeTypeCast)) {
        convertedExpression = (PsiExpression)maybeTypeCast.replace(((PsiTypeCastExpression)maybeTypeCast).getOperand());
      }
      return convertedExpression;
    }
  }",class,
"  private static class AndOrOrConversionDescriptor extends TypeConversionDescriptorBase {
    private final PsiType myTargetType;
    public AndOrOrConversionDescriptor(PsiType targetType) {
      myTargetType = targetType;
    }
    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {
      final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression;
      final String methodName = methodCall.getMethodExpression().getReferenceName();
      final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();
      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());
      if (arguments.length == 1) {
        return (PsiExpression)expression.replace(GuavaConversionUtil.adjustLambdaContainingExpression(arguments[0], true, myTargetType, evaluator));
      }
      LOG.assertTrue(arguments.length != 0);
      StringBuilder replaceBy = new StringBuilder();
      for (int i = 1; i < arguments.length; i++) {
        PsiExpression argument = arguments[i];
        replaceBy.append(""."").append(methodName).append(""("").append(GuavaConversionUtil.adjustLambdaContainingExpression(argument, false, myTargetType, evaluator).getText()).append("")"");
      }
      replaceBy.insert(0, GuavaConversionUtil.adjustLambdaContainingExpression(arguments[0], true, myTargetType, evaluator).getText());
      final PsiElement parent = expression.getParent();
      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }
      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {
        replaceBy.append(""::test"");
      }
      return (PsiExpression)expression.replace(elementFactory.createExpressionFromText(replaceBy.toString(), expression));
    }
  }",class,
"  @Nullable
  static TypeConversionDescriptorBase tryConvertIfPredicates(PsiMethod method, PsiExpression context) {
    final String name = method.getName();
    if (name.equals(""alwaysTrue"") || name.equals(""alwaysFalse"")) {
      return createConstantPredicate(name, name.contains(""True""));
    }
    else if (name.equals(""isNull"") || name.equals(""notNull"")) {
      final String operation = name.equals(""isNull"") ? ""=="" : ""!="";
      return new TypeConversionDescriptorWithLocalVariable(name, ""$x$ -> $x$"" + operation + "" null"");
    }
    else if (name.equals(""equalTo"")) {
      return new TypeConversionDescriptorWithLocalVariable(""equalTo"", ""$x$ -> java.util.Objects.equals($x$, $v$)"");
    }
    if (!isConvertablePredicatesMethod(method, (PsiMethodCallExpression)context)) return null;
    if (((PsiMethodCallExpression)context).getArgumentList().getExpressions().length == 0) {
      return createConstantPredicate(name, name.equals(""and""));
    }
    if (PREDICATES_AND_OR.contains(name) && canMigrateAndOrOr((PsiMethodCallExpression)context)) {
      return new AndOrOrConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaLambda.PREDICATE.getJavaAnalogueClassQName(), context.getType(), context));
    }
    else if (PREDICATES_NOT.equals(name)) {
      return new NotConversionDescriptor(GuavaConversionUtil.addTypeParameters(GuavaLambda.PREDICATE.getJavaAnalogueClassQName(), context.getType(), context));
    }
    return null;
  }",method,
"  @NotNull
  private static TypeConversionDescriptorWithLocalVariable createConstantPredicate(String methodName, boolean value) {
    return new TypeConversionDescriptorWithLocalVariable(methodName, ""$x$ -> "" + value);
  }",method,
"    TypeConversionDescriptorWithLocalVariable(String methodName, String replaceByString) {
      super(""'Predicates*."" + methodName + ""("" + (methodName.equals(""equalTo"") ? ""$v$"" : """") + "")"", null);
      myReplaceByStringTemplate = replaceByString;
    }",method,
"    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) {
      final String chosenName = FluentIterableConversionUtil.chooseName(expression, getIntroducedVariableType(expression));
      setReplaceByString(StringUtil.replace(myReplaceByStringTemplate, ""$x$"", chosenName));
      return super.replace(expression, evaluator);
    }",method,
"    private static PsiType getIntroducedVariableType(PsiExpression expression) {
      final PsiType type = expression.getType();
      if (type instanceof PsiClassType) {
        final PsiType[] parameters = ((PsiClassType)type).getParameters();
        if (parameters.length == 1) {
          final PsiType parameter = parameters[0];
          if (parameter instanceof PsiClassType) {
            return parameter;
          }
        }
      }
      return null;
    }",method,
"      if (type instanceof PsiClassType) {
        final PsiType[] parameters = ((PsiClassType)type).getParameters();
        if (parameters.length == 1) {
          final PsiType parameter = parameters[0];
          if (parameter instanceof PsiClassType) {
            return parameter;
          }
        }
      }",method,
"        if (parameters.length == 1) {
          final PsiType parameter = parameters[0];
          if (parameter instanceof PsiClassType) {
            return parameter;
          }
        }",method,
"          if (parameter instanceof PsiClassType) {
            return parameter;
          }",method,
"  public static boolean isConvertablePredicatesMethod(@NotNull PsiMethod method, PsiMethodCallExpression context) {
    if (method.getParameterList().getParametersCount() == 1) {
      final PsiParameter parameter = method.getParameterList().getParameters()[0];
      final PsiClass psiClass = PsiTypesUtil.getPsiClass(parameter.getType().getDeepComponentType());
      if (psiClass == null || CommonClassNames.JAVA_LANG_ITERABLE.equals(psiClass.getQualifiedName())) {
        return false;
      }
    }
    final PsiExpression[] expressions = context.getArgumentList().getExpressions();
    return !(expressions.length == 1 && expressions[0].getType() instanceof PsiArrayType);
  }",method,
"  private static boolean canMigrateAndOrOr(PsiMethodCallExpression expr) {
    final PsiMethod method = expr.resolveMethod();
    if (method == null) return false;
    final PsiParameterList parameters = method.getParameterList();
    if (parameters.getParametersCount() != 1) {
      return parameters.getParametersCount() != 0;
    }
    final PsiParameter parameter = parameters.getParameters()[0];
    final PsiType type = parameter.getType();
    return type instanceof PsiEllipsisType;
  }",method,
"    public NotConversionDescriptor(PsiType targetType) {
      myTargetType = targetType;
    }",method,
"    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {
      String newExpressionString =
        GuavaConversionUtil.adjustLambdaContainingExpression(((PsiMethodCallExpression)expression).getArgumentList().getExpressions()[0], true, myTargetType, evaluator).getText() + "".negate()"";
      final PsiElement parent = expression.getParent();
      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }
      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {
        newExpressionString += ""::test"";
      }
      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());
      PsiExpression convertedExpression =
        (PsiExpression)expression.replace(elementFactory.createExpressionFromText(newExpressionString, expression));
      convertedExpression = convertedExpression.getParent() instanceof PsiMethodReferenceExpression
                            ? (PsiExpression)convertedExpression.getParent().replace(convertedExpression)
                            : convertedExpression;
      final PsiElement maybeTypeCast = convertedExpression.getParent();
      if (maybeTypeCast instanceof PsiTypeCastExpression && RedundantCastUtil.isCastRedundant((PsiTypeCastExpression)maybeTypeCast)) {
        convertedExpression = (PsiExpression)maybeTypeCast.replace(((PsiTypeCastExpression)maybeTypeCast).getOperand());
      }
      return convertedExpression;
    }",method,
"      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }",method,
"    public AndOrOrConversionDescriptor(PsiType targetType) {
      myTargetType = targetType;
    }",method,
"    @Override
    public PsiExpression replace(PsiExpression expression, @NotNull TypeEvaluator evaluator) throws IncorrectOperationException {
      final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression;
      final String methodName = methodCall.getMethodExpression().getReferenceName();
      final PsiExpression[] arguments = methodCall.getArgumentList().getExpressions();
      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(expression.getProject());
      if (arguments.length == 1) {
        return (PsiExpression)expression.replace(GuavaConversionUtil.adjustLambdaContainingExpression(arguments[0], true, myTargetType, evaluator));
      }
      LOG.assertTrue(arguments.length != 0);
      StringBuilder replaceBy = new StringBuilder();
      for (int i = 1; i < arguments.length; i++) {
        PsiExpression argument = arguments[i];
        replaceBy.append(""."").append(methodName).append(""("").append(GuavaConversionUtil.adjustLambdaContainingExpression(argument, false, myTargetType, evaluator).getText()).append("")"");
      }
      replaceBy.insert(0, GuavaConversionUtil.adjustLambdaContainingExpression(arguments[0], true, myTargetType, evaluator).getText());
      final PsiElement parent = expression.getParent();
      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }
      else if (!GuavaConversionUtil.isJavaLambda(parent, evaluator)) {
        replaceBy.append(""::test"");
      }
      return (PsiExpression)expression.replace(elementFactory.createExpressionFromText(replaceBy.toString(), expression));
    }",method,
"      if (arguments.length == 1) {
        return (PsiExpression)expression.replace(GuavaConversionUtil.adjustLambdaContainingExpression(arguments[0], true, myTargetType, evaluator));
      }",method,
"      for (int i = 1; i < arguments.length; i++) {
        PsiExpression argument = arguments[i];
        replaceBy.append(""."").append(methodName).append(""("").append(GuavaConversionUtil.adjustLambdaContainingExpression(argument, false, myTargetType, evaluator).getText()).append("")"");
      }",method,
"      if (parent instanceof PsiMethodReferenceExpression) {
        expression = replaceTypeCast(expression, parent);
      }",method,
"  private static PsiExpression replaceTypeCast(PsiExpression expression, PsiElement parent) {
    final PsiElement parParent = parent.getParent();
    if (parParent instanceof PsiTypeCastExpression) {
      final PsiTypeElement typeElement = ((PsiTypeCastExpression)parParent).getCastType();
      if (typeElement != null) {
        final PsiType type = typeElement.getType();
        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);
        if (aClass != null && GuavaLambda.PREDICATE.getClassQName().equals(aClass.getQualifiedName())) {
          expression = (PsiExpression)parParent.replace(expression);
        }
      }
    }
    return expression;
  }",method,
"    if (parParent instanceof PsiTypeCastExpression) {
      final PsiTypeElement typeElement = ((PsiTypeCastExpression)parParent).getCastType();
      if (typeElement != null) {
        final PsiType type = typeElement.getType();
        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);
        if (aClass != null && GuavaLambda.PREDICATE.getClassQName().equals(aClass.getQualifiedName())) {
          expression = (PsiExpression)parParent.replace(expression);
        }
      }
    }",method,
"      if (typeElement != null) {
        final PsiType type = typeElement.getType();
        final PsiClass aClass = PsiTypesUtil.getPsiClass(type);
        if (aClass != null && GuavaLambda.PREDICATE.getClassQName().equals(aClass.getQualifiedName())) {
          expression = (PsiExpression)parParent.replace(expression);
        }
      }",method,
"public class msg_rally_fetch_point extends MAVLinkMessage {
  public static final int MAVLINK_MSG_ID_RALLY_FETCH_POINT = 176;
  private static final long serialVersionUID = MAVLINK_MSG_ID_RALLY_FETCH_POINT;
  public msg_rally_fetch_point(int sysId, int componentId) {
    messageType = MAVLINK_MSG_ID_RALLY_FETCH_POINT;
    this.sysId = sysId;
    this.componentId = componentId;
    length = 3;
}
  public int target_system;
  public int target_component;
  public int idx;
public void decode(ByteBuffer dis) throws IOException {
  target_system = (int)dis.get()&0x00FF;
  target_component = (int)dis.get()&0x00FF;
  idx = (int)dis.get()&0x00FF;
}
public byte[] encode() throws IOException {
  byte[] buffer = new byte[8+3];
   ByteBuffer dos = ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN);
  dos.put((byte)0xFE);
  dos.put((byte)(length & 0x00FF));
  dos.put((byte)(sequence & 0x00FF));
  dos.put((byte)(sysId & 0x00FF));
  dos.put((byte)(componentId & 0x00FF));
  dos.put((byte)(messageType & 0x00FF));
  dos.put((byte)(target_system&0x00FF));
  dos.put((byte)(target_component&0x00FF));
  dos.put((byte)(idx&0x00FF));
  int crc = MAVLinkCRC.crc_calculate_encode(buffer, 3);
  crc = MAVLinkCRC.crc_accumulate((byte) IMAVLinkCRC.MAVLINK_MESSAGE_CRCS[messageType], crc);
  byte crcl = (byte) (crc & 0x00FF);
  byte crch = (byte) ((crc >> 8) & 0x00FF);
  buffer[9] = crcl;
  buffer[10] = crch;
  return buffer;
}
public String toString() {
return ""MAVLINK_MSG_ID_RALLY_FETCH_POINT : "" +   ""  target_system=""+target_system+  ""  target_component=""+target_component+  ""  idx=""+idx;}
}",class,
"  public msg_rally_fetch_point(int sysId, int componentId) {
    messageType = MAVLINK_MSG_ID_RALLY_FETCH_POINT;
    this.sysId = sysId;
    this.componentId = componentId;
    length = 3;
}",method,
"public void decode(ByteBuffer dis) throws IOException {
  target_system = (int)dis.get()&0x00FF;
  target_component = (int)dis.get()&0x00FF;
  idx = (int)dis.get()&0x00FF;
}",method,
"public byte[] encode() throws IOException {
  byte[] buffer = new byte[8+3];
   ByteBuffer dos = ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN);
  dos.put((byte)0xFE);
  dos.put((byte)(length & 0x00FF));
  dos.put((byte)(sequence & 0x00FF));
  dos.put((byte)(sysId & 0x00FF));
  dos.put((byte)(componentId & 0x00FF));
  dos.put((byte)(messageType & 0x00FF));
  dos.put((byte)(target_system&0x00FF));
  dos.put((byte)(target_component&0x00FF));
  dos.put((byte)(idx&0x00FF));
  int crc = MAVLinkCRC.crc_calculate_encode(buffer, 3);
  crc = MAVLinkCRC.crc_accumulate((byte) IMAVLinkCRC.MAVLINK_MESSAGE_CRCS[messageType], crc);
  byte crcl = (byte) (crc & 0x00FF);
  byte crch = (byte) ((crc >> 8) & 0x00FF);
  buffer[9] = crcl;
  buffer[10] = crch;
  return buffer;
}",method,
"public String toString() {
return ""MAVLINK_MSG_ID_RALLY_FETCH_POINT : "" +   ""  target_system=""+target_system+  ""  target_component=""+target_component+  ""  idx=""+idx;}",method,
"public class KeyIterator extends OneStepIteratorForward
{
    static final long serialVersionUID = -1349109910100249661L;
  private QName m_name;
  public QName getName()
  {
    return m_name;
  }
  private Vector m_keyDeclarations;
  public Vector getKeyDeclarations()
  {
    return m_keyDeclarations;
  }
  KeyIterator(QName name, Vector keyDeclarations)
  {
    super(Axis.ALL);
    m_keyDeclarations = keyDeclarations;
    // m_prefixResolver = nscontext;
    m_name = name;
  }
  public short acceptNode(int testNode)
  {
    boolean foundKey = false;
    KeyIterator ki = (KeyIterator) m_lpi;
    org.apache.xpath.XPathContext xctxt = ki.getXPathContext();
    Vector keys = ki.getKeyDeclarations();
    QName name = ki.getName();
    try
    {
      // System.out.println(""lookupKey: ""+lookupKey);
      int nDeclarations = keys.size();
      // Walk through each of the declarations made with xsl:key
      for (int i = 0; i < nDeclarations; i++)
      {
        KeyDeclaration kd = (KeyDeclaration) keys.elementAt(i);
        // Only continue if the name on this key declaration
        // matches the name on the iterator for this walker. 
        if (!kd.getName().equals(name))
          continue;
        foundKey = true;
        // xctxt.setNamespaceContext(ki.getPrefixResolver());
        // See if our node matches the given key declaration according to 
        // the match attribute on xsl:key.
        XPath matchExpr = kd.getMatch();
        double score = matchExpr.getMatchScore(xctxt, testNode);
        if (score == kd.getMatch().MATCH_SCORE_NONE)
          continue;
        return DTMIterator.FILTER_ACCEPT;
      } // end for(int i = 0; i < nDeclarations; i++)
    }
    catch (TransformerException se)
    {
      // TODO: What to do?
    }
    if (!foundKey)
      throw new RuntimeException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_NO_XSLKEY_DECLARATION,
          new Object[] { name.getLocalName()}));
    return DTMIterator.FILTER_REJECT;
  }
}",class,
"  public QName getName()
  {
    return m_name;
  }",method,
"  public Vector getKeyDeclarations()
  {
    return m_keyDeclarations;
  }",method,
"  KeyIterator(QName name, Vector keyDeclarations)
  {
    super(Axis.ALL);
    m_keyDeclarations = keyDeclarations;
    // m_prefixResolver = nscontext;
    m_name = name;
  }",method,
"  public short acceptNode(int testNode)
  {
    boolean foundKey = false;
    KeyIterator ki = (KeyIterator) m_lpi;
    org.apache.xpath.XPathContext xctxt = ki.getXPathContext();
    Vector keys = ki.getKeyDeclarations();
    QName name = ki.getName();
    try
    {
      // System.out.println(""lookupKey: ""+lookupKey);
      int nDeclarations = keys.size();
      // Walk through each of the declarations made with xsl:key
      for (int i = 0; i < nDeclarations; i++)
      {
        KeyDeclaration kd = (KeyDeclaration) keys.elementAt(i);
        // Only continue if the name on this key declaration
        // matches the name on the iterator for this walker. 
        if (!kd.getName().equals(name))
          continue;
        foundKey = true;
        // xctxt.setNamespaceContext(ki.getPrefixResolver());
        // See if our node matches the given key declaration according to 
        // the match attribute on xsl:key.
        XPath matchExpr = kd.getMatch();
        double score = matchExpr.getMatchScore(xctxt, testNode);
        if (score == kd.getMatch().MATCH_SCORE_NONE)
          continue;
        return DTMIterator.FILTER_ACCEPT;
      } // end for(int i = 0; i < nDeclarations; i++)
    }
    catch (TransformerException se)
    {
      // TODO: What to do?
    }
    if (!foundKey)
      throw new RuntimeException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_NO_XSLKEY_DECLARATION,
          new Object[] { name.getLocalName()}));
    return DTMIterator.FILTER_REJECT;
  }",method,
"      for (int i = 0; i < nDeclarations; i++)
      {
        KeyDeclaration kd = (KeyDeclaration) keys.elementAt(i);
        // Only continue if the name on this key declaration
        // matches the name on the iterator for this walker. 
        if (!kd.getName().equals(name))
          continue;
        foundKey = true;
        // xctxt.setNamespaceContext(ki.getPrefixResolver());
        // See if our node matches the given key declaration according to 
        // the match attribute on xsl:key.
        XPath matchExpr = kd.getMatch();
        double score = matchExpr.getMatchScore(xctxt, testNode);
        if (score == kd.getMatch().MATCH_SCORE_NONE)
          continue;
        return DTMIterator.FILTER_ACCEPT;
      }",method,
"    catch (TransformerException se)
    {
      // TODO: What to do?
    }",method,
"public class ViewNameMethodReturnValueHandler implements HandlerMethodReturnValueHandler {
	@Nullable
	private String[] redirectPatterns;
	public void setRedirectPatterns(@Nullable String... redirectPatterns) {
		this.redirectPatterns = redirectPatterns;
	}
	@Nullable
	public String[] getRedirectPatterns() {
		return this.redirectPatterns;
	}
	@Override
	public boolean supportsReturnType(MethodParameter returnType) {
		Class<?> paramType = returnType.getParameterType();
		return (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));
	}
	@Override
	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
		if (returnValue instanceof CharSequence) {
			String viewName = returnValue.toString();
			mavContainer.setViewName(viewName);
			if (isRedirectViewName(viewName)) {
				mavContainer.setRedirectModelScenario(true);
			}
		}
		else if (returnValue != null){
			// should not happen
			throw new UnsupportedOperationException(""Unexpected return type: "" +
					returnType.getParameterType().getName() + "" in method: "" + returnType.getMethod());
		}
	}
	protected boolean isRedirectViewName(String viewName) {
		return (PatternMatchUtils.simpleMatch(this.redirectPatterns, viewName) || viewName.startsWith(""redirect:""));
	}
}",class,
"	public void setRedirectPatterns(@Nullable String... redirectPatterns) {
		this.redirectPatterns = redirectPatterns;
	}",method,
"	@Nullable
	public String[] getRedirectPatterns() {
		return this.redirectPatterns;
	}",method,
"	@Override
	public boolean supportsReturnType(MethodParameter returnType) {
		Class<?> paramType = returnType.getParameterType();
		return (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));
	}",method,
"	@Override
	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
		if (returnValue instanceof CharSequence) {
			String viewName = returnValue.toString();
			mavContainer.setViewName(viewName);
			if (isRedirectViewName(viewName)) {
				mavContainer.setRedirectModelScenario(true);
			}
		}
		else if (returnValue != null){
			// should not happen
			throw new UnsupportedOperationException(""Unexpected return type: "" +
					returnType.getParameterType().getName() + "" in method: "" + returnType.getMethod());
		}
	}",method,
"		if (returnValue instanceof CharSequence) {
			String viewName = returnValue.toString();
			mavContainer.setViewName(viewName);
			if (isRedirectViewName(viewName)) {
				mavContainer.setRedirectModelScenario(true);
			}
		}",method,
"		else if (returnValue != null){
			// should not happen
			throw new UnsupportedOperationException(""Unexpected return type: "" +
					returnType.getParameterType().getName() + "" in method: "" + returnType.getMethod());
		}",method,
"	protected boolean isRedirectViewName(String viewName) {
		return (PatternMatchUtils.simpleMatch(this.redirectPatterns, viewName) || viewName.startsWith(""redirect:""));
	}",method,
"public class UrlClassLoaderTest {
    public static void main(String[] args) throws Exception {
        URL gson = new URL(""file:/Users/zxh/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.3.1/ecb6e1f8e4b0e84c4b886c2f14a1500caf309757/gson-2.3.1.jar"");
        URLClassLoader loader1 = new URLClassLoader(new URL[]{gson});
        URLClassLoader loader2 = new URLClassLoader(new URL[]{gson});
        Class<?> c1 = loader1.loadClass(""com.google.gson.JsonArray"");
        Class<?> c2 = loader2.loadClass(""com.google.gson.JsonArray"");
        System.out.println(c1 == c2);
//        
//        Object gson1 = c1.newInstance();
//        Method toJson = c1.getMethod(""toJson"", Object.class);
//        System.out.println(toJson.invoke(gson1, ""123""));
    }
}",class,
"public class CatchTest {
    public static void main(String[] args) {
        if (f0() != 0) {
            System.out.println(""f0() failed!"");
        }
        if (f1() != 1) {
            System.out.println(""f1() failed!"");
        }
        if (f2() != 2) {
            System.out.println(""f2() failed!"");
        }
        if (f3() != 3) {
            System.out.println(""f3() failed!"");
        }
        System.out.println(""OK!"");
    }
    private static int f0() {
        try {
            bad();
            return -1;
        } catch (Throwable t) {
            return 0;
        }
    }
    private static int f1() {
        try {
            bad();
            return -1;
        } catch (Exception e) {
            return 1;
        }
    }
    private static int f2() {
        try {
            bad();
            return -1;
        } catch (RuntimeException e) {
            return 2;
        }
    }
    private static int f3() {
        try {
            bad2();
            return -1;
        } catch (RuntimeException e) {
            return 3;
        }
    }
    private static void bad() {
        throw new RuntimeException(""BAD!"");
    }
    private static void bad2() {
        try {
            bad();
        } catch (RuntimeException e) {
            throw e;
        }
    }
}",class,
"    public static void main(String[] args) throws Exception {
        URL gson = new URL(""file:/Users/zxh/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.3.1/ecb6e1f8e4b0e84c4b886c2f14a1500caf309757/gson-2.3.1.jar"");
        URLClassLoader loader1 = new URLClassLoader(new URL[]{gson});
        URLClassLoader loader2 = new URLClassLoader(new URL[]{gson});
        Class<?> c1 = loader1.loadClass(""com.google.gson.JsonArray"");
        Class<?> c2 = loader2.loadClass(""com.google.gson.JsonArray"");
        System.out.println(c1 == c2);
//        
//        Object gson1 = c1.newInstance();
//        Method toJson = c1.getMethod(""toJson"", Object.class);
//        System.out.println(toJson.invoke(gson1, ""123""));
    }",method,
"    public static void main(String[] args) {
        if (f0() != 0) {
            System.out.println(""f0() failed!"");
        }
        if (f1() != 1) {
            System.out.println(""f1() failed!"");
        }
        if (f2() != 2) {
            System.out.println(""f2() failed!"");
        }
        if (f3() != 3) {
            System.out.println(""f3() failed!"");
        }
        System.out.println(""OK!"");
    }",method,
"    private static int f0() {
        try {
            bad();
            return -1;
        } catch (Throwable t) {
            return 0;
        }
    }",method,
"    private static int f1() {
        try {
            bad();
            return -1;
        } catch (Exception e) {
            return 1;
        }
    }",method,
"    private static int f2() {
        try {
            bad();
            return -1;
        } catch (RuntimeException e) {
            return 2;
        }
    }",method,
"    private static int f3() {
        try {
            bad2();
            return -1;
        } catch (RuntimeException e) {
            return 3;
        }
    }",method,
"    private static void bad() {
        throw new RuntimeException(""BAD!"");
    }",method,
"    private static void bad2() {
        try {
            bad();
        } catch (RuntimeException e) {
            throw e;
        }
    }",method,
"public class StorageBrowser extends ListActivity {
    private static final String TAG = ""StorageBrowser"";
    private MtpClient mClient;
    private String mDeviceName;
    private List<MtpStorageInfo> mStorageList;
    private DeviceDisconnectedReceiver mDisconnectedReceiver;
    private class StorageAdapter extends BaseAdapter {
        private final Context mContext;
        private final LayoutInflater mInflater;
        public StorageAdapter(Context c) {
            mContext = c;
            mInflater = (LayoutInflater)c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        }
        public int getCount() {
            if (mStorageList == null) {
                return 0;
            } else {
                return mStorageList.size();
            }
        }
        public Object getItem(int position) {
            return mStorageList.get(position);
        }
        public long getItemId(int position) {
            return position;
        }
        public View getView(int position, View convertView, ViewGroup parent) {
            TextView view;
            if (convertView == null) {
                view = (TextView)mInflater.inflate(
                        android.R.layout.simple_list_item_1, parent, false);
            } else {
                view = (TextView)convertView;
            }
            MtpStorageInfo info = mStorageList.get(position);
            if (info != null) {
                view.setText(info.getDescription());
            } else {
                view.setText(""???"");
            }
            return view;
        }
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mClient = ((CameraBrowserApplication)getApplication()).getMtpClient();
        mDeviceName = getIntent().getStringExtra(""device"");
        mDisconnectedReceiver = new DeviceDisconnectedReceiver(this, mDeviceName);
    }
    @Override
    protected void onResume() {
        super.onResume();
        mStorageList = mClient.getStorageList(mDeviceName);
        setListAdapter(new StorageAdapter(this));
    }
    @Override
    protected void onDestroy() {
        unregisterReceiver(mDisconnectedReceiver);
        super.onDestroy();
    }
    @Override
    protected void onListItemClick(ListView l, View v, int position, long id) {
        Intent intent = new Intent(this, ObjectBrowser.class);
        intent.putExtra(""device"", mDeviceName);
        intent.putExtra(""storage"", mStorageList.get(position).getStorageId());
        startActivity(intent);
    }
}",class,
"    private class StorageAdapter extends BaseAdapter {
        private final Context mContext;
        private final LayoutInflater mInflater;
        public StorageAdapter(Context c) {
            mContext = c;
            mInflater = (LayoutInflater)c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        }
        public int getCount() {
            if (mStorageList == null) {
                return 0;
            } else {
                return mStorageList.size();
            }
        }
        public Object getItem(int position) {
            return mStorageList.get(position);
        }
        public long getItemId(int position) {
            return position;
        }
        public View getView(int position, View convertView, ViewGroup parent) {
            TextView view;
            if (convertView == null) {
                view = (TextView)mInflater.inflate(
                        android.R.layout.simple_list_item_1, parent, false);
            } else {
                view = (TextView)convertView;
            }
            MtpStorageInfo info = mStorageList.get(position);
            if (info != null) {
                view.setText(info.getDescription());
            } else {
                view.setText(""???"");
            }
            return view;
        }
    }",class,
"        public StorageAdapter(Context c) {
            mContext = c;
            mInflater = (LayoutInflater)c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        }",method,
"        public int getCount() {
            if (mStorageList == null) {
                return 0;
            } else {
                return mStorageList.size();
            }
        }",method,
"            if (mStorageList == null) {
                return 0;
            }",method,
"        public Object getItem(int position) {
            return mStorageList.get(position);
        }",method,
"        public long getItemId(int position) {
            return position;
        }",method,
"        public View getView(int position, View convertView, ViewGroup parent) {
            TextView view;
            if (convertView == null) {
                view = (TextView)mInflater.inflate(
                        android.R.layout.simple_list_item_1, parent, false);
            } else {
                view = (TextView)convertView;
            }
            MtpStorageInfo info = mStorageList.get(position);
            if (info != null) {
                view.setText(info.getDescription());
            } else {
                view.setText(""???"");
            }
            return view;
        }",method,
"            if (convertView == null) {
                view = (TextView)mInflater.inflate(
                        android.R.layout.simple_list_item_1, parent, false);
            }",method,
"            if (info != null) {
                view.setText(info.getDescription());
            }",method,
"    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mClient = ((CameraBrowserApplication)getApplication()).getMtpClient();
        mDeviceName = getIntent().getStringExtra(""device"");
        mDisconnectedReceiver = new DeviceDisconnectedReceiver(this, mDeviceName);
    }",method,
"    @Override
    protected void onResume() {
        super.onResume();
        mStorageList = mClient.getStorageList(mDeviceName);
        setListAdapter(new StorageAdapter(this));
    }",method,
"    @Override
    protected void onDestroy() {
        unregisterReceiver(mDisconnectedReceiver);
        super.onDestroy();
    }",method,
"    @Override
    protected void onListItemClick(ListView l, View v, int position, long id) {
        Intent intent = new Intent(this, ObjectBrowser.class);
        intent.putExtra(""device"", mDeviceName);
        intent.putExtra(""storage"", mStorageList.get(position).getStorageId());
        startActivity(intent);
    }",method,
"public final class SerialDisposable implements Disposable {
    final AtomicReference<Disposable> resource;
    public SerialDisposable() {
        this.resource = new AtomicReference<Disposable>();
    }
    public SerialDisposable(@Nullable Disposable initialDisposable) {
        this.resource = new AtomicReference<Disposable>(initialDisposable);
    }
    public boolean set(@Nullable Disposable next) {
        return DisposableHelper.set(resource, next);
    }
    public boolean replace(@Nullable Disposable next) {
        return DisposableHelper.replace(resource, next);
    }
    @Nullable
    public Disposable get() {
        Disposable d = resource.get();
        if (d == DisposableHelper.DISPOSED) {
            return Disposables.disposed();
        }
        return d;
    }
    @Override
    public void dispose() {
        DisposableHelper.dispose(resource);
    }
    @Override
    public boolean isDisposed() {
        return DisposableHelper.isDisposed(resource.get());
    }
}",class,
"    public SerialDisposable() {
        this.resource = new AtomicReference<Disposable>();
    }",method,
"    public SerialDisposable(@Nullable Disposable initialDisposable) {
        this.resource = new AtomicReference<Disposable>(initialDisposable);
    }",method,
"    public boolean set(@Nullable Disposable next) {
        return DisposableHelper.set(resource, next);
    }",method,
"    public boolean replace(@Nullable Disposable next) {
        return DisposableHelper.replace(resource, next);
    }",method,
"    @Nullable
    public Disposable get() {
        Disposable d = resource.get();
        if (d == DisposableHelper.DISPOSED) {
            return Disposables.disposed();
        }
        return d;
    }",method,
"        if (d == DisposableHelper.DISPOSED) {
            return Disposables.disposed();
        }",method,
"    @Override
    public void dispose() {
        DisposableHelper.dispose(resource);
    }",method,
"    @Override
    public boolean isDisposed() {
        return DisposableHelper.isDisposed(resource.get());
    }",method,
"public class CCRefactoringElementListenerProvider implements RefactoringElementListenerProvider {
  @Nullable
  @Override
  public RefactoringElementListener getListener(PsiElement element) {
    return new CCRenameListener(element);
  }
  static class CCRenameListener extends RefactoringElementAdapter {
    private String myElementRelativePath;
    public CCRenameListener(PsiElement element) {
      if (element instanceof PsiFile) {
        PsiFile psiFile = (PsiFile)element;
        myElementRelativePath = StudyUtils.pathRelativeToTask(psiFile.getVirtualFile());
      }
    }
    @Override
    protected void elementRenamedOrMoved(@NotNull PsiElement newElement) {
      if (newElement instanceof PsiFile && myElementRelativePath != null) {
        PsiFile psiFile = (PsiFile)newElement;
        tryToRenameTaskFile(psiFile, myElementRelativePath);
      }
    }
    private static void tryToRenameTaskFile(PsiFile file, String oldName) {
      final PsiDirectory taskDir = file.getContainingDirectory();
      final Project project = file.getProject();
      Course course = StudyTaskManager.getInstance(project).getCourse();
      if (course == null) {
        return;
      }
      if (taskDir == null || !taskDir.getName().contains(EduNames.TASK)) {
        return;
      }
      PsiDirectory lessonDir = taskDir.getParent();
      if (lessonDir == null || !lessonDir.getName().contains(EduNames.LESSON)) {
        return;
      }
      Lesson lesson = course.getLesson(lessonDir.getName());
      if (lesson == null) {
        return;
      }
      Task task = lesson.getTask(taskDir.getName());
      if (task == null) {
        return;
      }
      Map<String, TaskFile> taskFiles = task.getTaskFiles();
      TaskFile taskFile = task.getTaskFile(oldName);
      if (taskFile == null) {
        return;
      }
      taskFiles.remove(oldName);
      taskFiles.put(StudyUtils.pathRelativeToTask(file.getVirtualFile()), taskFile);
    }
    @Override
    public void undoElementMovedOrRenamed(@NotNull PsiElement newElement, @NotNull String oldQualifiedName) {
    }
  }
}",class,
"  static class CCRenameListener extends RefactoringElementAdapter {
    private String myElementRelativePath;
    public CCRenameListener(PsiElement element) {
      if (element instanceof PsiFile) {
        PsiFile psiFile = (PsiFile)element;
        myElementRelativePath = StudyUtils.pathRelativeToTask(psiFile.getVirtualFile());
      }
    }
    @Override
    protected void elementRenamedOrMoved(@NotNull PsiElement newElement) {
      if (newElement instanceof PsiFile && myElementRelativePath != null) {
        PsiFile psiFile = (PsiFile)newElement;
        tryToRenameTaskFile(psiFile, myElementRelativePath);
      }
    }
    private static void tryToRenameTaskFile(PsiFile file, String oldName) {
      final PsiDirectory taskDir = file.getContainingDirectory();
      final Project project = file.getProject();
      Course course = StudyTaskManager.getInstance(project).getCourse();
      if (course == null) {
        return;
      }
      if (taskDir == null || !taskDir.getName().contains(EduNames.TASK)) {
        return;
      }
      PsiDirectory lessonDir = taskDir.getParent();
      if (lessonDir == null || !lessonDir.getName().contains(EduNames.LESSON)) {
        return;
      }
      Lesson lesson = course.getLesson(lessonDir.getName());
      if (lesson == null) {
        return;
      }
      Task task = lesson.getTask(taskDir.getName());
      if (task == null) {
        return;
      }
      Map<String, TaskFile> taskFiles = task.getTaskFiles();
      TaskFile taskFile = task.getTaskFile(oldName);
      if (taskFile == null) {
        return;
      }
      taskFiles.remove(oldName);
      taskFiles.put(StudyUtils.pathRelativeToTask(file.getVirtualFile()), taskFile);
    }
    @Override
    public void undoElementMovedOrRenamed(@NotNull PsiElement newElement, @NotNull String oldQualifiedName) {
    }
  }",class,
"  @Nullable
  @Override
  public RefactoringElementListener getListener(PsiElement element) {
    return new CCRenameListener(element);
  }",method,
"    public CCRenameListener(PsiElement element) {
      if (element instanceof PsiFile) {
        PsiFile psiFile = (PsiFile)element;
        myElementRelativePath = StudyUtils.pathRelativeToTask(psiFile.getVirtualFile());
      }
    }",method,
"      if (element instanceof PsiFile) {
        PsiFile psiFile = (PsiFile)element;
        myElementRelativePath = StudyUtils.pathRelativeToTask(psiFile.getVirtualFile());
      }",method,
"    @Override
    protected void elementRenamedOrMoved(@NotNull PsiElement newElement) {
      if (newElement instanceof PsiFile && myElementRelativePath != null) {
        PsiFile psiFile = (PsiFile)newElement;
        tryToRenameTaskFile(psiFile, myElementRelativePath);
      }
    }",method,
"      if (newElement instanceof PsiFile && myElementRelativePath != null) {
        PsiFile psiFile = (PsiFile)newElement;
        tryToRenameTaskFile(psiFile, myElementRelativePath);
      }",method,
"    private static void tryToRenameTaskFile(PsiFile file, String oldName) {
      final PsiDirectory taskDir = file.getContainingDirectory();
      final Project project = file.getProject();
      Course course = StudyTaskManager.getInstance(project).getCourse();
      if (course == null) {
        return;
      }
      if (taskDir == null || !taskDir.getName().contains(EduNames.TASK)) {
        return;
      }
      PsiDirectory lessonDir = taskDir.getParent();
      if (lessonDir == null || !lessonDir.getName().contains(EduNames.LESSON)) {
        return;
      }
      Lesson lesson = course.getLesson(lessonDir.getName());
      if (lesson == null) {
        return;
      }
      Task task = lesson.getTask(taskDir.getName());
      if (task == null) {
        return;
      }
      Map<String, TaskFile> taskFiles = task.getTaskFiles();
      TaskFile taskFile = task.getTaskFile(oldName);
      if (taskFile == null) {
        return;
      }
      taskFiles.remove(oldName);
      taskFiles.put(StudyUtils.pathRelativeToTask(file.getVirtualFile()), taskFile);
    }",method,

code_snippet,type,score
"    @Override
    public void destroy() {
        if (mHolder != null) {
            mHolder.recycle();
        }
        mSize = 0;
        referenceCount = 0;
    }",method,
"        if (mHolder != null) {
            mHolder.recycle();
        }",method,
"    @Override
    public int size() {
        return mSize;
    }",method,
"    @Override
    public void setNextPoolable(DrawingCache element) {
        mNextElement = element;
    }",method,
"    @Override
    public DrawingCache getNextPoolable() {
        return mNextElement;
    }",method,
"    @Override
    public boolean isPooled() {
        return mIsPooled;
    }",method,
"    @Override
    public void setPooled(boolean isPooled) {
        mIsPooled = isPooled;
    }",method,
"    @Override
    public synchronized boolean hasReferences() {
        return referenceCount > 0;
    }",method,
"    @Override
    public synchronized void increaseReference() {
        referenceCount++;
    }",method,
"    @Override
    public synchronized void decreaseReference() {
        referenceCount--;
    }",method,
"    @Override
    public int width() {
        return mHolder.width;
    }",method,
"    @Override
    public int height() {
        return mHolder.height;
    }",method,
"public class OldZipFileTest extends junit.framework.TestCase {
    public byte[] getAllBytesFromStream(InputStream is) throws IOException {
        ByteArrayOutputStream bs = new ByteArrayOutputStream();
        byte[] buf = new byte[512];
        int iRead;
        while ((iRead = is.read(buf, 0, buf.length)) != -1) {
            bs.write(buf, 0, iRead);
        }
        return bs.toByteArray();
    }
    public void test_size() throws IOException {
        zfile.close();
        try {
            zfile.size();
            fail(""IllegalStateException expected"");
        } catch (IllegalStateException expected) {
        }
    }
    public void test_getEntryLjava_lang_String_AndroidOnly() throws IOException {
        java.util.zip.ZipEntry zentry = zfile.getEntry(""File1.txt"");
        assertNotNull(""Could not obtain ZipEntry"", zentry);
        int r;
        InputStream in;
        zentry = zfile.getEntry(""testdir1"");
        assertNotNull(""Must be able to obtain ZipEntry: testdir1"", zentry);
        in = zfile.getInputStream(zentry);
        int data = -1;
        if (in != null) {
            data = in.read();
            in.close();
        }
        assertEquals(""Must not be able to read directory data"", -1, data);
    }
    // the file hyts_zipFile.zip in setup must be included as a resource
    private String tempFileName;
    private ZipFile zfile;
    public void test_close() throws IOException {
        // Test for method void java.util.zip.ZipFile.close()
        File fl = new File(tempFileName);
        ZipFile zf = new ZipFile(fl);
        InputStream is1 = zf.getInputStream(zf.getEntry(""File1.txt""));
        InputStream is2 = zf.getInputStream(zf.getEntry(""File2.txt""));
        is1.read();
        is2.read();
        zf.close();
        try {
            is1.read();
            fail(""IOException expected"");
        } catch (IOException ee) {
            // expected
        }
        try {
            is2.read();
            fail(""IOException expected"");
        } catch (IOException ee) {
            // expected
        }
    }
    public void test_getEntryLjava_lang_String_Ex() throws IOException {
        java.util.zip.ZipEntry zentry = zfile.getEntry(""File1.txt"");
        assertNotNull(""Could not obtain ZipEntry"", zentry);
        zfile.close();
        try {
            zfile.getEntry(""File2.txt"");
            fail(""IllegalStateException expected"");
        } catch (IllegalStateException ee) {
        }
    }
    public void test_getInputStreamLjava_util_zip_ZipEntry() throws IOException {
        // Test for method java.io.InputStream
        // java.util.zip.ZipFile.getInputStream(java.util.zip.ZipEntry)
        ZipEntry zentry = null;
        InputStream is = null;
        zentry = zfile.getEntry(""File2.txt"");
        zfile.close();
        try {
            is = zfile.getInputStream(zentry);
            fail(""IllegalStateException expected"");
        } catch (IllegalStateException ee) {
            // expected
        }
    }
    @Override
    protected void setUp() throws IOException {
        // Create a local copy of the file since some tests want to alter information.
        File tempFile = File.createTempFile(""OldZipFileTest"", ""zip"");
        tempFileName = tempFile.getAbsolutePath();
        InputStream is = Support_Resources.getStream(""hyts_ZipFile.zip"");
        FileOutputStream fos = new FileOutputStream(tempFile);
        byte[] rbuf = getAllBytesFromStream(is);
        fos.write(rbuf, 0, rbuf.length);
        is.close();
        fos.close();
        zfile = new ZipFile(tempFile);
    }
    @Override
    protected void tearDown() throws IOException {
        // Note zfile is a user-defined zip file used by other tests and
        // should not be deleted
        zfile.close();
    }
}",class,
"    public byte[] getAllBytesFromStream(InputStream is) throws IOException {
        ByteArrayOutputStream bs = new ByteArrayOutputStream();
        byte[] buf = new byte[512];
        int iRead;
        while ((iRead = is.read(buf, 0, buf.length)) != -1) {
            bs.write(buf, 0, iRead);
        }
        return bs.toByteArray();
    }",method,
"    public void test_size() throws IOException {
        zfile.close();
        try {
            zfile.size();
            fail(""IllegalStateException expected"");
        } catch (IllegalStateException expected) {
        }
    }",method,
"    public void test_getEntryLjava_lang_String_AndroidOnly() throws IOException {
        java.util.zip.ZipEntry zentry = zfile.getEntry(""File1.txt"");
        assertNotNull(""Could not obtain ZipEntry"", zentry);
        int r;
        InputStream in;
        zentry = zfile.getEntry(""testdir1"");
        assertNotNull(""Must be able to obtain ZipEntry: testdir1"", zentry);
        in = zfile.getInputStream(zentry);
        int data = -1;
        if (in != null) {
            data = in.read();
            in.close();
        }
        assertEquals(""Must not be able to read directory data"", -1, data);
    }",method,
"        if (in != null) {
            data = in.read();
            in.close();
        }",method,
"    public void test_close() throws IOException {
        // Test for method void java.util.zip.ZipFile.close()
        File fl = new File(tempFileName);
        ZipFile zf = new ZipFile(fl);
        InputStream is1 = zf.getInputStream(zf.getEntry(""File1.txt""));
        InputStream is2 = zf.getInputStream(zf.getEntry(""File2.txt""));
        is1.read();
        is2.read();
        zf.close();
        try {
            is1.read();
            fail(""IOException expected"");
        } catch (IOException ee) {
            // expected
        }
        try {
            is2.read();
            fail(""IOException expected"");
        } catch (IOException ee) {
            // expected
        }
    }",method,
"    public void test_getEntryLjava_lang_String_Ex() throws IOException {
        java.util.zip.ZipEntry zentry = zfile.getEntry(""File1.txt"");
        assertNotNull(""Could not obtain ZipEntry"", zentry);
        zfile.close();
        try {
            zfile.getEntry(""File2.txt"");
            fail(""IllegalStateException expected"");
        } catch (IllegalStateException ee) {
        }
    }",method,
"    public void test_getInputStreamLjava_util_zip_ZipEntry() throws IOException {
        // Test for method java.io.InputStream
        // java.util.zip.ZipFile.getInputStream(java.util.zip.ZipEntry)
        ZipEntry zentry = null;
        InputStream is = null;
        zentry = zfile.getEntry(""File2.txt"");
        zfile.close();
        try {
            is = zfile.getInputStream(zentry);
            fail(""IllegalStateException expected"");
        } catch (IllegalStateException ee) {
            // expected
        }
    }",method,
"    @Override
    protected void setUp() throws IOException {
        // Create a local copy of the file since some tests want to alter information.
        File tempFile = File.createTempFile(""OldZipFileTest"", ""zip"");
        tempFileName = tempFile.getAbsolutePath();
        InputStream is = Support_Resources.getStream(""hyts_ZipFile.zip"");
        FileOutputStream fos = new FileOutputStream(tempFile);
        byte[] rbuf = getAllBytesFromStream(is);
        fos.write(rbuf, 0, rbuf.length);
        is.close();
        fos.close();
        zfile = new ZipFile(tempFile);
    }",method,
"    @Override
    protected void tearDown() throws IOException {
        // Note zfile is a user-defined zip file used by other tests and
        // should not be deleted
        zfile.close();
    }",method,
"import org.springframework.boot.actuate.autoconfigure.metrics.export.PropertiesConfigAdapter;
class GangliaPropertiesConfigAdapter
		extends PropertiesConfigAdapter<GangliaProperties, GangliaConfig>
		implements GangliaConfig {
	private static final GangliaConfig DEFAULTS = (k) -> null;
	GangliaPropertiesConfigAdapter(GangliaProperties properties) {
		super(properties, DEFAULTS);
	}
	@Override
	public String get(String k) {
		return null;
	}
	@Override
	public boolean enabled() {
		return get(GangliaProperties::getEnabled, GangliaConfig::enabled);
	}
	@Override
	public Duration step() {
		return get(GangliaProperties::getStep, GangliaConfig::step);
	}
	@Override
	public TimeUnit rateUnits() {
		return get(GangliaProperties::getRateUnits, GangliaConfig::rateUnits);
	}
	@Override
	public TimeUnit durationUnits() {
		return get(GangliaProperties::getDurationUnits, GangliaConfig::durationUnits);
	}
	@Override
	public String protocolVersion() {
		return get(GangliaProperties::getProtocolVersion, GangliaConfig::protocolVersion);
	}
	@Override
	public GMetric.UDPAddressingMode addressingMode() {
		return get(GangliaProperties::getAddressingMode, GangliaConfig::addressingMode);
	}
	@Override
	public int ttl() {
		return get(GangliaProperties::getTimeToLive, GangliaConfig::ttl);
	}
	@Override
	public String host() {
		return get(GangliaProperties::getHost, GangliaConfig::host);
	}
	@Override
	public int port() {
		return get(GangliaProperties::getPort, GangliaConfig::port);
	}
}",class,
"	GangliaPropertiesConfigAdapter(GangliaProperties properties) {
		super(properties, DEFAULTS);
	}",method,
"	@Override
	public String get(String k) {
		return null;
	}",method,
"	@Override
	public boolean enabled() {
		return get(GangliaProperties::getEnabled, GangliaConfig::enabled);
	}",method,
"	@Override
	public Duration step() {
		return get(GangliaProperties::getStep, GangliaConfig::step);
	}",method,
"	@Override
	public TimeUnit rateUnits() {
		return get(GangliaProperties::getRateUnits, GangliaConfig::rateUnits);
	}",method,
"	@Override
	public TimeUnit durationUnits() {
		return get(GangliaProperties::getDurationUnits, GangliaConfig::durationUnits);
	}",method,
"	@Override
	public String protocolVersion() {
		return get(GangliaProperties::getProtocolVersion, GangliaConfig::protocolVersion);
	}",method,
"	@Override
	public GMetric.UDPAddressingMode addressingMode() {
		return get(GangliaProperties::getAddressingMode, GangliaConfig::addressingMode);
	}",method,
"	@Override
	public int ttl() {
		return get(GangliaProperties::getTimeToLive, GangliaConfig::ttl);
	}",method,
"	@Override
	public String host() {
		return get(GangliaProperties::getHost, GangliaConfig::host);
	}",method,
"	@Override
	public int port() {
		return get(GangliaProperties::getPort, GangliaConfig::port);
	}",method,
"public class MappedPageSource
        implements ConnectorPageSource
{
    private final ConnectorPageSource delegate;
    private final int[] delegateFieldIndex;
    public MappedPageSource(ConnectorPageSource delegate, List<Integer> delegateFieldIndex)
    {
        this.delegate = requireNonNull(delegate, ""delegate is null"");
        this.delegateFieldIndex = Ints.toArray(requireNonNull(delegateFieldIndex, ""delegateFieldIndex is null""));
    }
    @Override
    public long getCompletedBytes()
    {
        return delegate.getCompletedBytes();
    }
    @Override
    public long getReadTimeNanos()
    {
        return delegate.getReadTimeNanos();
    }
    @Override
    public boolean isFinished()
    {
        return delegate.isFinished();
    }
    @Override
    public Page getNextPage()
    {
        Page nextPage = delegate.getNextPage();
        if (nextPage == null) {
            return null;
        }
        Block[] blocks = Arrays.stream(delegateFieldIndex)
                .mapToObj(nextPage::getBlock)
                .toArray(Block[]::new);
        return new Page(nextPage.getPositionCount(), blocks);
    }
    @Override
    public long getSystemMemoryUsage()
    {
        return delegate.getSystemMemoryUsage();
    }
    @Override
    public void close()
            throws IOException
    {
        delegate.close();
    }
}",class,
"    public MappedPageSource(ConnectorPageSource delegate, List<Integer> delegateFieldIndex)
    {
        this.delegate = requireNonNull(delegate, ""delegate is null"");
        this.delegateFieldIndex = Ints.toArray(requireNonNull(delegateFieldIndex, ""delegateFieldIndex is null""));
    }",method,
"    @Override
    public long getCompletedBytes()
    {
        return delegate.getCompletedBytes();
    }",method,
"    @Override
    public long getReadTimeNanos()
    {
        return delegate.getReadTimeNanos();
    }",method,
"    @Override
    public boolean isFinished()
    {
        return delegate.isFinished();
    }",method,
"    @Override
    public Page getNextPage()
    {
        Page nextPage = delegate.getNextPage();
        if (nextPage == null) {
            return null;
        }
        Block[] blocks = Arrays.stream(delegateFieldIndex)
                .mapToObj(nextPage::getBlock)
                .toArray(Block[]::new);
        return new Page(nextPage.getPositionCount(), blocks);
    }",method,
"        if (nextPage == null) {
            return null;
        }",method,
"    @Override
    public long getSystemMemoryUsage()
    {
        return delegate.getSystemMemoryUsage();
    }",method,
"    @Override
    public void close()
            throws IOException
    {
        delegate.close();
    }",method,
"public class SVGCSSStyler implements SVGSyntax{
    private static final char CSS_PROPERTY_VALUE_SEPARATOR = ':';
    private static final char CSS_RULE_SEPARATOR = ';';
    private static final char SPACE = ' ';
    public static void style(Node node){
        NamedNodeMap attributes = node.getAttributes();
        if (attributes != null){
            // Has to be an Element, as it has attributes
            // According to spec.
            Element element = (Element)node;
            StringBuffer styleAttrBuffer = new StringBuffer();
            int nAttr = attributes.getLength();
            List toBeRemoved = new ArrayList();
            for(int i=0; i<nAttr; i++){
                Attr attr = (Attr)attributes.item(i);
                String attrName = attr.getName();
                if(SVGStylingAttributes.set.contains( attrName )){
                    // System.out.println(""Found new style attribute"");
                    styleAttrBuffer.append( attrName );
                    styleAttrBuffer.append(CSS_PROPERTY_VALUE_SEPARATOR);
                    styleAttrBuffer.append(attr.getValue());
                    styleAttrBuffer.append(CSS_RULE_SEPARATOR);
                    styleAttrBuffer.append(SPACE);
                    toBeRemoved.add( attrName );
                }
            }
            if(styleAttrBuffer.length() > 0){
                // There were some styling attributes
                // System.out.println(""Setting style attribute on node: "" + styleAttrBuffer.toString().trim());
                element.setAttributeNS(null,
                                       SVG_STYLE_ATTRIBUTE,
                                       styleAttrBuffer.toString().trim());
                int n = toBeRemoved.size();
                for(int i=0; i<n; i++) {
                    element.removeAttribute((String)toBeRemoved.get( i ));
                }
            }
            // else
            // System.out.println(""NO STYLE PROPERTIES"");
        }
        // Now, process child elements
        NodeList children = node.getChildNodes();
        int nChildren = children.getLength();
        for(int i=0; i<nChildren; i++){
            Node child = children.item(i);
            style(child);
        }
    }
}",class,
"    public static void style(Node node){
        NamedNodeMap attributes = node.getAttributes();
        if (attributes != null){
            // Has to be an Element, as it has attributes
            // According to spec.
            Element element = (Element)node;
            StringBuffer styleAttrBuffer = new StringBuffer();
            int nAttr = attributes.getLength();
            List toBeRemoved = new ArrayList();
            for(int i=0; i<nAttr; i++){
                Attr attr = (Attr)attributes.item(i);
                String attrName = attr.getName();
                if(SVGStylingAttributes.set.contains( attrName )){
                    // System.out.println(""Found new style attribute"");
                    styleAttrBuffer.append( attrName );
                    styleAttrBuffer.append(CSS_PROPERTY_VALUE_SEPARATOR);
                    styleAttrBuffer.append(attr.getValue());
                    styleAttrBuffer.append(CSS_RULE_SEPARATOR);
                    styleAttrBuffer.append(SPACE);
                    toBeRemoved.add( attrName );
                }
            }
            if(styleAttrBuffer.length() > 0){
                // There were some styling attributes
                // System.out.println(""Setting style attribute on node: "" + styleAttrBuffer.toString().trim());
                element.setAttributeNS(null,
                                       SVG_STYLE_ATTRIBUTE,
                                       styleAttrBuffer.toString().trim());
                int n = toBeRemoved.size();
                for(int i=0; i<n; i++) {
                    element.removeAttribute((String)toBeRemoved.get( i ));
                }
            }
            // else
            // System.out.println(""NO STYLE PROPERTIES"");
        }
        // Now, process child elements
        NodeList children = node.getChildNodes();
        int nChildren = children.getLength();
        for(int i=0; i<nChildren; i++){
            Node child = children.item(i);
            style(child);
        }
    }",method,
"        if (attributes != null){
            // Has to be an Element, as it has attributes
            // According to spec.
            Element element = (Element)node;
            StringBuffer styleAttrBuffer = new StringBuffer();
            int nAttr = attributes.getLength();
            List toBeRemoved = new ArrayList();
            for(int i=0; i<nAttr; i++){
                Attr attr = (Attr)attributes.item(i);
                String attrName = attr.getName();
                if(SVGStylingAttributes.set.contains( attrName )){
                    // System.out.println(""Found new style attribute"");
                    styleAttrBuffer.append( attrName );
                    styleAttrBuffer.append(CSS_PROPERTY_VALUE_SEPARATOR);
                    styleAttrBuffer.append(attr.getValue());
                    styleAttrBuffer.append(CSS_RULE_SEPARATOR);
                    styleAttrBuffer.append(SPACE);
                    toBeRemoved.add( attrName );
                }
            }
            if(styleAttrBuffer.length() > 0){
                // There were some styling attributes
                // System.out.println(""Setting style attribute on node: "" + styleAttrBuffer.toString().trim());
                element.setAttributeNS(null,
                                       SVG_STYLE_ATTRIBUTE,
                                       styleAttrBuffer.toString().trim());
                int n = toBeRemoved.size();
                for(int i=0; i<n; i++) {
                    element.removeAttribute((String)toBeRemoved.get( i ));
                }
            }
            // else
            // System.out.println(""NO STYLE PROPERTIES"");
        }",method,
"            for(int i=0; i<nAttr; i++){
                Attr attr = (Attr)attributes.item(i);
                String attrName = attr.getName();
                if(SVGStylingAttributes.set.contains( attrName )){
                    // System.out.println(""Found new style attribute"");
                    styleAttrBuffer.append( attrName );
                    styleAttrBuffer.append(CSS_PROPERTY_VALUE_SEPARATOR);
                    styleAttrBuffer.append(attr.getValue());
                    styleAttrBuffer.append(CSS_RULE_SEPARATOR);
                    styleAttrBuffer.append(SPACE);
                    toBeRemoved.add( attrName );
                }
            }",method,
"                for(int i=0; i<n; i++) {
                    element.removeAttribute((String)toBeRemoved.get( i ));
                }",method,
"        for(int i=0; i<nChildren; i++){
            Node child = children.item(i);
            style(child);
        }",method,
"public class TestTBaseHelper extends TestCase {
  public void testByteArrayComparison() {
    assertTrue(TBaseHelper.compareTo(new byte[]{'a','b'}, new byte[]{'a','c'}) < 0);
  }
  public void testSets() {
    Set<String> a = new HashSet<String>();
    Set<String> b = new HashSet<String>();
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    a.add(""test"");
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
    b.add(""test"");
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    b.add(""aardvark"");
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
    a.add(""test2"");
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }
  public void testNestedStructures() {
    Set<List<String>> a = new HashSet<List<String>>();
    Set<List<String>> b = new HashSet<List<String>>();
    a.add(Arrays.asList(new String[] {""a"",""b""}));
    b.add(Arrays.asList(new String[] {""a"",""b"", ""c""}));
    a.add(Arrays.asList(new String[] {""a"",""b""}));
    b.add(Arrays.asList(new String[] {""a"",""b"", ""c""}));
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
  }
  public void testMapsInSets() {
    Set<Map<String, Long>> a = new HashSet<Map<String, Long>>();
    Set<Map<String, Long>> b = new HashSet<Map<String, Long>>();
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    Map<String, Long> innerA = new HashMap<String, Long>();
    Map<String, Long> innerB = new HashMap<String, Long>();
    a.add(innerA);
    b.add(innerB);
    innerA.put(""a"", 1l);
    innerB.put(""a"", 2l);
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
  }
  public void testByteArraysInMaps() {
    Map<byte[], Long> a = new HashMap<byte[], Long>();
    Map<byte[], Long> b = new HashMap<byte[], Long>();
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    a.put(new byte[]{'a','b'}, 1000L);
    b.put(new byte[]{'a','b'}, 1000L);
    a.put(new byte[]{'a','b', 'd'}, 1000L);
    b.put(new byte[]{'a','b', 'a'}, 1000L);
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }
  public void testMapsWithNulls() {
    Map<String, String> a = new HashMap<String, String>();
    Map<String, String> b = new HashMap<String, String>();
    a.put(""a"", null);
    a.put(""b"", null);
    b.put(""a"", null);
    b.put(""b"", null);
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
  }
  public void testMapKeyComparison() {
    Map<String, String> a = new HashMap<String, String>();
    Map<String, String> b = new HashMap<String, String>();
    a.put(""a"", ""a"");
    b.put(""b"", ""a"");
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
  }
  public void testMapValueComparison() {
    Map<String, String> a = new HashMap<String, String>();
    Map<String, String> b = new HashMap<String, String>();
    a.put(""a"", ""b"");
    b.put(""a"", ""a"");
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }
  public void testByteArraysInSets() {
    Set<byte[]> a = new HashSet<byte[]>();
    Set<byte[]> b = new HashSet<byte[]>();
    if (TBaseHelper.compareTo(a, b) != 0)
      throw new RuntimeException(""Set compare failed:"" + a + "" vs. "" + b);
    a.add(new byte[]{'a','b'});
    b.add(new byte[]{'a','b'});
    a.add(new byte[]{'a','b', 'd'});
    b.add(new byte[]{'a','b', 'a'});
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }
  public void testByteBufferToByteArray() throws Exception {
    byte[] b1 = {10,9,8,7,6,5,4,3,2,1,0};
    byte[] b2 = TBaseHelper.byteBufferToByteArray(ByteBuffer.wrap(b1));
    assertEquals(""b1 and b2 should be the exact same array (identity) due to fast path"", b1, b2);
    byte[] b3 = TBaseHelper.byteBufferToByteArray(ByteBuffer.wrap(b1, 1, 3));
    assertEquals(3, b3.length);
    assertEquals(ByteBuffer.wrap(b1, 1, 3), ByteBuffer.wrap(b3));
  }
  public void testRightSize() throws Exception {
    assertNull(TBaseHelper.rightSize(null));
  }
  public void testByteBufferToString() {
    byte[] array = new byte[]{1, 2, 3};
    ByteBuffer bb = ByteBuffer.wrap(array, 1, 2);
    StringBuilder sb = new StringBuilder();
    TBaseHelper.toString(bb, sb);
    assertEquals(""02 03"", sb.toString());
    bb = ByteBuffer.wrap(array, 0, array.length);
    bb.position(1);
    bb = bb.slice();
    assertEquals(1, bb.arrayOffset());
    assertEquals(0, bb.position());
    assertEquals(2, bb.limit());
    sb = new StringBuilder();
    TBaseHelper.toString(bb, sb);
    assertEquals(""02 03"", sb.toString());
  }
  public void testCopyBinaryWithByteBuffer() throws Exception {
    byte[] bytes = new byte[]{0, 1, 2, 3, 4, 5};
    ByteBuffer b = ByteBuffer.wrap(bytes);
    ByteBuffer bCopy = TBaseHelper.copyBinary(b);
    assertEquals(b, bCopy);
    assertEquals(0, b.position());
    b = ByteBuffer.allocateDirect(6);
    b.put(bytes);
    b.position(0);
    bCopy = TBaseHelper.copyBinary(b);
    assertEquals(6, b.remaining());
    assertEquals(0, b.position());
    assertEquals(b, bCopy);
    b.mark();
    b.get();
    bCopy = TBaseHelper.copyBinary(b);
    assertEquals(ByteBuffer.wrap(bytes, 1, 5), bCopy);
    assertEquals(1, b.position());
    b.reset();
    assertEquals(0, b.position());
    assertNull(TBaseHelper.copyBinary((ByteBuffer)null));
  }
  public void testCopyBinaryWithByteArray() throws Exception {
    byte[] bytes = new byte[]{0, 1, 2, 3, 4, 5};
    byte[] copy = TBaseHelper.copyBinary(bytes);
    assertEquals(ByteBuffer.wrap(bytes), ByteBuffer.wrap(copy));
    assertNotSame(bytes, copy);
    assertNull(TBaseHelper.copyBinary((byte[])null));
  }
}",class,
"  public void testByteArrayComparison() {
    assertTrue(TBaseHelper.compareTo(new byte[]{'a','b'}, new byte[]{'a','c'}) < 0);
  }",method,
"  public void testSets() {
    Set<String> a = new HashSet<String>();
    Set<String> b = new HashSet<String>();
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    a.add(""test"");
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
    b.add(""test"");
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    b.add(""aardvark"");
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
    a.add(""test2"");
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }",method,
"  public void testNestedStructures() {
    Set<List<String>> a = new HashSet<List<String>>();
    Set<List<String>> b = new HashSet<List<String>>();
    a.add(Arrays.asList(new String[] {""a"",""b""}));
    b.add(Arrays.asList(new String[] {""a"",""b"", ""c""}));
    a.add(Arrays.asList(new String[] {""a"",""b""}));
    b.add(Arrays.asList(new String[] {""a"",""b"", ""c""}));
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
  }",method,
"  public void testMapsInSets() {
    Set<Map<String, Long>> a = new HashSet<Map<String, Long>>();
    Set<Map<String, Long>> b = new HashSet<Map<String, Long>>();
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    Map<String, Long> innerA = new HashMap<String, Long>();
    Map<String, Long> innerB = new HashMap<String, Long>();
    a.add(innerA);
    b.add(innerB);
    innerA.put(""a"", 1l);
    innerB.put(""a"", 2l);
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
  }",method,
"  public void testByteArraysInMaps() {
    Map<byte[], Long> a = new HashMap<byte[], Long>();
    Map<byte[], Long> b = new HashMap<byte[], Long>();
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
    a.put(new byte[]{'a','b'}, 1000L);
    b.put(new byte[]{'a','b'}, 1000L);
    a.put(new byte[]{'a','b', 'd'}, 1000L);
    b.put(new byte[]{'a','b', 'a'}, 1000L);
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }",method,
"  public void testMapsWithNulls() {
    Map<String, String> a = new HashMap<String, String>();
    Map<String, String> b = new HashMap<String, String>();
    a.put(""a"", null);
    a.put(""b"", null);
    b.put(""a"", null);
    b.put(""b"", null);
    assertTrue(TBaseHelper.compareTo(a, b) == 0);
  }",method,
"  public void testMapKeyComparison() {
    Map<String, String> a = new HashMap<String, String>();
    Map<String, String> b = new HashMap<String, String>();
    a.put(""a"", ""a"");
    b.put(""b"", ""a"");
    assertTrue(TBaseHelper.compareTo(a, b) < 0);
  }",method,
"  public void testMapValueComparison() {
    Map<String, String> a = new HashMap<String, String>();
    Map<String, String> b = new HashMap<String, String>();
    a.put(""a"", ""b"");
    b.put(""a"", ""a"");
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }",method,
"  public void testByteArraysInSets() {
    Set<byte[]> a = new HashSet<byte[]>();
    Set<byte[]> b = new HashSet<byte[]>();
    if (TBaseHelper.compareTo(a, b) != 0)
      throw new RuntimeException(""Set compare failed:"" + a + "" vs. "" + b);
    a.add(new byte[]{'a','b'});
    b.add(new byte[]{'a','b'});
    a.add(new byte[]{'a','b', 'd'});
    b.add(new byte[]{'a','b', 'a'});
    assertTrue(TBaseHelper.compareTo(a, b) > 0);
  }",method,
"  public void testByteBufferToByteArray() throws Exception {
    byte[] b1 = {10,9,8,7,6,5,4,3,2,1,0};
    byte[] b2 = TBaseHelper.byteBufferToByteArray(ByteBuffer.wrap(b1));
    assertEquals(""b1 and b2 should be the exact same array (identity) due to fast path"", b1, b2);
    byte[] b3 = TBaseHelper.byteBufferToByteArray(ByteBuffer.wrap(b1, 1, 3));
    assertEquals(3, b3.length);
    assertEquals(ByteBuffer.wrap(b1, 1, 3), ByteBuffer.wrap(b3));
  }",method,
"  public void testRightSize() throws Exception {
    assertNull(TBaseHelper.rightSize(null));
  }",method,
"  public void testByteBufferToString() {
    byte[] array = new byte[]{1, 2, 3};
    ByteBuffer bb = ByteBuffer.wrap(array, 1, 2);
    StringBuilder sb = new StringBuilder();
    TBaseHelper.toString(bb, sb);
    assertEquals(""02 03"", sb.toString());
    bb = ByteBuffer.wrap(array, 0, array.length);
    bb.position(1);
    bb = bb.slice();
    assertEquals(1, bb.arrayOffset());
    assertEquals(0, bb.position());
    assertEquals(2, bb.limit());
    sb = new StringBuilder();
    TBaseHelper.toString(bb, sb);
    assertEquals(""02 03"", sb.toString());
  }",method,
"  public void testCopyBinaryWithByteBuffer() throws Exception {
    byte[] bytes = new byte[]{0, 1, 2, 3, 4, 5};
    ByteBuffer b = ByteBuffer.wrap(bytes);
    ByteBuffer bCopy = TBaseHelper.copyBinary(b);
    assertEquals(b, bCopy);
    assertEquals(0, b.position());
    b = ByteBuffer.allocateDirect(6);
    b.put(bytes);
    b.position(0);
    bCopy = TBaseHelper.copyBinary(b);
    assertEquals(6, b.remaining());
    assertEquals(0, b.position());
    assertEquals(b, bCopy);
    b.mark();
    b.get();
    bCopy = TBaseHelper.copyBinary(b);
    assertEquals(ByteBuffer.wrap(bytes, 1, 5), bCopy);
    assertEquals(1, b.position());
    b.reset();
    assertEquals(0, b.position());
    assertNull(TBaseHelper.copyBinary((ByteBuffer)null));
  }",method,
"  public void testCopyBinaryWithByteArray() throws Exception {
    byte[] bytes = new byte[]{0, 1, 2, 3, 4, 5};
    byte[] copy = TBaseHelper.copyBinary(bytes);
    assertEquals(ByteBuffer.wrap(bytes), ByteBuffer.wrap(copy));
    assertNotSame(bytes, copy);
    assertNull(TBaseHelper.copyBinary((byte[])null));
  }",method,
"public class Property
        extends Node
{
    private final Identifier name;
    private final Expression value;
    public Property(Identifier name, Expression value)
    {
        this(Optional.empty(), name, value);
    }
    public Property(NodeLocation location, Identifier name, Expression value)
    {
        this(Optional.of(location), name, value);
    }
    private Property(Optional<NodeLocation> location, Identifier name, Expression value)
    {
        super(location);
        this.name = requireNonNull(name, ""name is null"");
        this.value = requireNonNull(value, ""value is null"");
    }
    public Identifier getName()
    {
        return name;
    }
    public Expression getValue()
    {
        return value;
    }
    @Override
    public <R, C> R accept(AstVisitor<R, C> visitor, C context)
    {
        return visitor.visitProperty(this, context);
    }
    @Override
    public List<? extends Node> getChildren()
    {
        return ImmutableList.of(name, value);
    }
    @Override
    public boolean equals(Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Property other = (Property) obj;
        return Objects.equals(name, other.name) &&
                Objects.equals(value, other.value);
    }
    @Override
    public int hashCode()
    {
        return Objects.hash(name, value);
    }
    @Override
    public String toString()
    {
        return toStringHelper(this)
                .add(""name"", name)
                .add(""value"", value)
                .toString();
    }
}",class,
"    public Property(Identifier name, Expression value)
    {
        this(Optional.empty(), name, value);
    }",method,
"    public Property(NodeLocation location, Identifier name, Expression value)
    {
        this(Optional.of(location), name, value);
    }",method,
"    private Property(Optional<NodeLocation> location, Identifier name, Expression value)
    {
        super(location);
        this.name = requireNonNull(name, ""name is null"");
        this.value = requireNonNull(value, ""value is null"");
    }",method,
"    public Identifier getName()
    {
        return name;
    }",method,
"    public Expression getValue()
    {
        return value;
    }",method,
"    @Override
    public <R, C> R accept(AstVisitor<R, C> visitor, C context)
    {
        return visitor.visitProperty(this, context);
    }",method,
"    @Override
    public List<? extends Node> getChildren()
    {
        return ImmutableList.of(name, value);
    }",method,
"    @Override
    public boolean equals(Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Property other = (Property) obj;
        return Objects.equals(name, other.name) &&
                Objects.equals(value, other.value);
    }",method,
"        if (this == obj) {
            return true;
        }",method,
"    @Override
    public int hashCode()
    {
        return Objects.hash(name, value);
    }",method,
"    @Override
    public String toString()
    {
        return toStringHelper(this)
                .add(""name"", name)
                .add(""value"", value)
                .toString();
    }",method,
"public class GwtBinaryDescription implements Description<GwtBinaryDescriptionArg> {
  private static final Style DEFAULT_STYLE = Style.OBF;
  private static final Integer DEFAULT_NUM_LOCAL_WORKERS = Integer.valueOf(2);
  private static final Boolean DEFAULT_DRAFT_COMPILE = Boolean.FALSE;
  private static final Boolean DEFAULT_STRICT = Boolean.FALSE;
  private static final Integer DEFAULT_OPTIMIZE = Integer.valueOf(9);
  private final JavaOptions javaOptions;
  public GwtBinaryDescription(JavaOptions javaOptions) {
    this.javaOptions = javaOptions;
  }
  @Override
  public Class<GwtBinaryDescriptionArg> getConstructorArgType() {
    return GwtBinaryDescriptionArg.class;
  }
  @Override
  public BuildRule createBuildRule(
      TargetGraph targetGraph,
      BuildTarget buildTarget,
      final ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      final BuildRuleResolver resolver,
      CellPathResolver cellRoots,
      GwtBinaryDescriptionArg args) {
    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(resolver);
    final ImmutableSortedSet.Builder<BuildRule> extraDeps = ImmutableSortedSet.naturalOrder();
    // Find all of the reachable JavaLibrary rules and grab their associated GwtModules.
    final ImmutableSortedSet.Builder<SourcePath> gwtModuleJarsBuilder =
        ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet<BuildRule> moduleDependencies = resolver.getAllRules(args.getModuleDeps());
    new AbstractBreadthFirstTraversal<BuildRule>(moduleDependencies) {
      @Override
      public Iterable<BuildRule> visit(BuildRule rule) {
        if (!(rule instanceof JavaLibrary)) {
          return ImmutableSet.of();
        }
        // If the java library doesn't generate any output, it doesn't contribute a GwtModule
        JavaLibrary javaLibrary = (JavaLibrary) rule;
        if (javaLibrary.getSourcePathToOutput() == null) {
          return rule.getBuildDeps();
        }
        Optional<BuildRule> gwtModule;
        if (javaLibrary.getSourcePathToOutput() != null) {
          gwtModule =
              Optional.of(
                  resolver.computeIfAbsent(
                      BuildTarget.of(
                          javaLibrary.getBuildTarget().checkUnflavored(),
                          ImmutableSet.of(JavaLibrary.GWT_MODULE_FLAVOR)),
                      gwtModuleTarget -> {
                        ImmutableSortedSet<SourcePath> filesForGwtModule =
                            ImmutableSortedSet.<SourcePath>naturalOrder()
                                .addAll(javaLibrary.getSources())
                                .addAll(javaLibrary.getResources())
                                .build();
                        ImmutableSortedSet<BuildRule> deps =
                            ImmutableSortedSet.copyOf(
                                ruleFinder.filterBuildRuleInputs(filesForGwtModule));
                        return new GwtModule(
                            gwtModuleTarget,
                            projectFilesystem,
                            params.withDeclaredDeps(deps).withoutExtraDeps(),
                            ruleFinder,
                            filesForGwtModule);
                      }));
        } else {
          gwtModule = Optional.empty();
        }
        // Note that gwtModule could be absent if javaLibrary is a rule with no srcs of its own,
        // but a rule that exists only as a collection of deps.
        if (gwtModule.isPresent()) {
          extraDeps.add(gwtModule.get());
          gwtModuleJarsBuilder.add(
              Preconditions.checkNotNull(gwtModule.get().getSourcePathToOutput()));
        }
        // Traverse all of the deps of this rule.
        return rule.getBuildDeps();
      }
    }.start();
    return new GwtBinary(
        buildTarget,
        projectFilesystem,
        params.withExtraDeps(extraDeps.build()),
        args.getModules(),
        javaOptions.getJavaRuntimeLauncher(),
        args.getVmArgs(),
        args.getStyle().orElse(DEFAULT_STYLE),
        args.getDraftCompile().orElse(DEFAULT_DRAFT_COMPILE),
        args.getOptimize().orElse(DEFAULT_OPTIMIZE),
        args.getLocalWorkers().orElse(DEFAULT_NUM_LOCAL_WORKERS),
        args.getStrict().orElse(DEFAULT_STRICT),
        args.getExperimentalArgs(),
        gwtModuleJarsBuilder.build());
  }
  @BuckStyleImmutable
  @Value.Immutable
  interface AbstractGwtBinaryDescriptionArg extends CommonDescriptionArg, HasDeclaredDeps {
    @Value.NaturalOrder
    ImmutableSortedSet<String> getModules();
    @Value.NaturalOrder
    ImmutableSortedSet<BuildTarget> getModuleDeps();
    ImmutableList<String> getVmArgs();
    Optional<Style> getStyle();
    Optional<Boolean> getDraftCompile();
    Optional<Integer> getOptimize();
    Optional<Integer> getLocalWorkers();
    Optional<Boolean> getStrict();
    ImmutableList<String> getExperimentalArgs();
  }
}",class,
"  public GwtBinaryDescription(JavaOptions javaOptions) {
    this.javaOptions = javaOptions;
  }",method,
"  @Override
  public Class<GwtBinaryDescriptionArg> getConstructorArgType() {
    return GwtBinaryDescriptionArg.class;
  }",method,
"  @Override
  public BuildRule createBuildRule(
      TargetGraph targetGraph,
      BuildTarget buildTarget,
      final ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      final BuildRuleResolver resolver,
      CellPathResolver cellRoots,
      GwtBinaryDescriptionArg args) {
    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(resolver);
    final ImmutableSortedSet.Builder<BuildRule> extraDeps = ImmutableSortedSet.naturalOrder();
    // Find all of the reachable JavaLibrary rules and grab their associated GwtModules.
    final ImmutableSortedSet.Builder<SourcePath> gwtModuleJarsBuilder =
        ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet<BuildRule> moduleDependencies = resolver.getAllRules(args.getModuleDeps());
    new AbstractBreadthFirstTraversal<BuildRule>(moduleDependencies) {
      @Override
      public Iterable<BuildRule> visit(BuildRule rule) {
        if (!(rule instanceof JavaLibrary)) {
          return ImmutableSet.of();
        }
        // If the java library doesn't generate any output, it doesn't contribute a GwtModule
        JavaLibrary javaLibrary = (JavaLibrary) rule;
        if (javaLibrary.getSourcePathToOutput() == null) {
          return rule.getBuildDeps();
        }
        Optional<BuildRule> gwtModule;
        if (javaLibrary.getSourcePathToOutput() != null) {
          gwtModule =
              Optional.of(
                  resolver.computeIfAbsent(
                      BuildTarget.of(
                          javaLibrary.getBuildTarget().checkUnflavored(),
                          ImmutableSet.of(JavaLibrary.GWT_MODULE_FLAVOR)),
                      gwtModuleTarget -> {
                        ImmutableSortedSet<SourcePath> filesForGwtModule =
                            ImmutableSortedSet.<SourcePath>naturalOrder()
                                .addAll(javaLibrary.getSources())
                                .addAll(javaLibrary.getResources())
                                .build();
                        ImmutableSortedSet<BuildRule> deps =
                            ImmutableSortedSet.copyOf(
                                ruleFinder.filterBuildRuleInputs(filesForGwtModule));
                        return new GwtModule(
                            gwtModuleTarget,
                            projectFilesystem,
                            params.withDeclaredDeps(deps).withoutExtraDeps(),
                            ruleFinder,
                            filesForGwtModule);
                      }));
        } else {
          gwtModule = Optional.empty();
        }
        // Note that gwtModule could be absent if javaLibrary is a rule with no srcs of its own,
        // but a rule that exists only as a collection of deps.
        if (gwtModule.isPresent()) {
          extraDeps.add(gwtModule.get());
          gwtModuleJarsBuilder.add(
              Preconditions.checkNotNull(gwtModule.get().getSourcePathToOutput()));
        }
        // Traverse all of the deps of this rule.
        return rule.getBuildDeps();
      }
    }.start();
    return new GwtBinary(
        buildTarget,
        projectFilesystem,
        params.withExtraDeps(extraDeps.build()),
        args.getModules(),
        javaOptions.getJavaRuntimeLauncher(),
        args.getVmArgs(),
        args.getStyle().orElse(DEFAULT_STYLE),
        args.getDraftCompile().orElse(DEFAULT_DRAFT_COMPILE),
        args.getOptimize().orElse(DEFAULT_OPTIMIZE),
        args.getLocalWorkers().orElse(DEFAULT_NUM_LOCAL_WORKERS),
        args.getStrict().orElse(DEFAULT_STRICT),
        args.getExperimentalArgs(),
        gwtModuleJarsBuilder.build());
  }",method,
"      @Override
      public Iterable<BuildRule> visit(BuildRule rule) {
        if (!(rule instanceof JavaLibrary)) {
          return ImmutableSet.of();
        }
        // If the java library doesn't generate any output, it doesn't contribute a GwtModule
        JavaLibrary javaLibrary = (JavaLibrary) rule;
        if (javaLibrary.getSourcePathToOutput() == null) {
          return rule.getBuildDeps();
        }
        Optional<BuildRule> gwtModule;
        if (javaLibrary.getSourcePathToOutput() != null) {
          gwtModule =
              Optional.of(
                  resolver.computeIfAbsent(
                      BuildTarget.of(
                          javaLibrary.getBuildTarget().checkUnflavored(),
                          ImmutableSet.of(JavaLibrary.GWT_MODULE_FLAVOR)),
                      gwtModuleTarget -> {
                        ImmutableSortedSet<SourcePath> filesForGwtModule =
                            ImmutableSortedSet.<SourcePath>naturalOrder()
                                .addAll(javaLibrary.getSources())
                                .addAll(javaLibrary.getResources())
                                .build();
                        ImmutableSortedSet<BuildRule> deps =
                            ImmutableSortedSet.copyOf(
                                ruleFinder.filterBuildRuleInputs(filesForGwtModule));
                        return new GwtModule(
                            gwtModuleTarget,
                            projectFilesystem,
                            params.withDeclaredDeps(deps).withoutExtraDeps(),
                            ruleFinder,
                            filesForGwtModule);
                      }));
        } else {
          gwtModule = Optional.empty();
        }
        // Note that gwtModule could be absent if javaLibrary is a rule with no srcs of its own,
        // but a rule that exists only as a collection of deps.
        if (gwtModule.isPresent()) {
          extraDeps.add(gwtModule.get());
          gwtModuleJarsBuilder.add(
              Preconditions.checkNotNull(gwtModule.get().getSourcePathToOutput()));
        }
        // Traverse all of the deps of this rule.
        return rule.getBuildDeps();
      }",method,
"public class WebSocketAnnotationMethodMessageHandler extends SimpAnnotationMethodMessageHandler {
	public WebSocketAnnotationMethodMessageHandler(SubscribableChannel clientInChannel,
			MessageChannel clientOutChannel, SimpMessageSendingOperations brokerTemplate) {
		super(clientInChannel, clientOutChannel, brokerTemplate);
	}
	@Override
	public void afterPropertiesSet() {
		initControllerAdviceCache();
		super.afterPropertiesSet();
	}
	private void initControllerAdviceCache() {
		ApplicationContext context = getApplicationContext();
		if (context == null) {
			return;
		}
		if (logger.isDebugEnabled()) {
			logger.debug(""Looking for @MessageExceptionHandler mappings: "" + context);
		}
		List<ControllerAdviceBean> beans = ControllerAdviceBean.findAnnotatedBeans(context);
		AnnotationAwareOrderComparator.sort(beans);
		initMessagingAdviceCache(MessagingControllerAdviceBean.createFromList(beans));
	}
	private void initMessagingAdviceCache(@Nullable List<MessagingAdviceBean> beans) {
		if (beans == null) {
			return;
		}
		for (MessagingAdviceBean bean : beans) {
			Class<?> type = bean.getBeanType();
			if (type != null) {
				AnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);
				if (resolver.hasExceptionMappings()) {
					registerExceptionHandlerAdvice(bean, resolver);
					logger.info(""Detected @MessageExceptionHandler methods in "" + bean);
				}
			}
		}
	}
	private static class MessagingControllerAdviceBean implements MessagingAdviceBean {
		private final ControllerAdviceBean adviceBean;
		private MessagingControllerAdviceBean(ControllerAdviceBean adviceBean) {
			this.adviceBean = adviceBean;
		}
		public static List<MessagingAdviceBean> createFromList(List<ControllerAdviceBean> beans) {
			List<MessagingAdviceBean> result = new ArrayList<>(beans.size());
			for (ControllerAdviceBean bean : beans) {
				result.add(new MessagingControllerAdviceBean(bean));
			}
			return result;
		}
		@Override
		@Nullable
		public Class<?> getBeanType() {
			return this.adviceBean.getBeanType();
		}
		@Override
		public Object resolveBean() {
			return this.adviceBean.resolveBean();
		}
		@Override
		public boolean isApplicableToBeanType(Class<?> beanType) {
			return this.adviceBean.isApplicableToBeanType(beanType);
		}
		@Override
		public int getOrder() {
			return this.adviceBean.getOrder();
		}
	}
}",class,
"	private static class MessagingControllerAdviceBean implements MessagingAdviceBean {
		private final ControllerAdviceBean adviceBean;
		private MessagingControllerAdviceBean(ControllerAdviceBean adviceBean) {
			this.adviceBean = adviceBean;
		}
		public static List<MessagingAdviceBean> createFromList(List<ControllerAdviceBean> beans) {
			List<MessagingAdviceBean> result = new ArrayList<>(beans.size());
			for (ControllerAdviceBean bean : beans) {
				result.add(new MessagingControllerAdviceBean(bean));
			}
			return result;
		}
		@Override
		@Nullable
		public Class<?> getBeanType() {
			return this.adviceBean.getBeanType();
		}
		@Override
		public Object resolveBean() {
			return this.adviceBean.resolveBean();
		}
		@Override
		public boolean isApplicableToBeanType(Class<?> beanType) {
			return this.adviceBean.isApplicableToBeanType(beanType);
		}
		@Override
		public int getOrder() {
			return this.adviceBean.getOrder();
		}
	}",class,
"	public WebSocketAnnotationMethodMessageHandler(SubscribableChannel clientInChannel,
			MessageChannel clientOutChannel, SimpMessageSendingOperations brokerTemplate) {
		super(clientInChannel, clientOutChannel, brokerTemplate);
	}",method,
"	@Override
	public void afterPropertiesSet() {
		initControllerAdviceCache();
		super.afterPropertiesSet();
	}",method,
"	private void initControllerAdviceCache() {
		ApplicationContext context = getApplicationContext();
		if (context == null) {
			return;
		}
		if (logger.isDebugEnabled()) {
			logger.debug(""Looking for @MessageExceptionHandler mappings: "" + context);
		}
		List<ControllerAdviceBean> beans = ControllerAdviceBean.findAnnotatedBeans(context);
		AnnotationAwareOrderComparator.sort(beans);
		initMessagingAdviceCache(MessagingControllerAdviceBean.createFromList(beans));
	}",method,
"		if (context == null) {
			return;
		}",method,
"	private void initMessagingAdviceCache(@Nullable List<MessagingAdviceBean> beans) {
		if (beans == null) {
			return;
		}
		for (MessagingAdviceBean bean : beans) {
			Class<?> type = bean.getBeanType();
			if (type != null) {
				AnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);
				if (resolver.hasExceptionMappings()) {
					registerExceptionHandlerAdvice(bean, resolver);
					logger.info(""Detected @MessageExceptionHandler methods in "" + bean);
				}
			}
		}
	}",method,
"		if (beans == null) {
			return;
		}",method,
"		for (MessagingAdviceBean bean : beans) {
			Class<?> type = bean.getBeanType();
			if (type != null) {
				AnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);
				if (resolver.hasExceptionMappings()) {
					registerExceptionHandlerAdvice(bean, resolver);
					logger.info(""Detected @MessageExceptionHandler methods in "" + bean);
				}
			}
		}",method,
"			if (type != null) {
				AnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);
				if (resolver.hasExceptionMappings()) {
					registerExceptionHandlerAdvice(bean, resolver);
					logger.info(""Detected @MessageExceptionHandler methods in "" + bean);
				}
			}",method,
"		private MessagingControllerAdviceBean(ControllerAdviceBean adviceBean) {
			this.adviceBean = adviceBean;
		}",method,
"		public static List<MessagingAdviceBean> createFromList(List<ControllerAdviceBean> beans) {
			List<MessagingAdviceBean> result = new ArrayList<>(beans.size());
			for (ControllerAdviceBean bean : beans) {
				result.add(new MessagingControllerAdviceBean(bean));
			}
			return result;
		}",method,
"			for (ControllerAdviceBean bean : beans) {
				result.add(new MessagingControllerAdviceBean(bean));
			}",method,
"		@Override
		@Nullable
		public Class<?> getBeanType() {
			return this.adviceBean.getBeanType();
		}",method,
"		@Override
		public Object resolveBean() {
			return this.adviceBean.resolveBean();
		}",method,
"		@Override
		public boolean isApplicableToBeanType(Class<?> beanType) {
			return this.adviceBean.isApplicableToBeanType(beanType);
		}",method,
"		@Override
		public int getOrder() {
			return this.adviceBean.getOrder();
		}",method,
"public class SerializeWriterTest_BrowserSecure_5_script_model extends TestCase {
    public void test_0() throws Exception {
        Model object = new Model();
        object.value = ""<script>alert(1);</script>"";
        String text = JSON.toJSONString(object, SerializerFeature.BrowserSecure);
//        assertEquals(""{\""value\"":\""&lt;script&gt;alert(1);&lt;\\/script&gt;\""}"", text);
        assertEquals(""{\""value\"":\""\\u003Cscript\\u003Ealert\\u00281\\u0029;\\u003C/script\\u003E\""}"", text);
        Model object1 = JSON.parseObject(text, Model.class);
        assertEquals(object.value, object1.value);
    }
    public void test_1() throws Exception {
        Model object = new Model();
        object.value = ""<"";
        String text = JSON.toJSONString(object, SerializerFeature.BrowserSecure);
//        assertEquals(""{\""value\"":\""&lt;script&gt;alert(1);&lt;\\/script&gt;\""}"", text);
        assertEquals(""{\""value\"":\""\\u003C\""}"", text);
        Model object1 = JSON.parseObject(text, Model.class);
        assertEquals(object.value, object1.value);
    }
    public void test_2() throws Exception {
        Model object = new Model();
        object.value = ""<script>"";
        String text = JSON.toJSONString(object, SerializerFeature.BrowserSecure);
//        assertEquals(""{\""value\"":\""&lt;script&gt;alert(1);&lt;\\/script&gt;\""}"", text);
        assertEquals(""{\""value\"":\""\\u003Cscript\\u003E\""}"", text);
        Model object1 = JSON.parseObject(text, Model.class);
        assertEquals(object.value, object1.value);
    }
//
    public void test_3() throws Exception {
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < 500; i++) {
            buf.append(""<script>"");
        }
        StringBuilder buf1 = new StringBuilder();
        buf1.append(""{\""value\"":\"""");
        for (int i = 0; i < 500; i++) {
            buf1.append(""\\u003Cscript\\u003E"");
        }
        buf1.append(""\""}"");
        Model object = new Model();
        object.value = buf.toString();
        StringWriter out = new StringWriter();
        JSONWriter writer = new JSONWriter(out);
        writer.config(SerializerFeature.BrowserSecure, true);
        writer.writeObject(object);
        writer.flush();
        assertEquals(buf1.toString(), out.toString());
    }
//
    public void test_4() throws Exception {
        String text = JSON.toJSONString(new Model(""(""), SerializerFeature.BrowserSecure);
        assertEquals(""{\""value\"":\""\\u0028\""}"", text);
    }
    public void test_5() throws Exception {
        String text = JSON.toJSONString(new Model("")""), SerializerFeature.BrowserSecure);
        assertEquals(""{\""value\"":\""\\u0029\""}"", text);
    }
    public static class Model {
        public String value;
        public Model() {
        }
        public Model(String value) {
            this.value = value;
        }
    }
}",class,
"    public static class Model {
        public String value;
        public Model() {
        }
        public Model(String value) {
            this.value = value;
        }
    }",class,
"    public void test_0() throws Exception {
        Model object = new Model();
        object.value = ""<script>alert(1);</script>"";
        String text = JSON.toJSONString(object, SerializerFeature.BrowserSecure);
//        assertEquals(""{\""value\"":\""&lt;script&gt;alert(1);&lt;\\/script&gt;\""}"", text);
        assertEquals(""{\""value\"":\""\\u003Cscript\\u003Ealert\\u00281\\u0029;\\u003C/script\\u003E\""}"", text);
        Model object1 = JSON.parseObject(text, Model.class);
        assertEquals(object.value, object1.value);
    }",method,

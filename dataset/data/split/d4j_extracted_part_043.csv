code_snippet,type,score
"    public int getIndex() {
        return index;
    }",method,
"    public void setIndex(int index) {
        this.index = index;
    }",method,
"    public double getDistance() {
        return distance;
    }",method,
"    public void setDistance(double distance) {
        this.distance = distance;
    }",method,
"    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        HeapItem heapItem = (HeapItem) o;
        if (index != heapItem.index)
            return false;
        return Double.compare(heapItem.distance, distance) == 0;
    }",method,
"    @Override
    public int hashCode() {
        int result;
        long temp;
        result = index;
        temp = Double.doubleToLongBits(distance);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        return result;
    }",method,
"    @Override
    public int compareTo(HeapItem o) {
        return distance < o.distance ? 1 : 0;
    }",method,
"public class JDBCPrepareStatementWithNonConstantStringInspection extends BaseInspection {
  @SuppressWarnings(""PublicField"")
  public boolean considerStaticFinalConstant = false;
  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""jdbc.prepare.statement.with.non.constant.string.display.name"");
  }
  @Override
  @NotNull
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""jdbc.prepare.statement.with.non.constant.string.problem.descriptor"");
  }
  @Nullable
  @Override
  public JComponent createOptionsPanel() {
    return new SingleCheckboxOptionsPanel(InspectionGadgetsBundle.message(""consider.static.final.fields.constant.option""),
                                          this, ""considerStaticFinalConstant"");
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new RuntimeExecVisitor();
  }
  private class RuntimeExecVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
      super.visitMethodCallExpression(expression);
      if (!MethodCallUtils.callWithNonConstantString(expression, considerStaticFinalConstant, ""java.sql.Connection"",
                                                     ""prepareStatement"", ""prepareCall"")) {
        return;
      }
      registerMethodCallError(expression);
    }
  }
}",class,
"  private class RuntimeExecVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
      super.visitMethodCallExpression(expression);
      if (!MethodCallUtils.callWithNonConstantString(expression, considerStaticFinalConstant, ""java.sql.Connection"",
                                                     ""prepareStatement"", ""prepareCall"")) {
        return;
      }
      registerMethodCallError(expression);
    }
  }",class,
"  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""jdbc.prepare.statement.with.non.constant.string.display.name"");
  }",method,
"  @Override
  @NotNull
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""jdbc.prepare.statement.with.non.constant.string.problem.descriptor"");
  }",method,
"  @Nullable
  @Override
  public JComponent createOptionsPanel() {
    return new SingleCheckboxOptionsPanel(InspectionGadgetsBundle.message(""consider.static.final.fields.constant.option""),
                                          this, ""considerStaticFinalConstant"");
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new RuntimeExecVisitor();
  }",method,
"    @Override
    public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
      super.visitMethodCallExpression(expression);
      if (!MethodCallUtils.callWithNonConstantString(expression, considerStaticFinalConstant, ""java.sql.Connection"",
                                                     ""prepareStatement"", ""prepareCall"")) {
        return;
      }
      registerMethodCallError(expression);
    }",method,
"public abstract class ProxyHook extends Hook implements InvocationHandler {
    protected Object mOldObj;
    public ProxyHook(Context hostContext) {
        super(hostContext);
    }
    public void setOldObj(Object oldObj) {
        this.mOldObj = oldObj;
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if (!isEnable()) {
                return method.invoke(mOldObj, args);
            }
            HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);
            if (hookedMethodHandler != null) {
                return hookedMethodHandler.doHookInner(mOldObj, method, args);
            }
            return method.invoke(mOldObj, args);
        } catch (InvocationTargetException e) {
            Throwable cause = e.getTargetException();
            if (cause != null && MyProxy.isMethodDeclaredThrowable(method, cause)) {
                throw cause;
            } else if (cause != null) {
                RuntimeException runtimeException = !TextUtils.isEmpty(cause.getMessage()) ? new RuntimeException(cause.getMessage()) : new RuntimeException();
                runtimeException.initCause(cause);
                throw runtimeException;
            } else {
                RuntimeException runtimeException = !TextUtils.isEmpty(e.getMessage()) ? new RuntimeException(e.getMessage()) : new RuntimeException();
                runtimeException.initCause(e);
                throw runtimeException;
            }
        } catch (IllegalArgumentException e) {
            try {
                StringBuilder sb = new StringBuilder();
                sb.append("" DROIDPLUGIN{"");
                if (method != null) {
                    sb.append(""method["").append(method.toString()).append(""]"");
                } else {
                    sb.append(""method["").append(""NULL"").append(""]"");
                }
                if (args != null) {
                    sb.append(""args["").append(Arrays.toString(args)).append(""]"");
                } else {
                    sb.append(""args["").append(""NULL"").append(""]"");
                }
                sb.append(""}"");
                String message = e.getMessage() + sb.toString();
                throw new IllegalArgumentException(message, e);
            } catch (Throwable e1) {
                throw e;
            }
        } catch (Throwable e) {
            if (MyProxy.isMethodDeclaredThrowable(method, e)) {
                throw e;
            } else {
                RuntimeException runtimeException = !TextUtils.isEmpty(e.getMessage()) ? new RuntimeException(e.getMessage()) : new RuntimeException();
                runtimeException.initCause(e);
                throw runtimeException;
            }
        }
    }
}",class,
"    public ProxyHook(Context hostContext) {
        super(hostContext);
    }",method,
"    public void setOldObj(Object oldObj) {
        this.mOldObj = oldObj;
    }",method,
"    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if (!isEnable()) {
                return method.invoke(mOldObj, args);
            }
            HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);
            if (hookedMethodHandler != null) {
                return hookedMethodHandler.doHookInner(mOldObj, method, args);
            }
            return method.invoke(mOldObj, args);
        } catch (InvocationTargetException e) {
            Throwable cause = e.getTargetException();
            if (cause != null && MyProxy.isMethodDeclaredThrowable(method, cause)) {
                throw cause;
            } else if (cause != null) {
                RuntimeException runtimeException = !TextUtils.isEmpty(cause.getMessage()) ? new RuntimeException(cause.getMessage()) : new RuntimeException();
                runtimeException.initCause(cause);
                throw runtimeException;
            } else {
                RuntimeException runtimeException = !TextUtils.isEmpty(e.getMessage()) ? new RuntimeException(e.getMessage()) : new RuntimeException();
                runtimeException.initCause(e);
                throw runtimeException;
            }
        } catch (IllegalArgumentException e) {
            try {
                StringBuilder sb = new StringBuilder();
                sb.append("" DROIDPLUGIN{"");
                if (method != null) {
                    sb.append(""method["").append(method.toString()).append(""]"");
                } else {
                    sb.append(""method["").append(""NULL"").append(""]"");
                }
                if (args != null) {
                    sb.append(""args["").append(Arrays.toString(args)).append(""]"");
                } else {
                    sb.append(""args["").append(""NULL"").append(""]"");
                }
                sb.append(""}"");
                String message = e.getMessage() + sb.toString();
                throw new IllegalArgumentException(message, e);
            } catch (Throwable e1) {
                throw e;
            }
        } catch (Throwable e) {
            if (MyProxy.isMethodDeclaredThrowable(method, e)) {
                throw e;
            } else {
                RuntimeException runtimeException = !TextUtils.isEmpty(e.getMessage()) ? new RuntimeException(e.getMessage()) : new RuntimeException();
                runtimeException.initCause(e);
                throw runtimeException;
            }
        }
    }",method,
"            if (hookedMethodHandler != null) {
                return hookedMethodHandler.doHookInner(mOldObj, method, args);
            }",method,
"                if (method != null) {
                    sb.append(""method["").append(method.toString()).append(""]"");
                }",method,
"                if (args != null) {
                    sb.append(""args["").append(Arrays.toString(args)).append(""]"");
                }",method,
"public class ReactAppTestActivity extends FragmentActivity
    implements DefaultHardwareBackBtnHandler, PermissionAwareActivity {
  private static final String DEFAULT_BUNDLE_NAME = ""AndroidTestBundle.js"";
  private static final int ROOT_VIEW_ID = 8675309;
  // we need a bigger timeout for CI builds because they run on a slow emulator
  private static final long IDLE_TIMEOUT_MS = 120000;
  private CountDownLatch mLayoutEvent = new CountDownLatch(1);
  private @Nullable ReactBridgeIdleSignaler mBridgeIdleSignaler;
  private ScreenshotingFrameLayout mScreenshotingFrameLayout;
  private final CountDownLatch mDestroyCountDownLatch = new CountDownLatch(1);
  private @Nullable ReactInstanceManager mReactInstanceManager;
  private @Nullable ReactRootView mReactRootView;
  private LifecycleState mLifecycleState = LifecycleState.BEFORE_RESUME;
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    overridePendingTransition(0, 0);
    // We wrap screenshot layout in another FrameLayout in order to handle custom dimensions of the
    // screenshot view set through {@link #setScreenshotDimensions}
    FrameLayout rootView = new FrameLayout(this);
    setContentView(rootView);
    mScreenshotingFrameLayout = new ScreenshotingFrameLayout(this);
    mScreenshotingFrameLayout.setId(ROOT_VIEW_ID);
    rootView.addView(mScreenshotingFrameLayout);
    mReactRootView = new ReactRootView(this);
    mScreenshotingFrameLayout.addView(mReactRootView);
  }
  @Override
  protected void onPause() {
    super.onPause();
    mLifecycleState = LifecycleState.BEFORE_RESUME;
    overridePendingTransition(0, 0);
    if (mReactInstanceManager != null) {
      mReactInstanceManager.onHostPause();
    }
  }
  @Override
  protected void onResume() {
    super.onResume();
    mLifecycleState = LifecycleState.RESUMED;
    if (mReactInstanceManager != null) {
      mReactInstanceManager.onHostResume(this, this);
    }
  }
  @Override
  protected void onDestroy() {
    super.onDestroy();
    mDestroyCountDownLatch.countDown();
    if (mReactInstanceManager != null) {
      mReactInstanceManager.destroy();
      mReactInstanceManager = null;
    }
    if (mReactRootView != null) {
      mReactRootView.unmountReactApplication();
      mReactRootView = null;
    }
    mScreenshotingFrameLayout.clean();
  }
  public void waitForDestroy(long timeoutMs) throws InterruptedException {
    mDestroyCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);
  }
  public void loadApp(String appKey, ReactInstanceSpecForTest spec, boolean enableDevSupport) {
    loadApp(appKey, spec, null, DEFAULT_BUNDLE_NAME, enableDevSupport);
  }
  public void loadApp(String appKey, ReactInstanceSpecForTest spec, String bundleName) {
    loadApp(appKey, spec, null, bundleName, false );
  }
  public void loadApp(
    String appKey,
    ReactInstanceSpecForTest spec,
    String bundleName,
    UIImplementationProvider uiImplementationProvider) {
    loadApp(appKey, spec, null, bundleName, false , uiImplementationProvider);
  }
  public void resetRootViewForScreenshotTests() {
    if (mReactInstanceManager != null) {
      mReactInstanceManager.destroy();
      mReactInstanceManager = null;
    }
    if (mReactRootView != null) {
      mReactRootView.unmountReactApplication();
    }
    mReactRootView = new ReactRootView(this);
    mScreenshotingFrameLayout.removeAllViews();
    mScreenshotingFrameLayout.clean();
    mScreenshotingFrameLayout.addView(mReactRootView);
  }
  public void loadApp(
      String appKey,
      ReactInstanceSpecForTest spec,
      @Nullable Bundle initialProps,
      String bundleName,
      boolean useDevSupport) {
    loadApp(appKey, spec, initialProps, bundleName, useDevSupport, null);
  }
  public void loadApp(
    String appKey,
    ReactInstanceSpecForTest spec,
    @Nullable Bundle initialProps,
    String bundleName,
    boolean useDevSupport,
    UIImplementationProvider uiImplementationProvider) {
    final CountDownLatch currentLayoutEvent = mLayoutEvent = new CountDownLatch(1);
    mBridgeIdleSignaler = new ReactBridgeIdleSignaler();
    ReactInstanceManagerBuilder builder =
        ReactTestHelper.getReactTestFactory()
            .getReactInstanceManagerBuilder()
            .setApplication(getApplication())
            .setBundleAssetName(bundleName);
    if (!spec.getAlternativeReactPackagesForTest().isEmpty()) {
      builder.addPackages(spec.getAlternativeReactPackagesForTest());
    } else {
      builder.addPackage(new MainReactPackage());
    }
    builder
        .addPackage(new InstanceSpecForTestPackage(spec))
        // By not setting a JS module name, we force the bundle to be always loaded from
        // assets, not the devserver, even if dev mode is enabled (such as when testing redboxes).
        // This makes sense because we never run the devserver in tests.
        //.setJSMainModuleName()
        .setUseDeveloperSupport(useDevSupport)
        .setBridgeIdleDebugListener(mBridgeIdleSignaler)
        .setInitialLifecycleState(mLifecycleState)
        .setUIImplementationProvider(uiImplementationProvider);
    mReactInstanceManager = builder.build();
    mReactInstanceManager.onHostResume(this, this);
    Assertions.assertNotNull(mReactRootView).getViewTreeObserver().addOnGlobalLayoutListener(
        new ViewTreeObserver.OnGlobalLayoutListener() {
          @Override
          public void onGlobalLayout() {
            currentLayoutEvent.countDown();
          }
        });
    Assertions.assertNotNull(mReactRootView)
        .startReactApplication(mReactInstanceManager, appKey, initialProps);
  }
  public boolean waitForLayout(long millis) throws InterruptedException {
    return mLayoutEvent.await(millis, TimeUnit.MILLISECONDS);
  }
  public void waitForBridgeAndUIIdle() {
    waitForBridgeAndUIIdle(IDLE_TIMEOUT_MS);
  }
  public void waitForBridgeAndUIIdle(long timeoutMs) {
    ReactIdleDetectionUtil.waitForBridgeAndUIIdle(
        Assertions.assertNotNull(mBridgeIdleSignaler),
        getReactContext(),
        timeoutMs);
  }
  public View getRootView() {
    return Assertions.assertNotNull(mReactRootView);
  }
  public ReactContext getReactContext() {
    return waitForReactContext();
  }
  // Because react context is created asynchronously, we may have to wait until it is available.
  // It's simpler than exposing synchronosition mechanism to notify listener than react context
  // creation has completed.
  private ReactContext waitForReactContext() {
    Assertions.assertNotNull(mReactInstanceManager);
    try {
      while (true) {
        ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();
        if (reactContext != null) {
           return reactContext;
        }
        Thread.sleep(100);
      }
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  public void postDelayed(Runnable r, int delayMS) {
    getRootView().postDelayed(r, delayMS);
  }
  public Bitmap getCurrentScreenshot() {
    return mScreenshotingFrameLayout.getLastDrawnBitmap();
  }
  public boolean isScreenshotReady() {
    return mScreenshotingFrameLayout.isScreenshotReady();
  }
  public void setScreenshotDimensions(int width, int height) {
    mScreenshotingFrameLayout.setLayoutParams(new FrameLayout.LayoutParams(width, height));
  }
  @Override
  public void invokeDefaultOnBackPressed() {
    super.onBackPressed();
  }
  @Override
  public void onRequestPermissionsResult(
      int requestCode,
      String[] permissions,
      int[] grantResults) {
  }
  @Override
  public void requestPermissions(
      String[] permissions, int requestCode, PermissionListener listener) {}
}",class,
"  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    overridePendingTransition(0, 0);
    // We wrap screenshot layout in another FrameLayout in order to handle custom dimensions of the
    // screenshot view set through {@link #setScreenshotDimensions}
    FrameLayout rootView = new FrameLayout(this);
    setContentView(rootView);
    mScreenshotingFrameLayout = new ScreenshotingFrameLayout(this);
    mScreenshotingFrameLayout.setId(ROOT_VIEW_ID);
    rootView.addView(mScreenshotingFrameLayout);
    mReactRootView = new ReactRootView(this);
    mScreenshotingFrameLayout.addView(mReactRootView);
  }",method,
"  @Override
  protected void onPause() {
    super.onPause();
    mLifecycleState = LifecycleState.BEFORE_RESUME;
    overridePendingTransition(0, 0);
    if (mReactInstanceManager != null) {
      mReactInstanceManager.onHostPause();
    }
  }",method,
"    if (mReactInstanceManager != null) {
      mReactInstanceManager.onHostPause();
    }",method,
"  @Override
  protected void onResume() {
    super.onResume();
    mLifecycleState = LifecycleState.RESUMED;
    if (mReactInstanceManager != null) {
      mReactInstanceManager.onHostResume(this, this);
    }
  }",method,
"    if (mReactInstanceManager != null) {
      mReactInstanceManager.onHostResume(this, this);
    }",method,
"  @Override
  protected void onDestroy() {
    super.onDestroy();
    mDestroyCountDownLatch.countDown();
    if (mReactInstanceManager != null) {
      mReactInstanceManager.destroy();
      mReactInstanceManager = null;
    }
    if (mReactRootView != null) {
      mReactRootView.unmountReactApplication();
      mReactRootView = null;
    }
    mScreenshotingFrameLayout.clean();
  }",method,
"    if (mReactInstanceManager != null) {
      mReactInstanceManager.destroy();
      mReactInstanceManager = null;
    }",method,
"    if (mReactRootView != null) {
      mReactRootView.unmountReactApplication();
      mReactRootView = null;
    }",method,
"  public void waitForDestroy(long timeoutMs) throws InterruptedException {
    mDestroyCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);
  }",method,
"  public void loadApp(String appKey, ReactInstanceSpecForTest spec, boolean enableDevSupport) {
    loadApp(appKey, spec, null, DEFAULT_BUNDLE_NAME, enableDevSupport);
  }",method,
"  public void loadApp(String appKey, ReactInstanceSpecForTest spec, String bundleName) {
    loadApp(appKey, spec, null, bundleName, false );
  }",method,
"  public void loadApp(
    String appKey,
    ReactInstanceSpecForTest spec,
    String bundleName,
    UIImplementationProvider uiImplementationProvider) {
    loadApp(appKey, spec, null, bundleName, false , uiImplementationProvider);
  }",method,
"  public void resetRootViewForScreenshotTests() {
    if (mReactInstanceManager != null) {
      mReactInstanceManager.destroy();
      mReactInstanceManager = null;
    }
    if (mReactRootView != null) {
      mReactRootView.unmountReactApplication();
    }
    mReactRootView = new ReactRootView(this);
    mScreenshotingFrameLayout.removeAllViews();
    mScreenshotingFrameLayout.clean();
    mScreenshotingFrameLayout.addView(mReactRootView);
  }",method,
"    if (mReactInstanceManager != null) {
      mReactInstanceManager.destroy();
      mReactInstanceManager = null;
    }",method,
"    if (mReactRootView != null) {
      mReactRootView.unmountReactApplication();
    }",method,
"  public void loadApp(
      String appKey,
      ReactInstanceSpecForTest spec,
      @Nullable Bundle initialProps,
      String bundleName,
      boolean useDevSupport) {
    loadApp(appKey, spec, initialProps, bundleName, useDevSupport, null);
  }",method,
"  public void loadApp(
    String appKey,
    ReactInstanceSpecForTest spec,
    @Nullable Bundle initialProps,
    String bundleName,
    boolean useDevSupport,
    UIImplementationProvider uiImplementationProvider) {
    final CountDownLatch currentLayoutEvent = mLayoutEvent = new CountDownLatch(1);
    mBridgeIdleSignaler = new ReactBridgeIdleSignaler();
    ReactInstanceManagerBuilder builder =
        ReactTestHelper.getReactTestFactory()
            .getReactInstanceManagerBuilder()
            .setApplication(getApplication())
            .setBundleAssetName(bundleName);
    if (!spec.getAlternativeReactPackagesForTest().isEmpty()) {
      builder.addPackages(spec.getAlternativeReactPackagesForTest());
    } else {
      builder.addPackage(new MainReactPackage());
    }
    builder
        .addPackage(new InstanceSpecForTestPackage(spec))
        // By not setting a JS module name, we force the bundle to be always loaded from
        // assets, not the devserver, even if dev mode is enabled (such as when testing redboxes).
        // This makes sense because we never run the devserver in tests.
        //.setJSMainModuleName()
        .setUseDeveloperSupport(useDevSupport)
        .setBridgeIdleDebugListener(mBridgeIdleSignaler)
        .setInitialLifecycleState(mLifecycleState)
        .setUIImplementationProvider(uiImplementationProvider);
    mReactInstanceManager = builder.build();
    mReactInstanceManager.onHostResume(this, this);
    Assertions.assertNotNull(mReactRootView).getViewTreeObserver().addOnGlobalLayoutListener(
        new ViewTreeObserver.OnGlobalLayoutListener() {
          @Override
          public void onGlobalLayout() {
            currentLayoutEvent.countDown();
          }
        });
    Assertions.assertNotNull(mReactRootView)
        .startReactApplication(mReactInstanceManager, appKey, initialProps);
  }",method,
"        new ViewTreeObserver.OnGlobalLayoutListener() {
          @Override
          public void onGlobalLayout() {
            currentLayoutEvent.countDown();
          }
        }",method,
"          @Override
          public void onGlobalLayout() {
            currentLayoutEvent.countDown();
          }",method,
"  public boolean waitForLayout(long millis) throws InterruptedException {
    return mLayoutEvent.await(millis, TimeUnit.MILLISECONDS);
  }",method,
"  public void waitForBridgeAndUIIdle() {
    waitForBridgeAndUIIdle(IDLE_TIMEOUT_MS);
  }",method,
"  public void waitForBridgeAndUIIdle(long timeoutMs) {
    ReactIdleDetectionUtil.waitForBridgeAndUIIdle(
        Assertions.assertNotNull(mBridgeIdleSignaler),
        getReactContext(),
        timeoutMs);
  }",method,
"  public View getRootView() {
    return Assertions.assertNotNull(mReactRootView);
  }",method,
"  public ReactContext getReactContext() {
    return waitForReactContext();
  }",method,
"  private ReactContext waitForReactContext() {
    Assertions.assertNotNull(mReactInstanceManager);
    try {
      while (true) {
        ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();
        if (reactContext != null) {
           return reactContext;
        }
        Thread.sleep(100);
      }
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
  }",method,
"      while (true) {
        ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();
        if (reactContext != null) {
           return reactContext;
        }
        Thread.sleep(100);
      }",method,
"        if (reactContext != null) {
           return reactContext;
        }",method,
"  public void postDelayed(Runnable r, int delayMS) {
    getRootView().postDelayed(r, delayMS);
  }",method,
"  public Bitmap getCurrentScreenshot() {
    return mScreenshotingFrameLayout.getLastDrawnBitmap();
  }",method,
"  public boolean isScreenshotReady() {
    return mScreenshotingFrameLayout.isScreenshotReady();
  }",method,
"  public void setScreenshotDimensions(int width, int height) {
    mScreenshotingFrameLayout.setLayoutParams(new FrameLayout.LayoutParams(width, height));
  }",method,
"  @Override
  public void invokeDefaultOnBackPressed() {
    super.onBackPressed();
  }",method,
"  @Override
  public void onRequestPermissionsResult(
      int requestCode,
      String[] permissions,
      int[] grantResults) {
  }",method,
"  @Override
  public void requestPermissions(
      String[] permissions, int requestCode, PermissionListener listener) {}",method,
"public class DefaultWorkerProcessFactory implements WorkerProcessFactory {
    private final LoggingManager loggingManager;
    private final MessagingServer server;
    private final IdGenerator<?> idGenerator;
    private final File gradleUserHomeDir;
    private final JavaExecHandleFactory execHandleFactory;
    private final OutputEventListener outputEventListener;
    private final ApplicationClassesInSystemClassLoaderWorkerImplementationFactory workerImplementationFactory;
    private final MemoryManager memoryManager;
    private int connectTimeoutSeconds = 120;
    public DefaultWorkerProcessFactory(LoggingManager loggingManager, MessagingServer server, ClassPathRegistry classPathRegistry, IdGenerator<?> idGenerator,
                                       File gradleUserHomeDir, TemporaryFileProvider temporaryFileProvider, JavaExecHandleFactory execHandleFactory,
                                       JvmVersionDetector jvmVersionDetector, OutputEventListener outputEventListener, MemoryManager memoryManager) {
        this.loggingManager = loggingManager;
        this.server = server;
        this.idGenerator = idGenerator;
        this.gradleUserHomeDir = gradleUserHomeDir;
        this.execHandleFactory = execHandleFactory;
        this.outputEventListener = outputEventListener;
        this.workerImplementationFactory = new ApplicationClassesInSystemClassLoaderWorkerImplementationFactory(classPathRegistry, temporaryFileProvider, jvmVersionDetector, gradleUserHomeDir);
        this.memoryManager = memoryManager;
    }
    public void setConnectTimeoutSeconds(int connectTimeoutSeconds) {
        this.connectTimeoutSeconds = connectTimeoutSeconds;
    }
    @Override
    public WorkerProcessBuilder create(Action<? super WorkerProcessContext> workerAction) {
        DefaultWorkerProcessBuilder builder = newWorkerProcessBuilder();
        builder.worker(workerAction);
        builder.setImplementationClasspath(ClasspathUtil.getClasspath(workerAction.getClass().getClassLoader()).getAsURLs());
        return builder;
    }
    @Override
    public <P> SingleRequestWorkerProcessBuilder<P> singleRequestWorker(Class<P> protocolType, Class<? extends P> workerImplementation) {
        return new DefaultSingleRequestWorkerProcessBuilder<P>(protocolType, workerImplementation, newWorkerProcessBuilder());
    }
    @Override
    public <P, W extends P> MultiRequestWorkerProcessBuilder<W> multiRequestWorker(Class<W> workerType, Class<P> protocolType, Class<? extends P> workerImplementation) {
        return new DefaultMultiRequestWorkerProcessBuilder<W>(workerType, workerImplementation, newWorkerProcessBuilder());
    }
    private DefaultWorkerProcessBuilder newWorkerProcessBuilder() {
        DefaultWorkerProcessBuilder builder = new DefaultWorkerProcessBuilder(execHandleFactory, server, idGenerator, workerImplementationFactory, outputEventListener, memoryManager);
        builder.setLogLevel(loggingManager.getLevel());
        builder.setGradleUserHomeDir(gradleUserHomeDir);
        builder.setConnectTimeoutSeconds(connectTimeoutSeconds);
        return builder;
    }
}",class,
"    public DefaultWorkerProcessFactory(LoggingManager loggingManager, MessagingServer server, ClassPathRegistry classPathRegistry, IdGenerator<?> idGenerator,
                                       File gradleUserHomeDir, TemporaryFileProvider temporaryFileProvider, JavaExecHandleFactory execHandleFactory,
                                       JvmVersionDetector jvmVersionDetector, OutputEventListener outputEventListener, MemoryManager memoryManager) {
        this.loggingManager = loggingManager;
        this.server = server;
        this.idGenerator = idGenerator;
        this.gradleUserHomeDir = gradleUserHomeDir;
        this.execHandleFactory = execHandleFactory;
        this.outputEventListener = outputEventListener;
        this.workerImplementationFactory = new ApplicationClassesInSystemClassLoaderWorkerImplementationFactory(classPathRegistry, temporaryFileProvider, jvmVersionDetector, gradleUserHomeDir);
        this.memoryManager = memoryManager;
    }",method,
"    public void setConnectTimeoutSeconds(int connectTimeoutSeconds) {
        this.connectTimeoutSeconds = connectTimeoutSeconds;
    }",method,
"    @Override
    public WorkerProcessBuilder create(Action<? super WorkerProcessContext> workerAction) {
        DefaultWorkerProcessBuilder builder = newWorkerProcessBuilder();
        builder.worker(workerAction);
        builder.setImplementationClasspath(ClasspathUtil.getClasspath(workerAction.getClass().getClassLoader()).getAsURLs());
        return builder;
    }",method,
"    @Override
    public <P> SingleRequestWorkerProcessBuilder<P> singleRequestWorker(Class<P> protocolType, Class<? extends P> workerImplementation) {
        return new DefaultSingleRequestWorkerProcessBuilder<P>(protocolType, workerImplementation, newWorkerProcessBuilder());
    }",method,
"    @Override
    public <P, W extends P> MultiRequestWorkerProcessBuilder<W> multiRequestWorker(Class<W> workerType, Class<P> protocolType, Class<? extends P> workerImplementation) {
        return new DefaultMultiRequestWorkerProcessBuilder<W>(workerType, workerImplementation, newWorkerProcessBuilder());
    }",method,
"    private DefaultWorkerProcessBuilder newWorkerProcessBuilder() {
        DefaultWorkerProcessBuilder builder = new DefaultWorkerProcessBuilder(execHandleFactory, server, idGenerator, workerImplementationFactory, outputEventListener, memoryManager);
        builder.setLogLevel(loggingManager.getLevel());
        builder.setGradleUserHomeDir(gradleUserHomeDir);
        builder.setConnectTimeoutSeconds(connectTimeoutSeconds);
        return builder;
    }",method,
"public class btKinematicCharacterController extends btCharacterControllerInterface {
	private long swigCPtr;
	protected btKinematicCharacterController(final String className, long cPtr, boolean cMemoryOwn) {
		super(className, DynamicsJNI.btKinematicCharacterController_SWIGUpcast(cPtr), cMemoryOwn);
		swigCPtr = cPtr;
	}
	public btKinematicCharacterController(long cPtr, boolean cMemoryOwn) {
		this(""btKinematicCharacterController"", cPtr, cMemoryOwn);
		construct();
	}
	@Override
	protected void reset(long cPtr, boolean cMemoryOwn) {
		if (!destroyed)
			destroy();
		super.reset(DynamicsJNI.btKinematicCharacterController_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
	}
	public static long getCPtr(btKinematicCharacterController obj) {
		return (obj == null) ? 0 : obj.swigCPtr;
	}
	@Override
	protected void finalize() throws Throwable {
		if (!destroyed)
			destroy();
		super.finalize();
	}
  @Override protected synchronized void delete() {
		if (swigCPtr != 0) {
			if (swigCMemOwn) {
				swigCMemOwn = false;
				DynamicsJNI.delete_btKinematicCharacterController(swigCPtr);
			}
			swigCPtr = 0;
		}
		super.delete();
	}
  public btKinematicCharacterController(btPairCachingGhostObject ghostObject, btConvexShape convexShape, float stepHeight, Vector3 up) {
    this(DynamicsJNI.new_btKinematicCharacterController__SWIG_0(btPairCachingGhostObject.getCPtr(ghostObject), ghostObject, btConvexShape.getCPtr(convexShape), convexShape, stepHeight, up), true);
  }
  public btKinematicCharacterController(btPairCachingGhostObject ghostObject, btConvexShape convexShape, float stepHeight) {
    this(DynamicsJNI.new_btKinematicCharacterController__SWIG_1(btPairCachingGhostObject.getCPtr(ghostObject), ghostObject, btConvexShape.getCPtr(convexShape), convexShape, stepHeight), true);
  }
  public void setUp(Vector3 up) {
    DynamicsJNI.btKinematicCharacterController_setUp(swigCPtr, this, up);
  }
  public Vector3 getUp() {
	return DynamicsJNI.btKinematicCharacterController_getUp(swigCPtr, this);
}
  public void setAngularVelocity(Vector3 velocity) {
    DynamicsJNI.btKinematicCharacterController_setAngularVelocity(swigCPtr, this, velocity);
  }
  public Vector3 getAngularVelocity() {
	return DynamicsJNI.btKinematicCharacterController_getAngularVelocity(swigCPtr, this);
}
  public void setLinearVelocity(Vector3 velocity) {
    DynamicsJNI.btKinematicCharacterController_setLinearVelocity(swigCPtr, this, velocity);
  }
  public Vector3 getLinearVelocity() {
	return DynamicsJNI.btKinematicCharacterController_getLinearVelocity(swigCPtr, this);
}
  public void setLinearDamping(float d) {
    DynamicsJNI.btKinematicCharacterController_setLinearDamping(swigCPtr, this, d);
  }
  public float getLinearDamping() {
    return DynamicsJNI.btKinematicCharacterController_getLinearDamping(swigCPtr, this);
  }
  public void setAngularDamping(float d) {
    DynamicsJNI.btKinematicCharacterController_setAngularDamping(swigCPtr, this, d);
  }
  public float getAngularDamping() {
    return DynamicsJNI.btKinematicCharacterController_getAngularDamping(swigCPtr, this);
  }
  public void setStepHeight(float h) {
    DynamicsJNI.btKinematicCharacterController_setStepHeight(swigCPtr, this, h);
  }
  public float getStepHeight() {
    return DynamicsJNI.btKinematicCharacterController_getStepHeight(swigCPtr, this);
  }
  public void setFallSpeed(float fallSpeed) {
    DynamicsJNI.btKinematicCharacterController_setFallSpeed(swigCPtr, this, fallSpeed);
  }
  public float getFallSpeed() {
    return DynamicsJNI.btKinematicCharacterController_getFallSpeed(swigCPtr, this);
  }
  public void setJumpSpeed(float jumpSpeed) {
    DynamicsJNI.btKinematicCharacterController_setJumpSpeed(swigCPtr, this, jumpSpeed);
  }
  public float getJumpSpeed() {
    return DynamicsJNI.btKinematicCharacterController_getJumpSpeed(swigCPtr, this);
  }
  public void setMaxJumpHeight(float maxJumpHeight) {
    DynamicsJNI.btKinematicCharacterController_setMaxJumpHeight(swigCPtr, this, maxJumpHeight);
  }
  public void jump(Vector3 v) {
    DynamicsJNI.btKinematicCharacterController_jump__SWIG_0(swigCPtr, this, v);
  }
  public void jump() {
    DynamicsJNI.btKinematicCharacterController_jump__SWIG_1(swigCPtr, this);
  }
  public void applyImpulse(Vector3 v) {
    DynamicsJNI.btKinematicCharacterController_applyImpulse(swigCPtr, this, v);
  }
  public void setGravity(Vector3 gravity) {
    DynamicsJNI.btKinematicCharacterController_setGravity(swigCPtr, this, gravity);
  }
  public Vector3 getGravity() {
	return DynamicsJNI.btKinematicCharacterController_getGravity(swigCPtr, this);
}
  public void setMaxSlope(float slopeRadians) {
    DynamicsJNI.btKinematicCharacterController_setMaxSlope(swigCPtr, this, slopeRadians);
  }
  public float getMaxSlope() {
    return DynamicsJNI.btKinematicCharacterController_getMaxSlope(swigCPtr, this);
  }
  public void setMaxPenetrationDepth(float d) {
    DynamicsJNI.btKinematicCharacterController_setMaxPenetrationDepth(swigCPtr, this, d);
  }
  public float getMaxPenetrationDepth() {
    return DynamicsJNI.btKinematicCharacterController_getMaxPenetrationDepth(swigCPtr, this);
  }
  public btPairCachingGhostObject getGhostObject() {
    long cPtr = DynamicsJNI.btKinematicCharacterController_getGhostObject(swigCPtr, this);
    return (cPtr == 0) ? null : new btPairCachingGhostObject(cPtr, false);
  }
  public void setUseGhostSweepTest(boolean useGhostObjectSweepTest) {
    DynamicsJNI.btKinematicCharacterController_setUseGhostSweepTest(swigCPtr, this, useGhostObjectSweepTest);
  }
}",class,
"	protected btKinematicCharacterController(final String className, long cPtr, boolean cMemoryOwn) {
		super(className, DynamicsJNI.btKinematicCharacterController_SWIGUpcast(cPtr), cMemoryOwn);
		swigCPtr = cPtr;
	}",method,
"	public btKinematicCharacterController(long cPtr, boolean cMemoryOwn) {
		this(""btKinematicCharacterController"", cPtr, cMemoryOwn);
		construct();
	}",method,
"	@Override
	protected void reset(long cPtr, boolean cMemoryOwn) {
		if (!destroyed)
			destroy();
		super.reset(DynamicsJNI.btKinematicCharacterController_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
	}",method,
"	public static long getCPtr(btKinematicCharacterController obj) {
		return (obj == null) ? 0 : obj.swigCPtr;
	}",method,
"	@Override
	protected void finalize() throws Throwable {
		if (!destroyed)
			destroy();
		super.finalize();
	}",method,
"  @Override protected synchronized void delete() {
		if (swigCPtr != 0) {
			if (swigCMemOwn) {
				swigCMemOwn = false;
				DynamicsJNI.delete_btKinematicCharacterController(swigCPtr);
			}
			swigCPtr = 0;
		}",method,
"			if (swigCMemOwn) {
				swigCMemOwn = false;
				DynamicsJNI.delete_btKinematicCharacterController(swigCPtr);
			}",method,
"  public btKinematicCharacterController(btPairCachingGhostObject ghostObject, btConvexShape convexShape, float stepHeight, Vector3 up) {
    this(DynamicsJNI.new_btKinematicCharacterController__SWIG_0(btPairCachingGhostObject.getCPtr(ghostObject), ghostObject, btConvexShape.getCPtr(convexShape), convexShape, stepHeight, up), true);
  }",method,
"  public btKinematicCharacterController(btPairCachingGhostObject ghostObject, btConvexShape convexShape, float stepHeight) {
    this(DynamicsJNI.new_btKinematicCharacterController__SWIG_1(btPairCachingGhostObject.getCPtr(ghostObject), ghostObject, btConvexShape.getCPtr(convexShape), convexShape, stepHeight), true);
  }",method,
"  public void setUp(Vector3 up) {
    DynamicsJNI.btKinematicCharacterController_setUp(swigCPtr, this, up);
  }",method,
"  public Vector3 getUp() {
	return DynamicsJNI.btKinematicCharacterController_getUp(swigCPtr, this);
}",method,
"  public void setAngularVelocity(Vector3 velocity) {
    DynamicsJNI.btKinematicCharacterController_setAngularVelocity(swigCPtr, this, velocity);
  }",method,
"  public Vector3 getAngularVelocity() {
	return DynamicsJNI.btKinematicCharacterController_getAngularVelocity(swigCPtr, this);
}",method,
"  public void setLinearVelocity(Vector3 velocity) {
    DynamicsJNI.btKinematicCharacterController_setLinearVelocity(swigCPtr, this, velocity);
  }",method,
"  public Vector3 getLinearVelocity() {
	return DynamicsJNI.btKinematicCharacterController_getLinearVelocity(swigCPtr, this);
}",method,
"  public void setLinearDamping(float d) {
    DynamicsJNI.btKinematicCharacterController_setLinearDamping(swigCPtr, this, d);
  }",method,
"  public float getLinearDamping() {
    return DynamicsJNI.btKinematicCharacterController_getLinearDamping(swigCPtr, this);
  }",method,
"  public void setAngularDamping(float d) {
    DynamicsJNI.btKinematicCharacterController_setAngularDamping(swigCPtr, this, d);
  }",method,
"  public float getAngularDamping() {
    return DynamicsJNI.btKinematicCharacterController_getAngularDamping(swigCPtr, this);
  }",method,
"  public void setStepHeight(float h) {
    DynamicsJNI.btKinematicCharacterController_setStepHeight(swigCPtr, this, h);
  }",method,
"  public float getStepHeight() {
    return DynamicsJNI.btKinematicCharacterController_getStepHeight(swigCPtr, this);
  }",method,
"  public void setFallSpeed(float fallSpeed) {
    DynamicsJNI.btKinematicCharacterController_setFallSpeed(swigCPtr, this, fallSpeed);
  }",method,
"  public float getFallSpeed() {
    return DynamicsJNI.btKinematicCharacterController_getFallSpeed(swigCPtr, this);
  }",method,
"  public void setJumpSpeed(float jumpSpeed) {
    DynamicsJNI.btKinematicCharacterController_setJumpSpeed(swigCPtr, this, jumpSpeed);
  }",method,
"  public float getJumpSpeed() {
    return DynamicsJNI.btKinematicCharacterController_getJumpSpeed(swigCPtr, this);
  }",method,
"  public void setMaxJumpHeight(float maxJumpHeight) {
    DynamicsJNI.btKinematicCharacterController_setMaxJumpHeight(swigCPtr, this, maxJumpHeight);
  }",method,
"  public void jump(Vector3 v) {
    DynamicsJNI.btKinematicCharacterController_jump__SWIG_0(swigCPtr, this, v);
  }",method,
"  public void jump() {
    DynamicsJNI.btKinematicCharacterController_jump__SWIG_1(swigCPtr, this);
  }",method,
"  public void applyImpulse(Vector3 v) {
    DynamicsJNI.btKinematicCharacterController_applyImpulse(swigCPtr, this, v);
  }",method,
"  public void setGravity(Vector3 gravity) {
    DynamicsJNI.btKinematicCharacterController_setGravity(swigCPtr, this, gravity);
  }",method,
"  public Vector3 getGravity() {
	return DynamicsJNI.btKinematicCharacterController_getGravity(swigCPtr, this);
}",method,
"  public void setMaxSlope(float slopeRadians) {
    DynamicsJNI.btKinematicCharacterController_setMaxSlope(swigCPtr, this, slopeRadians);
  }",method,
"  public float getMaxSlope() {
    return DynamicsJNI.btKinematicCharacterController_getMaxSlope(swigCPtr, this);
  }",method,
"  public void setMaxPenetrationDepth(float d) {
    DynamicsJNI.btKinematicCharacterController_setMaxPenetrationDepth(swigCPtr, this, d);
  }",method,
"  public float getMaxPenetrationDepth() {
    return DynamicsJNI.btKinematicCharacterController_getMaxPenetrationDepth(swigCPtr, this);
  }",method,
"  public btPairCachingGhostObject getGhostObject() {
    long cPtr = DynamicsJNI.btKinematicCharacterController_getGhostObject(swigCPtr, this);
    return (cPtr == 0) ? null : new btPairCachingGhostObject(cPtr, false);
  }",method,
"  public void setUseGhostSweepTest(boolean useGhostObjectSweepTest) {
    DynamicsJNI.btKinematicCharacterController_setUseGhostSweepTest(swigCPtr, this, useGhostObjectSweepTest);
  }",method,

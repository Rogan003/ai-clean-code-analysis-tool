code_snippet,type,score
"    private void addOpacityStopsToGradientIfNeeded(GradientColor gradientColor, JSONArray array) {
      int startIndex = colorPoints * 4;
      if (array.length() <= startIndex) {
        return;
      }
      int opacityStops = (array.length() - startIndex) / 2;
      double[] positions = new double[opacityStops];
      double[] opacities = new double[opacityStops];
      for (int i = startIndex, j = 0; i < array.length(); i++) {
        if (i % 2 == 0) {
          positions[j] = array.optDouble(i);
        } else {
          opacities[j] = array.optDouble(i);
          j++;
        }
      }
      for (int i = 0; i < gradientColor.getSize(); i++) {
        int color = gradientColor.getColors()[i];
        color = Color.argb(
            getOpacityAtPosition(gradientColor.getPositions()[i], positions, opacities),
            Color.red(color),
            Color.green(color),
            Color.blue(color)
        );
        gradientColor.getColors()[i] = color;
      }
    }",method,
"        if (i % 2 == 0) {
          positions[j] = array.optDouble(i);
        }",method,
"    @IntRange(from=0, to=255)
    private int getOpacityAtPosition(double position, double[] positions, double[] opacities) {
      for (int i = 1; i < positions.length; i++) {
        double lastPosition = positions[i - 1];
        double thisPosition = positions[i];
        if (positions[i] >= position) {
          double progress = (position - lastPosition) / (thisPosition - lastPosition);
          return (int) (255 * MiscUtils.lerp(opacities[i - 1], opacities[i], progress));
        }
      }
      return (int) (255 * opacities[opacities.length - 1]);
    }",method,
"      for (int i = 1; i < positions.length; i++) {
        double lastPosition = positions[i - 1];
        double thisPosition = positions[i];
        if (positions[i] >= position) {
          double progress = (position - lastPosition) / (thisPosition - lastPosition);
          return (int) (255 * MiscUtils.lerp(opacities[i - 1], opacities[i], progress));
        }
      }",method,
"        if (positions[i] >= position) {
          double progress = (position - lastPosition) / (thisPosition - lastPosition);
          return (int) (255 * MiscUtils.lerp(opacities[i - 1], opacities[i], progress));
        }",method,
"public class KtCallExpression extends KtExpressionImpl implements KtCallElement, KtReferenceExpression {
    public KtCallExpression(@NotNull ASTNode node) {
        super(node);
    }
    @Override
    public <R, D> R accept(@NotNull KtVisitor<R, D> visitor, D data) {
        return visitor.visitCallExpression(this, data);
    }
    @Override
    @Nullable
    public KtExpression getCalleeExpression() {
        return findChildByClass(KtExpression.class);
    }
    @Override
    @Nullable
    public KtValueArgumentList getValueArgumentList() {
        return (KtValueArgumentList) findChildByType(KtNodeTypes.VALUE_ARGUMENT_LIST);
    }
    @Override
    @Nullable
    public KtTypeArgumentList getTypeArgumentList() {
        return (KtTypeArgumentList) findChildByType(KtNodeTypes.TYPE_ARGUMENT_LIST);
    }
    @Override
    @NotNull
    public List<KtLambdaArgument> getLambdaArguments() {
        return findChildrenByType(KtNodeTypes.LAMBDA_ARGUMENT);
    }
    @Override
    @NotNull
    public List<KtValueArgument> getValueArguments() {
        KtValueArgumentList list = getValueArgumentList();
        List<KtValueArgument> valueArgumentsInParentheses = list != null ? list.getArguments() : Collections.emptyList();
        List<KtLambdaArgument> functionLiteralArguments = getLambdaArguments();
        if (functionLiteralArguments.isEmpty()) {
            return valueArgumentsInParentheses;
        }
        List<KtValueArgument> allValueArguments = Lists.newArrayList();
        allValueArguments.addAll(valueArgumentsInParentheses);
        allValueArguments.addAll(functionLiteralArguments);
        return allValueArguments;
    }
    @Override
    @NotNull
    public List<KtTypeProjection> getTypeArguments() {
        KtTypeArgumentList list = getTypeArgumentList();
        return list != null ? list.getArguments() : Collections.emptyList();
    }
}",class,
"    public KtCallExpression(@NotNull ASTNode node) {
        super(node);
    }",method,
"    @Override
    public <R, D> R accept(@NotNull KtVisitor<R, D> visitor, D data) {
        return visitor.visitCallExpression(this, data);
    }",method,
"    @Override
    @Nullable
    public KtExpression getCalleeExpression() {
        return findChildByClass(KtExpression.class);
    }",method,
"    @Override
    @Nullable
    public KtValueArgumentList getValueArgumentList() {
        return (KtValueArgumentList) findChildByType(KtNodeTypes.VALUE_ARGUMENT_LIST);
    }",method,
"    @Override
    @Nullable
    public KtTypeArgumentList getTypeArgumentList() {
        return (KtTypeArgumentList) findChildByType(KtNodeTypes.TYPE_ARGUMENT_LIST);
    }",method,
"    @Override
    @NotNull
    public List<KtLambdaArgument> getLambdaArguments() {
        return findChildrenByType(KtNodeTypes.LAMBDA_ARGUMENT);
    }",method,
"    @Override
    @NotNull
    public List<KtValueArgument> getValueArguments() {
        KtValueArgumentList list = getValueArgumentList();
        List<KtValueArgument> valueArgumentsInParentheses = list != null ? list.getArguments() : Collections.emptyList();
        List<KtLambdaArgument> functionLiteralArguments = getLambdaArguments();
        if (functionLiteralArguments.isEmpty()) {
            return valueArgumentsInParentheses;
        }
        List<KtValueArgument> allValueArguments = Lists.newArrayList();
        allValueArguments.addAll(valueArgumentsInParentheses);
        allValueArguments.addAll(functionLiteralArguments);
        return allValueArguments;
    }",method,
"    @Override
    @NotNull
    public List<KtTypeProjection> getTypeArguments() {
        KtTypeArgumentList list = getTypeArgumentList();
        return list != null ? list.getArguments() : Collections.emptyList();
    }",method,
"public class EvaluationToolsTests {
    @Test
    public void testRocHtml() throws Exception {
        DataSetIterator iter = new IrisDataSetIterator(150, 150);
        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder().weightInit(WeightInit.XAVIER).list()
                        .layer(0, new DenseLayer.Builder().nIn(4).nOut(4).activation(Activation.TANH).build()).layer(1,
                                        new OutputLayer.Builder().nIn(4).nOut(2).activation(Activation.SOFTMAX)
                                                        .lossFunction(LossFunctions.LossFunction.MCXENT).build())
                        .build();
        MultiLayerNetwork net = new MultiLayerNetwork(conf);
        net.init();
        NormalizerStandardize ns = new NormalizerStandardize();
        DataSet ds = iter.next();
        ns.fit(ds);
        ns.transform(ds);
        INDArray newLabels = Nd4j.create(150, 2);
        newLabels.getColumn(0).assign(ds.getLabels().getColumn(0));
        newLabels.getColumn(0).addi(ds.getLabels().getColumn(1));
        newLabels.getColumn(1).assign(ds.getLabels().getColumn(2));
        ds.setLabels(newLabels);
        for (int i = 0; i < 30; i++) {
            net.fit(ds);
        }
        for (int numSteps : new int[] {20, 0}) {
            ROC roc = new ROC(numSteps);
            iter.reset();
            INDArray f = ds.getFeatures();
            INDArray l = ds.getLabels();
            INDArray out = net.output(f);
            roc.eval(l, out);
            String str = EvaluationTools.rocChartToHtml(roc);
            //            System.out.println(str);
        }
    }
    @Test
    public void testRocMultiToHtml() throws Exception {
        DataSetIterator iter = new IrisDataSetIterator(150, 150);
        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder().weightInit(WeightInit.XAVIER).list()
                        .layer(0, new DenseLayer.Builder().nIn(4).nOut(4).activation(Activation.TANH).build()).layer(1,
                                        new OutputLayer.Builder().nIn(4).nOut(3).activation(Activation.SOFTMAX)
                                                        .lossFunction(LossFunctions.LossFunction.MCXENT).build())
                        .build();
        MultiLayerNetwork net = new MultiLayerNetwork(conf);
        net.init();
        NormalizerStandardize ns = new NormalizerStandardize();
        DataSet ds = iter.next();
        ns.fit(ds);
        ns.transform(ds);
        for (int i = 0; i < 30; i++) {
            net.fit(ds);
        }
        for (int numSteps : new int[] {20, 0}) {
            ROCMultiClass roc = new ROCMultiClass(numSteps);
            iter.reset();
            INDArray f = ds.getFeatures();
            INDArray l = ds.getLabels();
            INDArray out = net.output(f);
            roc.eval(l, out);
            String str = EvaluationTools.rocChartToHtml(roc, Arrays.asList(""setosa"", ""versicolor"", ""virginica""));
            System.out.println(str);
        }
    }
    @Test
    public void testEvaluationCalibrationToHtml() throws Exception {
        int minibatch = 1000;
        int nClasses = 3;
        INDArray arr = Nd4j.rand(minibatch, nClasses);
        arr.diviColumnVector(arr.sum(1));
        INDArray labels = Nd4j.zeros(minibatch, nClasses);
        Random r = new Random(12345);
        for (int i = 0; i < minibatch; i++) {
            labels.putScalar(i, r.nextInt(nClasses), 1.0);
        }
        int numBins = 10;
        EvaluationCalibration ec = new EvaluationCalibration(numBins, numBins);
        ec.eval(labels, arr);
        String str = EvaluationTools.evaluationCalibrationToHtml(ec);
        //        System.out.println(str);
    }
}",class,
"    @Test
    public void testRocHtml() throws Exception {
        DataSetIterator iter = new IrisDataSetIterator(150, 150);
        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder().weightInit(WeightInit.XAVIER).list()
                        .layer(0, new DenseLayer.Builder().nIn(4).nOut(4).activation(Activation.TANH).build()).layer(1,
                                        new OutputLayer.Builder().nIn(4).nOut(2).activation(Activation.SOFTMAX)
                                                        .lossFunction(LossFunctions.LossFunction.MCXENT).build())
                        .build();
        MultiLayerNetwork net = new MultiLayerNetwork(conf);
        net.init();
        NormalizerStandardize ns = new NormalizerStandardize();
        DataSet ds = iter.next();
        ns.fit(ds);
        ns.transform(ds);
        INDArray newLabels = Nd4j.create(150, 2);
        newLabels.getColumn(0).assign(ds.getLabels().getColumn(0));
        newLabels.getColumn(0).addi(ds.getLabels().getColumn(1));
        newLabels.getColumn(1).assign(ds.getLabels().getColumn(2));
        ds.setLabels(newLabels);
        for (int i = 0; i < 30; i++) {
            net.fit(ds);
        }
        for (int numSteps : new int[] {20, 0}) {
            ROC roc = new ROC(numSteps);
            iter.reset();
            INDArray f = ds.getFeatures();
            INDArray l = ds.getLabels();
            INDArray out = net.output(f);
            roc.eval(l, out);
            String str = EvaluationTools.rocChartToHtml(roc);
            //            System.out.println(str);
        }
    }",method,
"        for (int i = 0; i < 30; i++) {
            net.fit(ds);
        }",method,
"        for (int numSteps : new int[] {20, 0}) {
            ROC roc = new ROC(numSteps);
            iter.reset();
            INDArray f = ds.getFeatures();
            INDArray l = ds.getLabels();
            INDArray out = net.output(f);
            roc.eval(l, out);
            String str = EvaluationTools.rocChartToHtml(roc);
            //            System.out.println(str);
        }",method,
"    @Test
    public void testRocMultiToHtml() throws Exception {
        DataSetIterator iter = new IrisDataSetIterator(150, 150);
        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder().weightInit(WeightInit.XAVIER).list()
                        .layer(0, new DenseLayer.Builder().nIn(4).nOut(4).activation(Activation.TANH).build()).layer(1,
                                        new OutputLayer.Builder().nIn(4).nOut(3).activation(Activation.SOFTMAX)
                                                        .lossFunction(LossFunctions.LossFunction.MCXENT).build())
                        .build();
        MultiLayerNetwork net = new MultiLayerNetwork(conf);
        net.init();
        NormalizerStandardize ns = new NormalizerStandardize();
        DataSet ds = iter.next();
        ns.fit(ds);
        ns.transform(ds);
        for (int i = 0; i < 30; i++) {
            net.fit(ds);
        }
        for (int numSteps : new int[] {20, 0}) {
            ROCMultiClass roc = new ROCMultiClass(numSteps);
            iter.reset();
            INDArray f = ds.getFeatures();
            INDArray l = ds.getLabels();
            INDArray out = net.output(f);
            roc.eval(l, out);
            String str = EvaluationTools.rocChartToHtml(roc, Arrays.asList(""setosa"", ""versicolor"", ""virginica""));
            System.out.println(str);
        }
    }",method,
"        for (int i = 0; i < 30; i++) {
            net.fit(ds);
        }",method,
"        for (int numSteps : new int[] {20, 0}) {
            ROCMultiClass roc = new ROCMultiClass(numSteps);
            iter.reset();
            INDArray f = ds.getFeatures();
            INDArray l = ds.getLabels();
            INDArray out = net.output(f);
            roc.eval(l, out);
            String str = EvaluationTools.rocChartToHtml(roc, Arrays.asList(""setosa"", ""versicolor"", ""virginica""));
            System.out.println(str);
        }",method,
"    @Test
    public void testEvaluationCalibrationToHtml() throws Exception {
        int minibatch = 1000;
        int nClasses = 3;
        INDArray arr = Nd4j.rand(minibatch, nClasses);
        arr.diviColumnVector(arr.sum(1));
        INDArray labels = Nd4j.zeros(minibatch, nClasses);
        Random r = new Random(12345);
        for (int i = 0; i < minibatch; i++) {
            labels.putScalar(i, r.nextInt(nClasses), 1.0);
        }
        int numBins = 10;
        EvaluationCalibration ec = new EvaluationCalibration(numBins, numBins);
        ec.eval(labels, arr);
        String str = EvaluationTools.evaluationCalibrationToHtml(ec);
        //        System.out.println(str);
    }",method,
"        for (int i = 0; i < minibatch; i++) {
            labels.putScalar(i, r.nextInt(nClasses), 1.0);
        }",method,
"public class MaybeFromCallableTest {
    @Test(expected = NullPointerException.class)
    public void fromCallableNull() {
        Maybe.fromCallable(null);
    }
    @Test
    public void fromCallable() {
        final AtomicInteger atomicInteger = new AtomicInteger();
        Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }
        })
            .test()
            .assertResult();
        assertEquals(1, atomicInteger.get());
    }
    @Test
    public void fromCallableTwice() {
        final AtomicInteger atomicInteger = new AtomicInteger();
        Callable<Object> callable = new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }
        };
        Maybe.fromCallable(callable)
            .test()
            .assertResult();
        assertEquals(1, atomicInteger.get());
        Maybe.fromCallable(callable)
            .test()
            .assertResult();
        assertEquals(2, atomicInteger.get());
    }
    @Test
    public void fromCallableInvokesLazy() {
        final AtomicInteger atomicInteger = new AtomicInteger();
        Maybe<Object> completable = Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }
        });
        assertEquals(0, atomicInteger.get());
        completable
            .test()
            .assertResult();
        assertEquals(1, atomicInteger.get());
    }
    @Test
    public void fromCallableThrows() {
        Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                throw new UnsupportedOperationException();
            }
        })
            .test()
            .assertFailure(UnsupportedOperationException.class);
    }
    @SuppressWarnings(""unchecked"")
    @Test
    public void callable() throws Exception {
        final int[] counter = { 0 };
        Maybe<Integer> m = Maybe.fromCallable(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                counter[0]++;
                return 0;
            }
        });
        assertTrue(m.getClass().toString(), m instanceof Callable);
        assertEquals(0, ((Callable<Void>)m).call());
        assertEquals(1, counter[0]);
    }
    @Test
    public void noErrorLoss() throws Exception {
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);
            TestObserver<Integer> to = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();
            assertTrue(cdl1.await(5, TimeUnit.SECONDS));
            to.cancel();
            int timeout = 10;
            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }
            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }
}",class,
"    @Test(expected = NullPointerException.class)
    public void fromCallableNull() {
        Maybe.fromCallable(null);
    }",method,
"    @Test
    public void fromCallable() {
        final AtomicInteger atomicInteger = new AtomicInteger();
        Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }
        })
            .test()
            .assertResult();
        assertEquals(1, atomicInteger.get());
    }",method,
"        Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }
        }",method,
"            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }",method,
"    @Test
    public void fromCallableTwice() {
        final AtomicInteger atomicInteger = new AtomicInteger();
        Callable<Object> callable = new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }
        };
        Maybe.fromCallable(callable)
            .test()
            .assertResult();
        assertEquals(1, atomicInteger.get());
        Maybe.fromCallable(callable)
            .test()
            .assertResult();
        assertEquals(2, atomicInteger.get());
    }",method,
"            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }",method,
"    @Test
    public void fromCallableInvokesLazy() {
        final AtomicInteger atomicInteger = new AtomicInteger();
        Maybe<Object> completable = Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }
        });
        assertEquals(0, atomicInteger.get());
        completable
            .test()
            .assertResult();
        assertEquals(1, atomicInteger.get());
    }",method,
"            @Override
            public Object call() throws Exception {
                atomicInteger.incrementAndGet();
                return null;
            }",method,
"    @Test
    public void fromCallableThrows() {
        Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                throw new UnsupportedOperationException();
            }
        })
            .test()
            .assertFailure(UnsupportedOperationException.class);
    }",method,
"        Maybe.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                throw new UnsupportedOperationException();
            }
        }",method,
"            @Override
            public Object call() throws Exception {
                throw new UnsupportedOperationException();
            }",method,
"    @SuppressWarnings(""unchecked"")
    @Test
    public void callable() throws Exception {
        final int[] counter = { 0 };
        Maybe<Integer> m = Maybe.fromCallable(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                counter[0]++;
                return 0;
            }
        });
        assertTrue(m.getClass().toString(), m instanceof Callable);
        assertEquals(0, ((Callable<Void>)m).call());
        assertEquals(1, counter[0]);
    }",method,
"            @Override
            public Integer call() throws Exception {
                counter[0]++;
                return 0;
            }",method,
"    @Test
    public void noErrorLoss() throws Exception {
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);
            TestObserver<Integer> to = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();
            assertTrue(cdl1.await(5, TimeUnit.SECONDS));
            to.cancel();
            int timeout = 10;
            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }
            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",method,
"                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }",method,
"public class DefaultMavenDependency implements MavenDependencyInternal {
    private final String groupId;
    private final String artifactId;
    private final String version;
    private final List<DependencyArtifact> artifacts = new ArrayList<DependencyArtifact>();
    private final List<ExcludeRule> excludeRules = new ArrayList<ExcludeRule>(); //exclude rules for a dependency specified in gradle DSL
    public DefaultMavenDependency(String groupId, String artifactId, String version) {
        this.groupId = groupId;
        this.artifactId = artifactId;
        this.version = version;
    }
    public DefaultMavenDependency(String groupId, String artifactId, String version, Collection<DependencyArtifact> artifacts) {
        this(groupId, artifactId, version);
        this.artifacts.addAll(artifacts);
    }
    public DefaultMavenDependency(String groupId, String artifactId, String version, Collection<DependencyArtifact> artifacts, Collection<ExcludeRule> excludeRules) {
        this(groupId, artifactId, version, artifacts);
        this.excludeRules.addAll(excludeRules);
    }
    public String getGroupId() {
        return groupId;
    }
    public String getArtifactId() {
        return artifactId;
    }
    public String getVersion() {
        return version;
    }
    public Collection<DependencyArtifact> getArtifacts() {
        return artifacts;
    }
    public Collection<ExcludeRule> getExcludeRules() {
        return excludeRules;
    }
}",class,
"    public DefaultMavenDependency(String groupId, String artifactId, String version) {
        this.groupId = groupId;
        this.artifactId = artifactId;
        this.version = version;
    }",method,
"    public DefaultMavenDependency(String groupId, String artifactId, String version, Collection<DependencyArtifact> artifacts) {
        this(groupId, artifactId, version);
        this.artifacts.addAll(artifacts);
    }",method,
"    public DefaultMavenDependency(String groupId, String artifactId, String version, Collection<DependencyArtifact> artifacts, Collection<ExcludeRule> excludeRules) {
        this(groupId, artifactId, version, artifacts);
        this.excludeRules.addAll(excludeRules);
    }",method,
"    public String getGroupId() {
        return groupId;
    }",method,
"    public String getArtifactId() {
        return artifactId;
    }",method,
"    public String getVersion() {
        return version;
    }",method,
"    public Collection<DependencyArtifact> getArtifacts() {
        return artifacts;
    }",method,
"    public Collection<ExcludeRule> getExcludeRules() {
        return excludeRules;
    }",method,
"public class VarcharsTest
{
    @Test
    public void testTruncateToLength()
            throws Exception
    {
        // Single byte code points
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), 0), Slices.utf8Slice(""""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), 1), Slices.utf8Slice(""a""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), 4), Slices.utf8Slice(""abc""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abcde""), 5), Slices.utf8Slice(""abcde""));
        // 2 bytes code points
        assertEquals(truncateToLength(Slices.utf8Slice(""абв""), 0), Slices.utf8Slice(""""));
        assertEquals(truncateToLength(Slices.utf8Slice(""абв""), 1), Slices.utf8Slice(""а""));
        assertEquals(truncateToLength(Slices.utf8Slice(""абв""), 4), Slices.utf8Slice(""абв""));
        assertEquals(truncateToLength(Slices.utf8Slice(""абвгд""), 5), Slices.utf8Slice(""абвгд""));
        // 4 bytes code points
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""), 0),
                Slices.utf8Slice(""""));
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""), 1),
                Slices.utf8Slice(""\uD841\uDF0E""));
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79""), 4),
                Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79""));
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""), 5),
                Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), createVarcharType(1)), Slices.utf8Slice(""a""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), (Type) createVarcharType(1)), Slices.utf8Slice(""a""));
    }
    @Test
    public void testByteCount()
            throws Exception
    {
        // Single byte code points
        assertByteCount(""abc"", 0, 0, 1, """");
        assertByteCount(""abc"", 0, 1, 0, """");
        assertByteCount(""abc"", 1, 1, 1, ""b"");
        assertByteCount(""abc"", 1, 1, 2, ""b"");
        assertByteCount(""abc"", 1, 2, 1, ""b"");
        assertByteCount(""abc"", 1, 2, 2, ""bc"");
        assertByteCount(""abc"", 1, 2, 3, ""bc"");
        assertByteCount(""abc"", 0, 3, 1, ""a"");
        assertByteCount(""abc"", 0, 3, 5, ""abc"");
        assertByteCountFailure(""abc"", 4, 5, 1);
        assertByteCountFailure(""abc"", 5, 0, 1);
        assertByteCountFailure(""abc"", -1, 1, 1);
        assertByteCountFailure(""abc"", 1, -1, 1);
        assertByteCountFailure(""abc"", 1, 1, -1);
        // 2 bytes code points
        assertByteCount(""абв"", 0, 0, 1, """");
        assertByteCount(""абв"", 0, 1, 0, """");
        assertByteCount(""абв"", 0, 2, 1, ""а"");
        assertByteCount(""абв"", 0, 4, 1, ""а"");
        assertByteCount(""абв"", 0, 1, 1, utf8Slice(""а"").getBytes(0, 1));
        assertByteCount(""абв"", 2, 2, 2, ""б"");
        assertByteCount(""абв"", 2, 2, 0, """");
        assertByteCount(""абв"", 0, 3, 5, utf8Slice(""аб"").getBytes(0, 3));
        assertByteCountFailure(""абв"", 8, 5, 1);
        // we do not check if the offset is in the middle of a code point
        assertByteCount(""абв"", 1, 1, 5, utf8Slice(""а"").getBytes(1, 1));
        assertByteCount(""абв"", 2, 1, 5, utf8Slice(""б"").getBytes(0, 1));
        // 3 bytes code points
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 0, 2, """");
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 1, 1, utf8Slice(""\u6000"").getBytes(0, 1));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 2, 1, utf8Slice(""\u6000"").getBytes(0, 2));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 3, 1, ""\u6000"");
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 6, 1, ""\u6000"");
        assertByteCount(""\u6000\u6001\u6002\u6003"", 6, 2, 4, utf8Slice(""\u6002"").getBytes(0, 2));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 12, 6, ""\u6000\u6001\u6002\u6003"");
        // we do not check if the offset is in the middle of a code point
        assertByteCount(""\u6000\u6001\u6002\u6003"", 1, 6, 2, utf8Slice(""\u6000\u6001\u6002"").getBytes(1, 6));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 2, 6, 2, utf8Slice(""\u6000\u6001\u6002"").getBytes(2, 6));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 3, 6, 2, utf8Slice(""\u6000\u6001\u6002"").getBytes(3, 6));
        assertByteCountFailure(""\u6000\u6001\u6002\u6003"", 21, 0, 1);
        // invalid code points; always return the original lengths unless code point count is 0
        assertByteCount(new byte[]{(byte) 0x81, (byte) 0x81, (byte) 0x81}, 0, 2, 0, new byte[]{});
        assertByteCount(new byte[]{(byte) 0x81, (byte) 0x81, (byte) 0x81}, 0, 2, 1, new byte[]{(byte) 0x81, (byte) 0x81});
        assertByteCount(new byte[]{(byte) 0x81, (byte) 0x81, (byte) 0x81}, 0, 2, 3, new byte[]{(byte) 0x81, (byte) 0x81});
    }
    private static void assertByteCountFailure(String string, int offset, int length, int codePointCount)
    {
        try {
            byteCount(utf8Slice(string), offset, length, codePointCount);
            fail(""Expected exception"");
        }
        catch (IllegalArgumentException expected) {
        }
    }
    private static void assertByteCount(String actual, int offset, int length, int codePointCount, String expected)
    {
        assertByteCount(utf8Slice(actual).getBytes(), offset, length, codePointCount, utf8Slice(expected).getBytes());
    }
    private static void assertByteCount(String actual, int offset, int length, int codePointCount, byte[] expected)
    {
        assertByteCount(utf8Slice(actual).getBytes(), offset, length, codePointCount, expected);
    }
    private static void assertByteCount(byte[] actual, int offset, int length, int codePointCount, byte[] expected)
    {
        Slice slice = wrappedBuffer(actual);
        int truncatedLength = byteCount(slice, offset, length, codePointCount);
        byte[] bytes = slice.getBytes(offset, truncatedLength);
        assertEquals(bytes, expected);
    }
}",class,
"    @Test
    public void testTruncateToLength()
            throws Exception
    {
        // Single byte code points
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), 0), Slices.utf8Slice(""""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), 1), Slices.utf8Slice(""a""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), 4), Slices.utf8Slice(""abc""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abcde""), 5), Slices.utf8Slice(""abcde""));
        // 2 bytes code points
        assertEquals(truncateToLength(Slices.utf8Slice(""абв""), 0), Slices.utf8Slice(""""));
        assertEquals(truncateToLength(Slices.utf8Slice(""абв""), 1), Slices.utf8Slice(""а""));
        assertEquals(truncateToLength(Slices.utf8Slice(""абв""), 4), Slices.utf8Slice(""абв""));
        assertEquals(truncateToLength(Slices.utf8Slice(""абвгд""), 5), Slices.utf8Slice(""абвгд""));
        // 4 bytes code points
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""), 0),
                Slices.utf8Slice(""""));
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""), 1),
                Slices.utf8Slice(""\uD841\uDF0E""));
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79""), 4),
                Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79""));
        assertEquals(truncateToLength(Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""), 5),
                Slices.utf8Slice(""\uD841\uDF0E\uD841\uDF31\uD841\uDF79\uD843\uDC53\uD843\uDC78""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), createVarcharType(1)), Slices.utf8Slice(""a""));
        assertEquals(truncateToLength(Slices.utf8Slice(""abc""), (Type) createVarcharType(1)), Slices.utf8Slice(""a""));
    }",method,
"    @Test
    public void testByteCount()
            throws Exception
    {
        // Single byte code points
        assertByteCount(""abc"", 0, 0, 1, """");
        assertByteCount(""abc"", 0, 1, 0, """");
        assertByteCount(""abc"", 1, 1, 1, ""b"");
        assertByteCount(""abc"", 1, 1, 2, ""b"");
        assertByteCount(""abc"", 1, 2, 1, ""b"");
        assertByteCount(""abc"", 1, 2, 2, ""bc"");
        assertByteCount(""abc"", 1, 2, 3, ""bc"");
        assertByteCount(""abc"", 0, 3, 1, ""a"");
        assertByteCount(""abc"", 0, 3, 5, ""abc"");
        assertByteCountFailure(""abc"", 4, 5, 1);
        assertByteCountFailure(""abc"", 5, 0, 1);
        assertByteCountFailure(""abc"", -1, 1, 1);
        assertByteCountFailure(""abc"", 1, -1, 1);
        assertByteCountFailure(""abc"", 1, 1, -1);
        // 2 bytes code points
        assertByteCount(""абв"", 0, 0, 1, """");
        assertByteCount(""абв"", 0, 1, 0, """");
        assertByteCount(""абв"", 0, 2, 1, ""а"");
        assertByteCount(""абв"", 0, 4, 1, ""а"");
        assertByteCount(""абв"", 0, 1, 1, utf8Slice(""а"").getBytes(0, 1));
        assertByteCount(""абв"", 2, 2, 2, ""б"");
        assertByteCount(""абв"", 2, 2, 0, """");
        assertByteCount(""абв"", 0, 3, 5, utf8Slice(""аб"").getBytes(0, 3));
        assertByteCountFailure(""абв"", 8, 5, 1);
        // we do not check if the offset is in the middle of a code point
        assertByteCount(""абв"", 1, 1, 5, utf8Slice(""а"").getBytes(1, 1));
        assertByteCount(""абв"", 2, 1, 5, utf8Slice(""б"").getBytes(0, 1));
        // 3 bytes code points
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 0, 2, """");
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 1, 1, utf8Slice(""\u6000"").getBytes(0, 1));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 2, 1, utf8Slice(""\u6000"").getBytes(0, 2));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 3, 1, ""\u6000"");
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 6, 1, ""\u6000"");
        assertByteCount(""\u6000\u6001\u6002\u6003"", 6, 2, 4, utf8Slice(""\u6002"").getBytes(0, 2));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 0, 12, 6, ""\u6000\u6001\u6002\u6003"");
        // we do not check if the offset is in the middle of a code point
        assertByteCount(""\u6000\u6001\u6002\u6003"", 1, 6, 2, utf8Slice(""\u6000\u6001\u6002"").getBytes(1, 6));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 2, 6, 2, utf8Slice(""\u6000\u6001\u6002"").getBytes(2, 6));
        assertByteCount(""\u6000\u6001\u6002\u6003"", 3, 6, 2, utf8Slice(""\u6000\u6001\u6002"").getBytes(3, 6));
        assertByteCountFailure(""\u6000\u6001\u6002\u6003"", 21, 0, 1);
        // invalid code points; always return the original lengths unless code point count is 0
        assertByteCount(new byte[]{(byte) 0x81, (byte) 0x81, (byte) 0x81}, 0, 2, 0, new byte[]{});
        assertByteCount(new byte[]{(byte) 0x81, (byte) 0x81, (byte) 0x81}, 0, 2, 1, new byte[]{(byte) 0x81, (byte) 0x81});
        assertByteCount(new byte[]{(byte) 0x81, (byte) 0x81, (byte) 0x81}, 0, 2, 3, new byte[]{(byte) 0x81, (byte) 0x81});
    }",method,
"    private static void assertByteCountFailure(String string, int offset, int length, int codePointCount)
    {
        try {
            byteCount(utf8Slice(string), offset, length, codePointCount);
            fail(""Expected exception"");
        }
        catch (IllegalArgumentException expected) {
        }
    }",method,
"        catch (IllegalArgumentException expected) {
        }",method,
"    private static void assertByteCount(String actual, int offset, int length, int codePointCount, String expected)
    {
        assertByteCount(utf8Slice(actual).getBytes(), offset, length, codePointCount, utf8Slice(expected).getBytes());
    }",method,
"    private static void assertByteCount(String actual, int offset, int length, int codePointCount, byte[] expected)
    {
        assertByteCount(utf8Slice(actual).getBytes(), offset, length, codePointCount, expected);
    }",method,
"    private static void assertByteCount(byte[] actual, int offset, int length, int codePointCount, byte[] expected)
    {
        Slice slice = wrappedBuffer(actual);
        int truncatedLength = byteCount(slice, offset, length, codePointCount);
        byte[] bytes = slice.getBytes(offset, truncatedLength);
        assertEquals(bytes, expected);
    }",method,
"public class BeanDefinitionTests {
	@Test
	public void beanDefinitionEquality() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.setAbstract(true);
		bd.setLazyInit(true);
		bd.setScope(""request"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.setAbstract(true);
		otherBd.setLazyInit(true);
		otherBd.setScope(""request"");
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}
	@Test
	public void beanDefinitionEqualityWithPropertyValues() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getPropertyValues().add(""name"", ""myName"");
		bd.getPropertyValues().add(""age"", ""99"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		otherBd.getPropertyValues().add(""name"", ""myName"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getPropertyValues().add(""age"", ""11"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getPropertyValues().add(""age"", ""99"");
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}
	@Test
	public void beanDefinitionEqualityWithConstructorArguments() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getConstructorArgumentValues().addGenericArgumentValue(""test"");
		bd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		otherBd.getConstructorArgumentValues().addGenericArgumentValue(""test"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(9));
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}
	@Test
	public void beanDefinitionEqualityWithTypedConstructorArguments() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getConstructorArgumentValues().addGenericArgumentValue(""test"", ""int"");
		bd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5), ""long"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		otherBd.getConstructorArgumentValues().addGenericArgumentValue(""test"", ""int"");
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5), ""int"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5), ""long"");
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}
	@Test
	public void beanDefinitionHolderEquality() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.setAbstract(true);
		bd.setLazyInit(true);
		bd.setScope(""request"");
		BeanDefinitionHolder holder = new BeanDefinitionHolder(bd, ""bd"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.setAbstract(true);
		otherBd.setLazyInit(true);
		otherBd.setScope(""request"");
		BeanDefinitionHolder otherHolder = new BeanDefinitionHolder(bd, ""bd"");
		assertTrue(holder.equals(otherHolder));
		assertTrue(otherHolder.equals(holder));
		assertTrue(holder.hashCode() == otherHolder.hashCode());
	}
	@Test
	public void beanDefinitionMerging() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getConstructorArgumentValues().addGenericArgumentValue(""test"");
		bd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		bd.getPropertyValues().add(""name"", ""myName"");
		bd.getPropertyValues().add(""age"", ""99"");
		bd.setQualifiedElement(getClass());
		GenericBeanDefinition childBd = new GenericBeanDefinition();
		childBd.setParentName(""bd"");
		RootBeanDefinition mergedBd = new RootBeanDefinition(bd);
		mergedBd.overrideFrom(childBd);
		assertEquals(2, mergedBd.getConstructorArgumentValues().getArgumentCount());
		assertEquals(2, mergedBd.getPropertyValues().size());
		assertEquals(bd, mergedBd);
		mergedBd.getConstructorArgumentValues().getArgumentValue(1, null).setValue(new Integer(9));
		assertEquals(new Integer(5), bd.getConstructorArgumentValues().getArgumentValue(1, null).getValue());
		assertEquals(getClass(), bd.getQualifiedElement());
	}
}",class,
"	@Test
	public void beanDefinitionEquality() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.setAbstract(true);
		bd.setLazyInit(true);
		bd.setScope(""request"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.setAbstract(true);
		otherBd.setLazyInit(true);
		otherBd.setScope(""request"");
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}",method,
"	@Test
	public void beanDefinitionEqualityWithPropertyValues() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getPropertyValues().add(""name"", ""myName"");
		bd.getPropertyValues().add(""age"", ""99"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		otherBd.getPropertyValues().add(""name"", ""myName"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getPropertyValues().add(""age"", ""11"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getPropertyValues().add(""age"", ""99"");
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}",method,
"	@Test
	public void beanDefinitionEqualityWithConstructorArguments() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getConstructorArgumentValues().addGenericArgumentValue(""test"");
		bd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		otherBd.getConstructorArgumentValues().addGenericArgumentValue(""test"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(9));
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}",method,
"	@Test
	public void beanDefinitionEqualityWithTypedConstructorArguments() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getConstructorArgumentValues().addGenericArgumentValue(""test"", ""int"");
		bd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5), ""long"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		otherBd.getConstructorArgumentValues().addGenericArgumentValue(""test"", ""int"");
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5), ""int"");
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5), ""long"");
		assertTrue(bd.equals(otherBd));
		assertTrue(otherBd.equals(bd));
		assertTrue(bd.hashCode() == otherBd.hashCode());
	}",method,
"	@Test
	public void beanDefinitionHolderEquality() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.setAbstract(true);
		bd.setLazyInit(true);
		bd.setScope(""request"");
		BeanDefinitionHolder holder = new BeanDefinitionHolder(bd, ""bd"");
		RootBeanDefinition otherBd = new RootBeanDefinition(TestBean.class);
		assertTrue(!bd.equals(otherBd));
		assertTrue(!otherBd.equals(bd));
		otherBd.setAbstract(true);
		otherBd.setLazyInit(true);
		otherBd.setScope(""request"");
		BeanDefinitionHolder otherHolder = new BeanDefinitionHolder(bd, ""bd"");
		assertTrue(holder.equals(otherHolder));
		assertTrue(otherHolder.equals(holder));
		assertTrue(holder.hashCode() == otherHolder.hashCode());
	}",method,
"	@Test
	public void beanDefinitionMerging() {
		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
		bd.getConstructorArgumentValues().addGenericArgumentValue(""test"");
		bd.getConstructorArgumentValues().addIndexedArgumentValue(1, new Integer(5));
		bd.getPropertyValues().add(""name"", ""myName"");
		bd.getPropertyValues().add(""age"", ""99"");
		bd.setQualifiedElement(getClass());
		GenericBeanDefinition childBd = new GenericBeanDefinition();
		childBd.setParentName(""bd"");
		RootBeanDefinition mergedBd = new RootBeanDefinition(bd);
		mergedBd.overrideFrom(childBd);
		assertEquals(2, mergedBd.getConstructorArgumentValues().getArgumentCount());
		assertEquals(2, mergedBd.getPropertyValues().size());
		assertEquals(bd, mergedBd);
		mergedBd.getConstructorArgumentValues().getArgumentValue(1, null).setValue(new Integer(9));
		assertEquals(new Integer(5), bd.getConstructorArgumentValues().getArgumentValue(1, null).getValue());
		assertEquals(getClass(), bd.getQualifiedElement());
	}",method,
"public class SingleFieldsVisitor extends FieldsVisitor {
    private String field;
    public SingleFieldsVisitor(String field) {
        super(false);
        this.field = field;
    }
    @Override
    public Status needsField(FieldInfo fieldInfo) throws IOException {
        if (fieldInfo.name.equals(field)) {
            return Status.YES;
        }
        if (fieldInfo.name.equals(UidFieldMapper.NAME)) {
            if (TypeFieldMapper.NAME.equals(field) || IdFieldMapper.NAME.equals(field)) {
                return Status.YES;
            }
        }
        return Status.NO;
    }
    public void reset(String field) {
        this.field = field;
        super.reset();
    }
    @Override
    public void postProcess(MapperService mapperService) {
        super.postProcess(mapperService);
        if (id != null) {
            addValue(IdFieldMapper.NAME, id);
        }
        if (type != null) {
            addValue(TypeFieldMapper.NAME, type);
        }
        if (type != null && id != null) {
            addValue(UidFieldMapper.NAME, Uid.createUid(type, id));
        }
    }
}",class,
"    public SingleFieldsVisitor(String field) {
        super(false);
        this.field = field;
    }",method,
"    @Override
    public Status needsField(FieldInfo fieldInfo) throws IOException {
        if (fieldInfo.name.equals(field)) {
            return Status.YES;
        }
        if (fieldInfo.name.equals(UidFieldMapper.NAME)) {
            if (TypeFieldMapper.NAME.equals(field) || IdFieldMapper.NAME.equals(field)) {
                return Status.YES;
            }
        }
        return Status.NO;
    }",method,
"    public void reset(String field) {
        this.field = field;
        super.reset();
    }",method,
"    @Override
    public void postProcess(MapperService mapperService) {
        super.postProcess(mapperService);
        if (id != null) {
            addValue(IdFieldMapper.NAME, id);
        }
        if (type != null) {
            addValue(TypeFieldMapper.NAME, type);
        }
        if (type != null && id != null) {
            addValue(UidFieldMapper.NAME, Uid.createUid(type, id));
        }
    }",method,
"        if (id != null) {
            addValue(IdFieldMapper.NAME, id);
        }",method,
"        if (type != null) {
            addValue(TypeFieldMapper.NAME, type);
        }",method,
"        if (type != null && id != null) {
            addValue(UidFieldMapper.NAME, Uid.createUid(type, id));
        }",method,
"public class BackupEngineTest {
  @ClassRule
  public static final RocksMemoryResource rocksMemoryResource =
      new RocksMemoryResource();
  @Rule
  public TemporaryFolder dbFolder = new TemporaryFolder();
  @Rule
  public TemporaryFolder backupFolder = new TemporaryFolder();
  @Test
  public void backupDb() throws RocksDBException {
    // Open empty database.
    try(final Options opt = new Options().setCreateIfMissing(true);
        final RocksDB db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath())) {
      // Fill database with some test values
      prepareDatabase(db);
      // Create two backups
      try(final BackupableDBOptions bopt = new BackupableDBOptions(
          backupFolder.getRoot().getAbsolutePath());
          final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
        be.createNewBackup(db, false);
        be.createNewBackup(db, true);
        verifyNumberOfValidBackups(be, 2);
      }
    }
  }
  @Test
  public void deleteBackup() throws RocksDBException {
    // Open empty database.
    try(final Options opt = new Options().setCreateIfMissing(true);
        final RocksDB db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath())) {
      // Fill database with some test values
      prepareDatabase(db);
      // Create two backups
      try(final BackupableDBOptions bopt = new BackupableDBOptions(
          backupFolder.getRoot().getAbsolutePath());
          final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
        be.createNewBackup(db, false);
        be.createNewBackup(db, true);
        final List<BackupInfo> backupInfo =
            verifyNumberOfValidBackups(be, 2);
        // Delete the first backup
        be.deleteBackup(backupInfo.get(0).backupId());
        final List<BackupInfo> newBackupInfo =
            verifyNumberOfValidBackups(be, 1);
        // The second backup must remain.
        assertThat(newBackupInfo.get(0).backupId()).
            isEqualTo(backupInfo.get(1).backupId());
      }
    }
  }
  @Test
  public void purgeOldBackups() throws RocksDBException {
    // Open empty database.
    try(final Options opt = new Options().setCreateIfMissing(true);
        final RocksDB db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath())) {
      // Fill database with some test values
      prepareDatabase(db);
      // Create four backups
      try(final BackupableDBOptions bopt = new BackupableDBOptions(
          backupFolder.getRoot().getAbsolutePath());
          final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
        be.createNewBackup(db, false);
        be.createNewBackup(db, true);
        be.createNewBackup(db, true);
        be.createNewBackup(db, true);
        final List<BackupInfo> backupInfo =
            verifyNumberOfValidBackups(be, 4);
        // Delete everything except the latest backup
        be.purgeOldBackups(1);
        final List<BackupInfo> newBackupInfo =
            verifyNumberOfValidBackups(be, 1);
        // The latest backup must remain.
        assertThat(newBackupInfo.get(0).backupId()).
            isEqualTo(backupInfo.get(3).backupId());
      }
    }
  }
  @Test
  public void restoreLatestBackup() throws RocksDBException {
    try(final Options opt = new Options().setCreateIfMissing(true)) {
      // Open empty database.
      RocksDB db = null;
      try {
        db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath());
        // Fill database with some test values
        prepareDatabase(db);
        try (final BackupableDBOptions bopt = new BackupableDBOptions(
            backupFolder.getRoot().getAbsolutePath());
             final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 1);
          db.put(""key1"".getBytes(), ""valueV2"".getBytes());
          db.put(""key2"".getBytes(), ""valueV2"".getBytes());
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 2);
          db.put(""key1"".getBytes(), ""valueV3"".getBytes());
          db.put(""key2"".getBytes(), ""valueV3"".getBytes());
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V3"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V3"");
          db.close();
          db = null;
          verifyNumberOfValidBackups(be, 2);
          // restore db from latest backup
          try(final RestoreOptions ropts = new RestoreOptions(false)) {
            be.restoreDbFromLatestBackup(dbFolder.getRoot().getAbsolutePath(),
                dbFolder.getRoot().getAbsolutePath(), ropts);
          }
          // Open database again.
          db = RocksDB.open(opt, dbFolder.getRoot().getAbsolutePath());
          // Values must have suffix V2 because of restoring latest backup.
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V2"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V2"");
        }
      } finally {
        if(db != null) {
          db.close();
        }
      }
    }
  }
  @Test
  public void restoreFromBackup()
      throws RocksDBException {
    try(final Options opt = new Options().setCreateIfMissing(true)) {
      RocksDB db = null;
      try {
        // Open empty database.
        db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath());
        // Fill database with some test values
        prepareDatabase(db);
        try (final BackupableDBOptions bopt = new BackupableDBOptions(
            backupFolder.getRoot().getAbsolutePath());
             final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 1);
          db.put(""key1"".getBytes(), ""valueV2"".getBytes());
          db.put(""key2"".getBytes(), ""valueV2"".getBytes());
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 2);
          db.put(""key1"".getBytes(), ""valueV3"".getBytes());
          db.put(""key2"".getBytes(), ""valueV3"".getBytes());
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V3"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V3"");
          //close the database
          db.close();
          db = null;
          //restore the backup
          final List<BackupInfo> backupInfo = verifyNumberOfValidBackups(be, 2);
          // restore db from first backup
          be.restoreDbFromBackup(backupInfo.get(0).backupId(),
              dbFolder.getRoot().getAbsolutePath(),
              dbFolder.getRoot().getAbsolutePath(),
              new RestoreOptions(false));
          // Open database again.
          db = RocksDB.open(opt,
              dbFolder.getRoot().getAbsolutePath());
          // Values must have suffix V2 because of restoring latest backup.
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V1"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V1"");
        }
      } finally {
        if(db != null) {
          db.close();
        }
      }
    }
  }
  private List<BackupInfo> verifyNumberOfValidBackups(final BackupEngine be,
      final int expectedNumberOfBackups) throws RocksDBException {
    // Verify that backups exist
    assertThat(be.getCorruptedBackups().length).
        isEqualTo(0);
    be.garbageCollect();
    final List<BackupInfo> backupInfo = be.getBackupInfo();
    assertThat(backupInfo.size()).
        isEqualTo(expectedNumberOfBackups);
    return backupInfo;
  }
  private void prepareDatabase(final RocksDB db)
      throws RocksDBException {
    db.put(""key1"".getBytes(), ""valueV1"".getBytes());
    db.put(""key2"".getBytes(), ""valueV1"".getBytes());
  }
}",class,
"  @Test
  public void backupDb() throws RocksDBException {
    // Open empty database.
    try(final Options opt = new Options().setCreateIfMissing(true);
        final RocksDB db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath())) {
      // Fill database with some test values
      prepareDatabase(db);
      // Create two backups
      try(final BackupableDBOptions bopt = new BackupableDBOptions(
          backupFolder.getRoot().getAbsolutePath());
          final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
        be.createNewBackup(db, false);
        be.createNewBackup(db, true);
        verifyNumberOfValidBackups(be, 2);
      }
    }
  }",method,
"  @Test
  public void deleteBackup() throws RocksDBException {
    // Open empty database.
    try(final Options opt = new Options().setCreateIfMissing(true);
        final RocksDB db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath())) {
      // Fill database with some test values
      prepareDatabase(db);
      // Create two backups
      try(final BackupableDBOptions bopt = new BackupableDBOptions(
          backupFolder.getRoot().getAbsolutePath());
          final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
        be.createNewBackup(db, false);
        be.createNewBackup(db, true);
        final List<BackupInfo> backupInfo =
            verifyNumberOfValidBackups(be, 2);
        // Delete the first backup
        be.deleteBackup(backupInfo.get(0).backupId());
        final List<BackupInfo> newBackupInfo =
            verifyNumberOfValidBackups(be, 1);
        // The second backup must remain.
        assertThat(newBackupInfo.get(0).backupId()).
            isEqualTo(backupInfo.get(1).backupId());
      }
    }
  }",method,
"  @Test
  public void purgeOldBackups() throws RocksDBException {
    // Open empty database.
    try(final Options opt = new Options().setCreateIfMissing(true);
        final RocksDB db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath())) {
      // Fill database with some test values
      prepareDatabase(db);
      // Create four backups
      try(final BackupableDBOptions bopt = new BackupableDBOptions(
          backupFolder.getRoot().getAbsolutePath());
          final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
        be.createNewBackup(db, false);
        be.createNewBackup(db, true);
        be.createNewBackup(db, true);
        be.createNewBackup(db, true);
        final List<BackupInfo> backupInfo =
            verifyNumberOfValidBackups(be, 4);
        // Delete everything except the latest backup
        be.purgeOldBackups(1);
        final List<BackupInfo> newBackupInfo =
            verifyNumberOfValidBackups(be, 1);
        // The latest backup must remain.
        assertThat(newBackupInfo.get(0).backupId()).
            isEqualTo(backupInfo.get(3).backupId());
      }
    }
  }",method,
"  @Test
  public void restoreLatestBackup() throws RocksDBException {
    try(final Options opt = new Options().setCreateIfMissing(true)) {
      // Open empty database.
      RocksDB db = null;
      try {
        db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath());
        // Fill database with some test values
        prepareDatabase(db);
        try (final BackupableDBOptions bopt = new BackupableDBOptions(
            backupFolder.getRoot().getAbsolutePath());
             final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 1);
          db.put(""key1"".getBytes(), ""valueV2"".getBytes());
          db.put(""key2"".getBytes(), ""valueV2"".getBytes());
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 2);
          db.put(""key1"".getBytes(), ""valueV3"".getBytes());
          db.put(""key2"".getBytes(), ""valueV3"".getBytes());
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V3"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V3"");
          db.close();
          db = null;
          verifyNumberOfValidBackups(be, 2);
          // restore db from latest backup
          try(final RestoreOptions ropts = new RestoreOptions(false)) {
            be.restoreDbFromLatestBackup(dbFolder.getRoot().getAbsolutePath(),
                dbFolder.getRoot().getAbsolutePath(), ropts);
          }
          // Open database again.
          db = RocksDB.open(opt, dbFolder.getRoot().getAbsolutePath());
          // Values must have suffix V2 because of restoring latest backup.
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V2"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V2"");
        }
      } finally {
        if(db != null) {
          db.close();
        }
      }
    }
  }",method,
"        if(db != null) {
          db.close();
        }",method,
"  @Test
  public void restoreFromBackup()
      throws RocksDBException {
    try(final Options opt = new Options().setCreateIfMissing(true)) {
      RocksDB db = null;
      try {
        // Open empty database.
        db = RocksDB.open(opt,
            dbFolder.getRoot().getAbsolutePath());
        // Fill database with some test values
        prepareDatabase(db);
        try (final BackupableDBOptions bopt = new BackupableDBOptions(
            backupFolder.getRoot().getAbsolutePath());
             final BackupEngine be = BackupEngine.open(opt.getEnv(), bopt)) {
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 1);
          db.put(""key1"".getBytes(), ""valueV2"".getBytes());
          db.put(""key2"".getBytes(), ""valueV2"".getBytes());
          be.createNewBackup(db, true);
          verifyNumberOfValidBackups(be, 2);
          db.put(""key1"".getBytes(), ""valueV3"".getBytes());
          db.put(""key2"".getBytes(), ""valueV3"".getBytes());
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V3"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V3"");
          //close the database
          db.close();
          db = null;
          //restore the backup
          final List<BackupInfo> backupInfo = verifyNumberOfValidBackups(be, 2);
          // restore db from first backup
          be.restoreDbFromBackup(backupInfo.get(0).backupId(),
              dbFolder.getRoot().getAbsolutePath(),
              dbFolder.getRoot().getAbsolutePath(),
              new RestoreOptions(false));
          // Open database again.
          db = RocksDB.open(opt,
              dbFolder.getRoot().getAbsolutePath());
          // Values must have suffix V2 because of restoring latest backup.
          assertThat(new String(db.get(""key1"".getBytes()))).endsWith(""V1"");
          assertThat(new String(db.get(""key2"".getBytes()))).endsWith(""V1"");
        }
      } finally {
        if(db != null) {
          db.close();
        }
      }
    }
  }",method,
"        if(db != null) {
          db.close();
        }",method,
"  private List<BackupInfo> verifyNumberOfValidBackups(final BackupEngine be,
      final int expectedNumberOfBackups) throws RocksDBException {
    // Verify that backups exist
    assertThat(be.getCorruptedBackups().length).
        isEqualTo(0);
    be.garbageCollect();
    final List<BackupInfo> backupInfo = be.getBackupInfo();
    assertThat(backupInfo.size()).
        isEqualTo(expectedNumberOfBackups);
    return backupInfo;
  }",method,
"  private void prepareDatabase(final RocksDB db)
      throws RocksDBException {
    db.put(""key1"".getBytes(), ""valueV1"".getBytes());
    db.put(""key2"".getBytes(), ""valueV1"".getBytes());
  }",method,
"public class AndroidInstrumentationTestDescription
    implements Description<AndroidInstrumentationTestDescriptionArg> {
  private final JavaOptions javaOptions;
  private final Optional<Long> defaultTestRuleTimeoutMs;
  private final ConcurrentHashMap<ProjectFilesystem, ConcurrentHashMap<String, PackagedResource>>
      resourceSupplierCache;
  public AndroidInstrumentationTestDescription(
      JavaOptions javaOptions, Optional<Long> defaultTestRuleTimeoutMs) {
    this.javaOptions = javaOptions;
    this.defaultTestRuleTimeoutMs = defaultTestRuleTimeoutMs;
    this.resourceSupplierCache = new ConcurrentHashMap<>();
  }
  @Override
  public Class<AndroidInstrumentationTestDescriptionArg> getConstructorArgType() {
    return AndroidInstrumentationTestDescriptionArg.class;
  }
  @Override
  public AndroidInstrumentationTest createBuildRule(
      TargetGraph targetGraph,
      BuildTarget buildTarget,
      ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CellPathResolver cellRoots,
      AndroidInstrumentationTestDescriptionArg args) {
    BuildRule apk = resolver.getRule(args.getApk());
    if (!(apk instanceof HasInstallableApk)) {
      throw new HumanReadableException(
          ""In %s, instrumentation_apk='%s' must be an android_binary(), apk_genrule() or ""
              + ""android_instrumentation_apk(), but was %s()."",
          buildTarget, apk.getFullyQualifiedName(), apk.getType());
    }
    return new AndroidInstrumentationTest(
        buildTarget,
        projectFilesystem,
        params.copyAppendingExtraDeps(BuildRules.getExportedRules(params.getDeclaredDeps().get())),
        (HasInstallableApk) apk,
        args.getLabels(),
        args.getContacts(),
        javaOptions.getJavaRuntimeLauncher(),
        args.getTestRuleTimeoutMs().map(Optional::of).orElse(defaultTestRuleTimeoutMs),
        getRelativePackagedResource(projectFilesystem, ""ddmlib.jar""),
        getRelativePackagedResource(projectFilesystem, ""kxml2.jar""),
        getRelativePackagedResource(projectFilesystem, ""guava.jar""),
        getRelativePackagedResource(projectFilesystem, ""android-tools-common.jar""));
  }
  private PackagedResource getRelativePackagedResource(
      ProjectFilesystem projectFilesystem, String resourceName) {
    return resourceSupplierCache
        .computeIfAbsent(projectFilesystem, fs -> new ConcurrentHashMap<>())
        .computeIfAbsent(
            resourceName,
            resource ->
                new PackagedResource(
                    projectFilesystem, AndroidInstrumentationTestDescription.class, resource));
  }
  @BuckStyleImmutable
  @Value.Immutable
  interface AbstractAndroidInstrumentationTestDescriptionArg
      extends CommonDescriptionArg, HasContacts, HasTestTimeout {
    BuildTarget getApk();
  }
}",class,
"  public AndroidInstrumentationTestDescription(
      JavaOptions javaOptions, Optional<Long> defaultTestRuleTimeoutMs) {
    this.javaOptions = javaOptions;
    this.defaultTestRuleTimeoutMs = defaultTestRuleTimeoutMs;
    this.resourceSupplierCache = new ConcurrentHashMap<>();
  }",method,
"  @Override
  public Class<AndroidInstrumentationTestDescriptionArg> getConstructorArgType() {
    return AndroidInstrumentationTestDescriptionArg.class;
  }",method,
"  @Override
  public AndroidInstrumentationTest createBuildRule(
      TargetGraph targetGraph,
      BuildTarget buildTarget,
      ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CellPathResolver cellRoots,
      AndroidInstrumentationTestDescriptionArg args) {
    BuildRule apk = resolver.getRule(args.getApk());
    if (!(apk instanceof HasInstallableApk)) {
      throw new HumanReadableException(
          ""In %s, instrumentation_apk='%s' must be an android_binary(), apk_genrule() or ""
              + ""android_instrumentation_apk(), but was %s()."",
          buildTarget, apk.getFullyQualifiedName(), apk.getType());
    }
    return new AndroidInstrumentationTest(
        buildTarget,
        projectFilesystem,
        params.copyAppendingExtraDeps(BuildRules.getExportedRules(params.getDeclaredDeps().get())),
        (HasInstallableApk) apk,
        args.getLabels(),
        args.getContacts(),
        javaOptions.getJavaRuntimeLauncher(),
        args.getTestRuleTimeoutMs().map(Optional::of).orElse(defaultTestRuleTimeoutMs),
        getRelativePackagedResource(projectFilesystem, ""ddmlib.jar""),
        getRelativePackagedResource(projectFilesystem, ""kxml2.jar""),
        getRelativePackagedResource(projectFilesystem, ""guava.jar""),
        getRelativePackagedResource(projectFilesystem, ""android-tools-common.jar""));
  }",method,
"  private PackagedResource getRelativePackagedResource(
      ProjectFilesystem projectFilesystem, String resourceName) {
    return resourceSupplierCache
        .computeIfAbsent(projectFilesystem, fs -> new ConcurrentHashMap<>())
        .computeIfAbsent(
            resourceName,
            resource ->
                new PackagedResource(
                    projectFilesystem, AndroidInstrumentationTestDescription.class, resource));
  }",method,
"public class BuildFileProjectSpec extends AbstractProjectSpec {
    private final File buildFile;
    public BuildFileProjectSpec(File buildFile) {
        this.buildFile = buildFile;
    }
    protected String formatNoMatchesMessage() {
        return String.format(""No projects in this build have build file '%s'."", buildFile);
    }
    protected String formatMultipleMatchesMessage(Iterable<? extends ProjectIdentifier> matches) {
        return String.format(""Multiple projects in this build have build file '%s': %s"", buildFile, matches);
    }
    @Override
    protected <T extends ProjectIdentifier> void select(ProjectRegistry<? extends T> candidates, List<? super T> matches) {
        for (T candidate : candidates.getAllProjects()) {
            if (candidate.getBuildFile().equals(buildFile)) {
                matches.add(candidate);
            }
        }
    }
    @Override
    protected void checkPreconditions(ProjectRegistry<?> registry) {
        if (!buildFile.exists()) {
            throw new InvalidUserDataException(String.format(""Build file '%s' does not exist."", buildFile));
        }
        if (!buildFile.isFile()) {
            throw new InvalidUserDataException(String.format(""Build file '%s' is not a file."", buildFile));
        }
    }
}",class,
"    public BuildFileProjectSpec(File buildFile) {
        this.buildFile = buildFile;
    }",method,
"    protected String formatNoMatchesMessage() {
        return String.format(""No projects in this build have build file '%s'."", buildFile);
    }",method,
"    protected String formatMultipleMatchesMessage(Iterable<? extends ProjectIdentifier> matches) {
        return String.format(""Multiple projects in this build have build file '%s': %s"", buildFile, matches);
    }",method,
"    @Override
    protected <T extends ProjectIdentifier> void select(ProjectRegistry<? extends T> candidates, List<? super T> matches) {
        for (T candidate : candidates.getAllProjects()) {
            if (candidate.getBuildFile().equals(buildFile)) {
                matches.add(candidate);
            }
        }
    }",method,
"    @Override
    protected void checkPreconditions(ProjectRegistry<?> registry) {
        if (!buildFile.exists()) {
            throw new InvalidUserDataException(String.format(""Build file '%s' does not exist."", buildFile));
        }
        if (!buildFile.isFile()) {
            throw new InvalidUserDataException(String.format(""Build file '%s' is not a file."", buildFile));
        }
    }",method,
"public class IntentFilterVerificationState {
    static final String TAG = IntentFilterVerificationState.class.getName();
    public final static int STATE_UNDEFINED = 0;
    public final static int STATE_VERIFICATION_PENDING = 1;
    public final static int STATE_VERIFICATION_SUCCESS = 2;
    public final static int STATE_VERIFICATION_FAILURE = 3;
    private int mRequiredVerifierUid = 0;
    private int mState;
    private ArrayList<PackageParser.ActivityIntentInfo> mFilters = new ArrayList<>();
    private ArraySet<String> mHosts = new ArraySet<>();
    private int mUserId;
    private String mPackageName;
    private boolean mVerificationComplete;
    public IntentFilterVerificationState(int verifierUid, int userId, String packageName) {
        mRequiredVerifierUid = verifierUid;
        mUserId = userId;
        mPackageName = packageName;
        mState = STATE_UNDEFINED;
        mVerificationComplete = false;
    }
    public void setState(int state) {
        if (state > STATE_VERIFICATION_FAILURE || state < STATE_UNDEFINED) {
            mState = STATE_UNDEFINED;
        } else {
            mState = state;
        }
    }
    public int getState() {
        return mState;
    }
    public void setPendingState() {
        setState(STATE_VERIFICATION_PENDING);
    }
    public ArrayList<PackageParser.ActivityIntentInfo> getFilters() {
        return mFilters;
    }
    public boolean isVerificationComplete() {
        return mVerificationComplete;
    }
    public boolean isVerified() {
        if (mVerificationComplete) {
            return (mState == STATE_VERIFICATION_SUCCESS);
        }
        return false;
    }
    public int getUserId() {
        return mUserId;
    }
    public String getPackageName() {
        return mPackageName;
    }
    public String getHostsString() {
        StringBuilder sb = new StringBuilder();
        final int count = mHosts.size();
        for (int i=0; i<count; i++) {
            if (i > 0) {
                sb.append("" "");
            }
            String host = mHosts.valueAt(i);
            // ""*.example.tld"" is validated via https://example.tld
            if (host.startsWith(""*."")) {
                host = host.substring(2);
            }
            sb.append(host);
        }
        return sb.toString();
    }
    public boolean setVerifierResponse(int callerUid, int code) {
        if (mRequiredVerifierUid == callerUid) {
            int state = STATE_UNDEFINED;
            if (code == PackageManager.INTENT_FILTER_VERIFICATION_SUCCESS) {
                state = STATE_VERIFICATION_SUCCESS;
            } else if (code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                state = STATE_VERIFICATION_FAILURE;
            }
            mVerificationComplete = true;
            setState(state);
            return true;
        }
        Slog.d(TAG, ""Cannot set verifier response with callerUid:"" + callerUid + "" and code:"" +
                code + "" as required verifierUid is:"" + mRequiredVerifierUid);
        return false;
    }
    public void addFilter(PackageParser.ActivityIntentInfo filter) {
        mFilters.add(filter);
        mHosts.addAll(filter.getHostsList());
    }
}",class,
"    public IntentFilterVerificationState(int verifierUid, int userId, String packageName) {
        mRequiredVerifierUid = verifierUid;
        mUserId = userId;
        mPackageName = packageName;
        mState = STATE_UNDEFINED;
        mVerificationComplete = false;
    }",method,
"    public void setState(int state) {
        if (state > STATE_VERIFICATION_FAILURE || state < STATE_UNDEFINED) {
            mState = STATE_UNDEFINED;
        } else {
            mState = state;
        }
    }",method,
"        if (state > STATE_VERIFICATION_FAILURE || state < STATE_UNDEFINED) {
            mState = STATE_UNDEFINED;
        }",method,
"    public int getState() {
        return mState;
    }",method,
"    public void setPendingState() {
        setState(STATE_VERIFICATION_PENDING);
    }",method,
"    public ArrayList<PackageParser.ActivityIntentInfo> getFilters() {
        return mFilters;
    }",method,
"    public boolean isVerificationComplete() {
        return mVerificationComplete;
    }",method,
"    public boolean isVerified() {
        if (mVerificationComplete) {
            return (mState == STATE_VERIFICATION_SUCCESS);
        }
        return false;
    }",method,

code_snippet,type,score
"public class MaterialShowcaseDrawer implements ShowcaseDrawer {
    private final float radius;
    private final Paint basicPaint;
    private final Paint eraserPaint;
    private int backgroundColor;
    public MaterialShowcaseDrawer(Resources resources) {
        this.radius = resources.getDimension(R.dimen.showcase_radius_material);
        this.eraserPaint = new Paint();
        this.eraserPaint.setColor(0xFFFFFF);
        this.eraserPaint.setAlpha(0);
        this.eraserPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));
        this.eraserPaint.setAntiAlias(true);
        this.basicPaint = new Paint();
    }
    @Override
    public void setShowcaseColour(int color) {
        // no-op
    }
    @Override
    public void drawShowcase(Bitmap buffer, float x, float y, float scaleMultiplier) {
        Canvas bufferCanvas = new Canvas(buffer);
        bufferCanvas.drawCircle(x, y, radius, eraserPaint);
    }
    @Override
    public int getShowcaseWidth() {
        return (int) (radius * 2);
    }
    @Override
    public int getShowcaseHeight() {
        return (int) (radius * 2);
    }
    @Override
    public float getBlockedRadius() {
        return radius;
    }
    @Override
    public void setBackgroundColour(int backgroundColor) {
        this.backgroundColor = backgroundColor;
    }
    @Override
    public void erase(Bitmap bitmapBuffer) {
        bitmapBuffer.eraseColor(backgroundColor);
    }
    @Override
    public void drawToCanvas(Canvas canvas, Bitmap bitmapBuffer) {
        canvas.drawBitmap(bitmapBuffer, 0, 0, basicPaint);
    }
}",class,
"    public MaterialShowcaseDrawer(Resources resources) {
        this.radius = resources.getDimension(R.dimen.showcase_radius_material);
        this.eraserPaint = new Paint();
        this.eraserPaint.setColor(0xFFFFFF);
        this.eraserPaint.setAlpha(0);
        this.eraserPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));
        this.eraserPaint.setAntiAlias(true);
        this.basicPaint = new Paint();
    }",method,
"    @Override
    public void setShowcaseColour(int color) {
        // no-op
    }",method,
"    @Override
    public void drawShowcase(Bitmap buffer, float x, float y, float scaleMultiplier) {
        Canvas bufferCanvas = new Canvas(buffer);
        bufferCanvas.drawCircle(x, y, radius, eraserPaint);
    }",method,
"    @Override
    public int getShowcaseWidth() {
        return (int) (radius * 2);
    }",method,
"    @Override
    public int getShowcaseHeight() {
        return (int) (radius * 2);
    }",method,
"    @Override
    public float getBlockedRadius() {
        return radius;
    }",method,
"    @Override
    public void setBackgroundColour(int backgroundColor) {
        this.backgroundColor = backgroundColor;
    }",method,
"    @Override
    public void erase(Bitmap bitmapBuffer) {
        bitmapBuffer.eraseColor(backgroundColor);
    }",method,
"    @Override
    public void drawToCanvas(Canvas canvas, Bitmap bitmapBuffer) {
        canvas.drawBitmap(bitmapBuffer, 0, 0, basicPaint);
    }",method,
"public class FirstPersonCameraController extends InputAdapter {
	private final Camera camera;
	private final IntIntMap keys = new IntIntMap();
	private int STRAFE_LEFT = Keys.A;
	private int STRAFE_RIGHT = Keys.D;
	private int FORWARD = Keys.W;
	private int BACKWARD = Keys.S;
	private int UP = Keys.Q;
	private int DOWN = Keys.E;
	private float velocity = 5;
	private float degreesPerPixel = 0.5f;
	private final Vector3 tmp = new Vector3();
	public FirstPersonCameraController (Camera camera) {
		this.camera = camera;
	}
	@Override
	public boolean keyDown (int keycode) {
		keys.put(keycode, keycode);
		return true;
	}
	@Override
	public boolean keyUp (int keycode) {
		keys.remove(keycode, 0);
		return true;
	}
	public void setVelocity (float velocity) {
		this.velocity = velocity;
	}
	public void setDegreesPerPixel (float degreesPerPixel) {
		this.degreesPerPixel = degreesPerPixel;
	}
	@Override
	public boolean touchDragged (int screenX, int screenY, int pointer) {
		float deltaX = -Gdx.input.getDeltaX() * degreesPerPixel;
		float deltaY = -Gdx.input.getDeltaY() * degreesPerPixel;
		camera.direction.rotate(camera.up, deltaX);
		tmp.set(camera.direction).crs(camera.up).nor();
		camera.direction.rotate(tmp, deltaY);
// camera.up.rotate(tmp, deltaY);
		return true;
	}
	public void update () {
		update(Gdx.graphics.getDeltaTime());
	}
	public void update (float deltaTime) {
		if (keys.containsKey(FORWARD)) {
			tmp.set(camera.direction).nor().scl(deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(BACKWARD)) {
			tmp.set(camera.direction).nor().scl(-deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(STRAFE_LEFT)) {
			tmp.set(camera.direction).crs(camera.up).nor().scl(-deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(STRAFE_RIGHT)) {
			tmp.set(camera.direction).crs(camera.up).nor().scl(deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(UP)) {
			tmp.set(camera.up).nor().scl(deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(DOWN)) {
			tmp.set(camera.up).nor().scl(-deltaTime * velocity);
			camera.position.add(tmp);
		}
		camera.update(true);
	}
}",class,
"	public FirstPersonCameraController (Camera camera) {
		this.camera = camera;
	}",method,
"	@Override
	public boolean keyDown (int keycode) {
		keys.put(keycode, keycode);
		return true;
	}",method,
"	@Override
	public boolean keyUp (int keycode) {
		keys.remove(keycode, 0);
		return true;
	}",method,
"	public void setVelocity (float velocity) {
		this.velocity = velocity;
	}",method,
"	public void setDegreesPerPixel (float degreesPerPixel) {
		this.degreesPerPixel = degreesPerPixel;
	}",method,
"	@Override
	public boolean touchDragged (int screenX, int screenY, int pointer) {
		float deltaX = -Gdx.input.getDeltaX() * degreesPerPixel;
		float deltaY = -Gdx.input.getDeltaY() * degreesPerPixel;
		camera.direction.rotate(camera.up, deltaX);
		tmp.set(camera.direction).crs(camera.up).nor();
		camera.direction.rotate(tmp, deltaY);
// camera.up.rotate(tmp, deltaY);
		return true;
	}",method,
"	public void update () {
		update(Gdx.graphics.getDeltaTime());
	}",method,
"	public void update (float deltaTime) {
		if (keys.containsKey(FORWARD)) {
			tmp.set(camera.direction).nor().scl(deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(BACKWARD)) {
			tmp.set(camera.direction).nor().scl(-deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(STRAFE_LEFT)) {
			tmp.set(camera.direction).crs(camera.up).nor().scl(-deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(STRAFE_RIGHT)) {
			tmp.set(camera.direction).crs(camera.up).nor().scl(deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(UP)) {
			tmp.set(camera.up).nor().scl(deltaTime * velocity);
			camera.position.add(tmp);
		}
		if (keys.containsKey(DOWN)) {
			tmp.set(camera.up).nor().scl(-deltaTime * velocity);
			camera.position.add(tmp);
		}
		camera.update(true);
	}",method,
"public class DoubleKeyValueMap<K1, K2, V> {
    private ConcurrentHashMap<K1, ConcurrentHashMap<K2, V>> k1_k2V_map;
    public DoubleKeyValueMap() {
        this.k1_k2V_map = new ConcurrentHashMap<K1, ConcurrentHashMap<K2, V>>();
    }
    public void put(K1 key1, K2 key2, V value) {
        if (key1 == null || key2 == null || value == null) return;
        if (k1_k2V_map.containsKey(key1)) {
            ConcurrentHashMap<K2, V> k2V_map = k1_k2V_map.get(key1);
            if (k2V_map != null) {
                k2V_map.put(key2, value);
            } else {
                k2V_map = new ConcurrentHashMap<K2, V>();
                k2V_map.put(key2, value);
                k1_k2V_map.put(key1, k2V_map);
            }
        } else {
            ConcurrentHashMap<K2, V> k2V_map = new ConcurrentHashMap<K2, V>();
            k2V_map.put(key2, value);
            k1_k2V_map.put(key1, k2V_map);
        }
    }
    public Set<K1> getFirstKeys() {
        return k1_k2V_map.keySet();
    }
    public ConcurrentHashMap<K2, V> get(K1 key1) {
        return k1_k2V_map.get(key1);
    }
    public V get(K1 key1, K2 key2) {
        ConcurrentHashMap<K2, V> k2_v = k1_k2V_map.get(key1);
        return k2_v == null ? null : k2_v.get(key2);
    }
    public Collection<V> getAllValues(K1 key1) {
        ConcurrentHashMap<K2, V> k2_v = k1_k2V_map.get(key1);
        return k2_v == null ? null : k2_v.values();
    }
    public Collection<V> getAllValues() {
        Collection<V> result = null;
        Set<K1> k1Set = k1_k2V_map.keySet();
        if (k1Set != null) {
            result = new ArrayList<V>();
            for (K1 k1 : k1Set) {
                Collection<V> values = k1_k2V_map.get(k1).values();
                if (values != null) {
                    result.addAll(values);
                }
            }
        }
        return result;
    }
    public boolean containsKey(K1 key1, K2 key2) {
        if (k1_k2V_map.containsKey(key1)) {
            return k1_k2V_map.get(key1).containsKey(key2);
        }
        return false;
    }
    public boolean containsKey(K1 key1) {
        return k1_k2V_map.containsKey(key1);
    }
    public int size() {
        if (k1_k2V_map.size() == 0) return 0;
        int result = 0;
        for (ConcurrentHashMap<K2, V> k2V_map : k1_k2V_map.values()) {
            result += k2V_map.size();
        }
        return result;
    }
    public void remove(K1 key1) {
        k1_k2V_map.remove(key1);
    }
    public void remove(K1 key1, K2 key2) {
        ConcurrentHashMap<K2, V> k2_v = k1_k2V_map.get(key1);
        if (k2_v != null) {
            k2_v.remove(key2);
        }
    }
    public void clear() {
        if (k1_k2V_map.size() > 0) {
            for (ConcurrentHashMap<K2, V> k2V_map : k1_k2V_map.values()) {
                k2V_map.clear();
            }
            k1_k2V_map.clear();
        }
    }
}",class,
"    public DoubleKeyValueMap() {
        this.k1_k2V_map = new ConcurrentHashMap<K1, ConcurrentHashMap<K2, V>>();
    }",method,
"    public void put(K1 key1, K2 key2, V value) {
        if (key1 == null || key2 == null || value == null) return;
        if (k1_k2V_map.containsKey(key1)) {
            ConcurrentHashMap<K2, V> k2V_map = k1_k2V_map.get(key1);
            if (k2V_map != null) {
                k2V_map.put(key2, value);
            } else {
                k2V_map = new ConcurrentHashMap<K2, V>();
                k2V_map.put(key2, value);
                k1_k2V_map.put(key1, k2V_map);
            }
        } else {
            ConcurrentHashMap<K2, V> k2V_map = new ConcurrentHashMap<K2, V>();
            k2V_map.put(key2, value);
            k1_k2V_map.put(key1, k2V_map);
        }
    }",method,
"            if (k2V_map != null) {
                k2V_map.put(key2, value);
            }",method,
"    public Set<K1> getFirstKeys() {
        return k1_k2V_map.keySet();
    }",method,
"    public ConcurrentHashMap<K2, V> get(K1 key1) {
        return k1_k2V_map.get(key1);
    }",method,
"    public V get(K1 key1, K2 key2) {
        ConcurrentHashMap<K2, V> k2_v = k1_k2V_map.get(key1);
        return k2_v == null ? null : k2_v.get(key2);
    }",method,
"    public Collection<V> getAllValues(K1 key1) {
        ConcurrentHashMap<K2, V> k2_v = k1_k2V_map.get(key1);
        return k2_v == null ? null : k2_v.values();
    }",method,
"    public Collection<V> getAllValues() {
        Collection<V> result = null;
        Set<K1> k1Set = k1_k2V_map.keySet();
        if (k1Set != null) {
            result = new ArrayList<V>();
            for (K1 k1 : k1Set) {
                Collection<V> values = k1_k2V_map.get(k1).values();
                if (values != null) {
                    result.addAll(values);
                }
            }
        }
        return result;
    }",method,
"        if (k1Set != null) {
            result = new ArrayList<V>();
            for (K1 k1 : k1Set) {
                Collection<V> values = k1_k2V_map.get(k1).values();
                if (values != null) {
                    result.addAll(values);
                }
            }
        }",method,
"            for (K1 k1 : k1Set) {
                Collection<V> values = k1_k2V_map.get(k1).values();
                if (values != null) {
                    result.addAll(values);
                }
            }",method,
"                if (values != null) {
                    result.addAll(values);
                }",method,
"    public boolean containsKey(K1 key1, K2 key2) {
        if (k1_k2V_map.containsKey(key1)) {
            return k1_k2V_map.get(key1).containsKey(key2);
        }
        return false;
    }",method,
"    public boolean containsKey(K1 key1) {
        return k1_k2V_map.containsKey(key1);
    }",method,
"    public int size() {
        if (k1_k2V_map.size() == 0) return 0;
        int result = 0;
        for (ConcurrentHashMap<K2, V> k2V_map : k1_k2V_map.values()) {
            result += k2V_map.size();
        }
        return result;
    }",method,
"    public void remove(K1 key1) {
        k1_k2V_map.remove(key1);
    }",method,
"    public void remove(K1 key1, K2 key2) {
        ConcurrentHashMap<K2, V> k2_v = k1_k2V_map.get(key1);
        if (k2_v != null) {
            k2_v.remove(key2);
        }
    }",method,
"        if (k2_v != null) {
            k2_v.remove(key2);
        }",method,
"    public void clear() {
        if (k1_k2V_map.size() > 0) {
            for (ConcurrentHashMap<K2, V> k2V_map : k1_k2V_map.values()) {
                k2V_map.clear();
            }
            k1_k2V_map.clear();
        }
    }",method,
"public class RelationEntityTestIdentityScope extends RelationEntityTest {
    @Override
    protected void setUp() throws Exception {
        identityScopeTypeForSession = IdentityScopeType.Session;
        super.setUp();
    }
    public void testToOneLoadDeepIdentityScope() {
        RelationEntity entity = insertEntityWithRelations(42l);
        RelationEntity entity2 = insertEntityWithRelations(42l);
        entity = dao.loadDeep(entity.getId());
        entity2 = dao.loadDeep(entity2.getId());
        assertFalse(entity.getId().equals(entity2.getId()));
        assertTestEntity(entity);
        assertTestEntity(entity2);
        assertSame(entity.getTestEntity(), entity2.getTestEntity());
    }
    public void testToQueryDeepIdentityScope() {
        insertEntityWithRelations(42l);
        RelationEntity entity2 = insertEntityWithRelations(42l);
        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
        List<RelationEntity> entityList = dao.queryDeep(""WHERE T."" + columnName + ""=?"", ""findMe"");
        assertEquals(2, entityList.size());
        RelationEntity entity = entityList.get(0);
        assertTestEntity(entity);
        entity2 = entityList.get(1);
        assertTestEntity(entity2);
        assertSame(entity.getTestEntity(), entity2.getTestEntity());
    }
    public void testLoadDeepIdentityScope() {
        RelationEntity entity = insertEntityWithRelations(42l);
        RelationEntity entity2 = dao.loadDeep(entity.getId());
        RelationEntity entity3 = dao.loadDeep(entity.getId());
        assertSame(entity, entity2);
        assertSame(entity, entity3);
        assertTestEntity(entity);
    }
    public void testQueryDeepIdentityScope() {
        RelationEntity entity = insertEntityWithRelations(42l);
        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
        List<RelationEntity> entityList = dao.queryDeep(""WHERE T."" + columnName + ""=?"", ""findMe"");
        RelationEntity entity2 = entityList.get(0);
        entityList = dao.queryDeep(""WHERE T."" + columnName + ""=?"", ""findMe"");
        RelationEntity entity3 = entityList.get(0);
        assertSame(entity, entity2);
        assertSame(entity, entity3);
        assertTestEntity(entity);
    }
}",class,
"    @Override
    protected void setUp() throws Exception {
        identityScopeTypeForSession = IdentityScopeType.Session;
        super.setUp();
    }",method,
"    public void testToOneLoadDeepIdentityScope() {
        RelationEntity entity = insertEntityWithRelations(42l);
        RelationEntity entity2 = insertEntityWithRelations(42l);
        entity = dao.loadDeep(entity.getId());
        entity2 = dao.loadDeep(entity2.getId());
        assertFalse(entity.getId().equals(entity2.getId()));
        assertTestEntity(entity);
        assertTestEntity(entity2);
        assertSame(entity.getTestEntity(), entity2.getTestEntity());
    }",method,
"    public void testToQueryDeepIdentityScope() {
        insertEntityWithRelations(42l);
        RelationEntity entity2 = insertEntityWithRelations(42l);
        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
        List<RelationEntity> entityList = dao.queryDeep(""WHERE T."" + columnName + ""=?"", ""findMe"");
        assertEquals(2, entityList.size());
        RelationEntity entity = entityList.get(0);
        assertTestEntity(entity);
        entity2 = entityList.get(1);
        assertTestEntity(entity2);
        assertSame(entity.getTestEntity(), entity2.getTestEntity());
    }",method,
"    public void testLoadDeepIdentityScope() {
        RelationEntity entity = insertEntityWithRelations(42l);
        RelationEntity entity2 = dao.loadDeep(entity.getId());
        RelationEntity entity3 = dao.loadDeep(entity.getId());
        assertSame(entity, entity2);
        assertSame(entity, entity3);
        assertTestEntity(entity);
    }",method,
"    public void testQueryDeepIdentityScope() {
        RelationEntity entity = insertEntityWithRelations(42l);
        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
        List<RelationEntity> entityList = dao.queryDeep(""WHERE T."" + columnName + ""=?"", ""findMe"");
        RelationEntity entity2 = entityList.get(0);
        entityList = dao.queryDeep(""WHERE T."" + columnName + ""=?"", ""findMe"");
        RelationEntity entity3 = entityList.get(0);
        assertSame(entity, entity2);
        assertSame(entity, entity3);
        assertTestEntity(entity);
    }",method,
"public class RollbackLineStatusAction extends DumbAwareAction {
  @Override
  public void update(AnActionEvent e) {
    Project project = e.getProject();
    Editor editor = e.getData(CommonDataKeys.EDITOR);
    if (project == null || editor == null) {
      e.getPresentation().setEnabledAndVisible(false);
      return;
    }
    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(project).getLineStatusTracker(editor.getDocument());
    if (tracker == null || !tracker.isValid() || !tracker.isAvailableAt(editor)) {
      e.getPresentation().setEnabledAndVisible(false);
      return;
    }
    if (!isSomeChangeSelected(editor, tracker)) {
      e.getPresentation().setVisible(true);
      e.getPresentation().setEnabled(false);
      return;
    }
    e.getPresentation().setEnabledAndVisible(true);
  }
  @Override
  public void actionPerformed(AnActionEvent e) {
    Project project = e.getProject();
    Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);
    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(project).getLineStatusTracker(editor.getDocument());
    assert tracker != null;
    rollback(tracker, editor, null);
  }
  protected static boolean isSomeChangeSelected(@NotNull Editor editor, @NotNull LineStatusTracker tracker) {
    List<Caret> carets = editor.getCaretModel().getAllCarets();
    if (carets.size() != 1) return true;
    Caret caret = carets.get(0);
    if (caret.hasSelection()) return true;
    if (caret.getOffset() == editor.getDocument().getTextLength() &&
        tracker.getRangeForLine(editor.getDocument().getLineCount()) != null) {
      return true;
    }
    return tracker.getRangeForLine(caret.getLogicalPosition().line) != null;
  }
  protected static void rollback(@NotNull LineStatusTracker tracker, @Nullable Editor editor, @Nullable Range range) {
    assert editor != null || range != null;
    if (range != null) {
      if (editor != null) DiffUtil.moveCaretToLineRangeIfNeeded(editor, range.getLine1(), range.getLine2());
      doRollback(tracker, range);
      return;
    }
    doRollback(tracker, DiffUtil.getSelectedLines(editor));
  }
  private static void doRollback(@NotNull final LineStatusTracker tracker, @NotNull final Range range) {
    execute(tracker, () -> tracker.rollbackChanges(range));
  }
  private static void doRollback(@NotNull final LineStatusTracker tracker, @NotNull final BitSet lines) {
    execute(tracker, () -> tracker.rollbackChanges(lines));
  }
  private static void execute(@NotNull final LineStatusTracker tracker, @NotNull final Runnable task) {
    DiffUtil.executeWriteCommand(tracker.getDocument(), tracker.getProject(), VcsBundle.message(""command.name.rollback.change""), task);
  }
}",class,
"  @Override
  public void update(AnActionEvent e) {
    Project project = e.getProject();
    Editor editor = e.getData(CommonDataKeys.EDITOR);
    if (project == null || editor == null) {
      e.getPresentation().setEnabledAndVisible(false);
      return;
    }
    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(project).getLineStatusTracker(editor.getDocument());
    if (tracker == null || !tracker.isValid() || !tracker.isAvailableAt(editor)) {
      e.getPresentation().setEnabledAndVisible(false);
      return;
    }
    if (!isSomeChangeSelected(editor, tracker)) {
      e.getPresentation().setVisible(true);
      e.getPresentation().setEnabled(false);
      return;
    }
    e.getPresentation().setEnabledAndVisible(true);
  }",method,
"    if (project == null || editor == null) {
      e.getPresentation().setEnabledAndVisible(false);
      return;
    }",method,
"  @Override
  public void actionPerformed(AnActionEvent e) {
    Project project = e.getProject();
    Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);
    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(project).getLineStatusTracker(editor.getDocument());
    assert tracker != null;
    rollback(tracker, editor, null);
  }",method,
"  protected static boolean isSomeChangeSelected(@NotNull Editor editor, @NotNull LineStatusTracker tracker) {
    List<Caret> carets = editor.getCaretModel().getAllCarets();
    if (carets.size() != 1) return true;
    Caret caret = carets.get(0);
    if (caret.hasSelection()) return true;
    if (caret.getOffset() == editor.getDocument().getTextLength() &&
        tracker.getRangeForLine(editor.getDocument().getLineCount()) != null) {
      return true;
    }
    return tracker.getRangeForLine(caret.getLogicalPosition().line) != null;
  }",method,
"  protected static void rollback(@NotNull LineStatusTracker tracker, @Nullable Editor editor, @Nullable Range range) {
    assert editor != null || range != null;
    if (range != null) {
      if (editor != null) DiffUtil.moveCaretToLineRangeIfNeeded(editor, range.getLine1(), range.getLine2());
      doRollback(tracker, range);
      return;
    }
    doRollback(tracker, DiffUtil.getSelectedLines(editor));
  }",method,
"    if (range != null) {
      if (editor != null) DiffUtil.moveCaretToLineRangeIfNeeded(editor, range.getLine1(), range.getLine2());
      doRollback(tracker, range);
      return;
    }",method,
"  private static void doRollback(@NotNull final LineStatusTracker tracker, @NotNull final Range range) {
    execute(tracker, () -> tracker.rollbackChanges(range));
  }",method,
"  private static void doRollback(@NotNull final LineStatusTracker tracker, @NotNull final BitSet lines) {
    execute(tracker, () -> tracker.rollbackChanges(lines));
  }",method,
"  private static void execute(@NotNull final LineStatusTracker tracker, @NotNull final Runnable task) {
    DiffUtil.executeWriteCommand(tracker.getDocument(), tracker.getProject(), VcsBundle.message(""command.name.rollback.change""), task);
  }",method,
"public class SuggestPhase extends AbstractComponent implements SearchPhase {
    public SuggestPhase(Settings settings) {
        super(settings);
    }
    @Override
    public void preProcess(SearchContext context) {
    }
    @Override
    public void execute(SearchContext context) {
        final SuggestionSearchContext suggest = context.suggest();
        if (suggest == null) {
            return;
        }
        try {
            CharsRefBuilder spare = new CharsRefBuilder();
            final List<Suggestion<? extends Entry<? extends Option>>> suggestions = new ArrayList<>(suggest.suggestions().size());
            for (Map.Entry<String, SuggestionSearchContext.SuggestionContext> entry : suggest.suggestions().entrySet()) {
                SuggestionSearchContext.SuggestionContext suggestion = entry.getValue();
                Suggester<SuggestionContext> suggester = suggestion.getSuggester();
                Suggestion<? extends Entry<? extends Option>> result =
                    suggester.execute(entry.getKey(), suggestion, context.searcher(), spare);
                if (result != null) {
                    assert entry.getKey().equals(result.name);
                    suggestions.add(result);
                }
            }
            context.queryResult().suggest(new Suggest(suggestions));
        } catch (IOException e) {
            throw new ElasticsearchException(""I/O exception during suggest phase"", e);
        }
    }
}",class,
"    public SuggestPhase(Settings settings) {
        super(settings);
    }",method,
"    @Override
    public void preProcess(SearchContext context) {
    }",method,
"    @Override
    public void execute(SearchContext context) {
        final SuggestionSearchContext suggest = context.suggest();
        if (suggest == null) {
            return;
        }
        try {
            CharsRefBuilder spare = new CharsRefBuilder();
            final List<Suggestion<? extends Entry<? extends Option>>> suggestions = new ArrayList<>(suggest.suggestions().size());
            for (Map.Entry<String, SuggestionSearchContext.SuggestionContext> entry : suggest.suggestions().entrySet()) {
                SuggestionSearchContext.SuggestionContext suggestion = entry.getValue();
                Suggester<SuggestionContext> suggester = suggestion.getSuggester();
                Suggestion<? extends Entry<? extends Option>> result =
                    suggester.execute(entry.getKey(), suggestion, context.searcher(), spare);
                if (result != null) {
                    assert entry.getKey().equals(result.name);
                    suggestions.add(result);
                }
            }
            context.queryResult().suggest(new Suggest(suggestions));
        } catch (IOException e) {
            throw new ElasticsearchException(""I/O exception during suggest phase"", e);
        }
    }",method,
"        if (suggest == null) {
            return;
        }",method,
"                if (result != null) {
                    assert entry.getKey().equals(result.name);
                    suggestions.add(result);
                }",method,
"public class MySqlSelectTest_59_neq extends MysqlTest {
    public void test_0() throws Exception {
        String sql =  ""SELECT * from t where t !  = 1"";
        System.out.println(sql);
        List<SQLStatement> statementList = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL, true);
        SQLStatement stmt = statementList.get(0);
        assertEquals(1, statementList.size());
        SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(JdbcConstants.MYSQL);
        stmt.accept(visitor);
//        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
//        System.out.println(""coditions : "" + visitor.getConditions());
//        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
//        assertEquals(1, visitor.getTables().size());
//        assertEquals(1, visitor.getColumns().size());
//        assertEquals(0, visitor.getConditions().size());
//        assertEquals(0, visitor.getOrderByColumns().size());
        {
            String output = SQLUtils.toMySqlString(stmt);
            assertEquals(""SELECT *\n"" +
                            ""FROM t\n"" +
                            ""WHERE t != 1"", //
                                output);
        }
        {
            String output = SQLUtils.toMySqlString(stmt, SQLUtils.DEFAULT_LCASE_FORMAT_OPTION);
            assertEquals(""select *\n"" +
                            ""from t\n"" +
                            ""where t != 1"", //
                                output);
        }
        {
            String output = SQLUtils.toMySqlString(stmt, new SQLUtils.FormatOption(true, true, true));
            assertEquals(""SELECT *\n"" +
                            ""FROM t\n"" +
                            ""WHERE t != ?"", //
                    output);
        }
    }
}",class,
"    public void test_0() throws Exception {
        String sql =  ""SELECT * from t where t !  = 1"";
        System.out.println(sql);
        List<SQLStatement> statementList = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL, true);
        SQLStatement stmt = statementList.get(0);
        assertEquals(1, statementList.size());
        SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(JdbcConstants.MYSQL);
        stmt.accept(visitor);
//        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
//        System.out.println(""coditions : "" + visitor.getConditions());
//        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
//        assertEquals(1, visitor.getTables().size());
//        assertEquals(1, visitor.getColumns().size());
//        assertEquals(0, visitor.getConditions().size());
//        assertEquals(0, visitor.getOrderByColumns().size());
        {
            String output = SQLUtils.toMySqlString(stmt);
            assertEquals(""SELECT *\n"" +
                            ""FROM t\n"" +
                            ""WHERE t != 1"", //
                                output);
        }
        {
            String output = SQLUtils.toMySqlString(stmt, SQLUtils.DEFAULT_LCASE_FORMAT_OPTION);
            assertEquals(""select *\n"" +
                            ""from t\n"" +
                            ""where t != 1"", //
                                output);
        }
        {
            String output = SQLUtils.toMySqlString(stmt, new SQLUtils.FormatOption(true, true, true));
            assertEquals(""SELECT *\n"" +
                            ""FROM t\n"" +
                            ""WHERE t != ?"", //
                    output);
        }
    }",method,
"public class SearchTemplateResponse  extends ActionResponse implements StatusToXContentObject {
    private BytesReference source;
    private SearchResponse response;
    SearchTemplateResponse() {
    }
    public BytesReference getSource() {
        return source;
    }
    public void setSource(BytesReference source) {
        this.source = source;
    }
    public SearchResponse getResponse() {
        return response;
    }
    public void setResponse(SearchResponse searchResponse) {
        this.response = searchResponse;
    }
    public boolean hasResponse() {
        return response != null;
    }
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeOptionalBytesReference(source);
        out.writeOptionalStreamable(response);
    }
    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        source = in.readOptionalBytesReference();
        response = in.readOptionalStreamable(SearchResponse::new);
    }
    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        if (hasResponse()) {
            response.toXContent(builder, params);
        } else {
            builder.startObject();
            //we can assume the template is always json as we convert it before compiling it
            builder.rawField(""template_output"", source, XContentType.JSON);
            builder.endObject();
        }
        return builder;
    }
    @Override
    public RestStatus status() {
        if (hasResponse()) {
            return response.status();
        } else {
            return RestStatus.OK;
        }
    }
}",class,
"    SearchTemplateResponse() {
    }",method,
"    public BytesReference getSource() {
        return source;
    }",method,
"    public void setSource(BytesReference source) {
        this.source = source;
    }",method,
"    public SearchResponse getResponse() {
        return response;
    }",method,
"    public void setResponse(SearchResponse searchResponse) {
        this.response = searchResponse;
    }",method,
"    public boolean hasResponse() {
        return response != null;
    }",method,
"    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeOptionalBytesReference(source);
        out.writeOptionalStreamable(response);
    }",method,
"    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        source = in.readOptionalBytesReference();
        response = in.readOptionalStreamable(SearchResponse::new);
    }",method,
"    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        if (hasResponse()) {
            response.toXContent(builder, params);
        } else {
            builder.startObject();
            //we can assume the template is always json as we convert it before compiling it
            builder.rawField(""template_output"", source, XContentType.JSON);
            builder.endObject();
        }
        return builder;
    }",method,
"    @Override
    public RestStatus status() {
        if (hasResponse()) {
            return response.status();
        } else {
            return RestStatus.OK;
        }
    }",method,
"import redis.clients.util.JedisURIHelper;
class JedisFactory implements PooledObjectFactory<Jedis> {
  private final AtomicReference<HostAndPort> hostAndPort = new AtomicReference<HostAndPort>();
  private final int connectionTimeout;
  private final int soTimeout;
  private final String password;
  private final int database;
  private final String clientName;
  private final boolean ssl;
  private final SSLSocketFactory sslSocketFactory;
  private SSLParameters sslParameters;
  private HostnameVerifier hostnameVerifier;
  public JedisFactory(final String host, final int port, final int connectionTimeout,
      final int soTimeout, final String password, final int database, final String clientName,
      final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
      final HostnameVerifier hostnameVerifier) {
    this.hostAndPort.set(new HostAndPort(host, port));
    this.connectionTimeout = connectionTimeout;
    this.soTimeout = soTimeout;
    this.password = password;
    this.database = database;
    this.clientName = clientName;
    this.ssl = ssl;
    this.sslSocketFactory = sslSocketFactory;
    this.sslParameters = sslParameters;
    this.hostnameVerifier = hostnameVerifier;
  }
  public JedisFactory(final URI uri, final int connectionTimeout, final int soTimeout,
      final String clientName, final boolean ssl, final SSLSocketFactory sslSocketFactory,
      final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
    if (!JedisURIHelper.isValid(uri)) {
      throw new InvalidURIException(String.format(
        ""Cannot open Redis connection due invalid URI. %s"", uri.toString()));
    }
    this.hostAndPort.set(new HostAndPort(uri.getHost(), uri.getPort()));
    this.connectionTimeout = connectionTimeout;
    this.soTimeout = soTimeout;
    this.password = JedisURIHelper.getPassword(uri);
    this.database = JedisURIHelper.getDBIndex(uri);
    this.clientName = clientName;
    this.ssl = ssl;
    this.sslSocketFactory = sslSocketFactory;
    this.sslParameters = sslParameters;
    this.hostnameVerifier = hostnameVerifier;
  }
  public void setHostAndPort(final HostAndPort hostAndPort) {
    this.hostAndPort.set(hostAndPort);
  }
  @Override
  public void activateObject(PooledObject<Jedis> pooledJedis) throws Exception {
    final BinaryJedis jedis = pooledJedis.getObject();
    if (jedis.getDB() != database) {
      jedis.select(database);
    }
  }
  @Override
  public void destroyObject(PooledObject<Jedis> pooledJedis) throws Exception {
    final BinaryJedis jedis = pooledJedis.getObject();
    if (jedis.isConnected()) {
      try {
        try {
          jedis.quit();
        } catch (Exception e) {
        }
        jedis.disconnect();
      } catch (Exception e) {
      }
    }
  }
  @Override
  public PooledObject<Jedis> makeObject() throws Exception {
    final HostAndPort hostAndPort = this.hostAndPort.get();
    final Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,
        soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);
    try {
      jedis.connect();
      if (password != null) {
        jedis.auth(password);
      }
      if (database != 0) {
        jedis.select(database);
      }
      if (clientName != null) {
        jedis.clientSetname(clientName);
      }
    } catch (JedisException je) {
      jedis.close();
      throw je;
    }
    return new DefaultPooledObject<Jedis>(jedis);
  }
  @Override
  public void passivateObject(PooledObject<Jedis> pooledJedis) throws Exception {
    // TODO maybe should select db 0? Not sure right now.
  }
  @Override
  public boolean validateObject(PooledObject<Jedis> pooledJedis) {
    final BinaryJedis jedis = pooledJedis.getObject();
    try {
      HostAndPort hostAndPort = this.hostAndPort.get();
      String connectionHost = jedis.getClient().getHost();
      int connectionPort = jedis.getClient().getPort();
      return hostAndPort.getHost().equals(connectionHost)
          && hostAndPort.getPort() == connectionPort && jedis.isConnected()
          && jedis.ping().equals(""PONG"");
    } catch (final Exception e) {
      return false;
    }
  }
}",class,
"public abstract class JedisMonitor {
  protected Client client;
  public void proceed(Client client) {
    this.client = client;
    this.client.setTimeoutInfinite();
    do {
      String command = client.getBulkReply();
      onCommand(command);
    } while (client.isConnected());
  }
  public abstract void onCommand(String command);
}",class,
"  public JedisFactory(final String host, final int port, final int connectionTimeout,
      final int soTimeout, final String password, final int database, final String clientName,
      final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
      final HostnameVerifier hostnameVerifier) {
    this.hostAndPort.set(new HostAndPort(host, port));
    this.connectionTimeout = connectionTimeout;
    this.soTimeout = soTimeout;
    this.password = password;
    this.database = database;
    this.clientName = clientName;
    this.ssl = ssl;
    this.sslSocketFactory = sslSocketFactory;
    this.sslParameters = sslParameters;
    this.hostnameVerifier = hostnameVerifier;
  }",method,
"  public JedisFactory(final URI uri, final int connectionTimeout, final int soTimeout,
      final String clientName, final boolean ssl, final SSLSocketFactory sslSocketFactory,
      final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
    if (!JedisURIHelper.isValid(uri)) {
      throw new InvalidURIException(String.format(
        ""Cannot open Redis connection due invalid URI. %s"", uri.toString()));
    }
    this.hostAndPort.set(new HostAndPort(uri.getHost(), uri.getPort()));
    this.connectionTimeout = connectionTimeout;
    this.soTimeout = soTimeout;
    this.password = JedisURIHelper.getPassword(uri);
    this.database = JedisURIHelper.getDBIndex(uri);
    this.clientName = clientName;
    this.ssl = ssl;
    this.sslSocketFactory = sslSocketFactory;
    this.sslParameters = sslParameters;
    this.hostnameVerifier = hostnameVerifier;
  }",method,
"  public void setHostAndPort(final HostAndPort hostAndPort) {
    this.hostAndPort.set(hostAndPort);
  }",method,
"  @Override
  public void activateObject(PooledObject<Jedis> pooledJedis) throws Exception {
    final BinaryJedis jedis = pooledJedis.getObject();
    if (jedis.getDB() != database) {
      jedis.select(database);
    }
  }",method,
"  @Override
  public void destroyObject(PooledObject<Jedis> pooledJedis) throws Exception {
    final BinaryJedis jedis = pooledJedis.getObject();
    if (jedis.isConnected()) {
      try {
        try {
          jedis.quit();
        } catch (Exception e) {
        }
        jedis.disconnect();
      } catch (Exception e) {
      }
    }
  }",method,
"  @Override
  public PooledObject<Jedis> makeObject() throws Exception {
    final HostAndPort hostAndPort = this.hostAndPort.get();
    final Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,
        soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);
    try {
      jedis.connect();
      if (password != null) {
        jedis.auth(password);
      }
      if (database != 0) {
        jedis.select(database);
      }
      if (clientName != null) {
        jedis.clientSetname(clientName);
      }
    } catch (JedisException je) {
      jedis.close();
      throw je;
    }
    return new DefaultPooledObject<Jedis>(jedis);
  }",method,
"      if (password != null) {
        jedis.auth(password);
      }",method,
"      if (database != 0) {
        jedis.select(database);
      }",method,
"      if (clientName != null) {
        jedis.clientSetname(clientName);
      }",method,
"  @Override
  public void passivateObject(PooledObject<Jedis> pooledJedis) throws Exception {
    // TODO maybe should select db 0? Not sure right now.
  }",method,
"  @Override
  public boolean validateObject(PooledObject<Jedis> pooledJedis) {
    final BinaryJedis jedis = pooledJedis.getObject();
    try {
      HostAndPort hostAndPort = this.hostAndPort.get();
      String connectionHost = jedis.getClient().getHost();
      int connectionPort = jedis.getClient().getPort();
      return hostAndPort.getHost().equals(connectionHost)
          && hostAndPort.getPort() == connectionPort && jedis.isConnected()
          && jedis.ping().equals(""PONG"");
    } catch (final Exception e) {
      return false;
    }
  }",method,
"  public void proceed(Client client) {
    this.client = client;
    this.client.setTimeoutInfinite();
    do {
      String command = client.getBulkReply();
      onCommand(command);
    } while (client.isConnected());
  }",method,
"public class Animal {
  @SerializedName(""className"")
  private String className = null;
  @SerializedName(""color"")
  private String color = ""red"";
  public Animal className(String className) {
    this.className = className;
    return this;
  }
  @ApiModelProperty(required = true, value = """")
  public String getClassName() {
    return className;
  }
  public void setClassName(String className) {
    this.className = className;
  }
  public Animal color(String color) {
    this.color = color;
    return this;
  }
  @ApiModelProperty(value = """")
  public String getColor() {
    return color;
  }
  public void setColor(String color) {
    this.color = color;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Animal animal = (Animal) o;
    return Objects.equals(this.className, animal.className) &&
        Objects.equals(this.color, animal.color);
  }
  @Override
  public int hashCode() {
    return Objects.hash(className, color);
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class Animal {\n"");
    sb.append(""    className: "").append(toIndentedString(className)).append(""\n"");
    sb.append(""    color: "").append(toIndentedString(color)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
}",class,
"    sb.append(""class Animal {\n"");
    sb.append(""    className: "").append(toIndentedString(className)).append(""\n"");
    sb.append(""    color: "").append(toIndentedString(color)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"  public Animal className(String className) {
    this.className = className;
    return this;
  }",method,
"  @ApiModelProperty(required = true, value = """")
  public String getClassName() {
    return className;
  }",method,
"  public void setClassName(String className) {
    this.className = className;
  }",method,
"  public Animal color(String color) {
    this.color = color;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public String getColor() {
    return color;
  }",method,
"  public void setColor(String color) {
    this.color = color;
  }",method,
"  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Animal animal = (Animal) o;
    return Objects.equals(this.className, animal.className) &&
        Objects.equals(this.color, animal.color);
  }",method,
"    if (this == o) {
      return true;
    }",method,
"  @Override
  public int hashCode() {
    return Objects.hash(className, color);
  }",method,
"  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class Animal {\n"");
    sb.append(""    className: "").append(toIndentedString(className)).append(""\n"");
    sb.append(""    color: "").append(toIndentedString(color)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }",method,
"  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",method,
"    if (o == null) {
      return ""null"";
    }",method,

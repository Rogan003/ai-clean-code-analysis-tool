code_snippet,type,score
"  @Override
  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    if (IS_WINDOWS) {
      makeWritable(file);
    }
    Files.delete(file);
    return FileVisitResult.CONTINUE;
  }",method,
"    if (IS_WINDOWS) {
      makeWritable(file);
    }",method,
"  @Override
  public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    Files.delete(dir);
    return FileVisitResult.CONTINUE;
  }",method,
"  @Override
  public void close() throws IOException {
    Files.walkFileTree(path, this);
  }",method,
"public final class DefaultExtractorInput implements ExtractorInput {
  private static final int PEEK_MIN_FREE_SPACE_AFTER_RESIZE = 64 * 1024;
  private static final int PEEK_MAX_FREE_SPACE = 512 * 1024;
  private static final byte[] SCRATCH_SPACE = new byte[4096];
  private final DataSource dataSource;
  private final long streamLength;
  private long position;
  private byte[] peekBuffer;
  private int peekBufferPosition;
  private int peekBufferLength;
  public DefaultExtractorInput(DataSource dataSource, long position, long length) {
    this.dataSource = dataSource;
    this.position = position;
    this.streamLength = length;
    peekBuffer = new byte[PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
  }
  @Override
  public int read(byte[] target, int offset, int length) throws IOException, InterruptedException {
    int bytesRead = readFromPeekBuffer(target, offset, length);
    if (bytesRead == 0) {
      bytesRead = readFromDataSource(target, offset, length, 0, true);
    }
    commitBytesRead(bytesRead);
    return bytesRead;
  }
  @Override
  public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    int bytesRead = readFromPeekBuffer(target, offset, length);
    while (bytesRead < length && bytesRead != C.RESULT_END_OF_INPUT) {
      bytesRead = readFromDataSource(target, offset, length, bytesRead, allowEndOfInput);
    }
    commitBytesRead(bytesRead);
    return bytesRead != C.RESULT_END_OF_INPUT;
  }
  @Override
  public void readFully(byte[] target, int offset, int length)
      throws IOException, InterruptedException {
    readFully(target, offset, length, false);
  }
  @Override
  public int skip(int length) throws IOException, InterruptedException {
    int bytesSkipped = skipFromPeekBuffer(length);
    if (bytesSkipped == 0) {
      bytesSkipped =
          readFromDataSource(SCRATCH_SPACE, 0, Math.min(length, SCRATCH_SPACE.length), 0, true);
    }
    commitBytesRead(bytesSkipped);
    return bytesSkipped;
  }
  @Override
  public boolean skipFully(int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    int bytesSkipped = skipFromPeekBuffer(length);
    while (bytesSkipped < length && bytesSkipped != C.RESULT_END_OF_INPUT) {
      bytesSkipped = readFromDataSource(SCRATCH_SPACE, -bytesSkipped,
          Math.min(length, bytesSkipped + SCRATCH_SPACE.length), bytesSkipped, allowEndOfInput);
    }
    commitBytesRead(bytesSkipped);
    return bytesSkipped != C.RESULT_END_OF_INPUT;
  }
  @Override
  public void skipFully(int length) throws IOException, InterruptedException {
    skipFully(length, false);
  }
  @Override
  public boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    if (!advancePeekPosition(length, allowEndOfInput)) {
      return false;
    }
    System.arraycopy(peekBuffer, peekBufferPosition - length, target, offset, length);
    return true;
  }
  @Override
  public void peekFully(byte[] target, int offset, int length)
      throws IOException, InterruptedException {
    peekFully(target, offset, length, false);
  }
  @Override
  public boolean advancePeekPosition(int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    ensureSpaceForPeek(length);
    int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
    while (bytesPeeked < length) {
      bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
          allowEndOfInput);
      if (bytesPeeked == C.RESULT_END_OF_INPUT) {
        return false;
      }
    }
    peekBufferPosition += length;
    peekBufferLength = Math.max(peekBufferLength, peekBufferPosition);
    return true;
  }
  @Override
  public void advancePeekPosition(int length) throws IOException, InterruptedException {
    advancePeekPosition(length, false);
  }
  @Override
  public void resetPeekPosition() {
    peekBufferPosition = 0;
  }
  @Override
  public long getPeekPosition() {
    return position + peekBufferPosition;
  }
  @Override
  public long getPosition() {
    return position;
  }
  @Override
  public long getLength() {
    return streamLength;
  }
  @Override
  public <E extends Throwable> void setRetryPosition(long position, E e) throws E {
    Assertions.checkArgument(position >= 0);
    this.position = position;
    throw e;
  }
  private void ensureSpaceForPeek(int length) {
    int requiredLength = peekBufferPosition + length;
    if (requiredLength > peekBuffer.length) {
      int newPeekCapacity = Util.constrainValue(peekBuffer.length * 2,
          requiredLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE, requiredLength + PEEK_MAX_FREE_SPACE);
      peekBuffer = Arrays.copyOf(peekBuffer, newPeekCapacity);
    }
  }
  private int skipFromPeekBuffer(int length) {
    int bytesSkipped = Math.min(peekBufferLength, length);
    updatePeekBuffer(bytesSkipped);
    return bytesSkipped;
  }
  private int readFromPeekBuffer(byte[] target, int offset, int length) {
    if (peekBufferLength == 0) {
      return 0;
    }
    int peekBytes = Math.min(peekBufferLength, length);
    System.arraycopy(peekBuffer, 0, target, offset, peekBytes);
    updatePeekBuffer(peekBytes);
    return peekBytes;
  }
  private void updatePeekBuffer(int bytesConsumed) {
    peekBufferLength -= bytesConsumed;
    peekBufferPosition = 0;
    byte[] newPeekBuffer = peekBuffer;
    if (peekBufferLength < peekBuffer.length - PEEK_MAX_FREE_SPACE) {
      newPeekBuffer = new byte[peekBufferLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
    }
    System.arraycopy(peekBuffer, bytesConsumed, newPeekBuffer, 0, peekBufferLength);
    peekBuffer = newPeekBuffer;
  }
  private int readFromDataSource(byte[] target, int offset, int length, int bytesAlreadyRead,
      boolean allowEndOfInput) throws InterruptedException, IOException {
    if (Thread.interrupted()) {
      throw new InterruptedException();
    }
    int bytesRead = dataSource.read(target, offset + bytesAlreadyRead, length - bytesAlreadyRead);
    if (bytesRead == C.RESULT_END_OF_INPUT) {
      if (bytesAlreadyRead == 0 && allowEndOfInput) {
        return C.RESULT_END_OF_INPUT;
      }
      throw new EOFException();
    }
    return bytesAlreadyRead + bytesRead;
  }
  private void commitBytesRead(int bytesRead) {
    if (bytesRead != C.RESULT_END_OF_INPUT) {
      position += bytesRead;
    }
  }
}",class,
"  public DefaultExtractorInput(DataSource dataSource, long position, long length) {
    this.dataSource = dataSource;
    this.position = position;
    this.streamLength = length;
    peekBuffer = new byte[PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
  }",method,
"  @Override
  public int read(byte[] target, int offset, int length) throws IOException, InterruptedException {
    int bytesRead = readFromPeekBuffer(target, offset, length);
    if (bytesRead == 0) {
      bytesRead = readFromDataSource(target, offset, length, 0, true);
    }
    commitBytesRead(bytesRead);
    return bytesRead;
  }",method,
"    if (bytesRead == 0) {
      bytesRead = readFromDataSource(target, offset, length, 0, true);
    }",method,
"  @Override
  public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    int bytesRead = readFromPeekBuffer(target, offset, length);
    while (bytesRead < length && bytesRead != C.RESULT_END_OF_INPUT) {
      bytesRead = readFromDataSource(target, offset, length, bytesRead, allowEndOfInput);
    }
    commitBytesRead(bytesRead);
    return bytesRead != C.RESULT_END_OF_INPUT;
  }",method,
"    while (bytesRead < length && bytesRead != C.RESULT_END_OF_INPUT) {
      bytesRead = readFromDataSource(target, offset, length, bytesRead, allowEndOfInput);
    }",method,
"  @Override
  public void readFully(byte[] target, int offset, int length)
      throws IOException, InterruptedException {
    readFully(target, offset, length, false);
  }",method,
"  @Override
  public int skip(int length) throws IOException, InterruptedException {
    int bytesSkipped = skipFromPeekBuffer(length);
    if (bytesSkipped == 0) {
      bytesSkipped =
          readFromDataSource(SCRATCH_SPACE, 0, Math.min(length, SCRATCH_SPACE.length), 0, true);
    }
    commitBytesRead(bytesSkipped);
    return bytesSkipped;
  }",method,
"    if (bytesSkipped == 0) {
      bytesSkipped =
          readFromDataSource(SCRATCH_SPACE, 0, Math.min(length, SCRATCH_SPACE.length), 0, true);
    }",method,
"  @Override
  public boolean skipFully(int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    int bytesSkipped = skipFromPeekBuffer(length);
    while (bytesSkipped < length && bytesSkipped != C.RESULT_END_OF_INPUT) {
      bytesSkipped = readFromDataSource(SCRATCH_SPACE, -bytesSkipped,
          Math.min(length, bytesSkipped + SCRATCH_SPACE.length), bytesSkipped, allowEndOfInput);
    }
    commitBytesRead(bytesSkipped);
    return bytesSkipped != C.RESULT_END_OF_INPUT;
  }",method,
"    while (bytesSkipped < length && bytesSkipped != C.RESULT_END_OF_INPUT) {
      bytesSkipped = readFromDataSource(SCRATCH_SPACE, -bytesSkipped,
          Math.min(length, bytesSkipped + SCRATCH_SPACE.length), bytesSkipped, allowEndOfInput);
    }",method,
"  @Override
  public void skipFully(int length) throws IOException, InterruptedException {
    skipFully(length, false);
  }",method,
"  @Override
  public boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    if (!advancePeekPosition(length, allowEndOfInput)) {
      return false;
    }
    System.arraycopy(peekBuffer, peekBufferPosition - length, target, offset, length);
    return true;
  }",method,
"  @Override
  public void peekFully(byte[] target, int offset, int length)
      throws IOException, InterruptedException {
    peekFully(target, offset, length, false);
  }",method,
"  @Override
  public boolean advancePeekPosition(int length, boolean allowEndOfInput)
      throws IOException, InterruptedException {
    ensureSpaceForPeek(length);
    int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
    while (bytesPeeked < length) {
      bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
          allowEndOfInput);
      if (bytesPeeked == C.RESULT_END_OF_INPUT) {
        return false;
      }
    }
    peekBufferPosition += length;
    peekBufferLength = Math.max(peekBufferLength, peekBufferPosition);
    return true;
  }",method,
"    while (bytesPeeked < length) {
      bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
          allowEndOfInput);
      if (bytesPeeked == C.RESULT_END_OF_INPUT) {
        return false;
      }
    }",method,
"      if (bytesPeeked == C.RESULT_END_OF_INPUT) {
        return false;
      }",method,
"  @Override
  public void advancePeekPosition(int length) throws IOException, InterruptedException {
    advancePeekPosition(length, false);
  }",method,
"  @Override
  public void resetPeekPosition() {
    peekBufferPosition = 0;
  }",method,
"  @Override
  public long getPeekPosition() {
    return position + peekBufferPosition;
  }",method,
"  @Override
  public long getPosition() {
    return position;
  }",method,
"  @Override
  public long getLength() {
    return streamLength;
  }",method,
"  @Override
  public <E extends Throwable> void setRetryPosition(long position, E e) throws E {
    Assertions.checkArgument(position >= 0);
    this.position = position;
    throw e;
  }",method,
"  private void ensureSpaceForPeek(int length) {
    int requiredLength = peekBufferPosition + length;
    if (requiredLength > peekBuffer.length) {
      int newPeekCapacity = Util.constrainValue(peekBuffer.length * 2,
          requiredLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE, requiredLength + PEEK_MAX_FREE_SPACE);
      peekBuffer = Arrays.copyOf(peekBuffer, newPeekCapacity);
    }
  }",method,
"    if (requiredLength > peekBuffer.length) {
      int newPeekCapacity = Util.constrainValue(peekBuffer.length * 2,
          requiredLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE, requiredLength + PEEK_MAX_FREE_SPACE);
      peekBuffer = Arrays.copyOf(peekBuffer, newPeekCapacity);
    }",method,
"  private int skipFromPeekBuffer(int length) {
    int bytesSkipped = Math.min(peekBufferLength, length);
    updatePeekBuffer(bytesSkipped);
    return bytesSkipped;
  }",method,
"  private int readFromPeekBuffer(byte[] target, int offset, int length) {
    if (peekBufferLength == 0) {
      return 0;
    }
    int peekBytes = Math.min(peekBufferLength, length);
    System.arraycopy(peekBuffer, 0, target, offset, peekBytes);
    updatePeekBuffer(peekBytes);
    return peekBytes;
  }",method,
"    if (peekBufferLength == 0) {
      return 0;
    }",method,
"  private void updatePeekBuffer(int bytesConsumed) {
    peekBufferLength -= bytesConsumed;
    peekBufferPosition = 0;
    byte[] newPeekBuffer = peekBuffer;
    if (peekBufferLength < peekBuffer.length - PEEK_MAX_FREE_SPACE) {
      newPeekBuffer = new byte[peekBufferLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
    }
    System.arraycopy(peekBuffer, bytesConsumed, newPeekBuffer, 0, peekBufferLength);
    peekBuffer = newPeekBuffer;
  }",method,
"    if (peekBufferLength < peekBuffer.length - PEEK_MAX_FREE_SPACE) {
      newPeekBuffer = new byte[peekBufferLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
    }",method,
"  private int readFromDataSource(byte[] target, int offset, int length, int bytesAlreadyRead,
      boolean allowEndOfInput) throws InterruptedException, IOException {
    if (Thread.interrupted()) {
      throw new InterruptedException();
    }
    int bytesRead = dataSource.read(target, offset + bytesAlreadyRead, length - bytesAlreadyRead);
    if (bytesRead == C.RESULT_END_OF_INPUT) {
      if (bytesAlreadyRead == 0 && allowEndOfInput) {
        return C.RESULT_END_OF_INPUT;
      }
      throw new EOFException();
    }
    return bytesAlreadyRead + bytesRead;
  }",method,
"    if (bytesRead == C.RESULT_END_OF_INPUT) {
      if (bytesAlreadyRead == 0 && allowEndOfInput) {
        return C.RESULT_END_OF_INPUT;
      }
      throw new EOFException();
    }",method,
"      if (bytesAlreadyRead == 0 && allowEndOfInput) {
        return C.RESULT_END_OF_INPUT;
      }",method,
"  private void commitBytesRead(int bytesRead) {
    if (bytesRead != C.RESULT_END_OF_INPUT) {
      position += bytesRead;
    }
  }",method,
"    if (bytesRead != C.RESULT_END_OF_INPUT) {
      position += bytesRead;
    }",method,
"public class DialogGifProcess extends DialogBase implements ActionListener {
	private static final long serialVersionUID = 1537290597241595179L;
	JProgressBar progress;
    int total;
    JLabel label;
    public DataOutputStream out;
    public DrawPanelFrame gxInstance;
    public Animation am;
    public DrawPanelExtended dp;
    public Rectangle rect;
    public GifEncoder en;
    public DialogGifProcess(Frame f) {
        super(f, false);
        this.setTitle(""Building GIF File"");
        progress = new JProgressBar(SwingConstants.HORIZONTAL, 0, 100);
        progress.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));
        progress.setBorderPainted(true);
        progress.setStringPainted(true);
        label = new JLabel(""0 frame(s) added"");
        JPanel pp = new JPanel();
        pp.setLayout(new FlowLayout());
        pp.add(Box.createHorizontalStrut(150));
        pp.add(label);
        JPanel panel = new JPanel();
        panel.add(Box.createVerticalStrut(10));
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.add(progress);
        panel.add(pp);
        panel.add(Box.createVerticalStrut(10));
        JPanel panel1 = new JPanel();
        panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));
        panel1.add(Box.createHorizontalGlue());
        JButton b1 = new JButton(""Cancel"");
        panel1.add(b1);
        b1.addActionListener(this);
        panel.add(panel1);
        panel.add(Box.createVerticalStrut(10));
        panel.setBorder((BorderFactory.createEmptyBorder(3, 3, 3, 3)));
        this.getContentPane().add(panel);
        this.pack();
    }
    boolean finished = false;
    public void setRun() {
        Saver sv = new Saver();
        Thread t = new Thread(sv, ""Progress"");
        finished = false;
        t.start();
    }
    class Saver implements Runnable {
        public void run() {
            double []r = dp.getParameter();
            am.minwd = rect.getX() +5;
            am.minht = rect.getY() +5;
            am.width = rect.getX() + rect.getWidth() -5;
            am.height = rect.getY() + rect.getHeight() -5;
            am.reCalculate();
            total = am.getRounds();
            DialogGifProcess.this.setVisible(true);
            dp.setCalMode1();
            try {
                int n = total;
                while (n >= 0) {
                    am.onTimer();
                    if (!dp.reCalculate()) {
                        am.resetXY();
                    }
                    DialogGifProcess.this.setValue(total - n + 1);
                    en.addFrame(gxInstance.getBufferedImage(rect));
                    n--;
                    if (finished)
                        break;
                }
                en.finish();
                out.close();
            } catch (IOException ee) {
                System.out.println(ee.getMessage());
            }
            DialogGifProcess.this.setVisible(false);
            dp.setCalMode0();
            dp.setParameter(r);
        }
    }
    public void setTotal(int n) {
        this.total = n;
    }
    public void setValue(int n) {
        progress.setValue(n * 100 / total);
        label.setText(n + "" frame(s) added"");
    }
    public void actionPerformed(ActionEvent e) {
        finished = true;
        this.setVisible(false);
    }
}",class,
"    class Saver implements Runnable {
        public void run() {
            double []r = dp.getParameter();
            am.minwd = rect.getX() +5;
            am.minht = rect.getY() +5;
            am.width = rect.getX() + rect.getWidth() -5;
            am.height = rect.getY() + rect.getHeight() -5;
            am.reCalculate();
            total = am.getRounds();
            DialogGifProcess.this.setVisible(true);
            dp.setCalMode1();
            try {
                int n = total;
                while (n >= 0) {
                    am.onTimer();
                    if (!dp.reCalculate()) {
                        am.resetXY();
                    }
                    DialogGifProcess.this.setValue(total - n + 1);
                    en.addFrame(gxInstance.getBufferedImage(rect));
                    n--;
                    if (finished)
                        break;
                }
                en.finish();
                out.close();
            } catch (IOException ee) {
                System.out.println(ee.getMessage());
            }
            DialogGifProcess.this.setVisible(false);
            dp.setCalMode0();
            dp.setParameter(r);
        }
    }",class,
"    public DialogGifProcess(Frame f) {
        super(f, false);
        this.setTitle(""Building GIF File"");
        progress = new JProgressBar(SwingConstants.HORIZONTAL, 0, 100);
        progress.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));
        progress.setBorderPainted(true);
        progress.setStringPainted(true);
        label = new JLabel(""0 frame(s) added"");
        JPanel pp = new JPanel();
        pp.setLayout(new FlowLayout());
        pp.add(Box.createHorizontalStrut(150));
        pp.add(label);
        JPanel panel = new JPanel();
        panel.add(Box.createVerticalStrut(10));
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.add(progress);
        panel.add(pp);
        panel.add(Box.createVerticalStrut(10));
        JPanel panel1 = new JPanel();
        panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));
        panel1.add(Box.createHorizontalGlue());
        JButton b1 = new JButton(""Cancel"");
        panel1.add(b1);
        b1.addActionListener(this);
        panel.add(panel1);
        panel.add(Box.createVerticalStrut(10));
        panel.setBorder((BorderFactory.createEmptyBorder(3, 3, 3, 3)));
        this.getContentPane().add(panel);
        this.pack();
    }",method,
"    public void setRun() {
        Saver sv = new Saver();
        Thread t = new Thread(sv, ""Progress"");
        finished = false;
        t.start();
    }",method,
"        public void run() {
            double []r = dp.getParameter();
            am.minwd = rect.getX() +5;
            am.minht = rect.getY() +5;
            am.width = rect.getX() + rect.getWidth() -5;
            am.height = rect.getY() + rect.getHeight() -5;
            am.reCalculate();
            total = am.getRounds();
            DialogGifProcess.this.setVisible(true);
            dp.setCalMode1();
            try {
                int n = total;
                while (n >= 0) {
                    am.onTimer();
                    if (!dp.reCalculate()) {
                        am.resetXY();
                    }
                    DialogGifProcess.this.setValue(total - n + 1);
                    en.addFrame(gxInstance.getBufferedImage(rect));
                    n--;
                    if (finished)
                        break;
                }
                en.finish();
                out.close();
            } catch (IOException ee) {
                System.out.println(ee.getMessage());
            }
            DialogGifProcess.this.setVisible(false);
            dp.setCalMode0();
            dp.setParameter(r);
        }",method,
"                while (n >= 0) {
                    am.onTimer();
                    if (!dp.reCalculate()) {
                        am.resetXY();
                    }
                    DialogGifProcess.this.setValue(total - n + 1);
                    en.addFrame(gxInstance.getBufferedImage(rect));
                    n--;
                    if (finished)
                        break;
                }",method,
"    public void setTotal(int n) {
        this.total = n;
    }",method,
"    public void setValue(int n) {
        progress.setValue(n * 100 / total);
        label.setText(n + "" frame(s) added"");
    }",method,
"    public void actionPerformed(ActionEvent e) {
        finished = true;
        this.setVisible(false);
    }",method,
"public class CassandraReactiveRepositoriesAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@After
	public void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	public void testDefaultRepositoryConfiguration() {
		load(TestConfiguration.class);
		assertThat(this.context.getBean(ReactiveCityRepository.class)).isNotNull();
		assertThat(this.context.getBean(Cluster.class)).isNotNull();
		assertThat(getInitialEntitySet()).hasSize(1);
	}
	@Test
	public void testNoRepositoryConfiguration() {
		load(TestExcludeConfiguration.class, EmptyConfiguration.class);
		assertThat(this.context.getBean(Cluster.class)).isNotNull();
		assertThat(getInitialEntitySet()).hasSize(1).containsOnly(City.class);
	}
	@Test
	public void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		load(TestExcludeConfiguration.class, CustomizedConfiguration.class);
		assertThat(this.context.getBean(ReactiveCityCassandraRepository.class))
				.isNotNull();
		assertThat(getInitialEntitySet()).hasSize(1).containsOnly(City.class);
	}
	@SuppressWarnings(""unchecked"")
	private Set<Class<?>> getInitialEntitySet() {
		CassandraMappingContext mappingContext = this.context
				.getBean(CassandraMappingContext.class);
		return (Set<Class<?>>) ReflectionTestUtils.getField(mappingContext,
				""initialEntitySet"");
	}
	private void load(Class<?>... configurations) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.register(configurations);
		ctx.register(CassandraAutoConfiguration.class,
				CassandraRepositoriesAutoConfiguration.class,
				CassandraDataAutoConfiguration.class,
				CassandraReactiveDataAutoConfiguration.class,
				CassandraReactiveRepositoriesAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		ctx.refresh();
		this.context = ctx;
	}
	@Configuration
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
		@Bean
		public Session Session() {
			return mock(Session.class);
		}
	}
	@Configuration
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration
	@TestAutoConfigurationPackage(CassandraReactiveRepositoriesAutoConfigurationTests.class)
	@EnableReactiveCassandraRepositories(basePackageClasses = ReactiveCityCassandraRepository.class)
	static class CustomizedConfiguration {
	}
	@Configuration
	@ComponentScan(excludeFilters = @Filter(classes = {
			ReactiveSession.class }, type = FilterType.ASSIGNABLE_TYPE))
	static class TestExcludeConfiguration {
	}
}",class,
"	static class TestConfiguration {
		@Bean
		public Session Session() {
			return mock(Session.class);
		}
	}",class,
"	static class EmptyConfiguration {
	}",class,
"	static class CustomizedConfiguration {
	}",class,
"	static class TestExcludeConfiguration {
	}",class,
"	@After
	public void close() {
		if (this.context != null) {
			this.context.close();
		}
	}",method,
"		if (this.context != null) {
			this.context.close();
		}",method,
"	@Test
	public void testDefaultRepositoryConfiguration() {
		load(TestConfiguration.class);
		assertThat(this.context.getBean(ReactiveCityRepository.class)).isNotNull();
		assertThat(this.context.getBean(Cluster.class)).isNotNull();
		assertThat(getInitialEntitySet()).hasSize(1);
	}",method,
"	@Test
	public void testNoRepositoryConfiguration() {
		load(TestExcludeConfiguration.class, EmptyConfiguration.class);
		assertThat(this.context.getBean(Cluster.class)).isNotNull();
		assertThat(getInitialEntitySet()).hasSize(1).containsOnly(City.class);
	}",method,
"	@Test
	public void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		load(TestExcludeConfiguration.class, CustomizedConfiguration.class);
		assertThat(this.context.getBean(ReactiveCityCassandraRepository.class))
				.isNotNull();
		assertThat(getInitialEntitySet()).hasSize(1).containsOnly(City.class);
	}",method,
"	@SuppressWarnings(""unchecked"")
	private Set<Class<?>> getInitialEntitySet() {
		CassandraMappingContext mappingContext = this.context
				.getBean(CassandraMappingContext.class);
		return (Set<Class<?>>) ReflectionTestUtils.getField(mappingContext,
				""initialEntitySet"");
	}",method,
"	private void load(Class<?>... configurations) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.register(configurations);
		ctx.register(CassandraAutoConfiguration.class,
				CassandraRepositoriesAutoConfiguration.class,
				CassandraDataAutoConfiguration.class,
				CassandraReactiveDataAutoConfiguration.class,
				CassandraReactiveRepositoriesAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		ctx.refresh();
		this.context = ctx;
	}",method,
"		@Bean
		public Session Session() {
			return mock(Session.class);
		}",method,
"public final class Tx3gDecoder extends SimpleSubtitleDecoder {
  private static final char BOM_UTF16_BE = '\uFEFF';
  private static final char BOM_UTF16_LE = '\uFFFE';
  private static final int TYPE_STYL = Util.getIntegerCodeForString(""styl"");
  private static final int TYPE_TBOX = Util.getIntegerCodeForString(""tbox"");
  private static final String TX3G_SERIF = ""Serif"";
  private static final int SIZE_ATOM_HEADER = 8;
  private static final int SIZE_SHORT = 2;
  private static final int SIZE_BOM_UTF16 = 2;
  private static final int SIZE_STYLE_RECORD = 12;
  private static final int FONT_FACE_BOLD = 0x0001;
  private static final int FONT_FACE_ITALIC = 0x0002;
  private static final int FONT_FACE_UNDERLINE = 0x0004;
  private static final int SPAN_PRIORITY_LOW = (0xFF << Spanned.SPAN_PRIORITY_SHIFT);
  private static final int SPAN_PRIORITY_HIGH = (0x00 << Spanned.SPAN_PRIORITY_SHIFT);
  private static final int DEFAULT_FONT_FACE = 0;
  private static final int DEFAULT_COLOR = Color.WHITE;
  private static final String DEFAULT_FONT_FAMILY = C.SANS_SERIF_NAME;
  private static final float DEFAULT_VERTICAL_PLACEMENT = 0.85f;
  private final ParsableByteArray parsableByteArray;
  private boolean customVerticalPlacement;
  private int defaultFontFace;
  private int defaultColorRgba;
  private String defaultFontFamily;
  private float defaultVerticalPlacement;
  private int calculatedVideoTrackHeight;
  public Tx3gDecoder(List<byte[]> initializationData) {
    super(""Tx3gDecoder"");
    parsableByteArray = new ParsableByteArray();
    decodeInitializationData(initializationData);
  }
  private void decodeInitializationData(List<byte[]> initializationData) {
    if (initializationData != null && initializationData.size() == 1
        && (initializationData.get(0).length == 48 || initializationData.get(0).length == 53)) {
      byte[] initializationBytes = initializationData.get(0);
      defaultFontFace = initializationBytes[24];
      defaultColorRgba = ((initializationBytes[26] & 0xFF) << 24)
          | ((initializationBytes[27] & 0xFF) << 16)
          | ((initializationBytes[28] & 0xFF) << 8)
          | (initializationBytes[29] & 0xFF);
      String fontFamily = new String(initializationBytes, 43, initializationBytes.length - 43);
      defaultFontFamily = TX3G_SERIF.equals(fontFamily) ? C.SERIF_NAME : C.SANS_SERIF_NAME;
      //font size (initializationBytes[25]) is 5% of video height
      calculatedVideoTrackHeight = 20 * initializationBytes[25];
      customVerticalPlacement = (initializationBytes[0] & 0x20) != 0;
      if (customVerticalPlacement) {
        int requestedVerticalPlacement = ((initializationBytes[10] & 0xFF) << 8)
            | (initializationBytes[11] & 0xFF);
        defaultVerticalPlacement = (float) requestedVerticalPlacement / calculatedVideoTrackHeight;
        defaultVerticalPlacement = Util.constrainValue(defaultVerticalPlacement, 0.0f, 0.95f);
      } else {
        defaultVerticalPlacement = DEFAULT_VERTICAL_PLACEMENT;
      }
    } else {
      defaultFontFace = DEFAULT_FONT_FACE;
      defaultColorRgba = DEFAULT_COLOR;
      defaultFontFamily = DEFAULT_FONT_FAMILY;
      customVerticalPlacement = false;
      defaultVerticalPlacement = DEFAULT_VERTICAL_PLACEMENT;
    }
  }
  @Override
  protected Subtitle decode(byte[] bytes, int length, boolean reset)
      throws SubtitleDecoderException {
    parsableByteArray.reset(bytes, length);
    String cueTextString = readSubtitleText(parsableByteArray);
    if (cueTextString.isEmpty()) {
      return Tx3gSubtitle.EMPTY;
    }
    // Attach default styles.
    SpannableStringBuilder cueText = new SpannableStringBuilder(cueTextString);
    attachFontFace(cueText, defaultFontFace, DEFAULT_FONT_FACE, 0, cueText.length(),
        SPAN_PRIORITY_LOW);
    attachColor(cueText, defaultColorRgba, DEFAULT_COLOR, 0, cueText.length(),
        SPAN_PRIORITY_LOW);
    attachFontFamily(cueText, defaultFontFamily, DEFAULT_FONT_FAMILY, 0, cueText.length(),
        SPAN_PRIORITY_LOW);
    float verticalPlacement = defaultVerticalPlacement;
    // Find and attach additional styles.
    while (parsableByteArray.bytesLeft() >= SIZE_ATOM_HEADER) {
      int position = parsableByteArray.getPosition();
      int atomSize = parsableByteArray.readInt();
      int atomType = parsableByteArray.readInt();
      if (atomType == TYPE_STYL) {
        assertTrue(parsableByteArray.bytesLeft() >= SIZE_SHORT);
        int styleRecordCount = parsableByteArray.readUnsignedShort();
        for (int i = 0; i < styleRecordCount; i++) {
          applyStyleRecord(parsableByteArray, cueText);
        }
      } else if (atomType == TYPE_TBOX && customVerticalPlacement) {
        assertTrue(parsableByteArray.bytesLeft() >= SIZE_SHORT);
        int requestedVerticalPlacement = parsableByteArray.readUnsignedShort();
        verticalPlacement = (float) requestedVerticalPlacement / calculatedVideoTrackHeight;
        verticalPlacement = Util.constrainValue(verticalPlacement, 0.0f, 0.95f);
      }
      parsableByteArray.setPosition(position + atomSize);
    }
    return new Tx3gSubtitle(new Cue(cueText, null, verticalPlacement, Cue.LINE_TYPE_FRACTION,
        Cue.ANCHOR_TYPE_START, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET));
  }
  private static String readSubtitleText(ParsableByteArray parsableByteArray)
      throws SubtitleDecoderException {
    assertTrue(parsableByteArray.bytesLeft() >= SIZE_SHORT);
    int textLength = parsableByteArray.readUnsignedShort();
    if (textLength == 0) {
      return """";
    }
    if (parsableByteArray.bytesLeft() >= SIZE_BOM_UTF16) {
      char firstChar = parsableByteArray.peekChar();
      if (firstChar == BOM_UTF16_BE || firstChar == BOM_UTF16_LE) {
        return parsableByteArray.readString(textLength, Charset.forName(C.UTF16_NAME));
      }
    }
    return parsableByteArray.readString(textLength, Charset.forName(C.UTF8_NAME));
  }
  private void applyStyleRecord(ParsableByteArray parsableByteArray,
      SpannableStringBuilder cueText) throws SubtitleDecoderException {
    assertTrue(parsableByteArray.bytesLeft() >= SIZE_STYLE_RECORD);
    int start = parsableByteArray.readUnsignedShort();
    int end = parsableByteArray.readUnsignedShort();
    parsableByteArray.skipBytes(2); // font identifier
    int fontFace = parsableByteArray.readUnsignedByte();
    parsableByteArray.skipBytes(1); // font size
    int colorRgba = parsableByteArray.readInt();
    attachFontFace(cueText, fontFace, defaultFontFace, start, end, SPAN_PRIORITY_HIGH);
    attachColor(cueText, colorRgba, defaultColorRgba, start, end, SPAN_PRIORITY_HIGH);
  }
  private static void attachFontFace(SpannableStringBuilder cueText, int fontFace,
      int defaultFontFace, int start, int end, int spanPriority) {
    if (fontFace != defaultFontFace) {
      final int flags = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority;
      boolean isBold = (fontFace & FONT_FACE_BOLD) != 0;
      boolean isItalic = (fontFace & FONT_FACE_ITALIC) != 0;
      if (isBold) {
        if (isItalic) {
          cueText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), start, end, flags);
        } else {
          cueText.setSpan(new StyleSpan(Typeface.BOLD), start, end, flags);
        }
      } else if (isItalic) {
        cueText.setSpan(new StyleSpan(Typeface.ITALIC), start, end, flags);
      }
      boolean isUnderlined = (fontFace & FONT_FACE_UNDERLINE) != 0;
      if (isUnderlined) {
        cueText.setSpan(new UnderlineSpan(), start, end, flags);
      }
      if (!isUnderlined && !isBold && !isItalic) {
        cueText.setSpan(new StyleSpan(Typeface.NORMAL), start, end, flags);
      }
    }
  }
  private static void attachColor(SpannableStringBuilder cueText, int colorRgba,
      int defaultColorRgba, int start, int end, int spanPriority) {
    if (colorRgba != defaultColorRgba) {
      int colorArgb = ((colorRgba & 0xFF) << 24) | (colorRgba >>> 8);
      cueText.setSpan(new ForegroundColorSpan(colorArgb), start, end,
          Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority);
    }
  }
  @SuppressWarnings(""ReferenceEquality"")
  private static void attachFontFamily(SpannableStringBuilder cueText, String fontFamily,
      String defaultFontFamily, int start, int end, int spanPriority) {
    if (fontFamily != defaultFontFamily) {
      cueText.setSpan(new TypefaceSpan(fontFamily), start, end,
          Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority);
    }
  }
  private static void assertTrue(boolean checkValue) throws SubtitleDecoderException {
    if (!checkValue) {
      throw new SubtitleDecoderException(""Unexpected subtitle format."");
    }
  }
}",class,
"  public Tx3gDecoder(List<byte[]> initializationData) {
    super(""Tx3gDecoder"");
    parsableByteArray = new ParsableByteArray();
    decodeInitializationData(initializationData);
  }",method,
"  private void decodeInitializationData(List<byte[]> initializationData) {
    if (initializationData != null && initializationData.size() == 1
        && (initializationData.get(0).length == 48 || initializationData.get(0).length == 53)) {
      byte[] initializationBytes = initializationData.get(0);
      defaultFontFace = initializationBytes[24];
      defaultColorRgba = ((initializationBytes[26] & 0xFF) << 24)
          | ((initializationBytes[27] & 0xFF) << 16)
          | ((initializationBytes[28] & 0xFF) << 8)
          | (initializationBytes[29] & 0xFF);
      String fontFamily = new String(initializationBytes, 43, initializationBytes.length - 43);
      defaultFontFamily = TX3G_SERIF.equals(fontFamily) ? C.SERIF_NAME : C.SANS_SERIF_NAME;
      //font size (initializationBytes[25]) is 5% of video height
      calculatedVideoTrackHeight = 20 * initializationBytes[25];
      customVerticalPlacement = (initializationBytes[0] & 0x20) != 0;
      if (customVerticalPlacement) {
        int requestedVerticalPlacement = ((initializationBytes[10] & 0xFF) << 8)
            | (initializationBytes[11] & 0xFF);
        defaultVerticalPlacement = (float) requestedVerticalPlacement / calculatedVideoTrackHeight;
        defaultVerticalPlacement = Util.constrainValue(defaultVerticalPlacement, 0.0f, 0.95f);
      } else {
        defaultVerticalPlacement = DEFAULT_VERTICAL_PLACEMENT;
      }
    } else {
      defaultFontFace = DEFAULT_FONT_FACE;
      defaultColorRgba = DEFAULT_COLOR;
      defaultFontFamily = DEFAULT_FONT_FAMILY;
      customVerticalPlacement = false;
      defaultVerticalPlacement = DEFAULT_VERTICAL_PLACEMENT;
    }
  }",method,
"      if (customVerticalPlacement) {
        int requestedVerticalPlacement = ((initializationBytes[10] & 0xFF) << 8)
            | (initializationBytes[11] & 0xFF);
        defaultVerticalPlacement = (float) requestedVerticalPlacement / calculatedVideoTrackHeight;
        defaultVerticalPlacement = Util.constrainValue(defaultVerticalPlacement, 0.0f, 0.95f);
      }",method,
"  @Override
  protected Subtitle decode(byte[] bytes, int length, boolean reset)
      throws SubtitleDecoderException {
    parsableByteArray.reset(bytes, length);
    String cueTextString = readSubtitleText(parsableByteArray);
    if (cueTextString.isEmpty()) {
      return Tx3gSubtitle.EMPTY;
    }
    // Attach default styles.
    SpannableStringBuilder cueText = new SpannableStringBuilder(cueTextString);
    attachFontFace(cueText, defaultFontFace, DEFAULT_FONT_FACE, 0, cueText.length(),
        SPAN_PRIORITY_LOW);
    attachColor(cueText, defaultColorRgba, DEFAULT_COLOR, 0, cueText.length(),
        SPAN_PRIORITY_LOW);
    attachFontFamily(cueText, defaultFontFamily, DEFAULT_FONT_FAMILY, 0, cueText.length(),
        SPAN_PRIORITY_LOW);
    float verticalPlacement = defaultVerticalPlacement;
    // Find and attach additional styles.
    while (parsableByteArray.bytesLeft() >= SIZE_ATOM_HEADER) {
      int position = parsableByteArray.getPosition();
      int atomSize = parsableByteArray.readInt();
      int atomType = parsableByteArray.readInt();
      if (atomType == TYPE_STYL) {
        assertTrue(parsableByteArray.bytesLeft() >= SIZE_SHORT);
        int styleRecordCount = parsableByteArray.readUnsignedShort();
        for (int i = 0; i < styleRecordCount; i++) {
          applyStyleRecord(parsableByteArray, cueText);
        }
      } else if (atomType == TYPE_TBOX && customVerticalPlacement) {
        assertTrue(parsableByteArray.bytesLeft() >= SIZE_SHORT);
        int requestedVerticalPlacement = parsableByteArray.readUnsignedShort();
        verticalPlacement = (float) requestedVerticalPlacement / calculatedVideoTrackHeight;
        verticalPlacement = Util.constrainValue(verticalPlacement, 0.0f, 0.95f);
      }
      parsableByteArray.setPosition(position + atomSize);
    }
    return new Tx3gSubtitle(new Cue(cueText, null, verticalPlacement, Cue.LINE_TYPE_FRACTION,
        Cue.ANCHOR_TYPE_START, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET));
  }",method,
"      if (atomType == TYPE_STYL) {
        assertTrue(parsableByteArray.bytesLeft() >= SIZE_SHORT);
        int styleRecordCount = parsableByteArray.readUnsignedShort();
        for (int i = 0; i < styleRecordCount; i++) {
          applyStyleRecord(parsableByteArray, cueText);
        }
      }",method,
"        for (int i = 0; i < styleRecordCount; i++) {
          applyStyleRecord(parsableByteArray, cueText);
        }",method,
"  private static String readSubtitleText(ParsableByteArray parsableByteArray)
      throws SubtitleDecoderException {
    assertTrue(parsableByteArray.bytesLeft() >= SIZE_SHORT);
    int textLength = parsableByteArray.readUnsignedShort();
    if (textLength == 0) {
      return """";
    }
    if (parsableByteArray.bytesLeft() >= SIZE_BOM_UTF16) {
      char firstChar = parsableByteArray.peekChar();
      if (firstChar == BOM_UTF16_BE || firstChar == BOM_UTF16_LE) {
        return parsableByteArray.readString(textLength, Charset.forName(C.UTF16_NAME));
      }
    }
    return parsableByteArray.readString(textLength, Charset.forName(C.UTF8_NAME));
  }",method,
"    if (textLength == 0) {
      return """";
    }",method,
"      if (firstChar == BOM_UTF16_BE || firstChar == BOM_UTF16_LE) {
        return parsableByteArray.readString(textLength, Charset.forName(C.UTF16_NAME));
      }",method,
"  private void applyStyleRecord(ParsableByteArray parsableByteArray,
      SpannableStringBuilder cueText) throws SubtitleDecoderException {
    assertTrue(parsableByteArray.bytesLeft() >= SIZE_STYLE_RECORD);
    int start = parsableByteArray.readUnsignedShort();
    int end = parsableByteArray.readUnsignedShort();
    parsableByteArray.skipBytes(2); // font identifier
    int fontFace = parsableByteArray.readUnsignedByte();
    parsableByteArray.skipBytes(1); // font size
    int colorRgba = parsableByteArray.readInt();
    attachFontFace(cueText, fontFace, defaultFontFace, start, end, SPAN_PRIORITY_HIGH);
    attachColor(cueText, colorRgba, defaultColorRgba, start, end, SPAN_PRIORITY_HIGH);
  }",method,
"  private static void attachFontFace(SpannableStringBuilder cueText, int fontFace,
      int defaultFontFace, int start, int end, int spanPriority) {
    if (fontFace != defaultFontFace) {
      final int flags = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority;
      boolean isBold = (fontFace & FONT_FACE_BOLD) != 0;
      boolean isItalic = (fontFace & FONT_FACE_ITALIC) != 0;
      if (isBold) {
        if (isItalic) {
          cueText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), start, end, flags);
        } else {
          cueText.setSpan(new StyleSpan(Typeface.BOLD), start, end, flags);
        }
      } else if (isItalic) {
        cueText.setSpan(new StyleSpan(Typeface.ITALIC), start, end, flags);
      }
      boolean isUnderlined = (fontFace & FONT_FACE_UNDERLINE) != 0;
      if (isUnderlined) {
        cueText.setSpan(new UnderlineSpan(), start, end, flags);
      }
      if (!isUnderlined && !isBold && !isItalic) {
        cueText.setSpan(new StyleSpan(Typeface.NORMAL), start, end, flags);
      }
    }
  }",method,
"    if (fontFace != defaultFontFace) {
      final int flags = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority;
      boolean isBold = (fontFace & FONT_FACE_BOLD) != 0;
      boolean isItalic = (fontFace & FONT_FACE_ITALIC) != 0;
      if (isBold) {
        if (isItalic) {
          cueText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), start, end, flags);
        } else {
          cueText.setSpan(new StyleSpan(Typeface.BOLD), start, end, flags);
        }
      } else if (isItalic) {
        cueText.setSpan(new StyleSpan(Typeface.ITALIC), start, end, flags);
      }
      boolean isUnderlined = (fontFace & FONT_FACE_UNDERLINE) != 0;
      if (isUnderlined) {
        cueText.setSpan(new UnderlineSpan(), start, end, flags);
      }
      if (!isUnderlined && !isBold && !isItalic) {
        cueText.setSpan(new StyleSpan(Typeface.NORMAL), start, end, flags);
      }
    }",method,
"      if (isBold) {
        if (isItalic) {
          cueText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), start, end, flags);
        } else {
          cueText.setSpan(new StyleSpan(Typeface.BOLD), start, end, flags);
        }
      }",method,
"        if (isItalic) {
          cueText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), start, end, flags);
        }",method,
"      if (isUnderlined) {
        cueText.setSpan(new UnderlineSpan(), start, end, flags);
      }",method,
"      if (!isUnderlined && !isBold && !isItalic) {
        cueText.setSpan(new StyleSpan(Typeface.NORMAL), start, end, flags);
      }",method,
"  private static void attachColor(SpannableStringBuilder cueText, int colorRgba,
      int defaultColorRgba, int start, int end, int spanPriority) {
    if (colorRgba != defaultColorRgba) {
      int colorArgb = ((colorRgba & 0xFF) << 24) | (colorRgba >>> 8);
      cueText.setSpan(new ForegroundColorSpan(colorArgb), start, end,
          Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority);
    }
  }",method,
"    if (colorRgba != defaultColorRgba) {
      int colorArgb = ((colorRgba & 0xFF) << 24) | (colorRgba >>> 8);
      cueText.setSpan(new ForegroundColorSpan(colorArgb), start, end,
          Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority);
    }",method,
"  @SuppressWarnings(""ReferenceEquality"")
  private static void attachFontFamily(SpannableStringBuilder cueText, String fontFamily,
      String defaultFontFamily, int start, int end, int spanPriority) {
    if (fontFamily != defaultFontFamily) {
      cueText.setSpan(new TypefaceSpan(fontFamily), start, end,
          Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority);
    }
  }",method,
"    if (fontFamily != defaultFontFamily) {
      cueText.setSpan(new TypefaceSpan(fontFamily), start, end,
          Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | spanPriority);
    }",method,
"  private static void assertTrue(boolean checkValue) throws SubtitleDecoderException {
    if (!checkValue) {
      throw new SubtitleDecoderException(""Unexpected subtitle format."");
    }
  }",method,
"    if (!checkValue) {
      throw new SubtitleDecoderException(""Unexpected subtitle format."");
    }",method,
"public class TroffAnalyzer extends FileAnalyzer {
    private char[] content;
    private int len;
    private final TroffFullTokenizer troffull;
    private final TroffXref xref;
    Reader dummy = new StringReader("""");
    protected TroffAnalyzer(FileAnalyzerFactory factory) {
        super(factory);
        troffull = new TroffFullTokenizer(dummy);
        xref = new TroffXref(dummy);
        content = new char[12 * 1024];
    }
    @Override
    public void analyze(Document doc, InputStream in) throws IOException {
        len = 0;
        do {
            InputStreamReader inReader = new InputStreamReader(in);
            int rbytes = inReader.read(content, len, content.length - len);
            if (rbytes > 0 ) {
                if (rbytes == (content.length - len)) {
                    content = Arrays.copyOf(content, content.length * 2);
                }
                len += rbytes;
            } else {
                break;
            }
        } while(true);
        doc.add(new Field(""full"", new StringReader("""")));
    }
    @Override
    public TokenStream overridableTokenStream(String fieldName, Reader reader) {
        if (""full"".equals(fieldName)) {
            troffull.reInit(content, len);
            return troffull;
        }
        return super.overridableTokenStream(fieldName, reader);
    }
    @Override
    public void writeXref(Writer out) throws IOException {
        xref.reInit(content, len);
        xref.project = project;
        out.write(""</pre><div id=\""man\"">"");
        xref.write(out);
        out.write(""</div><pre>"");
    }
    static void writeXref(Reader in, Writer out, Definitions defs, Annotation annotation, Project project) throws IOException {
        TroffXref xref = new TroffXref(in);
        xref.project = project;
        xref.setDefs(defs);
        out.write(""</pre><div id=\""man\"">"");
        xref.write(out);
        out.write(""</div><pre>"");
    }
}",class,
"    protected TroffAnalyzer(FileAnalyzerFactory factory) {
        super(factory);
        troffull = new TroffFullTokenizer(dummy);
        xref = new TroffXref(dummy);
        content = new char[12 * 1024];
    }",method,
"    @Override
    public void analyze(Document doc, InputStream in) throws IOException {
        len = 0;
        do {
            InputStreamReader inReader = new InputStreamReader(in);
            int rbytes = inReader.read(content, len, content.length - len);
            if (rbytes > 0 ) {
                if (rbytes == (content.length - len)) {
                    content = Arrays.copyOf(content, content.length * 2);
                }
                len += rbytes;
            } else {
                break;
            }
        } while(true);
        doc.add(new Field(""full"", new StringReader("""")));
    }",method,
"            if (rbytes > 0 ) {
                if (rbytes == (content.length - len)) {
                    content = Arrays.copyOf(content, content.length * 2);
                }
                len += rbytes;
            }",method,
"    @Override
    public TokenStream overridableTokenStream(String fieldName, Reader reader) {
        if (""full"".equals(fieldName)) {
            troffull.reInit(content, len);
            return troffull;
        }
        return super.overridableTokenStream(fieldName, reader);
    }",method,
"    @Override
    public void writeXref(Writer out) throws IOException {
        xref.reInit(content, len);
        xref.project = project;
        out.write(""</pre><div id=\""man\"">"");
        xref.write(out);
        out.write(""</div><pre>"");
    }",method,
"    static void writeXref(Reader in, Writer out, Definitions defs, Annotation annotation, Project project) throws IOException {
        TroffXref xref = new TroffXref(in);
        xref.project = project;
        xref.setDefs(defs);
        out.write(""</pre><div id=\""man\"">"");
        xref.write(out);
        out.write(""</div><pre>"");
    }",method,
"public class YearTypeHandlerTest extends BaseTypeHandlerTest {
  private static final TypeHandler<Year> TYPE_HANDLER = new YearTypeHandler();
  private static final Year INSTANT = Year.now();
  @Override
  @Test
  public void shouldSetParameter() throws Exception {
    TYPE_HANDLER.setParameter(ps, 1, INSTANT, null);
    verify(ps).setInt(1, INSTANT.getValue());
  }
  @Override
  @Test
  public void shouldGetResultFromResultSetByName() throws Exception {
    when(rs.getInt(""column"")).thenReturn(INSTANT.getValue());
    assertEquals(INSTANT, TYPE_HANDLER.getResult(rs, ""column""));
  }
  @Override
  @Test
  public void shouldGetResultNullFromResultSetByName() throws Exception {
    when(rs.getInt(""column"")).thenReturn(0);
    when(rs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(rs, ""column""));
  }
  @Override
  @Test
  public void shouldGetResultFromResultSetByPosition() throws Exception {
    when(rs.getInt(1)).thenReturn(INSTANT.getValue());
    assertEquals(INSTANT, TYPE_HANDLER.getResult(rs, 1));
  }
  @Override
  @Test
  public void shouldGetResultNullFromResultSetByPosition() throws Exception {
    when(rs.getInt(1)).thenReturn(0);
    when(rs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(rs, 1));
  }
  @Override
  @Test
  public void shouldGetResultFromCallableStatement() throws Exception {
    when(cs.getInt(1)).thenReturn(INSTANT.getValue());
    assertEquals(INSTANT, TYPE_HANDLER.getResult(cs, 1));
  }
  @Override
  @Test
  public void shouldGetResultNullFromCallableStatement() throws Exception {
    when(cs.getInt(1)).thenReturn(0);
    when(cs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(cs, 1));
  }
}",class,
"  @Override
  @Test
  public void shouldSetParameter() throws Exception {
    TYPE_HANDLER.setParameter(ps, 1, INSTANT, null);
    verify(ps).setInt(1, INSTANT.getValue());
  }",method,
"  @Override
  @Test
  public void shouldGetResultFromResultSetByName() throws Exception {
    when(rs.getInt(""column"")).thenReturn(INSTANT.getValue());
    assertEquals(INSTANT, TYPE_HANDLER.getResult(rs, ""column""));
  }",method,
"  @Override
  @Test
  public void shouldGetResultNullFromResultSetByName() throws Exception {
    when(rs.getInt(""column"")).thenReturn(0);
    when(rs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(rs, ""column""));
  }",method,
"  @Override
  @Test
  public void shouldGetResultFromResultSetByPosition() throws Exception {
    when(rs.getInt(1)).thenReturn(INSTANT.getValue());
    assertEquals(INSTANT, TYPE_HANDLER.getResult(rs, 1));
  }",method,
"  @Override
  @Test
  public void shouldGetResultNullFromResultSetByPosition() throws Exception {
    when(rs.getInt(1)).thenReturn(0);
    when(rs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(rs, 1));
  }",method,
"  @Override
  @Test
  public void shouldGetResultFromCallableStatement() throws Exception {
    when(cs.getInt(1)).thenReturn(INSTANT.getValue());
    assertEquals(INSTANT, TYPE_HANDLER.getResult(cs, 1));
  }",method,
"  @Override
  @Test
  public void shouldGetResultNullFromCallableStatement() throws Exception {
    when(cs.getInt(1)).thenReturn(0);
    when(cs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(cs, 1));
  }",method,
"public class DSymbolNode extends DNode {
    public DSymbolNode(ISourcePosition position, DStrNode node) {
        super(position, node.getEncoding());
        assert node != null : ""node is not null"";
        addAll(node);
    }
    public DSymbolNode(ISourcePosition position) {
        super(position);
    }
    @Override
    public NodeType getNodeType() {
        return NodeType.DSYMBOLNODE;
    }
    @Override
    public Object accept(NodeVisitor visitor) {
        return visitor.visitDSymbolNode(this);
    }
}",class,
"    public DSymbolNode(ISourcePosition position, DStrNode node) {
        super(position, node.getEncoding());
        assert node != null : ""node is not null"";
        addAll(node);
    }",method,

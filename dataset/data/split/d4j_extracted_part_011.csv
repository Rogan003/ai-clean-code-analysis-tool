code_snippet,type,score
"    if (this == o) {
      return true;
    }",method,
"    if (myOrdinal != that.myOrdinal) {
      return false;
    }",method,
"  public int hashCode() {
    int result = myLambda.hashCode();
    result = 31 * result + myOrdinal;
    return result;
  }",method,
"public final class ReadConfigTest extends JavaRequiresMongoDB {
    @Test
    public void shouldBeCreatableFromTheSparkConf() {
        ReadConfig readConfig = ReadConfig.create(getSparkConf().remove(""spark.mongodb.input.partitioner""));
        ReadConfig expectedReadConfig = ReadConfig.create(getDatabaseName(), getCollectionName(), getMongoClientURI(), 1000,
                ""DefaultMongoPartitioner$"", new HashMap<String, String>(), 15, ReadPreference.primary(), ReadConcern.DEFAULT);
        assertEquals(readConfig.databaseName(), expectedReadConfig.databaseName());
        assertEquals(readConfig.collectionName(), expectedReadConfig.collectionName());
        assertEquals(readConfig.connectionString(), expectedReadConfig.connectionString());
        assertEquals(readConfig.sampleSize(), expectedReadConfig.sampleSize());
        assertEquals(readConfig.partitioner(), expectedReadConfig.partitioner());
        assertEquals(readConfig.partitionerOptions(), expectedReadConfig.partitionerOptions());
        assertEquals(readConfig.localThreshold(), expectedReadConfig.localThreshold());
        assertEquals(readConfig.readPreferenceConfig(), expectedReadConfig.readPreferenceConfig());
        assertEquals(readConfig.readConcernConfig(), expectedReadConfig.readConcernConfig());
    }
    @Test
    public void shouldBeCreatableFromAJavaMap() {
        Map<String, String> options = new HashMap<String, String>();
        options.put(ReadConfig.databaseNameProperty(), ""db"");
        options.put(ReadConfig.collectionNameProperty(), ""collection"");
        options.put(ReadConfig.sampleSizeProperty(), ""500"");
        options.put(ReadConfig.partitionerProperty(), ""MongoSamplePartitioner$"");
        options.put(ReadConfig.partitionerOptionsProperty() + "".partitionSizeMB"", ""10"");
        options.put(ReadConfig.localThresholdProperty(), ""0"");
        options.put(ReadConfig.readPreferenceNameProperty(), ""secondaryPreferred"");
        options.put(ReadConfig.readPreferenceTagSetsProperty(), ""[{dc: \""east\"", use: \""production\""},{}]"");
        options.put(ReadConfig.readConcernLevelProperty(), ""majority"");
        ReadConfig readConfig = ReadConfig.create(options);
        HashMap<String, String> partitionerOptions = new HashMap<String, String>();
        partitionerOptions.put(ReadConfig.partitionerOptionsProperty() + "".partitionSizeMB"", ""10"");
        ReadConfig expectedReadConfig = ReadConfig.create(""db"", ""collection"", null, 500, ""MongoSamplePartitioner$"",
                partitionerOptions, 0,
                ReadPreference.secondaryPreferred(asList(new TagSet(asList(new Tag(""dc"", ""east""), new Tag(""use"", ""production""))), new TagSet())),
                ReadConcern.MAJORITY);
        assertEquals(readConfig.databaseName(), expectedReadConfig.databaseName());
        assertEquals(readConfig.collectionName(), expectedReadConfig.collectionName());
        assertEquals(readConfig.connectionString(), expectedReadConfig.connectionString());
        assertEquals(readConfig.sampleSize(), expectedReadConfig.sampleSize());
        assertEquals(readConfig.partitioner(), expectedReadConfig.partitioner());
        assertEquals(readConfig.partitionerOptions(), expectedReadConfig.partitionerOptions());
        assertEquals(readConfig.localThreshold(), expectedReadConfig.localThreshold());
        assertEquals(readConfig.readPreferenceConfig(), expectedReadConfig.readPreferenceConfig());
        assertEquals(readConfig.readConcernConfig(), expectedReadConfig.readConcernConfig());
    }
    @Test
    public void shouldBeCreatableFromAJavaMapAndUseDefaults() {
        Map<String, String> options = new HashMap<String, String>();
        options.put(ReadConfig.databaseNameProperty(), ""db"");
        options.put(ReadConfig.collectionNameProperty(), ""collection"");
        options.put(ReadConfig.readPreferenceNameProperty(), ""secondaryPreferred"");
        options.put(ReadConfig.readConcernLevelProperty(), ""majority"");
        ReadConfig readConfig = ReadConfig.create(options, ReadConfig.create(getSparkConf().remove(""spark.mongodb.input.partitioner"")));
        ReadConfig expectedReadConfig = ReadConfig.create(""db"", ""collection"", getMongoClientURI(), 1000,
                ""DefaultMongoPartitioner$"", new HashMap<String, String>(), 15, ReadPreference.secondaryPreferred(),
                ReadConcern.MAJORITY);
        assertEquals(readConfig.databaseName(), expectedReadConfig.databaseName());
        assertEquals(readConfig.collectionName(), expectedReadConfig.collectionName());
        assertEquals(readConfig.connectionString(), expectedReadConfig.connectionString());
        assertEquals(readConfig.sampleSize(), expectedReadConfig.sampleSize());
        assertEquals(readConfig.partitioner(), expectedReadConfig.partitioner());
        assertEquals(readConfig.partitionerOptions(), expectedReadConfig.partitionerOptions());
        assertEquals(readConfig.localThreshold(), expectedReadConfig.localThreshold());
        assertEquals(readConfig.readPreferenceConfig(), expectedReadConfig.readPreferenceConfig());
        assertEquals(readConfig.readConcernConfig(), expectedReadConfig.readConcernConfig());
    }
}",class,
"    @Test
    public void shouldBeCreatableFromTheSparkConf() {
        ReadConfig readConfig = ReadConfig.create(getSparkConf().remove(""spark.mongodb.input.partitioner""));
        ReadConfig expectedReadConfig = ReadConfig.create(getDatabaseName(), getCollectionName(), getMongoClientURI(), 1000,
                ""DefaultMongoPartitioner$"", new HashMap<String, String>(), 15, ReadPreference.primary(), ReadConcern.DEFAULT);
        assertEquals(readConfig.databaseName(), expectedReadConfig.databaseName());
        assertEquals(readConfig.collectionName(), expectedReadConfig.collectionName());
        assertEquals(readConfig.connectionString(), expectedReadConfig.connectionString());
        assertEquals(readConfig.sampleSize(), expectedReadConfig.sampleSize());
        assertEquals(readConfig.partitioner(), expectedReadConfig.partitioner());
        assertEquals(readConfig.partitionerOptions(), expectedReadConfig.partitionerOptions());
        assertEquals(readConfig.localThreshold(), expectedReadConfig.localThreshold());
        assertEquals(readConfig.readPreferenceConfig(), expectedReadConfig.readPreferenceConfig());
        assertEquals(readConfig.readConcernConfig(), expectedReadConfig.readConcernConfig());
    }",method,
"    @Test
    public void shouldBeCreatableFromAJavaMap() {
        Map<String, String> options = new HashMap<String, String>();
        options.put(ReadConfig.databaseNameProperty(), ""db"");
        options.put(ReadConfig.collectionNameProperty(), ""collection"");
        options.put(ReadConfig.sampleSizeProperty(), ""500"");
        options.put(ReadConfig.partitionerProperty(), ""MongoSamplePartitioner$"");
        options.put(ReadConfig.partitionerOptionsProperty() + "".partitionSizeMB"", ""10"");
        options.put(ReadConfig.localThresholdProperty(), ""0"");
        options.put(ReadConfig.readPreferenceNameProperty(), ""secondaryPreferred"");
        options.put(ReadConfig.readPreferenceTagSetsProperty(), ""[{dc: \""east\"", use: \""production\""},{}]"");
        options.put(ReadConfig.readConcernLevelProperty(), ""majority"");
        ReadConfig readConfig = ReadConfig.create(options);
        HashMap<String, String> partitionerOptions = new HashMap<String, String>();
        partitionerOptions.put(ReadConfig.partitionerOptionsProperty() + "".partitionSizeMB"", ""10"");
        ReadConfig expectedReadConfig = ReadConfig.create(""db"", ""collection"", null, 500, ""MongoSamplePartitioner$"",
                partitionerOptions, 0,
                ReadPreference.secondaryPreferred(asList(new TagSet(asList(new Tag(""dc"", ""east""), new Tag(""use"", ""production""))), new TagSet())),
                ReadConcern.MAJORITY);
        assertEquals(readConfig.databaseName(), expectedReadConfig.databaseName());
        assertEquals(readConfig.collectionName(), expectedReadConfig.collectionName());
        assertEquals(readConfig.connectionString(), expectedReadConfig.connectionString());
        assertEquals(readConfig.sampleSize(), expectedReadConfig.sampleSize());
        assertEquals(readConfig.partitioner(), expectedReadConfig.partitioner());
        assertEquals(readConfig.partitionerOptions(), expectedReadConfig.partitionerOptions());
        assertEquals(readConfig.localThreshold(), expectedReadConfig.localThreshold());
        assertEquals(readConfig.readPreferenceConfig(), expectedReadConfig.readPreferenceConfig());
        assertEquals(readConfig.readConcernConfig(), expectedReadConfig.readConcernConfig());
    }",method,
"    @Test
    public void shouldBeCreatableFromAJavaMapAndUseDefaults() {
        Map<String, String> options = new HashMap<String, String>();
        options.put(ReadConfig.databaseNameProperty(), ""db"");
        options.put(ReadConfig.collectionNameProperty(), ""collection"");
        options.put(ReadConfig.readPreferenceNameProperty(), ""secondaryPreferred"");
        options.put(ReadConfig.readConcernLevelProperty(), ""majority"");
        ReadConfig readConfig = ReadConfig.create(options, ReadConfig.create(getSparkConf().remove(""spark.mongodb.input.partitioner"")));
        ReadConfig expectedReadConfig = ReadConfig.create(""db"", ""collection"", getMongoClientURI(), 1000,
                ""DefaultMongoPartitioner$"", new HashMap<String, String>(), 15, ReadPreference.secondaryPreferred(),
                ReadConcern.MAJORITY);
        assertEquals(readConfig.databaseName(), expectedReadConfig.databaseName());
        assertEquals(readConfig.collectionName(), expectedReadConfig.collectionName());
        assertEquals(readConfig.connectionString(), expectedReadConfig.connectionString());
        assertEquals(readConfig.sampleSize(), expectedReadConfig.sampleSize());
        assertEquals(readConfig.partitioner(), expectedReadConfig.partitioner());
        assertEquals(readConfig.partitionerOptions(), expectedReadConfig.partitionerOptions());
        assertEquals(readConfig.localThreshold(), expectedReadConfig.localThreshold());
        assertEquals(readConfig.readPreferenceConfig(), expectedReadConfig.readPreferenceConfig());
        assertEquals(readConfig.readConcernConfig(), expectedReadConfig.readConcernConfig());
    }",method,
"public class ContributionIndexTableModel
    extends FilteredAbstractTableModel<ContributedPlatform> {
  private final List<ContributedPlatformReleases> contributions = new ArrayList<>();
  private final String[] columnNames = { ""Description"" };
  private final Class<?>[] columnTypes = { ContributedPlatform.class };
  public void updateIndexFilter(String[] filters,
                                Stream<Predicate<ContributedPlatform>> additionalFilters) {
    contributions.clear();
    Predicate<ContributedPlatform> filter = additionalFilters
        .reduce(Predicate::and).get();
    for (ContributedPackage pack : BaseNoGui.indexer.getPackages()) {
      for (ContributedPlatform platform : pack.getPlatforms()) {
        String compoundTargetSearchText = platform.getName() + ""\n""
                                          + platform.getBoards().stream()
                                              .map(ContributedBoard::getName)
                                              .collect(Collectors.joining("" ""));
        if (!filter.test(platform)) {
          continue;
        }
        if (!stringContainsAll(compoundTargetSearchText, filters))
          continue;
        addContribution(platform);
      }
    }
    fireTableDataChanged();
  }
  private boolean stringContainsAll(String string, String set[]) {
    if (set == null)
      return true;
    for (String s : set) {
      if (!string.toLowerCase().contains(s.toLowerCase()))
        return false;
    }
    return true;
  }
  private void addContribution(ContributedPlatform platform) {
    for (ContributedPlatformReleases contribution : contributions) {
      if (!contribution.shouldContain(platform))
        continue;
      contribution.add(platform);
      return;
    }
    contributions.add(new ContributedPlatformReleases(platform));
  }
  @Override
  public int getColumnCount() {
    return columnNames.length;
  }
  @Override
  public int getRowCount() {
    return contributions.size();
  }
  @Override
  public String getColumnName(int column) {
    return columnNames[column];
  }
  @Override
  public Class<?> getColumnClass(int colum) {
    return columnTypes[colum];
  }
  @Override
  public void setValueAt(Object value, int row, int col) {
    fireTableCellUpdated(row, col);
  }
  @Override
  public Object getValueAt(int row, int col) {
    if (row >= contributions.size()) {
      return null;
    }
    ContributedPlatformReleases contribution = contributions.get(row);
    return contribution;// .getSelected();
  }
  @Override
  public boolean isCellEditable(int row, int col) {
    return true;
  }
  public ContributedPlatformReleases getReleases(int row) {
    return contributions.get(row);
  }
  public ContributedPlatform getSelectedRelease(int row) {
    return contributions.get(row).getSelected();
  }
  public void update() {
    fireTableDataChanged();
  }
}",class,
"  public void updateIndexFilter(String[] filters,
                                Stream<Predicate<ContributedPlatform>> additionalFilters) {
    contributions.clear();
    Predicate<ContributedPlatform> filter = additionalFilters
        .reduce(Predicate::and).get();
    for (ContributedPackage pack : BaseNoGui.indexer.getPackages()) {
      for (ContributedPlatform platform : pack.getPlatforms()) {
        String compoundTargetSearchText = platform.getName() + ""\n""
                                          + platform.getBoards().stream()
                                              .map(ContributedBoard::getName)
                                              .collect(Collectors.joining("" ""));
        if (!filter.test(platform)) {
          continue;
        }
        if (!stringContainsAll(compoundTargetSearchText, filters))
          continue;
        addContribution(platform);
      }
    }
    fireTableDataChanged();
  }",method,
"  private boolean stringContainsAll(String string, String set[]) {
    if (set == null)
      return true;
    for (String s : set) {
      if (!string.toLowerCase().contains(s.toLowerCase()))
        return false;
    }
    return true;
  }",method,
"    for (String s : set) {
      if (!string.toLowerCase().contains(s.toLowerCase()))
        return false;
    }",method,
"  private void addContribution(ContributedPlatform platform) {
    for (ContributedPlatformReleases contribution : contributions) {
      if (!contribution.shouldContain(platform))
        continue;
      contribution.add(platform);
      return;
    }
    contributions.add(new ContributedPlatformReleases(platform));
  }",method,
"    for (ContributedPlatformReleases contribution : contributions) {
      if (!contribution.shouldContain(platform))
        continue;
      contribution.add(platform);
      return;
    }",method,
"  @Override
  public int getColumnCount() {
    return columnNames.length;
  }",method,
"  @Override
  public int getRowCount() {
    return contributions.size();
  }",method,
"  @Override
  public String getColumnName(int column) {
    return columnNames[column];
  }",method,
"  @Override
  public Class<?> getColumnClass(int colum) {
    return columnTypes[colum];
  }",method,
"  @Override
  public void setValueAt(Object value, int row, int col) {
    fireTableCellUpdated(row, col);
  }",method,
"  @Override
  public Object getValueAt(int row, int col) {
    if (row >= contributions.size()) {
      return null;
    }
    ContributedPlatformReleases contribution = contributions.get(row);
    return contribution;// .getSelected();
  }",method,
"  @Override
  public boolean isCellEditable(int row, int col) {
    return true;
  }",method,
"  public ContributedPlatformReleases getReleases(int row) {
    return contributions.get(row);
  }",method,
"  public ContributedPlatform getSelectedRelease(int row) {
    return contributions.get(row).getSelected();
  }",method,
"  public void update() {
    fireTableDataChanged();
  }",method,
"public class CachingOrcDataSource
        implements OrcDataSource
{
    private final OrcDataSource dataSource;
    private final RegionFinder regionFinder;
    private long cachePosition;
    private int cacheLength;
    private byte[] cache;
    public CachingOrcDataSource(OrcDataSource dataSource, RegionFinder regionFinder)
    {
        this.dataSource = requireNonNull(dataSource, ""dataSource is null"");
        this.regionFinder = requireNonNull(regionFinder, ""regionFinder is null"");
        this.cache = new byte[0];
    }
    @Override
    public OrcDataSourceId getId()
    {
        return dataSource.getId();
    }
    @Override
    public long getReadBytes()
    {
        return dataSource.getReadBytes();
    }
    @Override
    public long getReadTimeNanos()
    {
        return dataSource.getReadTimeNanos();
    }
    @Override
    public long getSize()
    {
        return dataSource.getSize();
    }
    @VisibleForTesting
    void readCacheAt(long offset)
            throws IOException
    {
        DiskRange newCacheRange = regionFinder.getRangeFor(offset);
        cachePosition = newCacheRange.getOffset();
        cacheLength = newCacheRange.getLength();
        if (cache.length < cacheLength) {
            cache = new byte[cacheLength];
        }
        dataSource.readFully(newCacheRange.getOffset(), cache, 0, cacheLength);
    }
    @Override
    public void readFully(long position, byte[] buffer)
            throws IOException
    {
        readFully(position, buffer, 0, buffer.length);
    }
    @Override
    public void readFully(long position, byte[] buffer, int bufferOffset, int length)
            throws IOException
    {
        if (position < cachePosition) {
            throw new IllegalArgumentException(String.format(""read request (offset %d length %d) is before cache (offset %d length %d)"", position, length, cachePosition, cacheLength));
        }
        if (position >= cachePosition + cacheLength) {
            readCacheAt(position);
        }
        if (position + length > cachePosition + cacheLength) {
            throw new IllegalArgumentException(String.format(""read request (offset %d length %d) partially overlaps cache (offset %d length %d)"", position, length, cachePosition, cacheLength));
        }
        System.arraycopy(cache, toIntExact(position - cachePosition), buffer, bufferOffset, length);
    }
    @Override
    public <K> Map<K, FixedLengthSliceInput> readFully(Map<K, DiskRange> diskRanges)
            throws IOException
    {
        ImmutableMap.Builder<K, FixedLengthSliceInput> builder = ImmutableMap.builder();
        // Assumption here: all disk ranges are in the same region. Therefore, serving them in arbitrary order
        // will not result in eviction of cache that otherwise could have served any of the DiskRanges provided.
        for (Map.Entry<K, DiskRange> entry : diskRanges.entrySet()) {
            DiskRange diskRange = entry.getValue();
            byte[] buffer = new byte[diskRange.getLength()];
            readFully(diskRange.getOffset(), buffer);
            builder.put(entry.getKey(), Slices.wrappedBuffer(buffer).getInput());
        }
        return builder.build();
    }
    @Override
    public void close()
            throws IOException
    {
        dataSource.close();
    }
    @Override
    public String toString()
    {
        return dataSource.toString();
    }
    public interface RegionFinder
    {
        DiskRange getRangeFor(long desiredOffset);
    }
}",class,
"    public CachingOrcDataSource(OrcDataSource dataSource, RegionFinder regionFinder)
    {
        this.dataSource = requireNonNull(dataSource, ""dataSource is null"");
        this.regionFinder = requireNonNull(regionFinder, ""regionFinder is null"");
        this.cache = new byte[0];
    }",method,
"    @Override
    public OrcDataSourceId getId()
    {
        return dataSource.getId();
    }",method,
"    @Override
    public long getReadBytes()
    {
        return dataSource.getReadBytes();
    }",method,
"    @Override
    public long getReadTimeNanos()
    {
        return dataSource.getReadTimeNanos();
    }",method,
"    @Override
    public long getSize()
    {
        return dataSource.getSize();
    }",method,
"    @VisibleForTesting
    void readCacheAt(long offset)
            throws IOException
    {
        DiskRange newCacheRange = regionFinder.getRangeFor(offset);
        cachePosition = newCacheRange.getOffset();
        cacheLength = newCacheRange.getLength();
        if (cache.length < cacheLength) {
            cache = new byte[cacheLength];
        }
        dataSource.readFully(newCacheRange.getOffset(), cache, 0, cacheLength);
    }",method,
"        if (cache.length < cacheLength) {
            cache = new byte[cacheLength];
        }",method,
"    @Override
    public void readFully(long position, byte[] buffer)
            throws IOException
    {
        readFully(position, buffer, 0, buffer.length);
    }",method,
"    @Override
    public void readFully(long position, byte[] buffer, int bufferOffset, int length)
            throws IOException
    {
        if (position < cachePosition) {
            throw new IllegalArgumentException(String.format(""read request (offset %d length %d) is before cache (offset %d length %d)"", position, length, cachePosition, cacheLength));
        }
        if (position >= cachePosition + cacheLength) {
            readCacheAt(position);
        }
        if (position + length > cachePosition + cacheLength) {
            throw new IllegalArgumentException(String.format(""read request (offset %d length %d) partially overlaps cache (offset %d length %d)"", position, length, cachePosition, cacheLength));
        }
        System.arraycopy(cache, toIntExact(position - cachePosition), buffer, bufferOffset, length);
    }",method,
"        if (position < cachePosition) {
            throw new IllegalArgumentException(String.format(""read request (offset %d length %d) is before cache (offset %d length %d)"", position, length, cachePosition, cacheLength));
        }",method,
"        if (position >= cachePosition + cacheLength) {
            readCacheAt(position);
        }",method,
"        if (position + length > cachePosition + cacheLength) {
            throw new IllegalArgumentException(String.format(""read request (offset %d length %d) partially overlaps cache (offset %d length %d)"", position, length, cachePosition, cacheLength));
        }",method,
"    @Override
    public <K> Map<K, FixedLengthSliceInput> readFully(Map<K, DiskRange> diskRanges)
            throws IOException
    {
        ImmutableMap.Builder<K, FixedLengthSliceInput> builder = ImmutableMap.builder();
        // Assumption here: all disk ranges are in the same region. Therefore, serving them in arbitrary order
        // will not result in eviction of cache that otherwise could have served any of the DiskRanges provided.
        for (Map.Entry<K, DiskRange> entry : diskRanges.entrySet()) {
            DiskRange diskRange = entry.getValue();
            byte[] buffer = new byte[diskRange.getLength()];
            readFully(diskRange.getOffset(), buffer);
            builder.put(entry.getKey(), Slices.wrappedBuffer(buffer).getInput());
        }
        return builder.build();
    }",method,
"    @Override
    public void close()
            throws IOException
    {
        dataSource.close();
    }",method,
"    @Override
    public String toString()
    {
        return dataSource.toString();
    }",method,
"import java.util.List;
class QuickListsUi implements ConfigurableUi<List<QuickList>> {
  public static final String EMPTY = ""empty"";
  public static final String PANEL = ""panel"";
  private final KeymapListener keymapListener;
  private final ListItemEditor<QuickList> itemEditor = new ListItemEditor<QuickList>() {
    @NotNull
    @Override
    public Class<QuickList> getItemClass() {
      return QuickList.class;
    }
    @Override
    public QuickList clone(@NotNull QuickList item, boolean forInPlaceEditing) {
      return new QuickList(item.getName(), item.getDescription(), item.getActionIds());
    }
    @Override
    public boolean isEmpty(@NotNull QuickList item) {
      return item.getName().isEmpty() && item.getDescription() == null && item.getActionIds().length == 0;
    }
    @NotNull
    @Override
    public String getName(@NotNull QuickList item) {
      return item.getName();
    }
    @Override
    public boolean isRemovable(@NotNull QuickList item) {
      return QuickListsManager.getInstance().getSchemeManager().isMetadataEditable(item);
    }
  };
  private final ListModelEditor<QuickList> editor = new ListModelEditor<>(itemEditor);
  private JComponent component;
  private final QuickListPanel itemPanel;
  private final JPanel itemPanelWrapper;
  public QuickListsUi() {
    keymapListener = ApplicationManager.getApplication().getMessageBus().syncPublisher(KeymapListener.CHANGE_TOPIC);
    final CardLayout cardLayout = new CardLayout();
    // doesn't make any sense (and in any case scheme manager cannot preserve order)
    editor.disableUpDownActions();
    editor.getList().addListSelectionListener(new ListSelectionListener() {
      @Override
      public void valueChanged(ListSelectionEvent e) {
        QuickList item = editor.getSelected();
        if (item == null) {
          cardLayout.show(itemPanelWrapper, EMPTY);
          itemPanel.setItem(null);
        }
        else {
          cardLayout.show(itemPanelWrapper, PANEL);
          itemPanel.setItem(editor.getMutable(item));
        }
      }
    });
    itemPanel = new QuickListPanel(editor.getModel());
    itemPanel.myName.getDocument().addDocumentListener(new DocumentAdapter() {
      @Override
      protected void textChanged(DocumentEvent e) {
        QuickList item = itemPanel.item;
        if (item != null) {
          String name = itemPanel.myName.getText();
          boolean changed = !item.getName().equals(name);
          item.setName(name);
          if (changed) {
            editor.getList().repaint();
          }
        }
      }
    });
    itemPanelWrapper = new JPanel(cardLayout);
    JLabel descLabel =
      new JLabel(""<html>Quick Lists allow you to define commonly used groups of actions (for example, refactoring or VCS actions)"" +
                 "" and to assign keyboard shortcuts to such groups.</html>"");
    descLabel.setBorder(new EmptyBorder(0, 25, 0, 25));
    itemPanelWrapper.add(descLabel, EMPTY);
    itemPanelWrapper.add(itemPanel.getPanel(), PANEL);
    Splitter splitter = new Splitter(false, 0.3f);
    splitter.setFirstComponent(editor.createComponent());
    splitter.setSecondComponent(itemPanelWrapper);
    component = splitter;
  }
  @Override
  public void reset(@NotNull List<QuickList> settings) {
    editor.reset(settings);
  }
  @Override
  public boolean isModified(@NotNull List<QuickList> settings) {
    itemPanel.apply();
    return editor.isModified();
  }
  @Override
  public void apply(@NotNull List<QuickList> settings) throws ConfigurationException {
    itemPanel.apply();
    editor.ensureNonEmptyNames(""Quick list should have non empty name"");
    editor.processModifiedItems((newItem, oldItem) -> {
      if (!oldItem.getName().equals(newItem.getName())) {
        keymapListener.quickListRenamed(oldItem, newItem);
      }
      return true;
    });
    if (isModified(settings)) {
      java.util.List<QuickList> result = editor.apply();
      keymapListener.processCurrentKeymapChanged(result.toArray(new QuickList[result.size()]));
      QuickListsManager.getInstance().setQuickLists(result);
    }
  }
  @NotNull
  @Override
  public JComponent getComponent() {
    return component;
  }
}",class,
"    @NotNull
    @Override
    public Class<QuickList> getItemClass() {
      return QuickList.class;
    }",method,
"    @Override
    public QuickList clone(@NotNull QuickList item, boolean forInPlaceEditing) {
      return new QuickList(item.getName(), item.getDescription(), item.getActionIds());
    }",method,
"    @Override
    public boolean isEmpty(@NotNull QuickList item) {
      return item.getName().isEmpty() && item.getDescription() == null && item.getActionIds().length == 0;
    }",method,
"    @NotNull
    @Override
    public String getName(@NotNull QuickList item) {
      return item.getName();
    }",method,
"    @Override
    public boolean isRemovable(@NotNull QuickList item) {
      return QuickListsManager.getInstance().getSchemeManager().isMetadataEditable(item);
    }",method,
"  public QuickListsUi() {
    keymapListener = ApplicationManager.getApplication().getMessageBus().syncPublisher(KeymapListener.CHANGE_TOPIC);
    final CardLayout cardLayout = new CardLayout();
    // doesn't make any sense (and in any case scheme manager cannot preserve order)
    editor.disableUpDownActions();
    editor.getList().addListSelectionListener(new ListSelectionListener() {
      @Override
      public void valueChanged(ListSelectionEvent e) {
        QuickList item = editor.getSelected();
        if (item == null) {
          cardLayout.show(itemPanelWrapper, EMPTY);
          itemPanel.setItem(null);
        }
        else {
          cardLayout.show(itemPanelWrapper, PANEL);
          itemPanel.setItem(editor.getMutable(item));
        }
      }
    });
    itemPanel = new QuickListPanel(editor.getModel());
    itemPanel.myName.getDocument().addDocumentListener(new DocumentAdapter() {
      @Override
      protected void textChanged(DocumentEvent e) {
        QuickList item = itemPanel.item;
        if (item != null) {
          String name = itemPanel.myName.getText();
          boolean changed = !item.getName().equals(name);
          item.setName(name);
          if (changed) {
            editor.getList().repaint();
          }
        }
      }
    });
    itemPanelWrapper = new JPanel(cardLayout);
    JLabel descLabel =
      new JLabel(""<html>Quick Lists allow you to define commonly used groups of actions (for example, refactoring or VCS actions)"" +
                 "" and to assign keyboard shortcuts to such groups.</html>"");
    descLabel.setBorder(new EmptyBorder(0, 25, 0, 25));
    itemPanelWrapper.add(descLabel, EMPTY);
    itemPanelWrapper.add(itemPanel.getPanel(), PANEL);
    Splitter splitter = new Splitter(false, 0.3f);
    splitter.setFirstComponent(editor.createComponent());
    splitter.setSecondComponent(itemPanelWrapper);
    component = splitter;
  }",method,
"      @Override
      public void valueChanged(ListSelectionEvent e) {
        QuickList item = editor.getSelected();
        if (item == null) {
          cardLayout.show(itemPanelWrapper, EMPTY);
          itemPanel.setItem(null);
        }
        else {
          cardLayout.show(itemPanelWrapper, PANEL);
          itemPanel.setItem(editor.getMutable(item));
        }
      }",method,
"        if (item == null) {
          cardLayout.show(itemPanelWrapper, EMPTY);
          itemPanel.setItem(null);
        }",method,
"      @Override
      protected void textChanged(DocumentEvent e) {
        QuickList item = itemPanel.item;
        if (item != null) {
          String name = itemPanel.myName.getText();
          boolean changed = !item.getName().equals(name);
          item.setName(name);
          if (changed) {
            editor.getList().repaint();
          }
        }
      }",method,
"        if (item != null) {
          String name = itemPanel.myName.getText();
          boolean changed = !item.getName().equals(name);
          item.setName(name);
          if (changed) {
            editor.getList().repaint();
          }
        }",method,
"          if (changed) {
            editor.getList().repaint();
          }",method,
"  @Override
  public void reset(@NotNull List<QuickList> settings) {
    editor.reset(settings);
  }",method,
"  @Override
  public boolean isModified(@NotNull List<QuickList> settings) {
    itemPanel.apply();
    return editor.isModified();
  }",method,
"  @Override
  public void apply(@NotNull List<QuickList> settings) throws ConfigurationException {
    itemPanel.apply();
    editor.ensureNonEmptyNames(""Quick list should have non empty name"");
    editor.processModifiedItems((newItem, oldItem) -> {
      if (!oldItem.getName().equals(newItem.getName())) {
        keymapListener.quickListRenamed(oldItem, newItem);
      }
      return true;
    });
    if (isModified(settings)) {
      java.util.List<QuickList> result = editor.apply();
      keymapListener.processCurrentKeymapChanged(result.toArray(new QuickList[result.size()]));
      QuickListsManager.getInstance().setQuickLists(result);
    }
  }",method,
"  @NotNull
  @Override
  public JComponent getComponent() {
    return component;
  }",method,
"public class EnumConstantsUtil {
  private EnumConstantsUtil() {
  }
  public static boolean isSuitableForEnumConstant(PsiType constantType, PsiClass enumClass) {
    if (enumClass != null && enumClass.isEnum()) {
      for (PsiMethod constructor : enumClass.getConstructors()) {
        final PsiParameter[] parameters = constructor.getParameterList().getParameters();
        if (parameters.length == 1 && TypeConversionUtil.isAssignable(parameters[0].getType(), constantType)) return true;
      }
    }
    return false;
  }
  public static PsiEnumConstant createEnumConstant(PsiClass enumClass, String constantName, PsiExpression initializerExpr) throws
                                                                                                                              IncorrectOperationException {
    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(enumClass.getProject()).getElementFactory();
    final String enumConstantText = initializerExpr != null ? constantName + ""("" + initializerExpr.getText() + "")"" : constantName;
    return elementFactory.createEnumConstantFromText(enumConstantText, enumClass);
  }
  public static PsiEnumConstant createEnumConstant(PsiClass enumClass, PsiLocalVariable local, final String fieldName) throws IncorrectOperationException {
    return createEnumConstant(enumClass, fieldName, local.getInitializer());
  }
  @Nullable
  public static PsiStatement isEnumSwitch(final PsiSwitchStatement switchStatement,
                                          final PsiType enumValueType,
                                          final Set<Object> enumValues) {
    final PsiExpression expression = switchStatement.getExpression();
    if (expression != null) {
      final PsiType expressionType = expression.getType();
      if (expressionType != null && !TypeConversionUtil.isAssignable(expressionType, enumValueType)) {
        return switchStatement;
      }
      final PsiConstantEvaluationHelper evaluationHelper =
        JavaPsiFacade.getInstance(expression.getProject()).getConstantEvaluationHelper();
      final PsiCodeBlock body = switchStatement.getBody();
      if (body != null) {
        for (PsiStatement statement : body.getStatements()) {
          if (statement instanceof PsiSwitchLabelStatement) {
            final PsiSwitchLabelStatement labelStatement = (PsiSwitchLabelStatement)statement;
            final Object caseValue = evaluationHelper.computeConstantExpression(labelStatement.getCaseValue());
            if (caseValue != null && !enumValues.contains(caseValue)) return statement;
          }
        }
        return null;
      }
    }
    return switchStatement;
  }
}",class,
"  private EnumConstantsUtil() {
  }",method,
"  public static boolean isSuitableForEnumConstant(PsiType constantType, PsiClass enumClass) {
    if (enumClass != null && enumClass.isEnum()) {
      for (PsiMethod constructor : enumClass.getConstructors()) {
        final PsiParameter[] parameters = constructor.getParameterList().getParameters();
        if (parameters.length == 1 && TypeConversionUtil.isAssignable(parameters[0].getType(), constantType)) return true;
      }
    }
    return false;
  }",method,
"  public static PsiEnumConstant createEnumConstant(PsiClass enumClass, String constantName, PsiExpression initializerExpr) throws
                                                                                                                              IncorrectOperationException {
    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(enumClass.getProject()).getElementFactory();
    final String enumConstantText = initializerExpr != null ? constantName + ""("" + initializerExpr.getText() + "")"" : constantName;
    return elementFactory.createEnumConstantFromText(enumConstantText, enumClass);
  }",method,
"  public static PsiEnumConstant createEnumConstant(PsiClass enumClass, PsiLocalVariable local, final String fieldName) throws IncorrectOperationException {
    return createEnumConstant(enumClass, fieldName, local.getInitializer());
  }",method,
"  @Nullable
  public static PsiStatement isEnumSwitch(final PsiSwitchStatement switchStatement,
                                          final PsiType enumValueType,
                                          final Set<Object> enumValues) {
    final PsiExpression expression = switchStatement.getExpression();
    if (expression != null) {
      final PsiType expressionType = expression.getType();
      if (expressionType != null && !TypeConversionUtil.isAssignable(expressionType, enumValueType)) {
        return switchStatement;
      }
      final PsiConstantEvaluationHelper evaluationHelper =
        JavaPsiFacade.getInstance(expression.getProject()).getConstantEvaluationHelper();
      final PsiCodeBlock body = switchStatement.getBody();
      if (body != null) {
        for (PsiStatement statement : body.getStatements()) {
          if (statement instanceof PsiSwitchLabelStatement) {
            final PsiSwitchLabelStatement labelStatement = (PsiSwitchLabelStatement)statement;
            final Object caseValue = evaluationHelper.computeConstantExpression(labelStatement.getCaseValue());
            if (caseValue != null && !enumValues.contains(caseValue)) return statement;
          }
        }
        return null;
      }
    }
    return switchStatement;
  }",method,
"    if (expression != null) {
      final PsiType expressionType = expression.getType();
      if (expressionType != null && !TypeConversionUtil.isAssignable(expressionType, enumValueType)) {
        return switchStatement;
      }
      final PsiConstantEvaluationHelper evaluationHelper =
        JavaPsiFacade.getInstance(expression.getProject()).getConstantEvaluationHelper();
      final PsiCodeBlock body = switchStatement.getBody();
      if (body != null) {
        for (PsiStatement statement : body.getStatements()) {
          if (statement instanceof PsiSwitchLabelStatement) {
            final PsiSwitchLabelStatement labelStatement = (PsiSwitchLabelStatement)statement;
            final Object caseValue = evaluationHelper.computeConstantExpression(labelStatement.getCaseValue());
            if (caseValue != null && !enumValues.contains(caseValue)) return statement;
          }
        }
        return null;
      }
    }",method,
"      if (body != null) {
        for (PsiStatement statement : body.getStatements()) {
          if (statement instanceof PsiSwitchLabelStatement) {
            final PsiSwitchLabelStatement labelStatement = (PsiSwitchLabelStatement)statement;
            final Object caseValue = evaluationHelper.computeConstantExpression(labelStatement.getCaseValue());
            if (caseValue != null && !enumValues.contains(caseValue)) return statement;
          }
        }
        return null;
      }",method,
"          if (statement instanceof PsiSwitchLabelStatement) {
            final PsiSwitchLabelStatement labelStatement = (PsiSwitchLabelStatement)statement;
            final Object caseValue = evaluationHelper.computeConstantExpression(labelStatement.getCaseValue());
            if (caseValue != null && !enumValues.contains(caseValue)) return statement;
          }",method,
"public abstract class AddressResolverGroup<T extends SocketAddress> implements Closeable {
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AddressResolverGroup.class);
    private final Map<EventExecutor, AddressResolver<T>> resolvers =
            new IdentityHashMap<EventExecutor, AddressResolver<T>>();
    protected AddressResolverGroup() { }
    public AddressResolver<T> getResolver(final EventExecutor executor) {
        if (executor == null) {
            throw new NullPointerException(""executor"");
        }
        if (executor.isShuttingDown()) {
            throw new IllegalStateException(""executor not accepting a task"");
        }
        AddressResolver<T> r;
        synchronized (resolvers) {
            r = resolvers.get(executor);
            if (r == null) {
                final AddressResolver<T> newResolver;
                try {
                    newResolver = newResolver(executor);
                } catch (Exception e) {
                    throw new IllegalStateException(""failed to create a new resolver"", e);
                }
                resolvers.put(executor, newResolver);
                executor.terminationFuture().addListener(new FutureListener<Object>() {
                    @Override
                    public void operationComplete(Future<Object> future) throws Exception {
                        synchronized (resolvers) {
                            resolvers.remove(executor);
                        }
                        newResolver.close();
                    }
                });
                r = newResolver;
            }
        }
        return r;
    }
    protected abstract AddressResolver<T> newResolver(EventExecutor executor) throws Exception;
    @Override
    @SuppressWarnings({ ""unchecked"", ""SuspiciousToArrayCall"" })
    public void close() {
        final AddressResolver<T>[] rArray;
        synchronized (resolvers) {
            rArray = (AddressResolver<T>[]) resolvers.values().toArray(new AddressResolver[resolvers.size()]);
            resolvers.clear();
        }
        for (AddressResolver<T> r: rArray) {
            try {
                r.close();
            } catch (Throwable t) {
                logger.warn(""Failed to close a resolver:"", t);
            }
        }
    }
}",class,
    protected AddressResolverGroup() { },method,
"    public AddressResolver<T> getResolver(final EventExecutor executor) {
        if (executor == null) {
            throw new NullPointerException(""executor"");
        }
        if (executor.isShuttingDown()) {
            throw new IllegalStateException(""executor not accepting a task"");
        }
        AddressResolver<T> r;
        synchronized (resolvers) {
            r = resolvers.get(executor);
            if (r == null) {
                final AddressResolver<T> newResolver;
                try {
                    newResolver = newResolver(executor);
                } catch (Exception e) {
                    throw new IllegalStateException(""failed to create a new resolver"", e);
                }
                resolvers.put(executor, newResolver);
                executor.terminationFuture().addListener(new FutureListener<Object>() {
                    @Override
                    public void operationComplete(Future<Object> future) throws Exception {
                        synchronized (resolvers) {
                            resolvers.remove(executor);
                        }
                        newResolver.close();
                    }
                });
                r = newResolver;
            }
        }
        return r;
    }",method,
"        if (executor == null) {
            throw new NullPointerException(""executor"");
        }",method,
"        synchronized (resolvers) {
            r = resolvers.get(executor);
            if (r == null) {
                final AddressResolver<T> newResolver;
                try {
                    newResolver = newResolver(executor);
                } catch (Exception e) {
                    throw new IllegalStateException(""failed to create a new resolver"", e);
                }
                resolvers.put(executor, newResolver);
                executor.terminationFuture().addListener(new FutureListener<Object>() {
                    @Override
                    public void operationComplete(Future<Object> future) throws Exception {
                        synchronized (resolvers) {
                            resolvers.remove(executor);
                        }
                        newResolver.close();
                    }
                });
                r = newResolver;
            }
        }",method,
"            if (r == null) {
                final AddressResolver<T> newResolver;
                try {
                    newResolver = newResolver(executor);
                } catch (Exception e) {
                    throw new IllegalStateException(""failed to create a new resolver"", e);
                }
                resolvers.put(executor, newResolver);
                executor.terminationFuture().addListener(new FutureListener<Object>() {
                    @Override
                    public void operationComplete(Future<Object> future) throws Exception {
                        synchronized (resolvers) {
                            resolvers.remove(executor);
                        }
                        newResolver.close();
                    }
                });
                r = newResolver;
            }",method,
"                    @Override
                    public void operationComplete(Future<Object> future) throws Exception {
                        synchronized (resolvers) {
                            resolvers.remove(executor);
                        }
                        newResolver.close();
                    }",method,
"                        synchronized (resolvers) {
                            resolvers.remove(executor);
                        }",method,
"    @Override
    @SuppressWarnings({ ""unchecked"", ""SuspiciousToArrayCall"" })
    public void close() {
        final AddressResolver<T>[] rArray;
        synchronized (resolvers) {
            rArray = (AddressResolver<T>[]) resolvers.values().toArray(new AddressResolver[resolvers.size()]);
            resolvers.clear();
        }
        for (AddressResolver<T> r: rArray) {
            try {
                r.close();
            } catch (Throwable t) {
                logger.warn(""Failed to close a resolver:"", t);
            }
        }
    }",method,
"        synchronized (resolvers) {
            rArray = (AddressResolver<T>[]) resolvers.values().toArray(new AddressResolver[resolvers.size()]);
            resolvers.clear();
        }",method,
"        for (AddressResolver<T> r: rArray) {
            try {
                r.close();
            } catch (Throwable t) {
                logger.warn(""Failed to close a resolver:"", t);
            }
        }",method,
"public class AppleResourceDescription
    implements Description<AppleResourceDescriptionArg>,
        Flavored,
        HasAppleBundleResourcesDescription<AppleResourceDescriptionArg> {
  @Override
  public Class<AppleResourceDescriptionArg> getConstructorArgType() {
    return AppleResourceDescriptionArg.class;
  }
  @Override
  public BuildRule createBuildRule(
      TargetGraph targetGraph,
      BuildTarget buildTarget,
      ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CellPathResolver cellRoots,
      AppleResourceDescriptionArg args) {
    return new NoopBuildRuleWithDeclaredAndExtraDeps(buildTarget, projectFilesystem, params);
  }
  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return true;
  }
  @Override
  public void addAppleBundleResources(
      AppleBundleResources.Builder builder,
      TargetNode<AppleResourceDescriptionArg, ?> targetNode,
      ProjectFilesystem filesystem,
      BuildRuleResolver resolver) {
    AppleResourceDescriptionArg appleResource = targetNode.getConstructorArg();
    builder.addAllResourceDirs(appleResource.getDirs());
    builder.addAllResourceFiles(appleResource.getFiles());
    builder.addAllResourceVariantFiles(appleResource.getVariants());
  }
  @BuckStyleImmutable
  @Value.Immutable
  interface AbstractAppleResourceDescriptionArg extends CommonDescriptionArg {
    ImmutableSet<SourcePath> getDirs();
    ImmutableSet<SourcePath> getFiles();
    ImmutableSet<SourcePath> getVariants();
    ImmutableSet<BuildTarget> getResourcesFromDeps();
  }
}",class,
"  @Override
  public Class<AppleResourceDescriptionArg> getConstructorArgType() {
    return AppleResourceDescriptionArg.class;
  }",method,
"  @Override
  public BuildRule createBuildRule(
      TargetGraph targetGraph,
      BuildTarget buildTarget,
      ProjectFilesystem projectFilesystem,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CellPathResolver cellRoots,
      AppleResourceDescriptionArg args) {
    return new NoopBuildRuleWithDeclaredAndExtraDeps(buildTarget, projectFilesystem, params);
  }",method,
"  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return true;
  }",method,
"  @Override
  public void addAppleBundleResources(
      AppleBundleResources.Builder builder,
      TargetNode<AppleResourceDescriptionArg, ?> targetNode,
      ProjectFilesystem filesystem,
      BuildRuleResolver resolver) {
    AppleResourceDescriptionArg appleResource = targetNode.getConstructorArg();
    builder.addAllResourceDirs(appleResource.getDirs());
    builder.addAllResourceFiles(appleResource.getFiles());
    builder.addAllResourceVariantFiles(appleResource.getVariants());
  }",method,
"public class PermissionsModule extends ReactContextBaseJavaModule implements PermissionListener {
  private static final String ERROR_INVALID_ACTIVITY = ""E_INVALID_ACTIVITY"";
  private final SparseArray<Callback> mCallbacks;
  private int mRequestCode = 0;
  private final String GRANTED = ""granted"";
  private final String DENIED = ""denied"";
  private final String NEVER_ASK_AGAIN = ""never_ask_again"";
  public PermissionsModule(ReactApplicationContext reactContext) {
    super(reactContext);
    mCallbacks = new SparseArray<Callback>();
  }
  @Override
  public String getName() {
    return ""PermissionsAndroid"";
  }
  @ReactMethod
  public void checkPermission(final String permission, final Promise promise) {
    Context context = getReactApplicationContext().getBaseContext();
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid()) ==
        PackageManager.PERMISSION_GRANTED);
      return;
    }
    promise.resolve(context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED);
  }
  @ReactMethod
  public void shouldShowRequestPermissionRationale(final String permission, final Promise promise) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(false);
      return;
    }
    try {
      promise.resolve(getPermissionAwareActivity().shouldShowRequestPermissionRationale(permission));
    } catch (IllegalStateException e) {
      promise.reject(ERROR_INVALID_ACTIVITY, e);
    }
  }
  @ReactMethod
  public void requestPermission(final String permission, final Promise promise) {
    Context context = getReactApplicationContext().getBaseContext();
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid()) ==
              PackageManager.PERMISSION_GRANTED);
      return;
    }
    if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
      promise.resolve(GRANTED);
      return;
    }
    try {
      PermissionAwareActivity activity = getPermissionAwareActivity();
      mCallbacks.put(
        mRequestCode, new Callback() {
          @Override
          public void invoke(Object... args) {
            int[] results = (int[]) args[0];
            if (results[0] == PackageManager.PERMISSION_GRANTED) {
              promise.resolve(GRANTED);
            } else {
              PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                promise.resolve(DENIED);
              } else {
                promise.resolve(NEVER_ASK_AGAIN);
              }
            }
          }
        }
      );
      activity.requestPermissions(new String[]{permission}, mRequestCode, this);
      mRequestCode++;
    } catch (IllegalStateException e) {
      promise.reject(ERROR_INVALID_ACTIVITY, e);
    }
  }
  @ReactMethod
  public void requestMultiplePermissions(final ReadableArray permissions, final Promise promise) {
    final WritableMap grantedPermissions = new WritableNativeMap();
    final ArrayList<String> permissionsToCheck = new ArrayList<String>();
    int checkedPermissionsCount = 0;
    Context context = getReactApplicationContext().getBaseContext();
    for (int i = 0; i < permissions.size(); i++) {
      String perm = permissions.getString(i);
      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
        grantedPermissions.putString(perm, context.checkPermission(perm, Process.myPid(), Process.myUid()) ==
        PackageManager.PERMISSION_GRANTED ? GRANTED : DENIED);
        checkedPermissionsCount++;
      } else if (context.checkSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {
        grantedPermissions.putString(perm, GRANTED);
        checkedPermissionsCount++;
      } else {
        permissionsToCheck.add(perm);
      }
    }
    if (permissions.size() == checkedPermissionsCount) {
      promise.resolve(grantedPermissions);
      return;
    }
    try {
      PermissionAwareActivity activity = getPermissionAwareActivity();
      mCallbacks.put(
      mRequestCode, new Callback() {
        @Override
        public void invoke(Object... args) {
          int[] results = (int[]) args[0];
          PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
          for (int j = 0; j < permissionsToCheck.size(); j++) {
            String permission = permissionsToCheck.get(j);
            if (results[j] == PackageManager.PERMISSION_GRANTED) {
              grantedPermissions.putString(permission, GRANTED);
            } else {
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                grantedPermissions.putString(permission, DENIED);
              } else {
                grantedPermissions.putString(permission, NEVER_ASK_AGAIN);
              }
            }
          }
          promise.resolve(grantedPermissions);
        }
      });
      activity.requestPermissions(permissionsToCheck.toArray(new String[0]), mRequestCode, this);
      mRequestCode++;
    } catch (IllegalStateException e) {
      promise.reject(ERROR_INVALID_ACTIVITY, e);
    }
  }
  @Override
  public boolean onRequestPermissionsResult(
    int requestCode,
    String[] permissions,
    int[] grantResults) {
      mCallbacks.get(requestCode).invoke(grantResults, getPermissionAwareActivity());
      mCallbacks.remove(requestCode);
      return mCallbacks.size() == 0;
  }
  private PermissionAwareActivity getPermissionAwareActivity() {
    Activity activity = getCurrentActivity();
    if (activity == null) {
      throw new IllegalStateException(""Tried to use permissions API while not attached to an "" +
          ""Activity."");
    } else if (!(activity instanceof PermissionAwareActivity)) {
      throw new IllegalStateException(""Tried to use permissions API but the host Activity doesn't"" +
          "" implement PermissionAwareActivity."");
    }
    return (PermissionAwareActivity) activity;
  }
}",class,
"  public PermissionsModule(ReactApplicationContext reactContext) {
    super(reactContext);
    mCallbacks = new SparseArray<Callback>();
  }",method,
"  @Override
  public String getName() {
    return ""PermissionsAndroid"";
  }",method,
"  @ReactMethod
  public void checkPermission(final String permission, final Promise promise) {
    Context context = getReactApplicationContext().getBaseContext();
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid()) ==
        PackageManager.PERMISSION_GRANTED);
      return;
    }
    promise.resolve(context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED);
  }",method,
"    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid()) ==
        PackageManager.PERMISSION_GRANTED);
      return;
    }",method,
"  @ReactMethod
  public void shouldShowRequestPermissionRationale(final String permission, final Promise promise) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(false);
      return;
    }
    try {
      promise.resolve(getPermissionAwareActivity().shouldShowRequestPermissionRationale(permission));
    } catch (IllegalStateException e) {
      promise.reject(ERROR_INVALID_ACTIVITY, e);
    }
  }",method,
"    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(false);
      return;
    }",method,
"  @ReactMethod
  public void requestPermission(final String permission, final Promise promise) {
    Context context = getReactApplicationContext().getBaseContext();
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid()) ==
              PackageManager.PERMISSION_GRANTED);
      return;
    }
    if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
      promise.resolve(GRANTED);
      return;
    }
    try {
      PermissionAwareActivity activity = getPermissionAwareActivity();
      mCallbacks.put(
        mRequestCode, new Callback() {
          @Override
          public void invoke(Object... args) {
            int[] results = (int[]) args[0];
            if (results[0] == PackageManager.PERMISSION_GRANTED) {
              promise.resolve(GRANTED);
            } else {
              PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                promise.resolve(DENIED);
              } else {
                promise.resolve(NEVER_ASK_AGAIN);
              }
            }
          }
        }
      );
      activity.requestPermissions(new String[]{permission}, mRequestCode, this);
      mRequestCode++;
    } catch (IllegalStateException e) {
      promise.reject(ERROR_INVALID_ACTIVITY, e);
    }
  }",method,
"    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid()) ==
              PackageManager.PERMISSION_GRANTED);
      return;
    }",method,
"      mCallbacks.put(
        mRequestCode, new Callback() {
          @Override
          public void invoke(Object... args) {
            int[] results = (int[]) args[0];
            if (results[0] == PackageManager.PERMISSION_GRANTED) {
              promise.resolve(GRANTED);
            } else {
              PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                promise.resolve(DENIED);
              } else {
                promise.resolve(NEVER_ASK_AGAIN);
              }
            }
          }
        }",method,
"          @Override
          public void invoke(Object... args) {
            int[] results = (int[]) args[0];
            if (results[0] == PackageManager.PERMISSION_GRANTED) {
              promise.resolve(GRANTED);
            } else {
              PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                promise.resolve(DENIED);
              } else {
                promise.resolve(NEVER_ASK_AGAIN);
              }
            }
          }",method,
"            if (results[0] == PackageManager.PERMISSION_GRANTED) {
              promise.resolve(GRANTED);
            }",method,
"  @ReactMethod
  public void requestMultiplePermissions(final ReadableArray permissions, final Promise promise) {
    final WritableMap grantedPermissions = new WritableNativeMap();
    final ArrayList<String> permissionsToCheck = new ArrayList<String>();
    int checkedPermissionsCount = 0;
    Context context = getReactApplicationContext().getBaseContext();
    for (int i = 0; i < permissions.size(); i++) {
      String perm = permissions.getString(i);
      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
        grantedPermissions.putString(perm, context.checkPermission(perm, Process.myPid(), Process.myUid()) ==
        PackageManager.PERMISSION_GRANTED ? GRANTED : DENIED);
        checkedPermissionsCount++;
      } else if (context.checkSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {
        grantedPermissions.putString(perm, GRANTED);
        checkedPermissionsCount++;
      } else {
        permissionsToCheck.add(perm);
      }
    }
    if (permissions.size() == checkedPermissionsCount) {
      promise.resolve(grantedPermissions);
      return;
    }
    try {
      PermissionAwareActivity activity = getPermissionAwareActivity();
      mCallbacks.put(
      mRequestCode, new Callback() {
        @Override
        public void invoke(Object... args) {
          int[] results = (int[]) args[0];
          PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
          for (int j = 0; j < permissionsToCheck.size(); j++) {
            String permission = permissionsToCheck.get(j);
            if (results[j] == PackageManager.PERMISSION_GRANTED) {
              grantedPermissions.putString(permission, GRANTED);
            } else {
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                grantedPermissions.putString(permission, DENIED);
              } else {
                grantedPermissions.putString(permission, NEVER_ASK_AGAIN);
              }
            }
          }
          promise.resolve(grantedPermissions);
        }
      });
      activity.requestPermissions(permissionsToCheck.toArray(new String[0]), mRequestCode, this);
      mRequestCode++;
    } catch (IllegalStateException e) {
      promise.reject(ERROR_INVALID_ACTIVITY, e);
    }
  }",method,
"      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
        grantedPermissions.putString(perm, context.checkPermission(perm, Process.myPid(), Process.myUid()) ==
        PackageManager.PERMISSION_GRANTED ? GRANTED : DENIED);
        checkedPermissionsCount++;
      }",method,
"      mCallbacks.put(
      mRequestCode, new Callback() {
        @Override
        public void invoke(Object... args) {
          int[] results = (int[]) args[0];
          PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
          for (int j = 0; j < permissionsToCheck.size(); j++) {
            String permission = permissionsToCheck.get(j);
            if (results[j] == PackageManager.PERMISSION_GRANTED) {
              grantedPermissions.putString(permission, GRANTED);
            } else {
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                grantedPermissions.putString(permission, DENIED);
              } else {
                grantedPermissions.putString(permission, NEVER_ASK_AGAIN);
              }
            }
          }
          promise.resolve(grantedPermissions);
        }
      }",method,
"        @Override
        public void invoke(Object... args) {
          int[] results = (int[]) args[0];
          PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
          for (int j = 0; j < permissionsToCheck.size(); j++) {
            String permission = permissionsToCheck.get(j);
            if (results[j] == PackageManager.PERMISSION_GRANTED) {
              grantedPermissions.putString(permission, GRANTED);
            } else {
              if (activity.shouldShowRequestPermissionRationale(permission)) {
                grantedPermissions.putString(permission, DENIED);
              } else {
                grantedPermissions.putString(permission, NEVER_ASK_AGAIN);
              }
            }
          }
          promise.resolve(grantedPermissions);
        }",method,
"            if (results[j] == PackageManager.PERMISSION_GRANTED) {
              grantedPermissions.putString(permission, GRANTED);
            }",method,
"  @Override
  public boolean onRequestPermissionsResult(
    int requestCode,
    String[] permissions,
    int[] grantResults) {
      mCallbacks.get(requestCode).invoke(grantResults, getPermissionAwareActivity());
      mCallbacks.remove(requestCode);
      return mCallbacks.size() == 0;
  }",method,
"  private PermissionAwareActivity getPermissionAwareActivity() {
    Activity activity = getCurrentActivity();
    if (activity == null) {
      throw new IllegalStateException(""Tried to use permissions API while not attached to an "" +
          ""Activity."");
    } else if (!(activity instanceof PermissionAwareActivity)) {
      throw new IllegalStateException(""Tried to use permissions API but the host Activity doesn't"" +
          "" implement PermissionAwareActivity."");
    }
    return (PermissionAwareActivity) activity;
  }",method,
"    if (activity == null) {
      throw new IllegalStateException(""Tried to use permissions API while not attached to an "" +
          ""Activity."");
    }",method,
"import java.util.List;
class Foo {
  public void matchAfterFragment(int patternIndex, int matchLen) {
    int star = patternIndex < matchLen ? matchLen : -1;
    while (matchLen > 0) {
      int i = matchLen == star ? matchLen : star;
    }
  }
  public void matchAfterFragmentBoxed(Integer patternIndex, Integer matchLen) {
    Integer star = patternIndex < matchLen ? matchLen : -1;
    while (matchLen > 0) {
      Integer i = matchLen == star ? matchLen : star;
    }
  }
  public void matchAfterFragmentSemiBoxed(Integer patternIndex, Integer matchLen) {
    int star = patternIndex < matchLen ? matchLen : -1;
    while (matchLen > 0) {
      Integer i = matchLen == star ? matchLen : star;
    }
  }
}",class,

code_snippet,type,score
"	@Test
	public void testClasspathPathName() throws Exception {
		PropertyEditor pathEditor = new PathEditor();
		pathEditor.setAsText(""classpath:"" + ClassUtils.classPackageAsResourcePath(getClass()) + ""/"" +
				ClassUtils.getShortName(getClass()) + "".class"");
		Object value = pathEditor.getValue();
		assertTrue(value instanceof Path);
		Path path = (Path) value;
		assertTrue(path.toFile().exists());
	}",method,
"	@Test(expected = IllegalArgumentException.class)
	public void testWithNonExistentResource() throws Exception {
		PropertyEditor propertyEditor = new PathEditor();
		propertyEditor.setAsText(""classpath:/no_way_this_file_is_found.doc"");
	}",method,
"	@Test
	public void testWithNonExistentPath() throws Exception {
		PropertyEditor pathEditor = new PathEditor();
		pathEditor.setAsText(""file:/no_way_this_file_is_found.doc"");
		Object value = pathEditor.getValue();
		assertTrue(value instanceof Path);
		Path path = (Path) value;
		assertTrue(!path.toFile().exists());
	}",method,
"	@Test
	public void testAbsolutePath() throws Exception {
		PropertyEditor pathEditor = new PathEditor();
		pathEditor.setAsText(""/no_way_this_file_is_found.doc"");
		Object value = pathEditor.getValue();
		assertTrue(value instanceof Path);
		Path path = (Path) value;
		assertTrue(!path.toFile().exists());
	}",method,
"	@Test
	public void testUnqualifiedPathNameFound() throws Exception {
		PropertyEditor pathEditor = new PathEditor();
		String fileName = ClassUtils.classPackageAsResourcePath(getClass()) + ""/"" +
				ClassUtils.getShortName(getClass()) + "".class"";
		pathEditor.setAsText(fileName);
		Object value = pathEditor.getValue();
		assertTrue(value instanceof Path);
		Path path = (Path) value;
		File file = path.toFile();
		assertTrue(file.exists());
		String absolutePath = file.getAbsolutePath();
		if (File.separatorChar == '\\') {
			absolutePath = absolutePath.replace('\\', '/');
		}
		assertTrue(absolutePath.endsWith(fileName));
	}",method,
"		if (File.separatorChar == '\\') {
			absolutePath = absolutePath.replace('\\', '/');
		}",method,
"	@Test
	public void testUnqualifiedPathNameNotFound() throws Exception {
		PropertyEditor pathEditor = new PathEditor();
		String fileName = ClassUtils.classPackageAsResourcePath(getClass()) + ""/"" +
				ClassUtils.getShortName(getClass()) + "".clazz"";
		pathEditor.setAsText(fileName);
		Object value = pathEditor.getValue();
		assertTrue(value instanceof Path);
		Path path = (Path) value;
		File file = path.toFile();
		assertFalse(file.exists());
		String absolutePath = file.getAbsolutePath();
		if (File.separatorChar == '\\') {
			absolutePath = absolutePath.replace('\\', '/');
		}
		assertTrue(absolutePath.endsWith(fileName));
	}",method,
"		if (File.separatorChar == '\\') {
			absolutePath = absolutePath.replace('\\', '/');
		}",method,
"public final class StreamDescriptor
{
    private final String streamName;
    private final int streamId;
    private final OrcTypeKind streamType;
    private final String fieldName;
    private final OrcDataSource orcDataSource;
    private final List<StreamDescriptor> nestedStreams;
    public StreamDescriptor(String streamName, int streamId, String fieldName, OrcTypeKind streamType, OrcDataSource orcDataSource, List<StreamDescriptor> nestedStreams)
    {
        this.streamName = requireNonNull(streamName, ""streamName is null"");
        this.streamId = streamId;
        this.fieldName = requireNonNull(fieldName, ""fieldName is null"");
        this.streamType = requireNonNull(streamType, ""type is null"");
        this.orcDataSource = requireNonNull(orcDataSource, ""orcDataSource is null"");
        this.nestedStreams = ImmutableList.copyOf(requireNonNull(nestedStreams, ""nestedStreams is null""));
    }
    public String getStreamName()
    {
        return streamName;
    }
    public int getStreamId()
    {
        return streamId;
    }
    public OrcTypeKind getStreamType()
    {
        return streamType;
    }
    public String getFieldName()
    {
        return fieldName;
    }
    public OrcDataSourceId getOrcDataSourceId()
    {
        return orcDataSource.getId();
    }
    public OrcDataSource getOrcDataSource()
    {
        return orcDataSource;
    }
    public List<StreamDescriptor> getNestedStreams()
    {
        return nestedStreams;
    }
    @Override
    public String toString()
    {
        return toStringHelper(this)
                .add(""streamName"", streamName)
                .add(""streamId"", streamId)
                .add(""streamType"", streamType)
                .add(""dataSource"", orcDataSource.getId())
                .toString();
    }
}",class,
"    public StreamDescriptor(String streamName, int streamId, String fieldName, OrcTypeKind streamType, OrcDataSource orcDataSource, List<StreamDescriptor> nestedStreams)
    {
        this.streamName = requireNonNull(streamName, ""streamName is null"");
        this.streamId = streamId;
        this.fieldName = requireNonNull(fieldName, ""fieldName is null"");
        this.streamType = requireNonNull(streamType, ""type is null"");
        this.orcDataSource = requireNonNull(orcDataSource, ""orcDataSource is null"");
        this.nestedStreams = ImmutableList.copyOf(requireNonNull(nestedStreams, ""nestedStreams is null""));
    }",method,
"    public String getStreamName()
    {
        return streamName;
    }",method,
"    public int getStreamId()
    {
        return streamId;
    }",method,
"    public OrcTypeKind getStreamType()
    {
        return streamType;
    }",method,
"    public String getFieldName()
    {
        return fieldName;
    }",method,
"    public OrcDataSourceId getOrcDataSourceId()
    {
        return orcDataSource.getId();
    }",method,
"    public OrcDataSource getOrcDataSource()
    {
        return orcDataSource;
    }",method,
"    public List<StreamDescriptor> getNestedStreams()
    {
        return nestedStreams;
    }",method,
"    @Override
    public String toString()
    {
        return toStringHelper(this)
                .add(""streamName"", streamName)
                .add(""streamId"", streamId)
                .add(""streamType"", streamType)
                .add(""dataSource"", orcDataSource.getId())
                .toString();
    }",method,
"public class TarInputStream extends FilterInputStream {
	private static final int SKIP_BUFFER_SIZE = 2048;
	private TarEntry currentEntry;
	private long currentFileSize;
	private long bytesRead;
	private boolean defaultSkip = false;
	public TarInputStream(InputStream in) {
		super(in);
		currentFileSize = 0;
		bytesRead = 0;
	}
	@Override
	public boolean markSupported() {
		return false;
	}
	@Override
	public synchronized void mark(int readlimit) {
	}
	@Override
	public synchronized void reset() throws IOException {
		throw new IOException(""mark/reset not supported"");
	}
	@Override
	public int read() throws IOException {
		byte[] buf = new byte[1];
		int res = this.read(buf, 0, 1);
		if (res != -1) {
			return 0xFF & buf[0];
		}
		return res;
	}
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		if (currentEntry != null) {
			if (currentFileSize == currentEntry.getSize()) {
				return -1;
			} else if ((currentEntry.getSize() - currentFileSize) < len) {
				len = (int) (currentEntry.getSize() - currentFileSize);
			}
		}
		int br = super.read(b, off, len);
		if (br != -1) {
			if (currentEntry != null) {
				currentFileSize += br;
			}
			bytesRead += br;
		}
		return br;
	}
	public TarEntry getNextEntry() throws IOException {
		closeCurrentEntry();
		byte[] header = new byte[TarConstants.HEADER_BLOCK];
		byte[] theader = new byte[TarConstants.HEADER_BLOCK];
		int tr = 0;
		// Read full header
		while (tr < TarConstants.HEADER_BLOCK) {
			int res = read(theader, 0, TarConstants.HEADER_BLOCK - tr);
			if (res < 0) {
				break;
			}
			System.arraycopy(theader, 0, header, tr, res);
			tr += res;
		}
		// Check if record is null
		boolean eof = true;
		for (byte b : header) {
			if (b != 0) {
				eof = false;
				break;
			}
		}
		if (!eof) {
			currentEntry = new TarEntry(header);
		}
		return currentEntry;
	}
	public long getCurrentOffset() {
		return bytesRead;
	}
	protected void closeCurrentEntry() throws IOException {
		if (currentEntry != null) {
			if (currentEntry.getSize() > currentFileSize) {
				// Not fully read, skip rest of the bytes
				long bs = 0;
				while (bs < currentEntry.getSize() - currentFileSize) {
					long res = skip(currentEntry.getSize() - currentFileSize - bs);
					if (res == 0 && currentEntry.getSize() - currentFileSize > 0) {
						// I suspect file corruption
						throw new IOException(""Possible tar file corruption"");
					}
					bs += res;
				}
			}
			currentEntry = null;
			currentFileSize = 0L;
			skipPad();
		}
	}
	protected void skipPad() throws IOException {
		if (bytesRead > 0) {
			int extra = (int) (bytesRead % TarConstants.DATA_BLOCK);
			if (extra > 0) {
				long bs = 0;
				while (bs < TarConstants.DATA_BLOCK - extra) {
					long res = skip(TarConstants.DATA_BLOCK - extra - bs);
					bs += res;
				}
			}
		}
	}
	@Override
	public long skip(long n) throws IOException {
		if (defaultSkip) {
			// use skip method of parent stream
			// may not work if skip not implemented by parent
			long bs = super.skip(n);
			bytesRead += bs;
			return bs;
		}
		if (n <= 0) {
			return 0;
		}
		long left = n;
		byte[] sBuff = new byte[SKIP_BUFFER_SIZE];
		while (left > 0) {
			int res = read(sBuff, 0, (int) (left < SKIP_BUFFER_SIZE ? left : SKIP_BUFFER_SIZE));
			if (res < 0) {
				break;
			}
			left -= res;
		}
		return n - left;
	}
	public boolean isDefaultSkip() {
		return defaultSkip;
	}
	public void setDefaultSkip(boolean defaultSkip) {
		this.defaultSkip = defaultSkip;
	}
}",class,
"	public TarInputStream(InputStream in) {
		super(in);
		currentFileSize = 0;
		bytesRead = 0;
	}",method,
"	@Override
	public boolean markSupported() {
		return false;
	}",method,
"	@Override
	public synchronized void mark(int readlimit) {
	}",method,
"	@Override
	public synchronized void reset() throws IOException {
		throw new IOException(""mark/reset not supported"");
	}",method,
"	@Override
	public int read() throws IOException {
		byte[] buf = new byte[1];
		int res = this.read(buf, 0, 1);
		if (res != -1) {
			return 0xFF & buf[0];
		}
		return res;
	}",method,
"		if (res != -1) {
			return 0xFF & buf[0];
		}",method,
"	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		if (currentEntry != null) {
			if (currentFileSize == currentEntry.getSize()) {
				return -1;
			} else if ((currentEntry.getSize() - currentFileSize) < len) {
				len = (int) (currentEntry.getSize() - currentFileSize);
			}
		}
		int br = super.read(b, off, len);
		if (br != -1) {
			if (currentEntry != null) {
				currentFileSize += br;
			}
			bytesRead += br;
		}
		return br;
	}",method,
"		if (currentEntry != null) {
			if (currentFileSize == currentEntry.getSize()) {
				return -1;
			} else if ((currentEntry.getSize() - currentFileSize) < len) {
				len = (int) (currentEntry.getSize() - currentFileSize);
			}
		}",method,
"		if (br != -1) {
			if (currentEntry != null) {
				currentFileSize += br;
			}
			bytesRead += br;
		}",method,
"			if (currentEntry != null) {
				currentFileSize += br;
			}",method,
"	public TarEntry getNextEntry() throws IOException {
		closeCurrentEntry();
		byte[] header = new byte[TarConstants.HEADER_BLOCK];
		byte[] theader = new byte[TarConstants.HEADER_BLOCK];
		int tr = 0;
		// Read full header
		while (tr < TarConstants.HEADER_BLOCK) {
			int res = read(theader, 0, TarConstants.HEADER_BLOCK - tr);
			if (res < 0) {
				break;
			}
			System.arraycopy(theader, 0, header, tr, res);
			tr += res;
		}
		// Check if record is null
		boolean eof = true;
		for (byte b : header) {
			if (b != 0) {
				eof = false;
				break;
			}
		}
		if (!eof) {
			currentEntry = new TarEntry(header);
		}
		return currentEntry;
	}",method,
"		while (tr < TarConstants.HEADER_BLOCK) {
			int res = read(theader, 0, TarConstants.HEADER_BLOCK - tr);
			if (res < 0) {
				break;
			}
			System.arraycopy(theader, 0, header, tr, res);
			tr += res;
		}",method,
"			if (res < 0) {
				break;
			}",method,
"		for (byte b : header) {
			if (b != 0) {
				eof = false;
				break;
			}
		}",method,
"			if (b != 0) {
				eof = false;
				break;
			}",method,
"		if (!eof) {
			currentEntry = new TarEntry(header);
		}",method,
"	public long getCurrentOffset() {
		return bytesRead;
	}",method,
"	protected void closeCurrentEntry() throws IOException {
		if (currentEntry != null) {
			if (currentEntry.getSize() > currentFileSize) {
				// Not fully read, skip rest of the bytes
				long bs = 0;
				while (bs < currentEntry.getSize() - currentFileSize) {
					long res = skip(currentEntry.getSize() - currentFileSize - bs);
					if (res == 0 && currentEntry.getSize() - currentFileSize > 0) {
						// I suspect file corruption
						throw new IOException(""Possible tar file corruption"");
					}
					bs += res;
				}
			}
			currentEntry = null;
			currentFileSize = 0L;
			skipPad();
		}
	}",method,
"		if (currentEntry != null) {
			if (currentEntry.getSize() > currentFileSize) {
				// Not fully read, skip rest of the bytes
				long bs = 0;
				while (bs < currentEntry.getSize() - currentFileSize) {
					long res = skip(currentEntry.getSize() - currentFileSize - bs);
					if (res == 0 && currentEntry.getSize() - currentFileSize > 0) {
						// I suspect file corruption
						throw new IOException(""Possible tar file corruption"");
					}
					bs += res;
				}
			}
			currentEntry = null;
			currentFileSize = 0L;
			skipPad();
		}",method,
"	protected void skipPad() throws IOException {
		if (bytesRead > 0) {
			int extra = (int) (bytesRead % TarConstants.DATA_BLOCK);
			if (extra > 0) {
				long bs = 0;
				while (bs < TarConstants.DATA_BLOCK - extra) {
					long res = skip(TarConstants.DATA_BLOCK - extra - bs);
					bs += res;
				}
			}
		}
	}",method,
"		if (bytesRead > 0) {
			int extra = (int) (bytesRead % TarConstants.DATA_BLOCK);
			if (extra > 0) {
				long bs = 0;
				while (bs < TarConstants.DATA_BLOCK - extra) {
					long res = skip(TarConstants.DATA_BLOCK - extra - bs);
					bs += res;
				}
			}
		}",method,
"			if (extra > 0) {
				long bs = 0;
				while (bs < TarConstants.DATA_BLOCK - extra) {
					long res = skip(TarConstants.DATA_BLOCK - extra - bs);
					bs += res;
				}
			}",method,
"				while (bs < TarConstants.DATA_BLOCK - extra) {
					long res = skip(TarConstants.DATA_BLOCK - extra - bs);
					bs += res;
				}",method,
"	@Override
	public long skip(long n) throws IOException {
		if (defaultSkip) {
			// use skip method of parent stream
			// may not work if skip not implemented by parent
			long bs = super.skip(n);
			bytesRead += bs;
			return bs;
		}
		if (n <= 0) {
			return 0;
		}
		long left = n;
		byte[] sBuff = new byte[SKIP_BUFFER_SIZE];
		while (left > 0) {
			int res = read(sBuff, 0, (int) (left < SKIP_BUFFER_SIZE ? left : SKIP_BUFFER_SIZE));
			if (res < 0) {
				break;
			}
			left -= res;
		}
		return n - left;
	}",method,
"		if (defaultSkip) {
			// use skip method of parent stream
			// may not work if skip not implemented by parent
			long bs = super.skip(n);
			bytesRead += bs;
			return bs;
		}",method,
"		if (n <= 0) {
			return 0;
		}",method,
"		while (left > 0) {
			int res = read(sBuff, 0, (int) (left < SKIP_BUFFER_SIZE ? left : SKIP_BUFFER_SIZE));
			if (res < 0) {
				break;
			}
			left -= res;
		}",method,
"			if (res < 0) {
				break;
			}",method,
"	public boolean isDefaultSkip() {
		return defaultSkip;
	}",method,
"	public void setDefaultSkip(boolean defaultSkip) {
		this.defaultSkip = defaultSkip;
	}",method,
"public class RoundedCornersDrawableTest {
  private Drawable mUnderlyingDrawable;
  private RoundedCornersDrawable mRoundedCornersDrawable;
  private Drawable.Callback mCallback;
  @Before
  public void setup() {
    mUnderlyingDrawable = mock(Drawable.class);
    mCallback = mock(Drawable.Callback.class);
    mRoundedCornersDrawable = new RoundedCornersDrawable(mUnderlyingDrawable);
    mRoundedCornersDrawable.setCallback(mCallback);
  }
  @Test
  public void testInitialSetup() {
    assertEquals(RoundedCornersDrawable.Type.OVERLAY_COLOR, mRoundedCornersDrawable.mType);
    assertFalse(mRoundedCornersDrawable.isCircle());
    assertArrayEquals(new float[]{0, 0, 0, 0, 0, 0, 0, 0}, mRoundedCornersDrawable.getRadii(), 0);
    assertEquals(0, mRoundedCornersDrawable.mPaint.getColor());
  }
  @Test
  public void testSetType() {
    RoundedCornersDrawable.Type type = RoundedCornersDrawable.Type.CLIPPING;
    mRoundedCornersDrawable.setType(type);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(type, mRoundedCornersDrawable.mType);
  }
  @Test
  public void testSetCircle() {
    mRoundedCornersDrawable.setCircle(true);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertTrue(mRoundedCornersDrawable.isCircle());
  }
  @Test
  public void testSetRadii() {
    mRoundedCornersDrawable.setRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertArrayEquals(new float[] {1, 2, 3, 4, 5, 6, 7, 8}, mRoundedCornersDrawable.getRadii(), 0);
  }
  @Test
  public void testSetRadius() {
    mRoundedCornersDrawable.setRadius(9);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundedCornersDrawable.getRadii(), 0);
  }
  @Test
  public void testSetOverlayColor() {
    int overlayColor = 0xC0123456;
    mRoundedCornersDrawable.setOverlayColor(overlayColor);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(overlayColor, mRoundedCornersDrawable.getOverlayColor());
  }
  @Test
  public void testSetBorder() {
    float borderWidth = 0.7f;
    int borderColor = Color.CYAN;
    mRoundedCornersDrawable.setBorder(borderColor, borderWidth);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(borderColor, mRoundedCornersDrawable.getBorderColor());
    assertEquals(borderWidth, mRoundedCornersDrawable.getBorderWidth(), 0);
  }
  @Test
  public void testSetPadding() {
    float padding = 10;
    mRoundedCornersDrawable.setPadding(padding);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(padding, mRoundedCornersDrawable.getPadding(), 0);
  }
}",class,
"  @Before
  public void setup() {
    mUnderlyingDrawable = mock(Drawable.class);
    mCallback = mock(Drawable.Callback.class);
    mRoundedCornersDrawable = new RoundedCornersDrawable(mUnderlyingDrawable);
    mRoundedCornersDrawable.setCallback(mCallback);
  }",method,
"  @Test
  public void testInitialSetup() {
    assertEquals(RoundedCornersDrawable.Type.OVERLAY_COLOR, mRoundedCornersDrawable.mType);
    assertFalse(mRoundedCornersDrawable.isCircle());
    assertArrayEquals(new float[]{0, 0, 0, 0, 0, 0, 0, 0}, mRoundedCornersDrawable.getRadii(), 0);
    assertEquals(0, mRoundedCornersDrawable.mPaint.getColor());
  }",method,
"  @Test
  public void testSetType() {
    RoundedCornersDrawable.Type type = RoundedCornersDrawable.Type.CLIPPING;
    mRoundedCornersDrawable.setType(type);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(type, mRoundedCornersDrawable.mType);
  }",method,
"  @Test
  public void testSetCircle() {
    mRoundedCornersDrawable.setCircle(true);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertTrue(mRoundedCornersDrawable.isCircle());
  }",method,
"  @Test
  public void testSetRadii() {
    mRoundedCornersDrawable.setRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertArrayEquals(new float[] {1, 2, 3, 4, 5, 6, 7, 8}, mRoundedCornersDrawable.getRadii(), 0);
  }",method,
"  @Test
  public void testSetRadius() {
    mRoundedCornersDrawable.setRadius(9);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundedCornersDrawable.getRadii(), 0);
  }",method,
"  @Test
  public void testSetOverlayColor() {
    int overlayColor = 0xC0123456;
    mRoundedCornersDrawable.setOverlayColor(overlayColor);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(overlayColor, mRoundedCornersDrawable.getOverlayColor());
  }",method,
"  @Test
  public void testSetBorder() {
    float borderWidth = 0.7f;
    int borderColor = Color.CYAN;
    mRoundedCornersDrawable.setBorder(borderColor, borderWidth);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(borderColor, mRoundedCornersDrawable.getBorderColor());
    assertEquals(borderWidth, mRoundedCornersDrawable.getBorderWidth(), 0);
  }",method,
"  @Test
  public void testSetPadding() {
    float padding = 10;
    mRoundedCornersDrawable.setPadding(padding);
    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
    assertEquals(padding, mRoundedCornersDrawable.getPadding(), 0);
  }",method,
"public class RuleKeyLoggerListenerTest {
  private ProjectFilesystem projectFilesystem;
  private ExecutorService outputExecutor;
  private InvocationInfo info;
  private BuildRuleDurationTracker durationTracker;
  @Before
  public void setUp() throws InterruptedException, IOException {
    TemporaryFolder tempDirectory = new TemporaryFolder();
    tempDirectory.create();
    projectFilesystem =
        TestProjectFilesystems.createProjectFilesystem(tempDirectory.getRoot().toPath());
    outputExecutor =
        MostExecutors.newSingleThreadExecutor(new CommandThreadFactory(getClass().getName()));
    info =
        InvocationInfo.of(
            new BuildId(),
            false,
            false,
            ""topspin"",
            ImmutableList.of(),
            ImmutableList.of(),
            tempDirectory.getRoot().toPath());
    durationTracker = new BuildRuleDurationTracker();
  }
  @Test
  public void testFileIsNotCreatedWithoutEvents() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.outputTrace(info.getBuildId());
    Assert.assertFalse(Files.exists(listener.getLogFilePath()));
  }
  @Test
  public void testSendingHttpCacheEvent() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.onArtifactCacheEvent(createArtifactCacheEvent(CacheResultType.MISS));
    listener.outputTrace(info.getBuildId());
    Assert.assertTrue(Files.exists(listener.getLogFilePath()));
    Assert.assertTrue(Files.size(listener.getLogFilePath()) > 0);
  }
  @Test
  public void testSendingInvalidHttpCacheEvent() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.onArtifactCacheEvent(createArtifactCacheEvent(CacheResultType.HIT));
    listener.outputTrace(info.getBuildId());
    Assert.assertFalse(Files.exists(listener.getLogFilePath()));
  }
  @Test
  public void testSendingBuildEvent() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.onBuildRuleEvent(createBuildEvent());
    listener.outputTrace(info.getBuildId());
    Assert.assertTrue(Files.exists(listener.getLogFilePath()));
    Assert.assertTrue(Files.size(listener.getLogFilePath()) > 0);
  }
  private BuildRuleEvent.Finished createBuildEvent() {
    BuildRule rule =
        new FakeBuildRule(
            BuildTarget.of(
                UnflavoredBuildTarget.of(
                    projectFilesystem.getRootPath(),
                    Optional.empty(),
                    ""//topspin"",
                    ""//downtheline"")));
    BuildRuleKeys keys = BuildRuleKeys.of(new RuleKey(""1a1a1a""));
    BuildRuleEvent.Started started =
        TestEventConfigurator.configureTestEvent(BuildRuleEvent.started(rule, durationTracker));
    return BuildRuleEvent.finished(
        started, keys, null, null, Optional.empty(), null, false, null, null, Optional.empty());
  }
  private HttpArtifactCacheEvent.Finished createArtifactCacheEvent(CacheResultType type) {
    return ArtifactCacheTestUtils.newFetchFinishedEvent(
        ArtifactCacheTestUtils.newFetchStartedEvent(new RuleKey(""abababab42"")),
        CacheResult.builder().setType(type).setCacheSource(""random source"").build());
  }
  private RuleKeyLoggerListener newInstance(int minLinesForAutoFlush) {
    return new RuleKeyLoggerListener(projectFilesystem, info, outputExecutor, minLinesForAutoFlush);
  }
}",class,
"  @Before
  public void setUp() throws InterruptedException, IOException {
    TemporaryFolder tempDirectory = new TemporaryFolder();
    tempDirectory.create();
    projectFilesystem =
        TestProjectFilesystems.createProjectFilesystem(tempDirectory.getRoot().toPath());
    outputExecutor =
        MostExecutors.newSingleThreadExecutor(new CommandThreadFactory(getClass().getName()));
    info =
        InvocationInfo.of(
            new BuildId(),
            false,
            false,
            ""topspin"",
            ImmutableList.of(),
            ImmutableList.of(),
            tempDirectory.getRoot().toPath());
    durationTracker = new BuildRuleDurationTracker();
  }",method,
"  @Test
  public void testFileIsNotCreatedWithoutEvents() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.outputTrace(info.getBuildId());
    Assert.assertFalse(Files.exists(listener.getLogFilePath()));
  }",method,
"  @Test
  public void testSendingHttpCacheEvent() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.onArtifactCacheEvent(createArtifactCacheEvent(CacheResultType.MISS));
    listener.outputTrace(info.getBuildId());
    Assert.assertTrue(Files.exists(listener.getLogFilePath()));
    Assert.assertTrue(Files.size(listener.getLogFilePath()) > 0);
  }",method,
"  @Test
  public void testSendingInvalidHttpCacheEvent() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.onArtifactCacheEvent(createArtifactCacheEvent(CacheResultType.HIT));
    listener.outputTrace(info.getBuildId());
    Assert.assertFalse(Files.exists(listener.getLogFilePath()));
  }",method,
"  @Test
  public void testSendingBuildEvent() throws InterruptedException, IOException {
    RuleKeyLoggerListener listener = newInstance(1);
    listener.onBuildRuleEvent(createBuildEvent());
    listener.outputTrace(info.getBuildId());
    Assert.assertTrue(Files.exists(listener.getLogFilePath()));
    Assert.assertTrue(Files.size(listener.getLogFilePath()) > 0);
  }",method,
"  private BuildRuleEvent.Finished createBuildEvent() {
    BuildRule rule =
        new FakeBuildRule(
            BuildTarget.of(
                UnflavoredBuildTarget.of(
                    projectFilesystem.getRootPath(),
                    Optional.empty(),
                    ""//topspin"",
                    ""//downtheline"")));
    BuildRuleKeys keys = BuildRuleKeys.of(new RuleKey(""1a1a1a""));
    BuildRuleEvent.Started started =
        TestEventConfigurator.configureTestEvent(BuildRuleEvent.started(rule, durationTracker));
    return BuildRuleEvent.finished(
        started, keys, null, null, Optional.empty(), null, false, null, null, Optional.empty());
  }",method,
"  private HttpArtifactCacheEvent.Finished createArtifactCacheEvent(CacheResultType type) {
    return ArtifactCacheTestUtils.newFetchFinishedEvent(
        ArtifactCacheTestUtils.newFetchStartedEvent(new RuleKey(""abababab42"")),
        CacheResult.builder().setType(type).setCacheSource(""random source"").build());
  }",method,
"  private RuleKeyLoggerListener newInstance(int minLinesForAutoFlush) {
    return new RuleKeyLoggerListener(projectFilesystem, info, outputExecutor, minLinesForAutoFlush);
  }",method,
"public class DirectChannelBufferFactory implements ChannelBufferFactory {
    private static final DirectChannelBufferFactory INSTANCE = new DirectChannelBufferFactory();
    public DirectChannelBufferFactory() {
        super();
    }
    public static ChannelBufferFactory getInstance() {
        return INSTANCE;
    }
    public ChannelBuffer getBuffer(int capacity) {
        if (capacity < 0) {
            throw new IllegalArgumentException(""capacity: "" + capacity);
        }
        if (capacity == 0) {
            return ChannelBuffers.EMPTY_BUFFER;
        }
        return ChannelBuffers.directBuffer(capacity);
    }
    public ChannelBuffer getBuffer(byte[] array, int offset, int length) {
        if (array == null) {
            throw new NullPointerException(""array"");
        }
        if (offset < 0) {
            throw new IndexOutOfBoundsException(""offset: "" + offset);
        }
        if (length == 0) {
            return ChannelBuffers.EMPTY_BUFFER;
        }
        if (offset + length > array.length) {
            throw new IndexOutOfBoundsException(""length: "" + length);
        }
        ChannelBuffer buf = getBuffer(length);
        buf.writeBytes(array, offset, length);
        return buf;
    }
    public ChannelBuffer getBuffer(ByteBuffer nioBuffer) {
        if (!nioBuffer.isReadOnly() && nioBuffer.isDirect()) {
            return ChannelBuffers.wrappedBuffer(nioBuffer);
        }
        ChannelBuffer buf = getBuffer(nioBuffer.remaining());
        int pos = nioBuffer.position();
        buf.writeBytes(nioBuffer);
        nioBuffer.position(pos);
        return buf;
    }
}",class,
"    public DirectChannelBufferFactory() {
        super();
    }",method,
"    public static ChannelBufferFactory getInstance() {
        return INSTANCE;
    }",method,
"    public ChannelBuffer getBuffer(int capacity) {
        if (capacity < 0) {
            throw new IllegalArgumentException(""capacity: "" + capacity);
        }
        if (capacity == 0) {
            return ChannelBuffers.EMPTY_BUFFER;
        }
        return ChannelBuffers.directBuffer(capacity);
    }",method,
"        if (capacity < 0) {
            throw new IllegalArgumentException(""capacity: "" + capacity);
        }",method,
"        if (capacity == 0) {
            return ChannelBuffers.EMPTY_BUFFER;
        }",method,
"    public ChannelBuffer getBuffer(byte[] array, int offset, int length) {
        if (array == null) {
            throw new NullPointerException(""array"");
        }
        if (offset < 0) {
            throw new IndexOutOfBoundsException(""offset: "" + offset);
        }
        if (length == 0) {
            return ChannelBuffers.EMPTY_BUFFER;
        }
        if (offset + length > array.length) {
            throw new IndexOutOfBoundsException(""length: "" + length);
        }
        ChannelBuffer buf = getBuffer(length);
        buf.writeBytes(array, offset, length);
        return buf;
    }",method,
"        if (array == null) {
            throw new NullPointerException(""array"");
        }",method,
"        if (offset < 0) {
            throw new IndexOutOfBoundsException(""offset: "" + offset);
        }",method,
"        if (length == 0) {
            return ChannelBuffers.EMPTY_BUFFER;
        }",method,
"        if (offset + length > array.length) {
            throw new IndexOutOfBoundsException(""length: "" + length);
        }",method,
"    public ChannelBuffer getBuffer(ByteBuffer nioBuffer) {
        if (!nioBuffer.isReadOnly() && nioBuffer.isDirect()) {
            return ChannelBuffers.wrappedBuffer(nioBuffer);
        }
        ChannelBuffer buf = getBuffer(nioBuffer.remaining());
        int pos = nioBuffer.position();
        buf.writeBytes(nioBuffer);
        nioBuffer.position(pos);
        return buf;
    }",method,
"public class MetricsAutoConfigurationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private RestTemplate external;
	@Autowired
	private TestRestTemplate loopback;
	@Autowired
	private MeterRegistry registry;
	@SuppressWarnings(""unchecked"")
	@Test
	public void restTemplateIsInstrumented() {
		MockRestServiceServer server = MockRestServiceServer.bindTo(this.external)
				.build();
		server.expect(once(), requestTo(""/api/external""))
				.andExpect(method(HttpMethod.GET)).andRespond(withSuccess(
						""{\""message\"": \""hello\""}"", MediaType.APPLICATION_JSON));
		assertThat(this.external.getForObject(""/api/external"", Map.class))
				.containsKey(""message"");
		assertThat(this.registry.find(""http.client.requests"").value(Statistic.Count, 1.0)
				.timer()).isPresent();
	}
	@Test
	public void requestMappingIsInstrumented() {
		this.loopback.getForObject(""/api/people"", Set.class);
		assertThat(this.registry.find(""http.server.requests"").value(Statistic.Count, 1.0)
				.timer()).isPresent();
	}
	@Test
	public void automaticallyRegisteredBinders() {
		assertThat(this.context.getBeansOfType(MeterBinder.class).values())
				.hasAtLeastOneElementOfType(LogbackMetrics.class)
				.hasAtLeastOneElementOfType(JvmMemoryMetrics.class);
	}
	@Configuration
	@ImportAutoConfiguration({ MetricsAutoConfiguration.class,
			JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			ServletWebServerFactoryAutoConfiguration.class })
	@Import(PersonController.class)
	static class MetricsApp {
		@Bean
		public MeterRegistry registry() {
			return new SimpleMeterRegistry();
		}
		@Bean
		public RestTemplate restTemplate() {
			return new RestTemplate();
		}
	}
	@RestController
	static class PersonController {
		@GetMapping(""/api/people"")
		Set<String> personName() {
			return Collections.singleton(""Jon"");
		}
	}
}",class,
"	static class MetricsApp {
		@Bean
		public MeterRegistry registry() {
			return new SimpleMeterRegistry();
		}
		@Bean
		public RestTemplate restTemplate() {
			return new RestTemplate();
		}
	}",class,
"	static class PersonController {
		@GetMapping(""/api/people"")
		Set<String> personName() {
			return Collections.singleton(""Jon"");
		}
	}",class,
"	@SuppressWarnings(""unchecked"")
	@Test
	public void restTemplateIsInstrumented() {
		MockRestServiceServer server = MockRestServiceServer.bindTo(this.external)
				.build();
		server.expect(once(), requestTo(""/api/external""))
				.andExpect(method(HttpMethod.GET)).andRespond(withSuccess(
						""{\""message\"": \""hello\""}"", MediaType.APPLICATION_JSON));
		assertThat(this.external.getForObject(""/api/external"", Map.class))
				.containsKey(""message"");
		assertThat(this.registry.find(""http.client.requests"").value(Statistic.Count, 1.0)
				.timer()).isPresent();
	}",method,
"	@Test
	public void requestMappingIsInstrumented() {
		this.loopback.getForObject(""/api/people"", Set.class);
		assertThat(this.registry.find(""http.server.requests"").value(Statistic.Count, 1.0)
				.timer()).isPresent();
	}",method,
"	@Test
	public void automaticallyRegisteredBinders() {
		assertThat(this.context.getBeansOfType(MeterBinder.class).values())
				.hasAtLeastOneElementOfType(LogbackMetrics.class)
				.hasAtLeastOneElementOfType(JvmMemoryMetrics.class);
	}",method,
"		@Bean
		public MeterRegistry registry() {
			return new SimpleMeterRegistry();
		}",method,
"		@Bean
		public RestTemplate restTemplate() {
			return new RestTemplate();
		}",method,
"		@GetMapping(""/api/people"")
		Set<String> personName() {
			return Collections.singleton(""Jon"");
		}",method,
"  @Deprecated
  default void clearOption(@NotNull String key) {
    setOption(key, null);
  }",method,
"  @Nullable
  default String getModuleTypeName() {
    //noinspection deprecation
    return getOptionValue(ELEMENT_TYPE);
  }",method,
"  default void setModuleType(@NotNull String name) {
    //noinspection deprecation
    setOption(ELEMENT_TYPE, name);
  }",method,
"public class UnInjectLanguageAction implements IntentionAction, LowPriorityAction {
  @NotNull
  public String getText() {
    return ""Un-inject Language/Reference"";
  }
  @NotNull
  public String getFamilyName() {
    return getText();
  }
  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
    final int offset = editor.getCaretModel().getOffset();
    PsiElement element = InjectedLanguageUtil.findInjectedPsiNoCommit(file, offset);
    if (element == null) {
      return InjectedReferencesContributor.isInjected(file.findReferenceAt(offset));
    }
    return element.getUserData(LanguageInjectionSupport.INJECTOR_SUPPORT) != null;
  }
  public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {
    ApplicationManager.getApplication().runReadAction(() -> invokeImpl(project, editor, file));
  }
  public static void invokeImpl(Project project, Editor editor, PsiFile file) {
    int offset = editor.getCaretModel().getOffset();
    final PsiFile psiFile = InjectedLanguageUtil.findInjectedPsiNoCommit(file, offset);
    if (psiFile == null) {
      PsiReference reference = file.findReferenceAt(offset);
      if (reference == null) return;
      if (reference.getElement() instanceof PsiLanguageInjectionHost) {
        PsiLanguageInjectionHost host = (PsiLanguageInjectionHost)reference.getElement();
        for (LanguageInjectionSupport support : InjectorUtils.getActiveInjectionSupports()) {
          if (support.isApplicableTo(host) && support.removeInjectionInPlace(host)) {
            PsiManager.getInstance(project).dropPsiCaches();
            return;
          }
        }
      }
      PsiElement element = reference.getElement();
      LanguageInjectionSupport support = element.getUserData(LanguageInjectionSupport.INJECTOR_SUPPORT);
      if (support != null) {
        if (support.removeInjection(element)) {
          PsiManager.getInstance(project).dropPsiCaches();
        }
      }
      return;
    }
    final PsiLanguageInjectionHost host = InjectedLanguageManager.getInstance(project).getInjectionHost(psiFile);
    if (host == null) return;
    final LanguageInjectionSupport support = psiFile.getUserData(LanguageInjectionSupport.INJECTOR_SUPPORT);
    if (support == null) return;
    try {
      if (psiFile.getUserData(LanguageInjectionSupport.TEMPORARY_INJECTED_LANGUAGE) != null) {
        // temporary injection
        TemporaryPlacesRegistry temporaryPlacesRegistry = TemporaryPlacesRegistry.getInstance(project);
        for (PsiLanguageInjectionHost.Shred shred : InjectedLanguageUtil.getShreds(psiFile)) {
          if (temporaryPlacesRegistry.removeHostWithUndo(project, shred.getHost())) break;
        }
      }
      else if (!support.removeInjectionInPlace(host)) {
        defaultFunctionalityWorked(host);
      }
    }
    finally {
      FileContentUtil.reparseFiles(project, Collections.emptyList(), true);
    }
  }
  private static boolean defaultFunctionalityWorked(final PsiLanguageInjectionHost host) {
    final THashSet<String> languages = new THashSet<>();
    final List<Pair<PsiElement, TextRange>> files = InjectedLanguageManager.getInstance(host.getProject()).getInjectedPsiFiles(host);
    if (files == null) return false;
    for (Pair<PsiElement, TextRange> pair : files) {
      for (Language lang = pair.first.getLanguage(); lang != null; lang = lang.getBaseLanguage()) {
        languages.add(lang.getID());
      }
    }
    // todo there is a problem: host i.e. literal expression is confused with ""target"" i.e. parameter
    // todo therefore this part doesn't work for java
    return Configuration.getProjectInstance(host.getProject()).setHostInjectionEnabled(host, languages, false);
  }
  public boolean startInWriteAction() {
    return false;
  }
}",class,
"  @NotNull
  public String getText() {
    return ""Un-inject Language/Reference"";
  }",method,
"  @NotNull
  public String getFamilyName() {
    return getText();
  }",method,
"  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
    final int offset = editor.getCaretModel().getOffset();
    PsiElement element = InjectedLanguageUtil.findInjectedPsiNoCommit(file, offset);
    if (element == null) {
      return InjectedReferencesContributor.isInjected(file.findReferenceAt(offset));
    }
    return element.getUserData(LanguageInjectionSupport.INJECTOR_SUPPORT) != null;
  }",method,
"    if (element == null) {
      return InjectedReferencesContributor.isInjected(file.findReferenceAt(offset));
    }",method,
"  public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {
    ApplicationManager.getApplication().runReadAction(() -> invokeImpl(project, editor, file));
  }",method,
"  public static void invokeImpl(Project project, Editor editor, PsiFile file) {
    int offset = editor.getCaretModel().getOffset();
    final PsiFile psiFile = InjectedLanguageUtil.findInjectedPsiNoCommit(file, offset);
    if (psiFile == null) {
      PsiReference reference = file.findReferenceAt(offset);
      if (reference == null) return;
      if (reference.getElement() instanceof PsiLanguageInjectionHost) {
        PsiLanguageInjectionHost host = (PsiLanguageInjectionHost)reference.getElement();
        for (LanguageInjectionSupport support : InjectorUtils.getActiveInjectionSupports()) {
          if (support.isApplicableTo(host) && support.removeInjectionInPlace(host)) {
            PsiManager.getInstance(project).dropPsiCaches();
            return;
          }
        }
      }
      PsiElement element = reference.getElement();
      LanguageInjectionSupport support = element.getUserData(LanguageInjectionSupport.INJECTOR_SUPPORT);
      if (support != null) {
        if (support.removeInjection(element)) {
          PsiManager.getInstance(project).dropPsiCaches();
        }
      }
      return;
    }
    final PsiLanguageInjectionHost host = InjectedLanguageManager.getInstance(project).getInjectionHost(psiFile);
    if (host == null) return;
    final LanguageInjectionSupport support = psiFile.getUserData(LanguageInjectionSupport.INJECTOR_SUPPORT);
    if (support == null) return;
    try {
      if (psiFile.getUserData(LanguageInjectionSupport.TEMPORARY_INJECTED_LANGUAGE) != null) {
        // temporary injection
        TemporaryPlacesRegistry temporaryPlacesRegistry = TemporaryPlacesRegistry.getInstance(project);
        for (PsiLanguageInjectionHost.Shred shred : InjectedLanguageUtil.getShreds(psiFile)) {
          if (temporaryPlacesRegistry.removeHostWithUndo(project, shred.getHost())) break;
        }
      }
      else if (!support.removeInjectionInPlace(host)) {
        defaultFunctionalityWorked(host);
      }
    }
    finally {
      FileContentUtil.reparseFiles(project, Collections.emptyList(), true);
    }
  }",method,
"    if (psiFile == null) {
      PsiReference reference = file.findReferenceAt(offset);
      if (reference == null) return;
      if (reference.getElement() instanceof PsiLanguageInjectionHost) {
        PsiLanguageInjectionHost host = (PsiLanguageInjectionHost)reference.getElement();
        for (LanguageInjectionSupport support : InjectorUtils.getActiveInjectionSupports()) {
          if (support.isApplicableTo(host) && support.removeInjectionInPlace(host)) {
            PsiManager.getInstance(project).dropPsiCaches();
            return;
          }
        }
      }
      PsiElement element = reference.getElement();
      LanguageInjectionSupport support = element.getUserData(LanguageInjectionSupport.INJECTOR_SUPPORT);
      if (support != null) {
        if (support.removeInjection(element)) {
          PsiManager.getInstance(project).dropPsiCaches();
        }
      }
      return;
    }",method,
"      if (support != null) {
        if (support.removeInjection(element)) {
          PsiManager.getInstance(project).dropPsiCaches();
        }
      }",method,

code_snippet,type,score
"      for(int i = 0, j = offsetS; j < arrayS.length && i < numBytes; j++, i++) {
        carray[i] = arrayS[j];
      }",method,
"public class Container {
	static private final WeakHashMap<Object, Object> containersByComponent = new WeakHashMap<Object, Object>();
	private static final Object MULTIPLE = ""COMPONENT IN MULTIPLE CONTAINERS"";
	synchronized
	static public Container of(Object component) {
		Object ret = containersByComponent.get(component);
		if (ret == null)     throw new IllegalArgumentException(""Unable to find container for component: "" + component);
		if (ret == MULTIPLE) throw new IllegalArgumentException(""Component '"" + component + ""' is in more than one container."");
		return (Container)ret;
	}
	private final ComponentLoader loader;
	private final Map<Object, Object> componentsByHandle = new HashMap<Object, Object>();
	public Container(ComponentLoader loader) {
		this.loader = loader;
	}
	public <T> T produce(Object handle) {
		synchronized (Container.class) {
			T cached = (T) componentsByHandle.get(handle);
			if (cached != null) return cached;
			T loaded = loader.load(handle, this);
			keep(handle, loaded);
			return loaded;
		}
	}
	public void inject(Object handle, Object component) {
		synchronized (Container.class) {
			check(!componentsByHandle.containsKey(handle));
			keep(handle, component);
		}
	}
	private void keep(Object handle, Object component) {
		if (containersByComponent.containsKey(component))
			containersByComponent.put(component, MULTIPLE);
		else
			containersByComponent.put(component, this);
		componentsByHandle.put(handle, component);
	}
	public interface ComponentLoader {
		<T> T load(Object handle, Container container);
	}
}",class,
"public abstract class InfiniteLoop extends Thread {
	private boolean quitLoop;
	{
		setDaemon(true);
		start();
	}
	@Override public void run() {
		while (!quitLoop) iterate();
	}
	protected abstract void iterate();
	protected void quitLoop() {
		quitLoop = true;
	}
}",class,
"	synchronized
	static public Container of(Object component) {
		Object ret = containersByComponent.get(component);
		if (ret == null)     throw new IllegalArgumentException(""Unable to find container for component: "" + component);
		if (ret == MULTIPLE) throw new IllegalArgumentException(""Component '"" + component + ""' is in more than one container."");
		return (Container)ret;
	}",method,
"	public Container(ComponentLoader loader) {
		this.loader = loader;
	}",method,
"	public <T> T produce(Object handle) {
		synchronized (Container.class) {
			T cached = (T) componentsByHandle.get(handle);
			if (cached != null) return cached;
			T loaded = loader.load(handle, this);
			keep(handle, loaded);
			return loaded;
		}
	}",method,
"		synchronized (Container.class) {
			T cached = (T) componentsByHandle.get(handle);
			if (cached != null) return cached;
			T loaded = loader.load(handle, this);
			keep(handle, loaded);
			return loaded;
		}",method,
"	public void inject(Object handle, Object component) {
		synchronized (Container.class) {
			check(!componentsByHandle.containsKey(handle));
			keep(handle, component);
		}
	}",method,
"		synchronized (Container.class) {
			check(!componentsByHandle.containsKey(handle));
			keep(handle, component);
		}",method,
"	private void keep(Object handle, Object component) {
		if (containersByComponent.containsKey(component))
			containersByComponent.put(component, MULTIPLE);
		else
			containersByComponent.put(component, this);
		componentsByHandle.put(handle, component);
	}",method,
"	protected void quitLoop() {
		quitLoop = true;
	}",method,
"public class DriverSessionTest {
  @Test
  public void testShouldRegisterCorrectDefaultsOnMac() {
    DriverFactory factory = new DefaultDriverFactory(Platform.MAC);
    new DefaultDriverSessions(factory, 18000);
    assertTrue(factory.hasMappingFor(DesiredCapabilities.chrome()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.firefox()));
    assertFalse(factory.hasMappingFor(DesiredCapabilities.internetExplorer()));
  }
  @Test
  public void testShouldRegisterCorrectDefaultsOnLinux() {
    DriverFactory factory = new DefaultDriverFactory(Platform.LINUX);
    new DefaultDriverSessions(factory, 18000);
    assertTrue(factory.hasMappingFor(DesiredCapabilities.chrome()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.firefox()));
    assertFalse(factory.hasMappingFor(DesiredCapabilities.internetExplorer()));
  }
  @Test
  public void testShouldRegisterCorrectDefaultsOnWindows() {
    DriverFactory factory = new DefaultDriverFactory(Platform.VISTA);
    new DefaultDriverSessions(factory, 18000);
    assertTrue(factory.hasMappingFor(DesiredCapabilities.chrome()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.firefox()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.internetExplorer()));
  }
  @Test
  public void testShouldBeAbleToRegisterOwnDriver() {
    DriverFactory factory = new DefaultDriverFactory(Platform.VISTA);
    DriverSessions sessions = new DefaultDriverSessions(factory, 18000);
    Capabilities capabilities = new DesiredCapabilities(""foo"", ""1"", Platform.ANY);
    sessions.registerDriver(capabilities, AbstractDriver.class);
    assertTrue(factory.hasMappingFor(capabilities));
  }
  public static abstract class AbstractDriver implements WebDriver {}
}",class,
  public static abstract class AbstractDriver implements WebDriver {},class,
"  @Test
  public void testShouldRegisterCorrectDefaultsOnMac() {
    DriverFactory factory = new DefaultDriverFactory(Platform.MAC);
    new DefaultDriverSessions(factory, 18000);
    assertTrue(factory.hasMappingFor(DesiredCapabilities.chrome()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.firefox()));
    assertFalse(factory.hasMappingFor(DesiredCapabilities.internetExplorer()));
  }",method,
"  @Test
  public void testShouldRegisterCorrectDefaultsOnLinux() {
    DriverFactory factory = new DefaultDriverFactory(Platform.LINUX);
    new DefaultDriverSessions(factory, 18000);
    assertTrue(factory.hasMappingFor(DesiredCapabilities.chrome()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.firefox()));
    assertFalse(factory.hasMappingFor(DesiredCapabilities.internetExplorer()));
  }",method,
"  @Test
  public void testShouldRegisterCorrectDefaultsOnWindows() {
    DriverFactory factory = new DefaultDriverFactory(Platform.VISTA);
    new DefaultDriverSessions(factory, 18000);
    assertTrue(factory.hasMappingFor(DesiredCapabilities.chrome()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.firefox()));
    assertTrue(factory.hasMappingFor(DesiredCapabilities.internetExplorer()));
  }",method,
"  @Test
  public void testShouldBeAbleToRegisterOwnDriver() {
    DriverFactory factory = new DefaultDriverFactory(Platform.VISTA);
    DriverSessions sessions = new DefaultDriverSessions(factory, 18000);
    Capabilities capabilities = new DesiredCapabilities(""foo"", ""1"", Platform.ANY);
    sessions.registerDriver(capabilities, AbstractDriver.class);
    assertTrue(factory.hasMappingFor(capabilities));
  }",method,
"public class PrioritySchedulerTest {
    private PriorityScheduler priorityScheduler = new PriorityScheduler();
    private Task task = new Task() {
        @Override
        public String getUUID() {
            return ""1"";
        }
        @Override
        public Site getSite() {
            return null;
        }
    };
    @Test
    public void testDifferentPriority() {
        Request request = new Request(""a"");
        request.setPriority(100);
        priorityScheduler.push(request,task);
        request = new Request(""b"");
        request.setPriority(900);
        priorityScheduler.push(request,task);
        request = new Request(""c"");
        priorityScheduler.push(request,task);
        request = new Request(""d"");
        request.setPriority(-900);
        priorityScheduler.push(request,task);
        Request poll = priorityScheduler.poll(task);
        Assert.assertEquals(""b"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""a"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""c"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""d"",poll.getUrl());
    }
    @Test
    public void testNoPriority() {
        Request request = new Request(""a"");
        priorityScheduler.push(request,task);
        request = new Request(""b"");
        priorityScheduler.push(request,task);
        request = new Request(""c"");
        priorityScheduler.push(request,task);
        Request poll = priorityScheduler.poll(task);
        Assert.assertEquals(""a"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""b"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""c"",poll.getUrl());
    }
}",class,
"        @Override
        public String getUUID() {
            return ""1"";
        }",method,
"        @Override
        public Site getSite() {
            return null;
        }",method,
"    @Test
    public void testDifferentPriority() {
        Request request = new Request(""a"");
        request.setPriority(100);
        priorityScheduler.push(request,task);
        request = new Request(""b"");
        request.setPriority(900);
        priorityScheduler.push(request,task);
        request = new Request(""c"");
        priorityScheduler.push(request,task);
        request = new Request(""d"");
        request.setPriority(-900);
        priorityScheduler.push(request,task);
        Request poll = priorityScheduler.poll(task);
        Assert.assertEquals(""b"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""a"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""c"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""d"",poll.getUrl());
    }",method,
"    @Test
    public void testNoPriority() {
        Request request = new Request(""a"");
        priorityScheduler.push(request,task);
        request = new Request(""b"");
        priorityScheduler.push(request,task);
        request = new Request(""c"");
        priorityScheduler.push(request,task);
        Request poll = priorityScheduler.poll(task);
        Assert.assertEquals(""a"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""b"",poll.getUrl());
        poll = priorityScheduler.poll(task);
        Assert.assertEquals(""c"",poll.getUrl());
    }",method,
"public class IconMarginSpan
implements LeadingMarginSpan, LineHeightSpan
{
    public IconMarginSpan(Bitmap b) {
        mBitmap = b;
    }
    public IconMarginSpan(Bitmap b, int pad) {
        mBitmap = b;
        mPad = pad;
    }
    public int getLeadingMargin(boolean first) {
        return mBitmap.getWidth() + mPad;
    }
    public void drawLeadingMargin(Canvas c, Paint p, int x, int dir,
                                  int top, int baseline, int bottom,
                                  CharSequence text, int start, int end,
                                  boolean first, Layout layout) {
        int st = ((Spanned) text).getSpanStart(this);
        int itop = layout.getLineTop(layout.getLineForOffset(st));
        if (dir < 0)
            x -= mBitmap.getWidth();
        c.drawBitmap(mBitmap, x, itop, p);
    }
    public void chooseHeight(CharSequence text, int start, int end,
                             int istartv, int v,
                             Paint.FontMetricsInt fm) {
        if (end == ((Spanned) text).getSpanEnd(this)) {
            int ht = mBitmap.getHeight();
            int need = ht - (v + fm.descent - fm.ascent - istartv);
            if (need > 0)
                fm.descent += need;
            need = ht - (v + fm.bottom - fm.top - istartv);
            if (need > 0)
                fm.bottom += need;
        }
    }
    private Bitmap mBitmap;
    private int mPad;
}",class,
"    public IconMarginSpan(Bitmap b) {
        mBitmap = b;
    }",method,
"    public IconMarginSpan(Bitmap b, int pad) {
        mBitmap = b;
        mPad = pad;
    }",method,
"    public int getLeadingMargin(boolean first) {
        return mBitmap.getWidth() + mPad;
    }",method,
"    public void drawLeadingMargin(Canvas c, Paint p, int x, int dir,
                                  int top, int baseline, int bottom,
                                  CharSequence text, int start, int end,
                                  boolean first, Layout layout) {
        int st = ((Spanned) text).getSpanStart(this);
        int itop = layout.getLineTop(layout.getLineForOffset(st));
        if (dir < 0)
            x -= mBitmap.getWidth();
        c.drawBitmap(mBitmap, x, itop, p);
    }",method,
"    public void chooseHeight(CharSequence text, int start, int end,
                             int istartv, int v,
                             Paint.FontMetricsInt fm) {
        if (end == ((Spanned) text).getSpanEnd(this)) {
            int ht = mBitmap.getHeight();
            int need = ht - (v + fm.descent - fm.ascent - istartv);
            if (need > 0)
                fm.descent += need;
            need = ht - (v + fm.bottom - fm.top - istartv);
            if (need > 0)
                fm.bottom += need;
        }
    }",method,
"public class SynchronossPartHttpMessageReader implements HttpMessageReader<Part> {
	private final DataBufferFactory bufferFactory = new DefaultDataBufferFactory();
	@Override
	public List<MediaType> getReadableMediaTypes() {
		return Collections.singletonList(MediaType.MULTIPART_FORM_DATA);
	}
	@Override
	public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {
		return Part.class.equals(elementType.resolve(Object.class)) &&
				(mediaType == null || MediaType.MULTIPART_FORM_DATA.isCompatibleWith(mediaType));
	}
	@Override
	public Flux<Part> read(ResolvableType elementType, ReactiveHttpInputMessage message,
			Map<String, Object> hints) {
		return Flux.create(new SynchronossPartGenerator(message, this.bufferFactory));
	}
	@Override
	public Mono<Part> readMono(ResolvableType elementType, ReactiveHttpInputMessage message,
			Map<String, Object> hints) {
		return Mono.error(new UnsupportedOperationException(
				""This reader does not support reading a single element.""));
	}
	private static class SynchronossPartGenerator implements Consumer<FluxSink<Part>> {
		private final ReactiveHttpInputMessage inputMessage;
		private final DataBufferFactory bufferFactory;
		SynchronossPartGenerator(ReactiveHttpInputMessage inputMessage, DataBufferFactory factory) {
			this.inputMessage = inputMessage;
			this.bufferFactory = factory;
		}
		@Override
		public void accept(FluxSink<Part> emitter) {
			HttpHeaders headers = this.inputMessage.getHeaders();
			MediaType mediaType = headers.getContentType();
			Assert.state(mediaType != null, ""No content type set"");
			int length = Math.toIntExact(headers.getContentLength());
			Charset charset = Optional.ofNullable(mediaType.getCharset()).orElse(StandardCharsets.UTF_8);
			MultipartContext context = new MultipartContext(mediaType.toString(), length, charset.name());
			NioMultipartParserListener listener = new FluxSinkAdapterListener(emitter, this.bufferFactory, context);
			NioMultipartParser parser = Multipart.multipart(context).forNIO(listener);
			this.inputMessage.getBody().subscribe(buffer -> {
				byte[] resultBytes = new byte[buffer.readableByteCount()];
				buffer.read(resultBytes);
				try {
					parser.write(resultBytes);
				}
				catch (IOException ex) {
					listener.onError(""Exception thrown providing input to the parser"", ex);
				}
				finally {
					DataBufferUtils.release(buffer);
				}
			}, (ex) -> {
				try {
					listener.onError(""Request body input error"", ex);
					parser.close();
				}
				catch (IOException ex2) {
					listener.onError(""Exception thrown while closing the parser"", ex2);
				}
			}, () -> {
				try {
					parser.close();
				}
				catch (IOException ex) {
					listener.onError(""Exception thrown while closing the parser"", ex);
				}
			});
		}
	}
	private static class FluxSinkAdapterListener implements NioMultipartParserListener {
		private final FluxSink<Part> sink;
		private final DataBufferFactory bufferFactory;
		private final MultipartContext context;
		private final AtomicInteger terminated = new AtomicInteger(0);
		FluxSinkAdapterListener(FluxSink<Part> sink, DataBufferFactory bufferFactory, MultipartContext context) {
			this.sink = sink;
			this.bufferFactory = bufferFactory;
			this.context = context;
		}
		@Override
		public void onPartFinished(StreamStorage storage, Map<String, List<String>> headers) {
			HttpHeaders httpHeaders = new HttpHeaders();
			httpHeaders.putAll(headers);
			this.sink.next(createPart(storage, httpHeaders));
		}
		private Part createPart(StreamStorage storage, HttpHeaders httpHeaders) {
			String filename = MultipartUtils.getFileName(httpHeaders);
			if (filename != null) {
				return new SynchronossFilePart(httpHeaders, storage, this.bufferFactory, filename);
			}
			else if (MultipartUtils.isFormField(httpHeaders, this.context)) {
				String value = MultipartUtils.readFormParameterValue(storage, httpHeaders);
				return new SynchronossFormFieldPart(httpHeaders, this.bufferFactory, value);
			}
			else {
				return new DefaultSynchronossPart(httpHeaders, storage, this.bufferFactory);
			}
		}
		@Override
		public void onError(String message, Throwable cause) {
			if (this.terminated.getAndIncrement() == 0) {
				this.sink.error(new RuntimeException(message, cause));
			}
		}
		@Override
		public void onAllPartsFinished() {
			if (this.terminated.getAndIncrement() == 0) {
				this.sink.complete();
			}
		}
		@Override
		public void onNestedPartStarted(Map<String, List<String>> headersFromParentPart) {
		}
		@Override
		public void onNestedPartFinished() {
		}
	}
	private static abstract class AbstractSynchronossPart implements Part {
		private final HttpHeaders headers;
		private final DataBufferFactory bufferFactory;
		AbstractSynchronossPart(HttpHeaders headers, DataBufferFactory bufferFactory) {
			Assert.notNull(headers, ""HttpHeaders is required"");
			Assert.notNull(bufferFactory, ""'bufferFactory' is required"");
			this.headers = headers;
			this.bufferFactory = bufferFactory;
		}
		@Override
		public String name() {
			return MultipartUtils.getFieldName(this.headers);
		}
		@Override
		public HttpHeaders headers() {
			return this.headers;
		}
		protected DataBufferFactory getBufferFactory() {
			return this.bufferFactory;
		}
	}
	private static class DefaultSynchronossPart extends AbstractSynchronossPart {
		private final StreamStorage storage;
		DefaultSynchronossPart(HttpHeaders headers, StreamStorage storage, DataBufferFactory factory) {
			super(headers, factory);
			Assert.notNull(storage, ""'storage' is required"");
			this.storage = storage;
		}
		@Override
		public Flux<DataBuffer> content() {
			InputStream inputStream = this.storage.getInputStream();
			return DataBufferUtils.read(inputStream, getBufferFactory(), 4096);
		}
		protected StreamStorage getStorage() {
			return this.storage;
		}
	}
	private static class SynchronossFilePart extends DefaultSynchronossPart implements FilePart {
		private final String filename;
		public SynchronossFilePart(
				HttpHeaders headers, StreamStorage storage, DataBufferFactory factory, String filename) {
			super(headers, storage, factory);
			this.filename = filename;
		}
		@Override
		public String filename() {
			return this.filename;
		}
		@Override
		public Mono<Void> transferTo(File destination) {
			ReadableByteChannel input = null;
			FileChannel output = null;
			try {
				input = Channels.newChannel(getStorage().getInputStream());
				output = FileChannel.open(destination.toPath(), StandardOpenOption.WRITE);
				long size = (input instanceof FileChannel ? ((FileChannel) input).size() : Long.MAX_VALUE);
				long totalWritten = 0;
				while (totalWritten < size) {
					long written = output.transferFrom(input, totalWritten, size - totalWritten);
					if (written <= 0) {
						break;
					}
					totalWritten += written;
				}
			}
			catch (IOException ex) {
				return Mono.error(ex);
			}
			finally {
				if (input != null) {
					try {
						input.close();
					}
					catch (IOException ignored) {
					}
				}
				if (output != null) {
					try {
						output.close();
					}
					catch (IOException ignored) {
					}
				}
			}
			return Mono.empty();
		}
	}
	private static class SynchronossFormFieldPart extends AbstractSynchronossPart implements FormFieldPart {
		private final String content;
		SynchronossFormFieldPart(HttpHeaders headers, DataBufferFactory bufferFactory, String content) {
			super(headers, bufferFactory);
			this.content = content;
		}
		@Override
		public String value() {
			return this.content;
		}
		@Override
		public Flux<DataBuffer> content() {
			byte[] bytes = this.content.getBytes(getCharset());
			DataBuffer buffer = getBufferFactory().allocateBuffer(bytes.length);
			buffer.write(bytes);
			return Flux.just(buffer);
		}
		private Charset getCharset() {
			return Optional.ofNullable(MultipartUtils.getCharEncoding(headers()))
					.map(Charset::forName).orElse(StandardCharsets.UTF_8);
		}
	}
}",class,
"	private static class SynchronossPartGenerator implements Consumer<FluxSink<Part>> {
		private final ReactiveHttpInputMessage inputMessage;
		private final DataBufferFactory bufferFactory;
		SynchronossPartGenerator(ReactiveHttpInputMessage inputMessage, DataBufferFactory factory) {
			this.inputMessage = inputMessage;
			this.bufferFactory = factory;
		}
		@Override
		public void accept(FluxSink<Part> emitter) {
			HttpHeaders headers = this.inputMessage.getHeaders();
			MediaType mediaType = headers.getContentType();
			Assert.state(mediaType != null, ""No content type set"");
			int length = Math.toIntExact(headers.getContentLength());
			Charset charset = Optional.ofNullable(mediaType.getCharset()).orElse(StandardCharsets.UTF_8);
			MultipartContext context = new MultipartContext(mediaType.toString(), length, charset.name());
			NioMultipartParserListener listener = new FluxSinkAdapterListener(emitter, this.bufferFactory, context);
			NioMultipartParser parser = Multipart.multipart(context).forNIO(listener);
			this.inputMessage.getBody().subscribe(buffer -> {
				byte[] resultBytes = new byte[buffer.readableByteCount()];
				buffer.read(resultBytes);
				try {
					parser.write(resultBytes);
				}
				catch (IOException ex) {
					listener.onError(""Exception thrown providing input to the parser"", ex);
				}
				finally {
					DataBufferUtils.release(buffer);
				}
			}, (ex) -> {
				try {
					listener.onError(""Request body input error"", ex);
					parser.close();
				}
				catch (IOException ex2) {
					listener.onError(""Exception thrown while closing the parser"", ex2);
				}
			}, () -> {
				try {
					parser.close();
				}
				catch (IOException ex) {
					listener.onError(""Exception thrown while closing the parser"", ex);
				}
			});
		}
	}",class,
"	private static class FluxSinkAdapterListener implements NioMultipartParserListener {
		private final FluxSink<Part> sink;
		private final DataBufferFactory bufferFactory;
		private final MultipartContext context;
		private final AtomicInteger terminated = new AtomicInteger(0);
		FluxSinkAdapterListener(FluxSink<Part> sink, DataBufferFactory bufferFactory, MultipartContext context) {
			this.sink = sink;
			this.bufferFactory = bufferFactory;
			this.context = context;
		}
		@Override
		public void onPartFinished(StreamStorage storage, Map<String, List<String>> headers) {
			HttpHeaders httpHeaders = new HttpHeaders();
			httpHeaders.putAll(headers);
			this.sink.next(createPart(storage, httpHeaders));
		}
		private Part createPart(StreamStorage storage, HttpHeaders httpHeaders) {
			String filename = MultipartUtils.getFileName(httpHeaders);
			if (filename != null) {
				return new SynchronossFilePart(httpHeaders, storage, this.bufferFactory, filename);
			}
			else if (MultipartUtils.isFormField(httpHeaders, this.context)) {
				String value = MultipartUtils.readFormParameterValue(storage, httpHeaders);
				return new SynchronossFormFieldPart(httpHeaders, this.bufferFactory, value);
			}
			else {
				return new DefaultSynchronossPart(httpHeaders, storage, this.bufferFactory);
			}
		}
		@Override
		public void onError(String message, Throwable cause) {
			if (this.terminated.getAndIncrement() == 0) {
				this.sink.error(new RuntimeException(message, cause));
			}
		}
		@Override
		public void onAllPartsFinished() {
			if (this.terminated.getAndIncrement() == 0) {
				this.sink.complete();
			}
		}
		@Override
		public void onNestedPartStarted(Map<String, List<String>> headersFromParentPart) {
		}
		@Override
		public void onNestedPartFinished() {
		}
	}",class,
"	private static abstract class AbstractSynchronossPart implements Part {
		private final HttpHeaders headers;
		private final DataBufferFactory bufferFactory;
		AbstractSynchronossPart(HttpHeaders headers, DataBufferFactory bufferFactory) {
			Assert.notNull(headers, ""HttpHeaders is required"");
			Assert.notNull(bufferFactory, ""'bufferFactory' is required"");
			this.headers = headers;
			this.bufferFactory = bufferFactory;
		}
		@Override
		public String name() {
			return MultipartUtils.getFieldName(this.headers);
		}
		@Override
		public HttpHeaders headers() {
			return this.headers;
		}
		protected DataBufferFactory getBufferFactory() {
			return this.bufferFactory;
		}
	}",class,
"	private static class DefaultSynchronossPart extends AbstractSynchronossPart {
		private final StreamStorage storage;
		DefaultSynchronossPart(HttpHeaders headers, StreamStorage storage, DataBufferFactory factory) {
			super(headers, factory);
			Assert.notNull(storage, ""'storage' is required"");
			this.storage = storage;
		}
		@Override
		public Flux<DataBuffer> content() {
			InputStream inputStream = this.storage.getInputStream();
			return DataBufferUtils.read(inputStream, getBufferFactory(), 4096);
		}
		protected StreamStorage getStorage() {
			return this.storage;
		}
	}",class,
"	private static class SynchronossFilePart extends DefaultSynchronossPart implements FilePart {
		private final String filename;
		public SynchronossFilePart(
				HttpHeaders headers, StreamStorage storage, DataBufferFactory factory, String filename) {
			super(headers, storage, factory);
			this.filename = filename;
		}
		@Override
		public String filename() {
			return this.filename;
		}
		@Override
		public Mono<Void> transferTo(File destination) {
			ReadableByteChannel input = null;
			FileChannel output = null;
			try {
				input = Channels.newChannel(getStorage().getInputStream());
				output = FileChannel.open(destination.toPath(), StandardOpenOption.WRITE);
				long size = (input instanceof FileChannel ? ((FileChannel) input).size() : Long.MAX_VALUE);
				long totalWritten = 0;
				while (totalWritten < size) {
					long written = output.transferFrom(input, totalWritten, size - totalWritten);
					if (written <= 0) {
						break;
					}
					totalWritten += written;
				}
			}
			catch (IOException ex) {
				return Mono.error(ex);
			}
			finally {
				if (input != null) {
					try {
						input.close();
					}
					catch (IOException ignored) {
					}
				}
				if (output != null) {
					try {
						output.close();
					}
					catch (IOException ignored) {
					}
				}
			}
			return Mono.empty();
		}
	}",class,
"	private static class SynchronossFormFieldPart extends AbstractSynchronossPart implements FormFieldPart {
		private final String content;
		SynchronossFormFieldPart(HttpHeaders headers, DataBufferFactory bufferFactory, String content) {
			super(headers, bufferFactory);
			this.content = content;
		}
		@Override
		public String value() {
			return this.content;
		}
		@Override
		public Flux<DataBuffer> content() {
			byte[] bytes = this.content.getBytes(getCharset());
			DataBuffer buffer = getBufferFactory().allocateBuffer(bytes.length);
			buffer.write(bytes);
			return Flux.just(buffer);
		}
		private Charset getCharset() {
			return Optional.ofNullable(MultipartUtils.getCharEncoding(headers()))
					.map(Charset::forName).orElse(StandardCharsets.UTF_8);
		}
	}",class,
"	@Override
	public List<MediaType> getReadableMediaTypes() {
		return Collections.singletonList(MediaType.MULTIPART_FORM_DATA);
	}",method,
"	@Override
	public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {
		return Part.class.equals(elementType.resolve(Object.class)) &&
				(mediaType == null || MediaType.MULTIPART_FORM_DATA.isCompatibleWith(mediaType));
	}",method,
"	@Override
	public Flux<Part> read(ResolvableType elementType, ReactiveHttpInputMessage message,
			Map<String, Object> hints) {
		return Flux.create(new SynchronossPartGenerator(message, this.bufferFactory));
	}",method,
"	@Override
	public Mono<Part> readMono(ResolvableType elementType, ReactiveHttpInputMessage message,
			Map<String, Object> hints) {
		return Mono.error(new UnsupportedOperationException(
				""This reader does not support reading a single element.""));
	}",method,
"		SynchronossPartGenerator(ReactiveHttpInputMessage inputMessage, DataBufferFactory factory) {
			this.inputMessage = inputMessage;
			this.bufferFactory = factory;
		}",method,
"		@Override
		public void accept(FluxSink<Part> emitter) {
			HttpHeaders headers = this.inputMessage.getHeaders();
			MediaType mediaType = headers.getContentType();
			Assert.state(mediaType != null, ""No content type set"");
			int length = Math.toIntExact(headers.getContentLength());
			Charset charset = Optional.ofNullable(mediaType.getCharset()).orElse(StandardCharsets.UTF_8);
			MultipartContext context = new MultipartContext(mediaType.toString(), length, charset.name());
			NioMultipartParserListener listener = new FluxSinkAdapterListener(emitter, this.bufferFactory, context);
			NioMultipartParser parser = Multipart.multipart(context).forNIO(listener);
			this.inputMessage.getBody().subscribe(buffer -> {
				byte[] resultBytes = new byte[buffer.readableByteCount()];
				buffer.read(resultBytes);
				try {
					parser.write(resultBytes);
				}
				catch (IOException ex) {
					listener.onError(""Exception thrown providing input to the parser"", ex);
				}
				finally {
					DataBufferUtils.release(buffer);
				}
			}, (ex) -> {
				try {
					listener.onError(""Request body input error"", ex);
					parser.close();
				}
				catch (IOException ex2) {
					listener.onError(""Exception thrown while closing the parser"", ex2);
				}
			}, () -> {
				try {
					parser.close();
				}
				catch (IOException ex) {
					listener.onError(""Exception thrown while closing the parser"", ex);
				}
			});
		}",method,
"				catch (IOException ex) {
					listener.onError(""Exception thrown providing input to the parser"", ex);
				}",method,
"				catch (IOException ex2) {
					listener.onError(""Exception thrown while closing the parser"", ex2);
				}",method,
"				catch (IOException ex) {
					listener.onError(""Exception thrown while closing the parser"", ex);
				}",method,
"		FluxSinkAdapterListener(FluxSink<Part> sink, DataBufferFactory bufferFactory, MultipartContext context) {
			this.sink = sink;
			this.bufferFactory = bufferFactory;
			this.context = context;
		}",method,
"		@Override
		public void onPartFinished(StreamStorage storage, Map<String, List<String>> headers) {
			HttpHeaders httpHeaders = new HttpHeaders();
			httpHeaders.putAll(headers);
			this.sink.next(createPart(storage, httpHeaders));
		}",method,
"		private Part createPart(StreamStorage storage, HttpHeaders httpHeaders) {
			String filename = MultipartUtils.getFileName(httpHeaders);
			if (filename != null) {
				return new SynchronossFilePart(httpHeaders, storage, this.bufferFactory, filename);
			}
			else if (MultipartUtils.isFormField(httpHeaders, this.context)) {
				String value = MultipartUtils.readFormParameterValue(storage, httpHeaders);
				return new SynchronossFormFieldPart(httpHeaders, this.bufferFactory, value);
			}
			else {
				return new DefaultSynchronossPart(httpHeaders, storage, this.bufferFactory);
			}
		}",method,
"			if (filename != null) {
				return new SynchronossFilePart(httpHeaders, storage, this.bufferFactory, filename);
			}",method,
"		@Override
		public void onError(String message, Throwable cause) {
			if (this.terminated.getAndIncrement() == 0) {
				this.sink.error(new RuntimeException(message, cause));
			}
		}",method,
"		@Override
		public void onAllPartsFinished() {
			if (this.terminated.getAndIncrement() == 0) {
				this.sink.complete();
			}
		}",method,
"		@Override
		public void onNestedPartStarted(Map<String, List<String>> headersFromParentPart) {
		}",method,
"		@Override
		public void onNestedPartFinished() {
		}",method,
"		AbstractSynchronossPart(HttpHeaders headers, DataBufferFactory bufferFactory) {
			Assert.notNull(headers, ""HttpHeaders is required"");
			Assert.notNull(bufferFactory, ""'bufferFactory' is required"");
			this.headers = headers;
			this.bufferFactory = bufferFactory;
		}",method,
"		@Override
		public String name() {
			return MultipartUtils.getFieldName(this.headers);
		}",method,
"		@Override
		public HttpHeaders headers() {
			return this.headers;
		}",method,
"		protected DataBufferFactory getBufferFactory() {
			return this.bufferFactory;
		}",method,
"		DefaultSynchronossPart(HttpHeaders headers, StreamStorage storage, DataBufferFactory factory) {
			super(headers, factory);
			Assert.notNull(storage, ""'storage' is required"");
			this.storage = storage;
		}",method,
"		@Override
		public Flux<DataBuffer> content() {
			InputStream inputStream = this.storage.getInputStream();
			return DataBufferUtils.read(inputStream, getBufferFactory(), 4096);
		}",method,
"		protected StreamStorage getStorage() {
			return this.storage;
		}",method,
"		public SynchronossFilePart(
				HttpHeaders headers, StreamStorage storage, DataBufferFactory factory, String filename) {
			super(headers, storage, factory);
			this.filename = filename;
		}",method,
"		@Override
		public String filename() {
			return this.filename;
		}",method,
"		@Override
		public Mono<Void> transferTo(File destination) {
			ReadableByteChannel input = null;
			FileChannel output = null;
			try {
				input = Channels.newChannel(getStorage().getInputStream());
				output = FileChannel.open(destination.toPath(), StandardOpenOption.WRITE);
				long size = (input instanceof FileChannel ? ((FileChannel) input).size() : Long.MAX_VALUE);
				long totalWritten = 0;
				while (totalWritten < size) {
					long written = output.transferFrom(input, totalWritten, size - totalWritten);
					if (written <= 0) {
						break;
					}
					totalWritten += written;
				}
			}
			catch (IOException ex) {
				return Mono.error(ex);
			}
			finally {
				if (input != null) {
					try {
						input.close();
					}
					catch (IOException ignored) {
					}
				}
				if (output != null) {
					try {
						output.close();
					}
					catch (IOException ignored) {
					}
				}
			}
			return Mono.empty();
		}",method,
"				while (totalWritten < size) {
					long written = output.transferFrom(input, totalWritten, size - totalWritten);
					if (written <= 0) {
						break;
					}
					totalWritten += written;
				}",method,
"					if (written <= 0) {
						break;
					}",method,
"			catch (IOException ex) {
				return Mono.error(ex);
			}",method,
"				if (input != null) {
					try {
						input.close();
					}
					catch (IOException ignored) {
					}
				}",method,
"					catch (IOException ignored) {
					}",method,
"				if (output != null) {
					try {
						output.close();
					}
					catch (IOException ignored) {
					}
				}",method,
"					catch (IOException ignored) {
					}",method,
"		SynchronossFormFieldPart(HttpHeaders headers, DataBufferFactory bufferFactory, String content) {
			super(headers, bufferFactory);
			this.content = content;
		}",method,
"		@Override
		public String value() {
			return this.content;
		}",method,
"		@Override
		public Flux<DataBuffer> content() {
			byte[] bytes = this.content.getBytes(getCharset());
			DataBuffer buffer = getBufferFactory().allocateBuffer(bytes.length);
			buffer.write(bytes);
			return Flux.just(buffer);
		}",method,
"		private Charset getCharset() {
			return Optional.ofNullable(MultipartUtils.getCharEncoding(headers()))
					.map(Charset::forName).orElse(StandardCharsets.UTF_8);
		}",method,
"public class TestScalarisStorage {
    @After
    public void after() {
        deleteAllInstances(Author.class, Product.class, Book.class,
                Inventory.class);
    }
    @Test
    public void test01Store() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        storeObject(product);
    }
    @Test
    public void test02Store() {
        Author author = new Author(""Jrr"");
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        storeObject(book);
    }
    @Test
    public void test03Store() {
        Author author = new Author(""Tolkien"");
        Inventory inv = new Inventory(""My Inventory"");
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 200.00);
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        inv.add(product);
        inv.add(book);
        storeObject(inv);
    }
    @Test
    public void test01RetrieveById() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        Object productId = storeObject(product);
        Product retrieved = (Product) retrieveObjectById(productId);
        assertEquals(product, retrieved);
    }
    @Test
    public void test02RetrieveById() {
        Author author = new Author(""JRRR Tolkien"");
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        Object bookId = storeObject(book);
        Book retrieved = (Book) retrieveObjectById(bookId);
        assertEquals(book, retrieved);
    }
    @Test
    public void test03RetrieveById() {
        Inventory inv = new Inventory(""Retrieval_Inventory"");
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 200.00);
        Author author = new Author(""JRR Tolkien"");
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        inv.add(product);
        inv.add(book);
        Object inventoryId = storeObject(inv);
        // check child objects
        Product retrievedProduct = (Product) retrieveObjectBySingleKey(
                Product.class, product.getId());
        assertEquals(product, retrievedProduct);
        Book retrievedBook = (Book) retrieveObjectBySingleKey(Book.class,
                book.getId());
        assertEquals(book, retrievedBook);
        // check parent
        Inventory retrieved = (Inventory) retrieveObjectById(inventoryId);
        assertEquals(inv, retrieved);
    }
    @Test
    public void test01RetrieveBySingleKey() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        storeObject(product);
        Product retrieved = (Product) retrieveObjectBySingleKey(
                product.getClass(), product.getId());
        assertEquals(product, retrieved);
    }
    @Test
    public void test02RetrieveBySingleKey() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        try {
            retrieveObjectBySingleKey(product.getClass(), product.getId());
            fail(""Expected an expcetion to be thrown because the stored object does not exist"");
        } catch (JDOObjectNotFoundException e) {
            // good
        }
    }
    @Test
    public void test01DeleteById() {
        Author author = new Author(""JRR"");
        Book book = new Book(""Lord"", ""The "", 49.99, author, ""1234"", ""MyBooks"");
        Object bookId = storeObject(book);
        deleteObjectById(bookId);
        try {
            retrieveObjectById(bookId);
            fail(""Excepted JDOObjectNotFoundException"");
        } catch (JDOObjectNotFoundException e) {
            // if we are here everything worked fine
        }
    }
    @Test
    public void test01SingleFieldUpdate() {
        Author author = new Author(""JRR2"");
        Book book = new Book(""Lord"", ""The "", 49.99, author, ""1234"", ""MyBooks"");
        Object bookId = storeObject(book);
        Book retrieved = (Book) retrieveObjectById(bookId);
        assertEquals(book, retrieved);
        retrieved.setPrice(100.99);
        Object updatedId = storeObject(retrieved);
        Book updated = (Book) retrieveObjectById(updatedId);
        assertEquals(retrieved, updated);
    }
}",class,
"    @After
    public void after() {
        deleteAllInstances(Author.class, Product.class, Book.class,
                Inventory.class);
    }",method,
"    @Test
    public void test01Store() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        storeObject(product);
    }",method,
"    @Test
    public void test02Store() {
        Author author = new Author(""Jrr"");
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        storeObject(book);
    }",method,
"    @Test
    public void test03Store() {
        Author author = new Author(""Tolkien"");
        Inventory inv = new Inventory(""My Inventory"");
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 200.00);
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        inv.add(product);
        inv.add(book);
        storeObject(inv);
    }",method,
"    @Test
    public void test01RetrieveById() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        Object productId = storeObject(product);
        Product retrieved = (Product) retrieveObjectById(productId);
        assertEquals(product, retrieved);
    }",method,
"    @Test
    public void test02RetrieveById() {
        Author author = new Author(""JRRR Tolkien"");
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        Object bookId = storeObject(book);
        Book retrieved = (Book) retrieveObjectById(bookId);
        assertEquals(book, retrieved);
    }",method,
"    @Test
    public void test03RetrieveById() {
        Inventory inv = new Inventory(""Retrieval_Inventory"");
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 200.00);
        Author author = new Author(""JRR Tolkien"");
        Book book = new Book(""Lord of the Rings by Tolkien"",
                ""The classic story"", 49.99, author, ""12345678"",
                ""MyBooks Factory"");
        inv.add(product);
        inv.add(book);
        Object inventoryId = storeObject(inv);
        // check child objects
        Product retrievedProduct = (Product) retrieveObjectBySingleKey(
                Product.class, product.getId());
        assertEquals(product, retrievedProduct);
        Book retrievedBook = (Book) retrieveObjectBySingleKey(Book.class,
                book.getId());
        assertEquals(book, retrievedBook);
        // check parent
        Inventory retrieved = (Inventory) retrieveObjectById(inventoryId);
        assertEquals(inv, retrieved);
    }",method,
"    @Test
    public void test01RetrieveBySingleKey() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        storeObject(product);
        Product retrieved = (Product) retrieveObjectBySingleKey(
                product.getClass(), product.getId());
        assertEquals(product, retrieved);
    }",method,
"    @Test
    public void test02RetrieveBySingleKey() {
        Product product = new Product(""Sony Discman"",
                ""A standard discman from Sony"", 1.99);
        try {
            retrieveObjectBySingleKey(product.getClass(), product.getId());
            fail(""Expected an expcetion to be thrown because the stored object does not exist"");
        } catch (JDOObjectNotFoundException e) {
            // good
        }
    }",method,
"    @Test
    public void test01DeleteById() {
        Author author = new Author(""JRR"");
        Book book = new Book(""Lord"", ""The "", 49.99, author, ""1234"", ""MyBooks"");
        Object bookId = storeObject(book);
        deleteObjectById(bookId);
        try {
            retrieveObjectById(bookId);
            fail(""Excepted JDOObjectNotFoundException"");
        } catch (JDOObjectNotFoundException e) {
            // if we are here everything worked fine
        }
    }",method,
"    @Test
    public void test01SingleFieldUpdate() {
        Author author = new Author(""JRR2"");
        Book book = new Book(""Lord"", ""The "", 49.99, author, ""1234"", ""MyBooks"");
        Object bookId = storeObject(book);
        Book retrieved = (Book) retrieveObjectById(bookId);
        assertEquals(book, retrieved);
        retrieved.setPrice(100.99);
        Object updatedId = storeObject(retrieved);
        Book updated = (Book) retrieveObjectById(updatedId);
        assertEquals(retrieved, updated);
    }",method,
"public class VideoPlayer implements ExoPlayer.EventListener, SimpleExoPlayer.VideoListener {
    public interface RendererBuilder {
        void buildRenderers(VideoPlayer player);
        void cancel();
    }
    public interface VideoPlayerDelegate {
        void onStateChanged(boolean playWhenReady, int playbackState);
        void onError(Exception e);
        void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio);
        void onRenderedFirstFrame();
        void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture);
        boolean onSurfaceDestroyed(SurfaceTexture surfaceTexture);
    }
    private SimpleExoPlayer player;
    private MappingTrackSelector trackSelector;
    private Handler mainHandler;
    private DataSource.Factory mediaDataSourceFactory;
    private TextureView textureView;
    private boolean autoplay;
    private VideoPlayerDelegate delegate;
    private int lastReportedPlaybackState;
    private boolean lastReportedPlayWhenReady;
    private static final int RENDERER_BUILDING_STATE_IDLE = 1;
    private static final int RENDERER_BUILDING_STATE_BUILDING = 2;
    private static final int RENDERER_BUILDING_STATE_BUILT = 3;
    private static final DefaultBandwidthMeter BANDWIDTH_METER = new DefaultBandwidthMeter();
    public VideoPlayer() {
        mediaDataSourceFactory = new ExtendedDefaultDataSourceFactory(ApplicationLoader.applicationContext, BANDWIDTH_METER, new DefaultHttpDataSourceFactory(""Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20150101 Firefox/47.0 (Chrome)"", BANDWIDTH_METER));
        mainHandler = new Handler();
        TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory(BANDWIDTH_METER);
        trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
        lastReportedPlaybackState = ExoPlayer.STATE_IDLE;
    }
    private void ensurePleyaerCreated() {
        if (player == null) {
            player = ExoPlayerFactory.newSimpleInstance(ApplicationLoader.applicationContext, trackSelector, new DefaultLoadControl(), null, DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF);
            player.addListener(this);
            player.setVideoListener(this);
            player.setVideoTextureView(textureView);
            player.setPlayWhenReady(autoplay);
        }
    }
    public void preparePlayerLoop(Uri videoUri, String videoType, Uri audioUri, String audioType) {
        ensurePleyaerCreated();
        MediaSource mediaSource1 = null, mediaSource2 = null;
        for (int a = 0; a < 2; a++) {
            MediaSource mediaSource;
            String type;
            Uri uri;
            if (a == 0) {
                type = videoType;
                uri = videoUri;
            } else {
                type = audioType;
                uri = audioUri;
            }
            switch (type) {
                case ""dash"":
                    mediaSource = new DashMediaSource(uri, mediaDataSourceFactory, new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                case ""hls"":
                    mediaSource = new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);
                    break;
                case ""ss"":
                    mediaSource = new SsMediaSource(uri, mediaDataSourceFactory, new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                default:
                    mediaSource = new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(), mainHandler, null);
                    break;
            }
            mediaSource = new LoopingMediaSource(mediaSource);
            if (a == 0) {
                mediaSource1 = mediaSource;
            } else {
                mediaSource2 = mediaSource;
            }
        }
        MediaSource mediaSource = new MergingMediaSource(mediaSource1, mediaSource2);
        player.prepare(mediaSource1, true, true);
    }
    public void preparePlayer(Uri uri, String type) {
        ensurePleyaerCreated();
        MediaSource mediaSource;
        switch (type) {
            case ""dash"":
                mediaSource = new DashMediaSource(uri, mediaDataSourceFactory, new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                break;
            case ""hls"":
                mediaSource = new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);
                break;
            case ""ss"":
                mediaSource = new SsMediaSource(uri, mediaDataSourceFactory, new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                break;
            default:
                mediaSource = new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(), mainHandler, null);
                break;
        }
        player.prepare(mediaSource, true, true);
    }
    public boolean isPlayerPrepared() {
        return player != null;
    }
    public void releasePlayer() {
        if (player != null) {
            player.release();
            player = null;
        }
    }
    public void setTextureView(TextureView texture) {
        if (textureView == texture) {
            return;
        }
        textureView = texture;
        if (player == null) {
            return;
        }
        player.setVideoTextureView(textureView);
    }
    public void play() {
        if (player == null) {
            return;
        }
        player.setPlayWhenReady(true);
    }
    public void pause() {
        if (player == null) {
            return;
        }
        player.setPlayWhenReady(false);
    }
    public void setPlayWhenReady(boolean playWhenReady) {
        autoplay = playWhenReady;
        if (player == null) {
            return;
        }
        player.setPlayWhenReady(playWhenReady);
    }
    public long getDuration() {
        return player != null ? player.getDuration() : 0;
    }
    public long getCurrentPosition() {
        return player != null ? player.getCurrentPosition() : 0;
    }
    public boolean isMuted() {
        return player.getVolume() == 0.0f;
    }
    public void setMute(boolean value) {
        if (player == null) {
            return;
        }
        if (value) {
            player.setVolume(0.0f);
        } else {
            player.setVolume(1.0f);
        }
    }
    public void setVolume(float volume) {
        if (player == null) {
            return;
        }
        player.setVolume(volume);
    }
    public void seekTo(long positionMs) {
        if (player == null) {
            return;
        }
        player.seekTo(positionMs);
    }
    public void setDelegate(VideoPlayerDelegate videoPlayerDelegate) {
        delegate = videoPlayerDelegate;
    }
    public int getBufferedPercentage() {
        return player != null ? player.getBufferedPercentage() : 0;
    }
    public long getBufferedPosition() {
        return player != null ? player.getBufferedPosition() : 0;
    }
    public boolean isPlaying() {
        return player != null && player.getPlayWhenReady();
    }
    public boolean isBuffering() {
        return player != null && lastReportedPlaybackState == ExoPlayer.STATE_BUFFERING;
    }
    public void setStreamType(int type) {
        if (player != null) {
            player.setAudioStreamType(type);
        }
    }
    @Override
    public void onLoadingChanged(boolean isLoading) {
    }
    @Override
    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
        maybeReportPlayerState();
    }
    @Override
    public void onTimelineChanged(Timeline timeline, Object manifest) {
    }
    @Override
    public void onPlayerError(ExoPlaybackException error) {
        delegate.onError(error);
    }
    @Override
    public void onPositionDiscontinuity() {
    }
    @Override
    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
    }
    @Override
    public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
        delegate.onVideoSizeChanged(width, height, unappliedRotationDegrees, pixelWidthHeightRatio);
    }
    @Override
    public void onRenderedFirstFrame() {
        delegate.onRenderedFirstFrame();
    }
    @Override
    public boolean onSurfaceDestroyed(SurfaceTexture surfaceTexture) {
        return delegate.onSurfaceDestroyed(surfaceTexture);
    }
    @Override
    public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {
        delegate.onSurfaceTextureUpdated(surfaceTexture);
    }
    @Override
    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
    }
    private void maybeReportPlayerState() {
        boolean playWhenReady = player.getPlayWhenReady();
        int playbackState = player.getPlaybackState();
        if (lastReportedPlayWhenReady != playWhenReady || lastReportedPlaybackState != playbackState) {
            delegate.onStateChanged(playWhenReady, playbackState);
            lastReportedPlayWhenReady = playWhenReady;
            lastReportedPlaybackState = playbackState;
        }
    }
}",class,
"    public VideoPlayer() {
        mediaDataSourceFactory = new ExtendedDefaultDataSourceFactory(ApplicationLoader.applicationContext, BANDWIDTH_METER, new DefaultHttpDataSourceFactory(""Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20150101 Firefox/47.0 (Chrome)"", BANDWIDTH_METER));
        mainHandler = new Handler();
        TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory(BANDWIDTH_METER);
        trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
        lastReportedPlaybackState = ExoPlayer.STATE_IDLE;
    }",method,
"    private void ensurePleyaerCreated() {
        if (player == null) {
            player = ExoPlayerFactory.newSimpleInstance(ApplicationLoader.applicationContext, trackSelector, new DefaultLoadControl(), null, DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF);
            player.addListener(this);
            player.setVideoListener(this);
            player.setVideoTextureView(textureView);
            player.setPlayWhenReady(autoplay);
        }
    }",method,
"        if (player == null) {
            player = ExoPlayerFactory.newSimpleInstance(ApplicationLoader.applicationContext, trackSelector, new DefaultLoadControl(), null, DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF);
            player.addListener(this);
            player.setVideoListener(this);
            player.setVideoTextureView(textureView);
            player.setPlayWhenReady(autoplay);
        }",method,
"    public void preparePlayerLoop(Uri videoUri, String videoType, Uri audioUri, String audioType) {
        ensurePleyaerCreated();
        MediaSource mediaSource1 = null, mediaSource2 = null;
        for (int a = 0; a < 2; a++) {
            MediaSource mediaSource;
            String type;
            Uri uri;
            if (a == 0) {
                type = videoType;
                uri = videoUri;
            } else {
                type = audioType;
                uri = audioUri;
            }
            switch (type) {
                case ""dash"":
                    mediaSource = new DashMediaSource(uri, mediaDataSourceFactory, new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                case ""hls"":
                    mediaSource = new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);
                    break;
                case ""ss"":
                    mediaSource = new SsMediaSource(uri, mediaDataSourceFactory, new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                default:
                    mediaSource = new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(), mainHandler, null);
                    break;
            }
            mediaSource = new LoopingMediaSource(mediaSource);
            if (a == 0) {
                mediaSource1 = mediaSource;
            } else {
                mediaSource2 = mediaSource;
            }
        }
        MediaSource mediaSource = new MergingMediaSource(mediaSource1, mediaSource2);
        player.prepare(mediaSource1, true, true);
    }",method,
"        for (int a = 0; a < 2; a++) {
            MediaSource mediaSource;
            String type;
            Uri uri;
            if (a == 0) {
                type = videoType;
                uri = videoUri;
            } else {
                type = audioType;
                uri = audioUri;
            }
            switch (type) {
                case ""dash"":
                    mediaSource = new DashMediaSource(uri, mediaDataSourceFactory, new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                case ""hls"":
                    mediaSource = new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);
                    break;
                case ""ss"":
                    mediaSource = new SsMediaSource(uri, mediaDataSourceFactory, new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                default:
                    mediaSource = new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(), mainHandler, null);
                    break;
            }
            mediaSource = new LoopingMediaSource(mediaSource);
            if (a == 0) {
                mediaSource1 = mediaSource;
            } else {
                mediaSource2 = mediaSource;
            }
        }",method,
"            if (a == 0) {
                type = videoType;
                uri = videoUri;
            }",method,
"            switch (type) {
                case ""dash"":
                    mediaSource = new DashMediaSource(uri, mediaDataSourceFactory, new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                case ""hls"":
                    mediaSource = new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);
                    break;
                case ""ss"":
                    mediaSource = new SsMediaSource(uri, mediaDataSourceFactory, new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                    break;
                default:
                    mediaSource = new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(), mainHandler, null);
                    break;
            }",method,
"            if (a == 0) {
                mediaSource1 = mediaSource;
            }",method,
"    public void preparePlayer(Uri uri, String type) {
        ensurePleyaerCreated();
        MediaSource mediaSource;
        switch (type) {
            case ""dash"":
                mediaSource = new DashMediaSource(uri, mediaDataSourceFactory, new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                break;
            case ""hls"":
                mediaSource = new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);
                break;
            case ""ss"":
                mediaSource = new SsMediaSource(uri, mediaDataSourceFactory, new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                break;
            default:
                mediaSource = new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(), mainHandler, null);
                break;
        }
        player.prepare(mediaSource, true, true);
    }",method,
"        switch (type) {
            case ""dash"":
                mediaSource = new DashMediaSource(uri, mediaDataSourceFactory, new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                break;
            case ""hls"":
                mediaSource = new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);
                break;
            case ""ss"":
                mediaSource = new SsMediaSource(uri, mediaDataSourceFactory, new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);
                break;
            default:
                mediaSource = new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(), mainHandler, null);
                break;
        }",method,
"    public boolean isPlayerPrepared() {
        return player != null;
    }",method,
"    public void releasePlayer() {
        if (player != null) {
            player.release();
            player = null;
        }
    }",method,
"        if (player != null) {
            player.release();
            player = null;
        }",method,
"    public void setTextureView(TextureView texture) {
        if (textureView == texture) {
            return;
        }
        textureView = texture;
        if (player == null) {
            return;
        }
        player.setVideoTextureView(textureView);
    }",method,
"        if (textureView == texture) {
            return;
        }",method,

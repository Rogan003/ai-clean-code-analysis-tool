code_snippet,type,score
"    protected void destroyFragments() {
        mFragments.dispatchDestroy();
        processAllMessages();
        mFragments = null;
    }",method,
"    protected void processAllMessages() {
        TestableLooper.get(this).processAllMessages();
    }",method,
"    private View findViewById(int id) {
        return mView.findViewById(id);
    }",method,
"        public HostCallbacks() {
            super(mContext, BaseFragmentTest.this.mHandler, 0);
        }",method,
"        @Override
        public BaseFragmentTest onGetHost() {
            return BaseFragmentTest.this;
        }",method,
"        @Override
        public void onDump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
        }",method,
"        @Override
        public boolean onShouldSaveFragmentState(Fragment fragment) {
            return true; // True for now.
        }",method,
"        @Override
        public LayoutInflater onGetLayoutInflater() {
            return LayoutInflater.from(mContext);
        }",method,
"        @Override
        public boolean onUseFragmentManagerInflaterFactory() {
            return true;
        }",method,
"        @Override
        public boolean onHasWindowAnimations() {
            return false;
        }",method,
"        @Override
        public int onGetWindowAnimations() {
            return 0;
        }",method,
"        @Override
        public void onAttachFragment(Fragment fragment) {
        }",method,
"        @Nullable
        @Override
        public View onFindViewById(int id) {
            return BaseFragmentTest.this.findViewById(id);
        }",method,
"        @Override
        public boolean onHasView() {
            return true;
        }",method,
"public class ProxyConfiguration {
    @NotEmpty
    private String host;
    @PortRange(min = -1)
    private Integer port = -1;
    @OneOf(value = {""http"", ""https""}, ignoreCase = true)
    private String scheme = ""http"";
    @Valid
    @Nullable
    private AuthConfiguration auth;
    @Nullable
    private List<String> nonProxyHosts;
    public ProxyConfiguration() {
    }
    public ProxyConfiguration(@NotNull String host) {
        this.host = host;
    }
    public ProxyConfiguration(@NotNull String host, int port) {
        this(host);
        this.port = port;
    }
    public ProxyConfiguration(@NotNull String host, int port, String scheme, AuthConfiguration auth) {
        this(host, port);
        this.scheme = scheme;
        this.auth = auth;
    }
    @JsonProperty
    public String getHost() {
        return host;
    }
    @JsonProperty
    public void setHost(String host) {
        this.host = host;
    }
    @JsonProperty
    public Integer getPort() {
        return port;
    }
    @JsonProperty
    public void setPort(Integer port) {
        this.port = port;
    }
    @JsonProperty
    public String getScheme() {
        return scheme;
    }
    @JsonProperty
    public void setScheme(String scheme) {
        this.scheme = scheme;
    }
    @JsonProperty
    public List<String> getNonProxyHosts() {
        return nonProxyHosts;
    }
    @JsonProperty
    public void setNonProxyHosts(List<String> nonProxyHosts) {
        this.nonProxyHosts = nonProxyHosts;
    }
    public AuthConfiguration getAuth() {
        return auth;
    }
    public void setAuth(AuthConfiguration auth) {
        this.auth = auth;
    }
}",class,
"    public ProxyConfiguration() {
    }",method,
"    public ProxyConfiguration(@NotNull String host) {
        this.host = host;
    }",method,
"    public ProxyConfiguration(@NotNull String host, int port) {
        this(host);
        this.port = port;
    }",method,
"    public ProxyConfiguration(@NotNull String host, int port, String scheme, AuthConfiguration auth) {
        this(host, port);
        this.scheme = scheme;
        this.auth = auth;
    }",method,
"    @JsonProperty
    public String getHost() {
        return host;
    }",method,
"    @JsonProperty
    public void setHost(String host) {
        this.host = host;
    }",method,
"    @JsonProperty
    public Integer getPort() {
        return port;
    }",method,
"    @JsonProperty
    public void setPort(Integer port) {
        this.port = port;
    }",method,
"    @JsonProperty
    public String getScheme() {
        return scheme;
    }",method,
"    @JsonProperty
    public void setScheme(String scheme) {
        this.scheme = scheme;
    }",method,
"    @JsonProperty
    public List<String> getNonProxyHosts() {
        return nonProxyHosts;
    }",method,
"    @JsonProperty
    public void setNonProxyHosts(List<String> nonProxyHosts) {
        this.nonProxyHosts = nonProxyHosts;
    }",method,
"    public AuthConfiguration getAuth() {
        return auth;
    }",method,
"    public void setAuth(AuthConfiguration auth) {
        this.auth = auth;
    }",method,
"public class JsonWriterTest {
  private final StringWriter mStringWriter;
  private final JsonWriter mWriter;
  public JsonWriterTest() {
    mStringWriter = new StringWriter();
    mWriter = new JsonWriter(mStringWriter);
  }
  @Test
  public void emptyObject() throws IOException {
    mWriter.beginObject();
    mWriter.endObject();
    verify(""{}"");
  }
  @Test
  public void emptyNestedObject() throws IOException {
    mWriter.beginObject();
    mWriter.beginObject();
    mWriter.endObject();
    mWriter.endObject();
    verify(""{{}}"");
  }
  @Test
  public void emptyArray() throws IOException {
    mWriter.beginArray();
    mWriter.endArray();
    verify(""[]"");
  }
  @Test
  public void emptyNestedArray() throws IOException {
    mWriter.beginArray();
    mWriter.beginArray();
    mWriter.endArray();
    mWriter.endArray();
    verify(""[[]]"");
  }
  @Test
  public void smallObject() throws IOException {
    mWriter.beginObject();
    mWriter.name(""hello"").value(true);
    mWriter.name(""hello_again"").value(""hi!"");
    mWriter.endObject();
    verify(""{\""hello\"":true,\""hello_again\"":\""hi!\""}"");
  }
  @Test
  public void smallArray() throws IOException {
    mWriter.beginArray();
    mWriter.value(true);
    mWriter.value(1);
    mWriter.value(1.0);
    mWriter.value(""hi!"");
    mWriter.endArray();
    verify(""[true,1,1.0,\""hi!\""]"");
  }
  @Test
  public void string() throws IOException {
    mWriter.beginObject();
    mWriter.name(""string"").value(""hello!"");
    mWriter.endObject();
    verify(""{\""string\"":\""hello!\""}"");
  }
  @Test
  public void complexString() throws IOException {
    mWriter.beginObject();
    mWriter.name(""string"").value(""\t\uD83D\uDCA9"");
    mWriter.endObject();
    verify(""{\""string\"":\""\\t\uD83D\uDCA9\""}"");
  }
  private void verify(String expected) throws IOException {
    mWriter.close();
    assertThat(mStringWriter.getBuffer().toString()).isEqualTo(expected);
  }
}",class,
"  public JsonWriterTest() {
    mStringWriter = new StringWriter();
    mWriter = new JsonWriter(mStringWriter);
  }",method,
"  @Test
  public void emptyObject() throws IOException {
    mWriter.beginObject();
    mWriter.endObject();
    verify(""{}"");
  }",method,
"  @Test
  public void emptyNestedObject() throws IOException {
    mWriter.beginObject();
    mWriter.beginObject();
    mWriter.endObject();
    mWriter.endObject();
    verify(""{{}}"");
  }",method,
"  @Test
  public void emptyArray() throws IOException {
    mWriter.beginArray();
    mWriter.endArray();
    verify(""[]"");
  }",method,
"  @Test
  public void emptyNestedArray() throws IOException {
    mWriter.beginArray();
    mWriter.beginArray();
    mWriter.endArray();
    mWriter.endArray();
    verify(""[[]]"");
  }",method,
"  @Test
  public void smallObject() throws IOException {
    mWriter.beginObject();
    mWriter.name(""hello"").value(true);
    mWriter.name(""hello_again"").value(""hi!"");
    mWriter.endObject();
    verify(""{\""hello\"":true,\""hello_again\"":\""hi!\""}"");
  }",method,
"  @Test
  public void smallArray() throws IOException {
    mWriter.beginArray();
    mWriter.value(true);
    mWriter.value(1);
    mWriter.value(1.0);
    mWriter.value(""hi!"");
    mWriter.endArray();
    verify(""[true,1,1.0,\""hi!\""]"");
  }",method,
"  @Test
  public void string() throws IOException {
    mWriter.beginObject();
    mWriter.name(""string"").value(""hello!"");
    mWriter.endObject();
    verify(""{\""string\"":\""hello!\""}"");
  }",method,
"  @Test
  public void complexString() throws IOException {
    mWriter.beginObject();
    mWriter.name(""string"").value(""\t\uD83D\uDCA9"");
    mWriter.endObject();
    verify(""{\""string\"":\""\\t\uD83D\uDCA9\""}"");
  }",method,
"  private void verify(String expected) throws IOException {
    mWriter.close();
    assertThat(mStringWriter.getBuffer().toString()).isEqualTo(expected);
  }",method,
"public final class EpollChannelOption<T> extends UnixChannelOption<T> {
    public static final ChannelOption<Boolean> TCP_CORK = valueOf(EpollChannelOption.class, ""TCP_CORK"");
    public static final ChannelOption<Long> TCP_NOTSENT_LOWAT = valueOf(EpollChannelOption.class, ""TCP_NOTSENT_LOWAT"");
    public static final ChannelOption<Integer> TCP_KEEPIDLE = valueOf(EpollChannelOption.class, ""TCP_KEEPIDLE"");
    public static final ChannelOption<Integer> TCP_KEEPINTVL = valueOf(EpollChannelOption.class, ""TCP_KEEPINTVL"");
    public static final ChannelOption<Integer> TCP_KEEPCNT = valueOf(EpollChannelOption.class, ""TCP_KEEPCNT"");
    public static final ChannelOption<Integer> TCP_USER_TIMEOUT =
            valueOf(EpollChannelOption.class, ""TCP_USER_TIMEOUT"");
    public static final ChannelOption<Boolean> IP_FREEBIND = valueOf(""IP_FREEBIND"");
    public static final ChannelOption<Boolean> IP_TRANSPARENT = valueOf(""IP_TRANSPARENT"");
    public static final ChannelOption<Integer> TCP_FASTOPEN = valueOf(EpollChannelOption.class, ""TCP_FASTOPEN"");
    public static final ChannelOption<Integer> TCP_DEFER_ACCEPT =
            ChannelOption.valueOf(EpollChannelOption.class, ""TCP_DEFER_ACCEPT"");
    public static final ChannelOption<Boolean> TCP_QUICKACK = valueOf(EpollChannelOption.class, ""TCP_QUICKACK"");
    public static final ChannelOption<EpollMode> EPOLL_MODE =
            ChannelOption.valueOf(EpollChannelOption.class, ""EPOLL_MODE"");
    public static final ChannelOption<Map<InetAddress, byte[]>> TCP_MD5SIG = valueOf(""TCP_MD5SIG"");
    @SuppressWarnings({ ""unused"", ""deprecation"" })
    private EpollChannelOption() {
    }
}",class,
"    @SuppressWarnings({ ""unused"", ""deprecation"" })
    private EpollChannelOption() {
    }",method,
"public class AfterTestEvent extends AbstractTestEvent {
  public AfterTestEvent(GradleTestsExecutionConsole executionConsole) {
    super(executionConsole);
  }
  @Override
  public void process(@NotNull final TestEventXmlView eventXml) throws TestEventXmlView.XmlParserException {
    final String testId = eventXml.getTestId();
    final String startTime = eventXml.getEventTestResultStartTime();
    final String endTime = eventXml.getEventTestResultEndTime();
    final String exceptionMsg = decode(eventXml.getEventTestResultErrorMsg());
    final String stackTrace = decode(eventXml.getEventTestResultStackTrace());
    final SMTestProxy testProxy = findTestProxy(testId);
    if (testProxy == null) return;
    try {
      testProxy.setDuration(Long.valueOf(endTime) - Long.valueOf(startTime));
    }
    catch (NumberFormatException ignored) {
    }
    final CompositeRunnable runInEdt = new CompositeRunnable();
    final TestEventResult result = TestEventResult.fromValue(eventXml.getTestEventResultType());
    switch (result) {
      case SUCCESS:
        runInEdt.add(testProxy::setFinished);
        break;
      case FAILURE:
        final String failureType = eventXml.getEventTestResultFailureType();
        if (""comparison"".equals(failureType)) {
          String actualText = decode(eventXml.getEventTestResultActual());
          String expectedText = decode(eventXml.getEventTestResultExpected());
          final Condition<String> emptyString = StringUtil::isEmpty;
          String filePath = ObjectUtils.nullizeByCondition(decode(eventXml.getEventTestResultFilePath()), emptyString);
          String actualFilePath = ObjectUtils.nullizeByCondition(
            decode(eventXml.getEventTestResultActualFilePath()), emptyString);
          testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, actualText, expectedText, filePath, actualFilePath);
        }
        else {
          Couple<String> comparisonPair =
            parseComparisonMessage(exceptionMsg, ""\nExpected: is \""(.*)\""\n\\s*got: \""(.*)\""\n"");
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: is \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: (.*)\n\\s*got: (.*)"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\\s*expected same:<(.*)> was not:<(.*)>"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, "".*\\s*expected:<(.*)> but was:<(.*)>"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }
          final Couple<String> finalComparisonPair = comparisonPair;
          runInEdt.add(() -> {
            if (finalComparisonPair != null) {
              testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, finalComparisonPair.second, finalComparisonPair.first);
            }
            else {
              testProxy.setTestFailed(exceptionMsg, stackTrace, ""error"".equals(failureType));
            }
          });
        }
        runInEdt.add(() -> getResultsViewer().onTestFailed(testProxy));
        break;
      case SKIPPED:
        runInEdt.add(() -> {
          testProxy.setTestIgnored(null, null);
          getResultsViewer().onTestIgnored(testProxy);
        });
        break;
      case UNKNOWN_RESULT:
        break;
    }
    runInEdt.add(() -> getResultsViewer().onTestFinished(testProxy));
    addToInvokeLater(runInEdt);
  }
  private static Couple<String> parseComparisonMessage(String message, final String regex) {
    final Matcher matcher = Pattern.compile(regex, Pattern.DOTALL | Pattern.CASE_INSENSITIVE).matcher(message);
    if (matcher.matches()) {
      return Couple.of(matcher.group(1).replaceAll(""\\\\n"", ""\n""), matcher.group(2).replaceAll(""\\\\n"", ""\n""));
    }
    return null;
  }
}",class,
"  public AfterTestEvent(GradleTestsExecutionConsole executionConsole) {
    super(executionConsole);
  }",method,
"  @Override
  public void process(@NotNull final TestEventXmlView eventXml) throws TestEventXmlView.XmlParserException {
    final String testId = eventXml.getTestId();
    final String startTime = eventXml.getEventTestResultStartTime();
    final String endTime = eventXml.getEventTestResultEndTime();
    final String exceptionMsg = decode(eventXml.getEventTestResultErrorMsg());
    final String stackTrace = decode(eventXml.getEventTestResultStackTrace());
    final SMTestProxy testProxy = findTestProxy(testId);
    if (testProxy == null) return;
    try {
      testProxy.setDuration(Long.valueOf(endTime) - Long.valueOf(startTime));
    }
    catch (NumberFormatException ignored) {
    }
    final CompositeRunnable runInEdt = new CompositeRunnable();
    final TestEventResult result = TestEventResult.fromValue(eventXml.getTestEventResultType());
    switch (result) {
      case SUCCESS:
        runInEdt.add(testProxy::setFinished);
        break;
      case FAILURE:
        final String failureType = eventXml.getEventTestResultFailureType();
        if (""comparison"".equals(failureType)) {
          String actualText = decode(eventXml.getEventTestResultActual());
          String expectedText = decode(eventXml.getEventTestResultExpected());
          final Condition<String> emptyString = StringUtil::isEmpty;
          String filePath = ObjectUtils.nullizeByCondition(decode(eventXml.getEventTestResultFilePath()), emptyString);
          String actualFilePath = ObjectUtils.nullizeByCondition(
            decode(eventXml.getEventTestResultActualFilePath()), emptyString);
          testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, actualText, expectedText, filePath, actualFilePath);
        }
        else {
          Couple<String> comparisonPair =
            parseComparisonMessage(exceptionMsg, ""\nExpected: is \""(.*)\""\n\\s*got: \""(.*)\""\n"");
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: is \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: (.*)\n\\s*got: (.*)"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\\s*expected same:<(.*)> was not:<(.*)>"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, "".*\\s*expected:<(.*)> but was:<(.*)>"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }
          final Couple<String> finalComparisonPair = comparisonPair;
          runInEdt.add(() -> {
            if (finalComparisonPair != null) {
              testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, finalComparisonPair.second, finalComparisonPair.first);
            }
            else {
              testProxy.setTestFailed(exceptionMsg, stackTrace, ""error"".equals(failureType));
            }
          });
        }
        runInEdt.add(() -> getResultsViewer().onTestFailed(testProxy));
        break;
      case SKIPPED:
        runInEdt.add(() -> {
          testProxy.setTestIgnored(null, null);
          getResultsViewer().onTestIgnored(testProxy);
        });
        break;
      case UNKNOWN_RESULT:
        break;
    }
    runInEdt.add(() -> getResultsViewer().onTestFinished(testProxy));
    addToInvokeLater(runInEdt);
  }",method,
"    catch (NumberFormatException ignored) {
    }",method,
"    switch (result) {
      case SUCCESS:
        runInEdt.add(testProxy::setFinished);
        break;
      case FAILURE:
        final String failureType = eventXml.getEventTestResultFailureType();
        if (""comparison"".equals(failureType)) {
          String actualText = decode(eventXml.getEventTestResultActual());
          String expectedText = decode(eventXml.getEventTestResultExpected());
          final Condition<String> emptyString = StringUtil::isEmpty;
          String filePath = ObjectUtils.nullizeByCondition(decode(eventXml.getEventTestResultFilePath()), emptyString);
          String actualFilePath = ObjectUtils.nullizeByCondition(
            decode(eventXml.getEventTestResultActualFilePath()), emptyString);
          testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, actualText, expectedText, filePath, actualFilePath);
        }
        else {
          Couple<String> comparisonPair =
            parseComparisonMessage(exceptionMsg, ""\nExpected: is \""(.*)\""\n\\s*got: \""(.*)\""\n"");
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: is \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: (.*)\n\\s*got: (.*)"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\\s*expected same:<(.*)> was not:<(.*)>"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, "".*\\s*expected:<(.*)> but was:<(.*)>"");
          }
          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }
          final Couple<String> finalComparisonPair = comparisonPair;
          runInEdt.add(() -> {
            if (finalComparisonPair != null) {
              testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, finalComparisonPair.second, finalComparisonPair.first);
            }
            else {
              testProxy.setTestFailed(exceptionMsg, stackTrace, ""error"".equals(failureType));
            }
          });
        }
        runInEdt.add(() -> getResultsViewer().onTestFailed(testProxy));
        break;
      case SKIPPED:
        runInEdt.add(() -> {
          testProxy.setTestIgnored(null, null);
          getResultsViewer().onTestIgnored(testProxy);
        });
        break;
      case UNKNOWN_RESULT:
        break;
    }",method,
"          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: is \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }",method,
"          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: (.*)\n\\s*got: (.*)"");
          }",method,
"          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\\s*expected same:<(.*)> was not:<(.*)>"");
          }",method,
"          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, "".*\\s*expected:<(.*)> but was:<(.*)>"");
          }",method,
"          if (comparisonPair == null) {
            comparisonPair = parseComparisonMessage(exceptionMsg, ""\nExpected: \""(.*)\""\n\\s*but: was \""(.*)\"""");
          }",method,
"            if (finalComparisonPair != null) {
              testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, finalComparisonPair.second, finalComparisonPair.first);
            }",method,
"  private static Couple<String> parseComparisonMessage(String message, final String regex) {
    final Matcher matcher = Pattern.compile(regex, Pattern.DOTALL | Pattern.CASE_INSENSITIVE).matcher(message);
    if (matcher.matches()) {
      return Couple.of(matcher.group(1).replaceAll(""\\\\n"", ""\n""), matcher.group(2).replaceAll(""\\\\n"", ""\n""));
    }
    return null;
  }",method,
"public class NetworkPartitionFaultSpec extends AbstractFaultSpec {
    private final List<List<String>> partitions;
    @JsonCreator
    public NetworkPartitionFaultSpec(@JsonProperty(""startMs"") long startMs,
                         @JsonProperty(""durationMs"") long durationMs,
                         @JsonProperty(""partitions"") List<List<String>> partitions) {
        super(startMs, durationMs);
        this.partitions = partitions;
    }
    @JsonProperty
    public List<List<String>> partitions() {
        return partitions;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NetworkPartitionFaultSpec that = (NetworkPartitionFaultSpec) o;
        return Objects.equals(startMs(), that.startMs()) &&
            Objects.equals(durationMs(), that.durationMs()) &&
            Objects.equals(partitions, that.partitions);
    }
    @Override
    public int hashCode() {
        return Objects.hash(startMs(), durationMs(), partitions);
    }
    @Override
    public String toString() {
        return JsonUtil.toJsonString(this);
    }
}",class,
"    @JsonProperty
    public List<List<String>> partitions() {
        return partitions;
    }",method,
"    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NetworkPartitionFaultSpec that = (NetworkPartitionFaultSpec) o;
        return Objects.equals(startMs(), that.startMs()) &&
            Objects.equals(durationMs(), that.durationMs()) &&
            Objects.equals(partitions, that.partitions);
    }",method,
"    @Override
    public int hashCode() {
        return Objects.hash(startMs(), durationMs(), partitions);
    }",method,
"    @Override
    public String toString() {
        return JsonUtil.toJsonString(this);
    }",method,
"public class BuildTargetParser {
  public static final BuildTargetParser INSTANCE = new BuildTargetParser();
  private static final String BUILD_RULE_PREFIX = ""//"";
  private static final String BUILD_RULE_SEPARATOR = "":"";
  private static final Splitter BUILD_RULE_SEPARATOR_SPLITTER = Splitter.on(BUILD_RULE_SEPARATOR);
  private static final Set<String> INVALID_BASE_NAME_PARTS = ImmutableSet.of(""."", "".."");
  private final Interner<BuildTarget> flavoredTargetCache = Interners.newWeakInterner();
  private final FlavorParser flavorParser = new FlavorParser();
  private BuildTargetParser() {
    // this is stateless. There's no need to do anything other than grab the instance needed.
  }
  public BuildTarget parse(
      String buildTargetName,
      BuildTargetPatternParser<?> buildTargetPatternParser,
      CellPathResolver cellNames) {
    if (buildTargetName.endsWith(BUILD_RULE_SEPARATOR)
        && !buildTargetPatternParser.isWildCardAllowed()) {
      throw new BuildTargetParseException(
          String.format(""%s cannot end with a colon"", buildTargetName));
    }
    Optional<String> givenCellName = Optional.empty();
    String targetAfterCell = buildTargetName;
    if (buildTargetName.contains(BUILD_RULE_PREFIX)
        && !buildTargetName.startsWith(BUILD_RULE_PREFIX)) {
      int slashIndex = buildTargetName.indexOf(BUILD_RULE_PREFIX);
      givenCellName = Optional.of(buildTargetName.substring(0, slashIndex));
      targetAfterCell = buildTargetName.substring(slashIndex);
    }
    if (givenCellName.isPresent() && givenCellName.get().isEmpty()) {
      throw new BuildTargetParseException(""Cell name must not be empty."");
    }
    List<String> parts = BUILD_RULE_SEPARATOR_SPLITTER.splitToList(targetAfterCell);
    if (parts.size() != 2) {
      throw new BuildTargetParseException(
          String.format(
              ""%s must contain exactly one colon (found %d)"", buildTargetName, parts.size() - 1));
    }
    String baseName =
        parts.get(0).isEmpty() ? buildTargetPatternParser.getBaseName() : parts.get(0);
    String shortName = parts.get(1);
    Iterable<String> flavorNames = new HashSet<>();
    int hashIndex = shortName.indexOf('#');
    if (hashIndex != -1 && hashIndex < shortName.length()) {
      flavorNames = flavorParser.parseFlavorString(shortName.substring(hashIndex + 1));
      shortName = shortName.substring(0, hashIndex);
    }
    Preconditions.checkNotNull(baseName);
    // On Windows, baseName may contain backslashes, which are not permitted by BuildTarget.
    baseName = baseName.replace('\\', '/');
    checkBaseName(baseName, buildTargetName);
    Path cellPath = cellNames.getCellPath(givenCellName);
    UnflavoredBuildTarget.Builder unflavoredBuilder =
        UnflavoredBuildTarget.builder()
            .setBaseName(baseName)
            .setShortName(shortName)
            // Set the cell path correctly. Because the cellNames comes from the owning cell we can
            // be sure that if this doesn't throw an exception the target cell is visible to the
            // owning cell.
            .setCellPath(cellPath)
            // We are setting the cell name so we can print it later
            .setCell(cellNames.getCanonicalCellName(cellPath));
    UnflavoredBuildTarget unflavoredBuildTarget = unflavoredBuilder.build();
    return flavoredTargetCache.intern(
        BuildTarget.of(
            unflavoredBuildTarget,
            RichStream.from(flavorNames).map(InternalFlavor::of).toImmutableSet()));
  }
  protected static void checkBaseName(String baseName, String buildTargetName) {
    if (baseName.equals(BUILD_RULE_PREFIX)) {
      return;
    }
    if (!baseName.startsWith(BUILD_RULE_PREFIX)) {
      throw new BuildTargetParseException(
          String.format(""Path in %s must start with %s"", buildTargetName, BUILD_RULE_PREFIX));
    }
    String baseNamePath = baseName.substring(BUILD_RULE_PREFIX.length());
    if (baseNamePath.startsWith(""/"")) {
      throw new BuildTargetParseException(
          String.format(
              ""Build target path should start with an optional cell name, then // and then a ""
                  + ""relative directory name, not an absolute directory path (found %s)"",
              buildTargetName));
    }",class,
"  private BuildTargetParser() {
    // this is stateless. There's no need to do anything other than grab the instance needed.
  }
  public BuildTarget parse(
      String buildTargetName,
      BuildTargetPatternParser<?> buildTargetPatternParser,
      CellPathResolver cellNames) {
    if (buildTargetName.endsWith(BUILD_RULE_SEPARATOR)
        && !buildTargetPatternParser.isWildCardAllowed()) {
      throw new BuildTargetParseException(
          String.format(""%s cannot end with a colon"", buildTargetName));
    }
    Optional<String> givenCellName = Optional.empty();
    String targetAfterCell = buildTargetName;
    if (buildTargetName.contains(BUILD_RULE_PREFIX)
        && !buildTargetName.startsWith(BUILD_RULE_PREFIX)) {
      int slashIndex = buildTargetName.indexOf(BUILD_RULE_PREFIX);
      givenCellName = Optional.of(buildTargetName.substring(0, slashIndex));
      targetAfterCell = buildTargetName.substring(slashIndex);
    }
    if (givenCellName.isPresent() && givenCellName.get().isEmpty()) {
      throw new BuildTargetParseException(""Cell name must not be empty."");
    }
    List<String> parts = BUILD_RULE_SEPARATOR_SPLITTER.splitToList(targetAfterCell);
    if (parts.size() != 2) {
      throw new BuildTargetParseException(
          String.format(
              ""%s must contain exactly one colon (found %d)"", buildTargetName, parts.size() - 1));
    }
    String baseName =
        parts.get(0).isEmpty() ? buildTargetPatternParser.getBaseName() : parts.get(0);
    String shortName = parts.get(1);
    Iterable<String> flavorNames = new HashSet<>();
    int hashIndex = shortName.indexOf('#');
    if (hashIndex != -1 && hashIndex < shortName.length()) {
      flavorNames = flavorParser.parseFlavorString(shortName.substring(hashIndex + 1));
      shortName = shortName.substring(0, hashIndex);
    }
    Preconditions.checkNotNull(baseName);
    // On Windows, baseName may contain backslashes, which are not permitted by BuildTarget.
    baseName = baseName.replace('\\', '/');
    checkBaseName(baseName, buildTargetName);
    Path cellPath = cellNames.getCellPath(givenCellName);
    UnflavoredBuildTarget.Builder unflavoredBuilder =
        UnflavoredBuildTarget.builder()
            .setBaseName(baseName)
            .setShortName(shortName)
            // Set the cell path correctly. Because the cellNames comes from the owning cell we can
            // be sure that if this doesn't throw an exception the target cell is visible to the
            // owning cell.
            .setCellPath(cellPath)
            // We are setting the cell name so we can print it later
            .setCell(cellNames.getCanonicalCellName(cellPath));
    UnflavoredBuildTarget unflavoredBuildTarget = unflavoredBuilder.build();
    return flavoredTargetCache.intern(
        BuildTarget.of(
            unflavoredBuildTarget,
            RichStream.from(flavorNames).map(InternalFlavor::of).toImmutableSet()));
  }
  protected static void checkBaseName(String baseName, String buildTargetName) {
    if (baseName.equals(BUILD_RULE_PREFIX)) {
      return;
    }
    if (!baseName.startsWith(BUILD_RULE_PREFIX)) {
      throw new BuildTargetParseException(
          String.format(""Path in %s must start with %s"", buildTargetName, BUILD_RULE_PREFIX));
    }
    String baseNamePath = baseName.substring(BUILD_RULE_PREFIX.length());
    if (baseNamePath.startsWith(""/"")) {
      throw new BuildTargetParseException(
          String.format(
              ""Build target path should start with an optional cell name, then // and then a ""
                  + ""relative directory name, not an absolute directory path (found %s)"",
              buildTargetName));
    }
    for (String baseNamePart : Splitter.on('/').split(baseNamePath)) {
      if ("""".equals(baseNamePart)) {
        throw new BuildTargetParseException(
            String.format(
                ""Build target path cannot contain // other than at the start ""
                    + ""(or after a cell name) (found %s)"",
                buildTargetName));
      }
      if (INVALID_BASE_NAME_PARTS.contains(baseNamePart)) {
        throw new BuildTargetParseException(
            String.format(""Build target path cannot contain . or .. (found %s)"", buildTargetName));
      }
    }",method,
"  public BuildTarget parse(
      String buildTargetName,
      BuildTargetPatternParser<?> buildTargetPatternParser,
      CellPathResolver cellNames) {
    if (buildTargetName.endsWith(BUILD_RULE_SEPARATOR)
        && !buildTargetPatternParser.isWildCardAllowed()) {
      throw new BuildTargetParseException(
          String.format(""%s cannot end with a colon"", buildTargetName));
    }
    Optional<String> givenCellName = Optional.empty();
    String targetAfterCell = buildTargetName;
    if (buildTargetName.contains(BUILD_RULE_PREFIX)
        && !buildTargetName.startsWith(BUILD_RULE_PREFIX)) {
      int slashIndex = buildTargetName.indexOf(BUILD_RULE_PREFIX);
      givenCellName = Optional.of(buildTargetName.substring(0, slashIndex));
      targetAfterCell = buildTargetName.substring(slashIndex);
    }
    if (givenCellName.isPresent() && givenCellName.get().isEmpty()) {
      throw new BuildTargetParseException(""Cell name must not be empty."");
    }
    List<String> parts = BUILD_RULE_SEPARATOR_SPLITTER.splitToList(targetAfterCell);
    if (parts.size() != 2) {
      throw new BuildTargetParseException(
          String.format(
              ""%s must contain exactly one colon (found %d)"", buildTargetName, parts.size() - 1));
    }
    String baseName =
        parts.get(0).isEmpty() ? buildTargetPatternParser.getBaseName() : parts.get(0);
    String shortName = parts.get(1);
    Iterable<String> flavorNames = new HashSet<>();
    int hashIndex = shortName.indexOf('#');
    if (hashIndex != -1 && hashIndex < shortName.length()) {
      flavorNames = flavorParser.parseFlavorString(shortName.substring(hashIndex + 1));
      shortName = shortName.substring(0, hashIndex);
    }
    Preconditions.checkNotNull(baseName);
    // On Windows, baseName may contain backslashes, which are not permitted by BuildTarget.
    baseName = baseName.replace('\\', '/');
    checkBaseName(baseName, buildTargetName);
    Path cellPath = cellNames.getCellPath(givenCellName);
    UnflavoredBuildTarget.Builder unflavoredBuilder =
        UnflavoredBuildTarget.builder()
            .setBaseName(baseName)
            .setShortName(shortName)
            // Set the cell path correctly. Because the cellNames comes from the owning cell we can
            // be sure that if this doesn't throw an exception the target cell is visible to the
            // owning cell.
            .setCellPath(cellPath)
            // We are setting the cell name so we can print it later
            .setCell(cellNames.getCanonicalCellName(cellPath));
    UnflavoredBuildTarget unflavoredBuildTarget = unflavoredBuilder.build();
    return flavoredTargetCache.intern(
        BuildTarget.of(
            unflavoredBuildTarget,
            RichStream.from(flavorNames).map(InternalFlavor::of).toImmutableSet()));
  }
  protected static void checkBaseName(String baseName, String buildTargetName) {
    if (baseName.equals(BUILD_RULE_PREFIX)) {
      return;
    }
    if (!baseName.startsWith(BUILD_RULE_PREFIX)) {
      throw new BuildTargetParseException(
          String.format(""Path in %s must start with %s"", buildTargetName, BUILD_RULE_PREFIX));
    }
    String baseNamePath = baseName.substring(BUILD_RULE_PREFIX.length());
    if (baseNamePath.startsWith(""/"")) {
      throw new BuildTargetParseException(
          String.format(
              ""Build target path should start with an optional cell name, then // and then a ""
                  + ""relative directory name, not an absolute directory path (found %s)"",
              buildTargetName));
    }
    for (String baseNamePart : Splitter.on('/').split(baseNamePath)) {
      if ("""".equals(baseNamePart)) {
        throw new BuildTargetParseException(
            String.format(
                ""Build target path cannot contain // other than at the start ""
                    + ""(or after a cell name) (found %s)"",
                buildTargetName));
      }
      if (INVALID_BASE_NAME_PARTS.contains(baseNamePart)) {
        throw new BuildTargetParseException(
            String.format(""Build target path cannot contain . or .. (found %s)"", buildTargetName));
      }
    }",method,
"  protected static void checkBaseName(String baseName, String buildTargetName) {
    if (baseName.equals(BUILD_RULE_PREFIX)) {
      return;
    }
    if (!baseName.startsWith(BUILD_RULE_PREFIX)) {
      throw new BuildTargetParseException(
          String.format(""Path in %s must start with %s"", buildTargetName, BUILD_RULE_PREFIX));
    }
    String baseNamePath = baseName.substring(BUILD_RULE_PREFIX.length());
    if (baseNamePath.startsWith(""/"")) {
      throw new BuildTargetParseException(
          String.format(
              ""Build target path should start with an optional cell name, then // and then a ""
                  + ""relative directory name, not an absolute directory path (found %s)"",
              buildTargetName));
    }
    for (String baseNamePart : Splitter.on('/').split(baseNamePath)) {
      if ("""".equals(baseNamePart)) {
        throw new BuildTargetParseException(
            String.format(
                ""Build target path cannot contain // other than at the start ""
                    + ""(or after a cell name) (found %s)"",
                buildTargetName));
      }
      if (INVALID_BASE_NAME_PARTS.contains(baseNamePart)) {
        throw new BuildTargetParseException(
            String.format(""Build target path cannot contain . or .. (found %s)"", buildTargetName));
      }
    }",method,
"	public JdbcTemplate() {
	}",method,
"	public JdbcTemplate(DataSource dataSource) {
		setDataSource(dataSource);
		afterPropertiesSet();
	}",method,
"	public JdbcTemplate(DataSource dataSource, boolean lazyInit) {
		setDataSource(dataSource);
		setLazyInit(lazyInit);
		afterPropertiesSet();
	}",method,
"	public void setIgnoreWarnings(boolean ignoreWarnings) {
		this.ignoreWarnings = ignoreWarnings;
	}",method,
"	public boolean isIgnoreWarnings() {
		return this.ignoreWarnings;
	}",method,
"public class QNameUtil {
    public static final QName NONE = null;
    public static final QName UNRESOLVED = new ExtendedQName(""null"");
    public static final QName ANY = new ExtendedQName(""*"");
    private QNameUtil() {
    }
    public static boolean equal(QName q1, QName q2) {
        if (q1 == UNRESOLVED || q2 == UNRESOLVED) return false;
        if (q1 == ANY || q2 == ANY) return true;
        if (Comparing.equal(q1, q2)) return true;
        if (q1 instanceof ExtendedQName) {
            return q1.getNamespaceURI().equals(q2.getNamespaceURI());
        } else if (q2 instanceof ExtendedQName) {
            return q2.getNamespaceURI().equals(q1.getNamespaceURI());
        }
        return false;
    }
    public static QName createAnyLocalName(String namespace) {
        return new ExtendedQName(namespace);
    }
    @SuppressWarnings({""SimplifiableIfStatement""})
    private static boolean isNamespaceDeclared(@Nullable XmlTag tag, String namespace) {
        if (tag == null) return false;
        if (tag.getLocalNamespaceDeclarations().containsValue(namespace)) return true;
        return isNamespaceDeclared(tag.getParentTag(), namespace);
    }
    public static QName createQName(@NotNull String qname, @NotNull PsiElement context) {
        final String[] strings = qname.split("":"", 2);
        if (strings.length == 1) {
            return new QName(null, qname);
        }
        final XmlElement ctx = PsiTreeUtil.getParentOfType(context, XmlElement.class, false);
        if (ctx == null) return UNRESOLVED;
        final String uri = XsltNamespaceContext.getNamespaceUriStatic(strings[0], ctx);
        if (uri == null) return UNRESOLVED;
        return new QName(uri, strings[1], strings[0]);
    }
    public static QName createQName(@NotNull XmlAttribute attribute) {
        final String name = attribute.getName();
        if (name.indexOf(':') != -1) {
            return new QName(attribute.getNamespace(), attribute.getLocalName());
        } else {
            return new QName(null, attribute.getLocalName());
        }
    }
    public static QName createQName(@NotNull XmlTag tag) {
        if (isNamespaceDeclared(tag, tag.getNamespace())) {
            return new QName(tag.getNamespace(), tag.getLocalName(), tag.getNamespacePrefix());
        } else {
            return new QName(null, tag.getLocalName());
        }
    }
    static final class ExtendedQName extends QName {
        ExtendedQName(String namespace) {
            super(namespace, ""*"");
        }
    }
}",class,
"    static final class ExtendedQName extends QName {
        ExtendedQName(String namespace) {
            super(namespace, ""*"");
        }
    }",class,
"    private QNameUtil() {
    }",method,
"    public static boolean equal(QName q1, QName q2) {
        if (q1 == UNRESOLVED || q2 == UNRESOLVED) return false;
        if (q1 == ANY || q2 == ANY) return true;
        if (Comparing.equal(q1, q2)) return true;
        if (q1 instanceof ExtendedQName) {
            return q1.getNamespaceURI().equals(q2.getNamespaceURI());
        } else if (q2 instanceof ExtendedQName) {
            return q2.getNamespaceURI().equals(q1.getNamespaceURI());
        }
        return false;
    }",method,
"        if (q1 instanceof ExtendedQName) {
            return q1.getNamespaceURI().equals(q2.getNamespaceURI());
        }",method,
"    public static QName createAnyLocalName(String namespace) {
        return new ExtendedQName(namespace);
    }",method,
"    @SuppressWarnings({""SimplifiableIfStatement""})
    private static boolean isNamespaceDeclared(@Nullable XmlTag tag, String namespace) {
        if (tag == null) return false;
        if (tag.getLocalNamespaceDeclarations().containsValue(namespace)) return true;
        return isNamespaceDeclared(tag.getParentTag(), namespace);
    }",method,
"    public static QName createQName(@NotNull String qname, @NotNull PsiElement context) {
        final String[] strings = qname.split("":"", 2);
        if (strings.length == 1) {
            return new QName(null, qname);
        }
        final XmlElement ctx = PsiTreeUtil.getParentOfType(context, XmlElement.class, false);
        if (ctx == null) return UNRESOLVED;
        final String uri = XsltNamespaceContext.getNamespaceUriStatic(strings[0], ctx);
        if (uri == null) return UNRESOLVED;
        return new QName(uri, strings[1], strings[0]);
    }",method,
"        if (strings.length == 1) {
            return new QName(null, qname);
        }",method,
"    public static QName createQName(@NotNull XmlAttribute attribute) {
        final String name = attribute.getName();
        if (name.indexOf(':') != -1) {
            return new QName(attribute.getNamespace(), attribute.getLocalName());
        } else {
            return new QName(null, attribute.getLocalName());
        }
    }",method,
"    public static QName createQName(@NotNull XmlTag tag) {
        if (isNamespaceDeclared(tag, tag.getNamespace())) {
            return new QName(tag.getNamespace(), tag.getLocalName(), tag.getNamespacePrefix());
        } else {
            return new QName(null, tag.getLocalName());
        }
    }",method,
"        ExtendedQName(String namespace) {
            super(namespace, ""*"");
        }",method,
"public class RecordTooLargeException extends ApiException {
    private static final long serialVersionUID = 1L;
    private Map<TopicPartition, Long> recordTooLargePartitions = null;
    public RecordTooLargeException() {
        super();
    }
    public RecordTooLargeException(String message, Throwable cause) {
        super(message, cause);
    }
    public RecordTooLargeException(String message) {
        super(message);
    }
    public RecordTooLargeException(Throwable cause) {
        super(cause);
    }
    public RecordTooLargeException(String message, Map<TopicPartition, Long> recordTooLargePartitions) {
        super(message);
        this.recordTooLargePartitions = recordTooLargePartitions;
    }
    public Map<TopicPartition, Long> recordTooLargePartitions() {
        return recordTooLargePartitions;
    }
}",class,
"public class ReplicaNotAvailableException extends ApiException {
    private static final long serialVersionUID = 1L;
    public ReplicaNotAvailableException(String message) {
        super(message);
    }
    public ReplicaNotAvailableException(String message, Throwable cause) {
        super(message, cause);
    }
    public ReplicaNotAvailableException(Throwable cause) {
        super(cause);
    }
}",class,
"public abstract class RetriableException extends ApiException {
    private static final long serialVersionUID = 1L;
    public RetriableException(String message, Throwable cause) {
        super(message, cause);
    }
    public RetriableException(String message) {
        super(message);
    }
    public RetriableException(Throwable cause) {
        super(cause);
    }
    public RetriableException() {
    }
}",class,
"    public RecordTooLargeException() {
        super();
    }",method,
"    public RecordTooLargeException(String message, Throwable cause) {
        super(message, cause);
    }",method,
"    public RecordTooLargeException(String message) {
        super(message);
    }",method,
"    public RecordTooLargeException(Throwable cause) {
        super(cause);
    }",method,
"    public RecordTooLargeException(String message, Map<TopicPartition, Long> recordTooLargePartitions) {
        super(message);
        this.recordTooLargePartitions = recordTooLargePartitions;
    }",method,
"    public Map<TopicPartition, Long> recordTooLargePartitions() {
        return recordTooLargePartitions;
    }",method,
"    public ReplicaNotAvailableException(String message) {
        super(message);
    }",method,
"    public ReplicaNotAvailableException(String message, Throwable cause) {
        super(message, cause);
    }",method,
"    public ReplicaNotAvailableException(Throwable cause) {
        super(cause);
    }",method,
"    public RetriableException(String message, Throwable cause) {
        super(message, cause);
    }",method,
"    public RetriableException(String message) {
        super(message);
    }",method,
"    public RetriableException(Throwable cause) {
        super(cause);
    }",method,
"    public RetriableException() {
    }",method,
"import java.util.List;
class SoftMargins implements Cloneable {
  private List<Integer> myValues;
  @SuppressWarnings(""unused"") // Serialization getter
  @Nullable
  public String getSOFT_MARGINS() {
    return myValues != null ? toString() : null;
  }
  @SuppressWarnings(""unused"") // Serialization setter
  public void setSOFT_MARGINS(@Nullable String valueList) {
    if (valueList != null) {
      String[] values = valueList.split("",\\s*"");
      myValues = new ArrayList<>(values.length);
      int i = 0;
      for (String value : values) {
        try {
          myValues.add(Integer.parseInt(value));
        }
        catch (NumberFormatException nfe) {
          myValues = null;
          return;
        }
      }
      Collections.sort(myValues);
    }
  }
  @NotNull
  List<Integer> getValues() {
    return myValues != null ? myValues : Collections.emptyList();
  }
  void setValues(List<Integer> values) {
    if (values != null) {
      myValues = new ArrayList<>(values);
      Collections.sort(myValues);
    }
    else {
      myValues = null;
    }
  }
  @SuppressWarnings(""MethodDoesntCallSuperMethod"")
  @Override
  public Object clone() {
    SoftMargins copy = new SoftMargins();
    copy.setValues(myValues);
    return copy;
  }
  @Override
  public boolean equals(Object obj) {
    if (obj instanceof SoftMargins) {
      List<Integer> otherMargins = ((SoftMargins)obj).getValues();
      return otherMargins.equals(getValues());
    }
    return false;
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    if (myValues != null) {
      for (int margin: myValues) {
        if (sb.length() > 0) sb.append("","");
        sb.append(margin);
      }
    }
    return sb.toString();
  }
  public void serializeInto(@NotNull Element element) {
    if (myValues != null && myValues.size() > 0) {
      XmlSerializer.serializeInto(this, element);
    }
  }
  public void deserializeFrom(@NotNull Element element) {
    XmlSerializer.deserializeInto(this, element);
  }
}",class,
"  @SuppressWarnings(""unused"") // Serialization getter
  @Nullable
  public String getSOFT_MARGINS() {
    return myValues != null ? toString() : null;
  }",method,
"  @SuppressWarnings(""unused"") // Serialization setter
  public void setSOFT_MARGINS(@Nullable String valueList) {
    if (valueList != null) {
      String[] values = valueList.split("",\\s*"");
      myValues = new ArrayList<>(values.length);
      int i = 0;
      for (String value : values) {
        try {
          myValues.add(Integer.parseInt(value));
        }
        catch (NumberFormatException nfe) {
          myValues = null;
          return;
        }
      }
      Collections.sort(myValues);
    }
  }",method,
"    if (valueList != null) {
      String[] values = valueList.split("",\\s*"");
      myValues = new ArrayList<>(values.length);
      int i = 0;
      for (String value : values) {
        try {
          myValues.add(Integer.parseInt(value));
        }
        catch (NumberFormatException nfe) {
          myValues = null;
          return;
        }
      }
      Collections.sort(myValues);
    }",method,
"      for (String value : values) {
        try {
          myValues.add(Integer.parseInt(value));
        }
        catch (NumberFormatException nfe) {
          myValues = null;
          return;
        }
      }",method,

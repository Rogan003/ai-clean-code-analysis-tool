code_snippet,type,score
"		if(pShaderProgram == null) {
			throw new IllegalArgumentException(""pShaderProgram must not be null!"");
		}",method,
"	public void loadShaderPrograms(final ShaderProgram ... pShaderPrograms) {
		for(int i = pShaderPrograms.length - 1; i >= 0; i--) {
			this.loadShaderProgram(pShaderPrograms[i]);
		}
	}",method,
"		for(int i = pShaderPrograms.length - 1; i >= 0; i--) {
			this.loadShaderProgram(pShaderPrograms[i]);
		}",method,
"	public synchronized void onReload() {
		final ArrayList<ShaderProgram> managedShaderPrograms = this.mShaderProgramsManaged;
		for(int i = managedShaderPrograms.size() - 1; i >= 0; i--) {
			managedShaderPrograms.get(i).setCompiled(false);
		}
	}",method,
"	public ShaderProgramCompileException(final String pMessage, final String pSource) {
		super(""Reason: "" + pMessage + ""\nSource:\n##########################\n"" + pSource + ""\n##########################"");
	}",method,
"public class Animal {
  @JsonProperty(""className"")
  private String className = null;
  @JsonProperty(""color"")
  private String color = ""red"";
  public Animal className(String className) {
    this.className = className;
    return this;
  }
  @ApiModelProperty(required = true, value = """")
  public String getClassName() {
    return className;
  }
  public void setClassName(String className) {
    this.className = className;
  }
  public Animal color(String color) {
    this.color = color;
    return this;
  }
  @ApiModelProperty(value = """")
  public String getColor() {
    return color;
  }
  public void setColor(String color) {
    this.color = color;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Animal animal = (Animal) o;
    return Objects.equals(this.className, animal.className) &&
        Objects.equals(this.color, animal.color);
  }
  @Override
  public int hashCode() {
    return Objects.hash(className, color);
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class Animal {\n"");
    sb.append(""    className: "").append(toIndentedString(className)).append(""\n"");
    sb.append(""    color: "").append(toIndentedString(color)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
}",class,
"    sb.append(""class Animal {\n"");
    sb.append(""    className: "").append(toIndentedString(className)).append(""\n"");
    sb.append(""    color: "").append(toIndentedString(color)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"  public Animal className(String className) {
    this.className = className;
    return this;
  }",method,
"  @ApiModelProperty(required = true, value = """")
  public String getClassName() {
    return className;
  }",method,
"  public void setClassName(String className) {
    this.className = className;
  }",method,
"  public Animal color(String color) {
    this.color = color;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public String getColor() {
    return color;
  }",method,
"  public void setColor(String color) {
    this.color = color;
  }",method,
"  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Animal animal = (Animal) o;
    return Objects.equals(this.className, animal.className) &&
        Objects.equals(this.color, animal.color);
  }",method,
"    if (this == o) {
      return true;
    }",method,
"  @Override
  public int hashCode() {
    return Objects.hash(className, color);
  }",method,
"  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class Animal {\n"");
    sb.append(""    className: "").append(toIndentedString(className)).append(""\n"");
    sb.append(""    color: "").append(toIndentedString(color)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }",method,
"  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",method,
"    if (o == null) {
      return ""null"";
    }",method,
"public class FlowableOnBackpressureBufferTest {
    @Test
    public void testNoBackpressureSupport() {
        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
        // this will be ignored
        ts.request(100);
        // we take 500 so it unsubscribes
        infinite.take(500).subscribe(ts);
        // it completely ignores the `request(100)` and we get 500
        assertEquals(500, ts.values().size());
        ts.assertNoErrors();
    }
    @Test(timeout = 2000)
    public void testFixBackpressureWithBuffer() throws InterruptedException {
        final CountDownLatch l1 = new CountDownLatch(100);
        final CountDownLatch l2 = new CountDownLatch(150);
        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {
            @Override
            protected void onStart() {
            }
            @Override
            public void onComplete() {
            }
            @Override
            public void onError(Throwable e) {
            }
            @Override
            public void onNext(Long t) {
                l1.countDown();
                l2.countDown();
            }
        }, 0L);
        // this will be ignored
        ts.request(100);
        // we take 500 so it unsubscribes
        infinite.subscribeOn(Schedulers.computation())
        .onBackpressureBuffer()
        .take(500)
        .subscribe(ts);
        // it completely ignores the `request(100)` and we get 500
        l1.await();
        assertEquals(100, ts.values().size());
        ts.request(50);
        l2.await();
        assertEquals(150, ts.values().size());
        ts.request(350);
        ts.awaitTerminalEvent();
        assertEquals(500, ts.values().size());
        ts.assertNoErrors();
        assertEquals(0, ts.values().get(0).intValue());
        assertEquals(499, ts.values().get(499).intValue());
    }
    @Test(expected = IllegalArgumentException.class)
    public void testFixBackpressureBufferNegativeCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(-1);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testFixBackpressureBufferZeroCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(0);
    }
    @Test
    public void testFixBackpressureBoundedBuffer() throws InterruptedException {
        final CountDownLatch l1 = new CountDownLatch(100);
        final CountDownLatch backpressureCallback = new CountDownLatch(1);
        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {
            @Override
            protected void onStart() {
            }
            @Override
            public void onComplete() { }
            @Override
            public void onError(Throwable e) { }
            @Override
            public void onNext(Long t) {
                l1.countDown();
            }
        }, 0L);
        ts.request(100);
        infinite.subscribeOn(Schedulers.computation())
             .onBackpressureBuffer(500, new Action() {
                 @Override
                 public void run() {
                     backpressureCallback.countDown();
                 }
             })
             .subscribe(ts);
        l1.await();
        ts.request(50);
        assertTrue(backpressureCallback.await(500, TimeUnit.MILLISECONDS));
        ts.awaitTerminalEvent(1, TimeUnit.SECONDS);
        ts.assertError(MissingBackpressureException.class);
        int size = ts.values().size();
        assertTrue(size <= 150);  // will get up to 50 more
        assertTrue(ts.values().get(size - 1) == size - 1);
    }
    static final Flowable<Long> infinite = Flowable.unsafeCreate(new Publisher<Long>() {
        @Override
        public void subscribe(Subscriber<? super Long> s) {
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled()) {
                s.onNext(i++);
            }
        }
    });
    private static final Action THROWS_NON_FATAL = new Action() {
        @Override
        public void run() {
            throw new RuntimeException();
        }
    };
    @Test
    public void nonFatalExceptionThrownByOnOverflowIsNotReportedByUpstream() {
         final AtomicBoolean errorOccurred = new AtomicBoolean(false);
         TestSubscriber<Long> ts = TestSubscriber.create(0);
         infinite
           .subscribeOn(Schedulers.computation())
           .doOnError(new Consumer<Throwable>() {
                 @Override
                 public void accept(Throwable t) {
                     errorOccurred.set(true);
                 }
             })
           .onBackpressureBuffer(1, THROWS_NON_FATAL)
           .subscribe(ts);
         ts.awaitTerminalEvent();
         assertFalse(errorOccurred.get());
    }
    @Test
    public void maxSize() {
        TestSubscriber<Integer> ts = TestSubscriber.create(0);
        Flowable.range(1, 10).onBackpressureBuffer(1).subscribe(ts);
        ts.assertNoValues();
        ts.assertError(MissingBackpressureException.class);
        ts.assertNotComplete();
    }
    @Test(expected = IllegalArgumentException.class)
    public void fixBackpressureBufferNegativeCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(-1);
    }
    @Test(expected = IllegalArgumentException.class)
    public void fixBackpressureBufferZeroCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(0);
    }
    @Test(expected = NullPointerException.class)
    public void fixBackpressureBufferNullStrategy() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(10, new Action() {
            @Override
            public void run() { }
        }, null);
    }
    @Test
    public void noDelayError() {
        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
        .onBackpressureBuffer(false)
        .test(0L)
        .assertFailure(TestException.class);
    }
    @Test
    public void delayError() {
        TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
        .onBackpressureBuffer(true)
        .test(0L)
        .assertEmpty();
        ts.request(1);
        ts.assertFailure(TestException.class, 1);
    }
    @Test
    public void delayErrorBuffer() {
        TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
        .onBackpressureBuffer(16, true)
        .test(0L)
        .assertEmpty();
        ts.request(1);
        ts.assertFailure(TestException.class, 1);
    }
    @Test
    public void fusedNormal() {
        TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueSubscription.ANY);
        Flowable.range(1, 10).onBackpressureBuffer().subscribe(ts);
        ts.assertOf(SubscriberFusion.<Integer>assertFuseable())
          .assertOf(SubscriberFusion.<Integer>assertFusionMode(QueueSubscription.ASYNC))
          .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }
    @Test
    public void fusedError() {
        TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueSubscription.ANY);
        Flowable.<Integer>error(new TestException()).onBackpressureBuffer().subscribe(ts);
        ts.assertOf(SubscriberFusion.<Integer>assertFuseable())
          .assertOf(SubscriberFusion.<Integer>assertFusionMode(QueueSubscription.ASYNC))
          .assertFailure(TestException.class);
    }
    @Test
    public void fusedPreconsume() throws Exception {
        TestSubscriber<Integer> ts = Flowable.range(1, 1000 * 1000)
        .onBackpressureBuffer()
        .observeOn(Schedulers.single())
        .test(0L);
        ts.assertEmpty();
        Thread.sleep(100);
        ts.request(1000 * 1000);
        ts
        .awaitDone(5, TimeUnit.SECONDS)
        .assertValueCount(1000 * 1000)
        .assertNoErrors()
        .assertComplete();
    }
    @Test
    public void emptyDelayError() {
        Flowable.empty()
        .onBackpressureBuffer(true)
        .test()
        .assertResult();
    }
    @Test
    public void fusionRejected() {
        TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueSubscription.SYNC);
        Flowable.<Integer>never().onBackpressureBuffer().subscribe(ts);
        SubscriberFusion.assertFusion(ts, QueueSubscription.NONE)
        .assertEmpty();
    }
}",class,
"    @Test
    public void testNoBackpressureSupport() {
        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
        // this will be ignored
        ts.request(100);
        // we take 500 so it unsubscribes
        infinite.take(500).subscribe(ts);
        // it completely ignores the `request(100)` and we get 500
        assertEquals(500, ts.values().size());
        ts.assertNoErrors();
    }",method,
"    @Test(timeout = 2000)
    public void testFixBackpressureWithBuffer() throws InterruptedException {
        final CountDownLatch l1 = new CountDownLatch(100);
        final CountDownLatch l2 = new CountDownLatch(150);
        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {
            @Override
            protected void onStart() {
            }
            @Override
            public void onComplete() {
            }
            @Override
            public void onError(Throwable e) {
            }
            @Override
            public void onNext(Long t) {
                l1.countDown();
                l2.countDown();
            }
        }, 0L);
        // this will be ignored
        ts.request(100);
        // we take 500 so it unsubscribes
        infinite.subscribeOn(Schedulers.computation())
        .onBackpressureBuffer()
        .take(500)
        .subscribe(ts);
        // it completely ignores the `request(100)` and we get 500
        l1.await();
        assertEquals(100, ts.values().size());
        ts.request(50);
        l2.await();
        assertEquals(150, ts.values().size());
        ts.request(350);
        ts.awaitTerminalEvent();
        assertEquals(500, ts.values().size());
        ts.assertNoErrors();
        assertEquals(0, ts.values().get(0).intValue());
        assertEquals(499, ts.values().get(499).intValue());
    }",method,
"            @Override
            protected void onStart() {
            }",method,
"            @Override
            public void onComplete() {
            }",method,
"            @Override
            public void onError(Throwable e) {
            }",method,
"            @Override
            public void onNext(Long t) {
                l1.countDown();
                l2.countDown();
            }",method,
"    @Test(expected = IllegalArgumentException.class)
    public void testFixBackpressureBufferNegativeCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(-1);
    }",method,
"    @Test(expected = IllegalArgumentException.class)
    public void testFixBackpressureBufferZeroCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(0);
    }",method,
"    @Test
    public void testFixBackpressureBoundedBuffer() throws InterruptedException {
        final CountDownLatch l1 = new CountDownLatch(100);
        final CountDownLatch backpressureCallback = new CountDownLatch(1);
        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {
            @Override
            protected void onStart() {
            }
            @Override
            public void onComplete() { }
            @Override
            public void onError(Throwable e) { }
            @Override
            public void onNext(Long t) {
                l1.countDown();
            }
        }, 0L);
        ts.request(100);
        infinite.subscribeOn(Schedulers.computation())
             .onBackpressureBuffer(500, new Action() {
                 @Override
                 public void run() {
                     backpressureCallback.countDown();
                 }
             })
             .subscribe(ts);
        l1.await();
        ts.request(50);
        assertTrue(backpressureCallback.await(500, TimeUnit.MILLISECONDS));
        ts.awaitTerminalEvent(1, TimeUnit.SECONDS);
        ts.assertError(MissingBackpressureException.class);
        int size = ts.values().size();
        assertTrue(size <= 150);  // will get up to 50 more
        assertTrue(ts.values().get(size - 1) == size - 1);
    }",method,
"            @Override
            protected void onStart() {
            }",method,
"            @Override
            public void onComplete() { }",method,
"            @Override
            public void onError(Throwable e) { }",method,
"            @Override
            public void onNext(Long t) {
                l1.countDown();
            }",method,
"             .onBackpressureBuffer(500, new Action() {
                 @Override
                 public void run() {
                     backpressureCallback.countDown();
                 }
             }",method,
"                 @Override
                 public void run() {
                     backpressureCallback.countDown();
                 }",method,
"        @Override
        public void subscribe(Subscriber<? super Long> s) {
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled()) {
                s.onNext(i++);
            }
        }",method,
"        @Override
        public void run() {
            throw new RuntimeException();
        }",method,
"    @Test
    public void nonFatalExceptionThrownByOnOverflowIsNotReportedByUpstream() {
         final AtomicBoolean errorOccurred = new AtomicBoolean(false);
         TestSubscriber<Long> ts = TestSubscriber.create(0);
         infinite
           .subscribeOn(Schedulers.computation())
           .doOnError(new Consumer<Throwable>() {
                 @Override
                 public void accept(Throwable t) {
                     errorOccurred.set(true);
                 }
             })
           .onBackpressureBuffer(1, THROWS_NON_FATAL)
           .subscribe(ts);
         ts.awaitTerminalEvent();
         assertFalse(errorOccurred.get());
    }",method,
"           .doOnError(new Consumer<Throwable>() {
                 @Override
                 public void accept(Throwable t) {
                     errorOccurred.set(true);
                 }
             }",method,
"                 @Override
                 public void accept(Throwable t) {
                     errorOccurred.set(true);
                 }",method,
"    @Test
    public void maxSize() {
        TestSubscriber<Integer> ts = TestSubscriber.create(0);
        Flowable.range(1, 10).onBackpressureBuffer(1).subscribe(ts);
        ts.assertNoValues();
        ts.assertError(MissingBackpressureException.class);
        ts.assertNotComplete();
    }",method,
"    @Test(expected = IllegalArgumentException.class)
    public void fixBackpressureBufferNegativeCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(-1);
    }",method,
"    @Test(expected = IllegalArgumentException.class)
    public void fixBackpressureBufferZeroCapacity() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(0);
    }",method,
"    @Test(expected = NullPointerException.class)
    public void fixBackpressureBufferNullStrategy() throws InterruptedException {
        Flowable.empty().onBackpressureBuffer(10, new Action() {
            @Override
            public void run() { }
        }, null);
    }",method,
"            @Override
            public void run() { }",method,
"    @Test
    public void noDelayError() {
        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
        .onBackpressureBuffer(false)
        .test(0L)
        .assertFailure(TestException.class);
    }",method,
"    @Test
    public void delayError() {
        TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
        .onBackpressureBuffer(true)
        .test(0L)
        .assertEmpty();
        ts.request(1);
        ts.assertFailure(TestException.class, 1);
    }",method,
"    @Test
    public void delayErrorBuffer() {
        TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
        .onBackpressureBuffer(16, true)
        .test(0L)
        .assertEmpty();
        ts.request(1);
        ts.assertFailure(TestException.class, 1);
    }",method,
"    @Test
    public void fusedNormal() {
        TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueSubscription.ANY);
        Flowable.range(1, 10).onBackpressureBuffer().subscribe(ts);
        ts.assertOf(SubscriberFusion.<Integer>assertFuseable())
          .assertOf(SubscriberFusion.<Integer>assertFusionMode(QueueSubscription.ASYNC))
          .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",method,
"    @Test
    public void fusedError() {
        TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueSubscription.ANY);
        Flowable.<Integer>error(new TestException()).onBackpressureBuffer().subscribe(ts);
        ts.assertOf(SubscriberFusion.<Integer>assertFuseable())
          .assertOf(SubscriberFusion.<Integer>assertFusionMode(QueueSubscription.ASYNC))
          .assertFailure(TestException.class);
    }",method,
"    @Test
    public void fusedPreconsume() throws Exception {
        TestSubscriber<Integer> ts = Flowable.range(1, 1000 * 1000)
        .onBackpressureBuffer()
        .observeOn(Schedulers.single())
        .test(0L);
        ts.assertEmpty();
        Thread.sleep(100);
        ts.request(1000 * 1000);
        ts
        .awaitDone(5, TimeUnit.SECONDS)
        .assertValueCount(1000 * 1000)
        .assertNoErrors()
        .assertComplete();
    }",method,
"    @Test
    public void emptyDelayError() {
        Flowable.empty()
        .onBackpressureBuffer(true)
        .test()
        .assertResult();
    }",method,
"    @Test
    public void fusionRejected() {
        TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueSubscription.SYNC);
        Flowable.<Integer>never().onBackpressureBuffer().subscribe(ts);
        SubscriberFusion.assertFusion(ts, QueueSubscription.NONE)
        .assertEmpty();
    }",method,
"public class JoinNode
        extends PlanNode
{
    private final Type type;
    private final PlanNode left;
    private final PlanNode right;
    private final List<EquiJoinClause> criteria;
    private final List<Symbol> outputSymbols;
    private final Optional<Expression> filter;
    private final Optional<Symbol> leftHashSymbol;
    private final Optional<Symbol> rightHashSymbol;
    private final Optional<DistributionType> distributionType;
    @JsonCreator
    public JoinNode(@JsonProperty(""id"") PlanNodeId id,
            @JsonProperty(""type"") Type type,
            @JsonProperty(""left"") PlanNode left,
            @JsonProperty(""right"") PlanNode right,
            @JsonProperty(""criteria"") List<EquiJoinClause> criteria,
            @JsonProperty(""outputSymbols"") List<Symbol> outputSymbols,
            @JsonProperty(""filter"") Optional<Expression> filter,
            @JsonProperty(""leftHashSymbol"") Optional<Symbol> leftHashSymbol,
            @JsonProperty(""rightHashSymbol"") Optional<Symbol> rightHashSymbol,
            @JsonProperty(""distributionType"") Optional<DistributionType> distributionType)
    {
        super(id);
        requireNonNull(type, ""type is null"");
        requireNonNull(left, ""left is null"");
        requireNonNull(right, ""right is null"");
        requireNonNull(criteria, ""criteria is null"");
        requireNonNull(outputSymbols, ""outputSymbols is null"");
        requireNonNull(filter, ""filter is null"");
        requireNonNull(leftHashSymbol, ""leftHashSymbol is null"");
        requireNonNull(rightHashSymbol, ""rightHashSymbol is null"");
        requireNonNull(distributionType, ""distributionType is null"");
        this.type = type;
        this.left = left;
        this.right = right;
        this.criteria = ImmutableList.copyOf(criteria);
        this.outputSymbols = ImmutableList.copyOf(outputSymbols);
        this.filter = filter;
        this.leftHashSymbol = leftHashSymbol;
        this.rightHashSymbol = rightHashSymbol;
        this.distributionType = distributionType;
        List<Symbol> inputSymbols = ImmutableList.<Symbol>builder()
                .addAll(left.getOutputSymbols())
                .addAll(right.getOutputSymbols())
                .build();
        checkArgument(new HashSet<>(inputSymbols).containsAll(outputSymbols), ""Left and right join inputs do not contain all output symbols"");
        checkArgument(!isCrossJoin() || inputSymbols.equals(outputSymbols), ""Cross join does not support output symbols pruning or reordering"");
        checkArgument(!(criteria.isEmpty() && leftHashSymbol.isPresent()), ""Left hash symbol is only valid in an equijoin"");
        checkArgument(!(criteria.isEmpty() && rightHashSymbol.isPresent()), ""Right hash symbol is only valid in an equijoin"");
    }
    public enum DistributionType
    {
        PARTITIONED,
        REPLICATED
    }
    public enum Type
    {
        INNER(""InnerJoin""),
        LEFT(""LeftJoin""),
        RIGHT(""RightJoin""),
        FULL(""FullJoin"");
        private final String joinLabel;
        Type(String joinLabel)
        {
            this.joinLabel = joinLabel;
        }
        public String getJoinLabel()
        {
            return joinLabel;
        }
        public static Type typeConvert(Join.Type joinType)
        {
            // Omit SEMI join types because they must be inferred by the planner and not part of the SQL parse tree
            switch (joinType) {
                case CROSS:
                case IMPLICIT:
                case INNER:
                    return Type.INNER;
                case LEFT:
                    return Type.LEFT;
                case RIGHT:
                    return Type.RIGHT;
                case FULL:
                    return Type.FULL;
                default:
                    throw new UnsupportedOperationException(""Unsupported join type: "" + joinType);
            }
        }
    }
    @JsonProperty(""type"")
    public Type getType()
    {
        return type;
    }
    @JsonProperty(""left"")
    public PlanNode getLeft()
    {
        return left;
    }
    @JsonProperty(""right"")
    public PlanNode getRight()
    {
        return right;
    }
    @JsonProperty(""criteria"")
    public List<EquiJoinClause> getCriteria()
    {
        return criteria;
    }
    @JsonProperty(""filter"")
    public Optional<Expression> getFilter()
    {
        return filter;
    }
    public Optional<SortExpressionContext> getSortExpressionContext()
    {
        return filter
                .flatMap(filter -> extractSortExpression(ImmutableSet.copyOf(right.getOutputSymbols()), filter));
    }
    @JsonProperty(""leftHashSymbol"")
    public Optional<Symbol> getLeftHashSymbol()
    {
        return leftHashSymbol;
    }
    @JsonProperty(""rightHashSymbol"")
    public Optional<Symbol> getRightHashSymbol()
    {
        return rightHashSymbol;
    }
    @Override
    public List<PlanNode> getSources()
    {
        return ImmutableList.of(left, right);
    }
    @Override
    @JsonProperty(""outputSymbols"")
    public List<Symbol> getOutputSymbols()
    {
        return outputSymbols;
    }
    @JsonProperty(""distributionType"")
    public Optional<DistributionType> getDistributionType()
    {
        return distributionType;
    }
    @Override
    public <R, C> R accept(PlanVisitor<R, C> visitor, C context)
    {
        return visitor.visitJoin(this, context);
    }
    @Override
    public PlanNode replaceChildren(List<PlanNode> newChildren)
    {
        checkArgument(newChildren.size() == 2, ""expected newChildren to contain 2 nodes"");
        PlanNode newLeft = newChildren.get(0);
        PlanNode newRight = newChildren.get(1);
        // Reshuffle join output symbols (for cross joins) since order of symbols in child nodes might have changed
        List<Symbol> newOutputSymbols = Stream.concat(newLeft.getOutputSymbols().stream(), newRight.getOutputSymbols().stream())
                .filter(outputSymbols::contains)
                .collect(toImmutableList());
        return new JoinNode(getId(), type, newLeft, newRight, criteria, newOutputSymbols, filter, leftHashSymbol, rightHashSymbol, distributionType);
    }
    public boolean isCrossJoin()
    {
        return criteria.isEmpty() && !filter.isPresent() && type == INNER;
    }
    public static class EquiJoinClause
    {
        private final Symbol left;
        private final Symbol right;
        @JsonCreator
        public EquiJoinClause(@JsonProperty(""left"") Symbol left, @JsonProperty(""right"") Symbol right)
        {
            this.left = requireNonNull(left, ""left is null"");
            this.right = requireNonNull(right, ""right is null"");
        }
        @JsonProperty(""left"")
        public Symbol getLeft()
        {
            return left;
        }
        @JsonProperty(""right"")
        public Symbol getRight()
        {
            return right;
        }
        public ComparisonExpression toExpression()
        {
            return new ComparisonExpression(ComparisonExpressionType.EQUAL, left.toSymbolReference(), right.toSymbolReference());
        }
        @Override
        public boolean equals(Object obj)
        {
            if (this == obj) {
                return true;
            }
            if (obj == null || !this.getClass().equals(obj.getClass())) {
                return false;
            }
            EquiJoinClause other = (EquiJoinClause) obj;
            return Objects.equals(this.left, other.left) &&
                    Objects.equals(this.right, other.right);
        }
        @Override
        public int hashCode()
        {
            return Objects.hash(left, right);
        }
    }
}",class,
"    public static class EquiJoinClause
    {
        private final Symbol left;
        private final Symbol right;
        @JsonCreator
        public EquiJoinClause(@JsonProperty(""left"") Symbol left, @JsonProperty(""right"") Symbol right)
        {
            this.left = requireNonNull(left, ""left is null"");
            this.right = requireNonNull(right, ""right is null"");
        }
        @JsonProperty(""left"")
        public Symbol getLeft()
        {
            return left;
        }
        @JsonProperty(""right"")
        public Symbol getRight()
        {
            return right;
        }
        public ComparisonExpression toExpression()
        {
            return new ComparisonExpression(ComparisonExpressionType.EQUAL, left.toSymbolReference(), right.toSymbolReference());
        }
        @Override
        public boolean equals(Object obj)
        {
            if (this == obj) {
                return true;
            }
            if (obj == null || !this.getClass().equals(obj.getClass())) {
                return false;
            }
            EquiJoinClause other = (EquiJoinClause) obj;
            return Objects.equals(this.left, other.left) &&
                    Objects.equals(this.right, other.right);
        }
        @Override
        public int hashCode()
        {
            return Objects.hash(left, right);
        }
    }",class,
"        Type(String joinLabel)
        {
            this.joinLabel = joinLabel;
        }",method,
"        public String getJoinLabel()
        {
            return joinLabel;
        }",method,
"        public static Type typeConvert(Join.Type joinType)
        {
            // Omit SEMI join types because they must be inferred by the planner and not part of the SQL parse tree
            switch (joinType) {
                case CROSS:
                case IMPLICIT:
                case INNER:
                    return Type.INNER;
                case LEFT:
                    return Type.LEFT;
                case RIGHT:
                    return Type.RIGHT;
                case FULL:
                    return Type.FULL;
                default:
                    throw new UnsupportedOperationException(""Unsupported join type: "" + joinType);
            }
        }",method,
"            switch (joinType) {
                case CROSS:
                case IMPLICIT:
                case INNER:
                    return Type.INNER;
                case LEFT:
                    return Type.LEFT;
                case RIGHT:
                    return Type.RIGHT;
                case FULL:
                    return Type.FULL;
                default:
                    throw new UnsupportedOperationException(""Unsupported join type: "" + joinType);
            }",method,
"    @JsonProperty(""type"")
    public Type getType()
    {
        return type;
    }",method,
"    @JsonProperty(""left"")
    public PlanNode getLeft()
    {
        return left;
    }",method,
"    @JsonProperty(""right"")
    public PlanNode getRight()
    {
        return right;
    }",method,
"    @JsonProperty(""criteria"")
    public List<EquiJoinClause> getCriteria()
    {
        return criteria;
    }",method,
"    @JsonProperty(""filter"")
    public Optional<Expression> getFilter()
    {
        return filter;
    }",method,
"    public Optional<SortExpressionContext> getSortExpressionContext()
    {
        return filter
                .flatMap(filter -> extractSortExpression(ImmutableSet.copyOf(right.getOutputSymbols()), filter));
    }",method,
"    @JsonProperty(""leftHashSymbol"")
    public Optional<Symbol> getLeftHashSymbol()
    {
        return leftHashSymbol;
    }",method,
"    @JsonProperty(""rightHashSymbol"")
    public Optional<Symbol> getRightHashSymbol()
    {
        return rightHashSymbol;
    }",method,
"    @Override
    public List<PlanNode> getSources()
    {
        return ImmutableList.of(left, right);
    }",method,
"    @Override
    @JsonProperty(""outputSymbols"")
    public List<Symbol> getOutputSymbols()
    {
        return outputSymbols;
    }",method,
"    @JsonProperty(""distributionType"")
    public Optional<DistributionType> getDistributionType()
    {
        return distributionType;
    }",method,
"    @Override
    public <R, C> R accept(PlanVisitor<R, C> visitor, C context)
    {
        return visitor.visitJoin(this, context);
    }",method,
"    @Override
    public PlanNode replaceChildren(List<PlanNode> newChildren)
    {
        checkArgument(newChildren.size() == 2, ""expected newChildren to contain 2 nodes"");
        PlanNode newLeft = newChildren.get(0);
        PlanNode newRight = newChildren.get(1);
        // Reshuffle join output symbols (for cross joins) since order of symbols in child nodes might have changed
        List<Symbol> newOutputSymbols = Stream.concat(newLeft.getOutputSymbols().stream(), newRight.getOutputSymbols().stream())
                .filter(outputSymbols::contains)
                .collect(toImmutableList());
        return new JoinNode(getId(), type, newLeft, newRight, criteria, newOutputSymbols, filter, leftHashSymbol, rightHashSymbol, distributionType);
    }",method,
"    public boolean isCrossJoin()
    {
        return criteria.isEmpty() && !filter.isPresent() && type == INNER;
    }",method,
"        @JsonProperty(""left"")
        public Symbol getLeft()
        {
            return left;
        }",method,
"        @JsonProperty(""right"")
        public Symbol getRight()
        {
            return right;
        }",method,
"        public ComparisonExpression toExpression()
        {
            return new ComparisonExpression(ComparisonExpressionType.EQUAL, left.toSymbolReference(), right.toSymbolReference());
        }",method,
"        @Override
        public boolean equals(Object obj)
        {
            if (this == obj) {
                return true;
            }
            if (obj == null || !this.getClass().equals(obj.getClass())) {
                return false;
            }
            EquiJoinClause other = (EquiJoinClause) obj;
            return Objects.equals(this.left, other.left) &&
                    Objects.equals(this.right, other.right);
        }",method,
"            if (this == obj) {
                return true;
            }",method,
"        @Override
        public int hashCode()
        {
            return Objects.hash(left, right);
        }",method,
"abstract public class MetaParser {
    static public class LanguageInfo {
        final public String                 name;
        final public LanguageSpecificParser parser;
        final public String                 defaultExpression;
        LanguageInfo(String name, LanguageSpecificParser parser, String defaultExpression) {
            this.name = name;
            this.parser = parser;
            this.defaultExpression = defaultExpression;
        }
    }
    static final protected Map<String, LanguageInfo> s_languages = new HashMap<String, LanguageInfo>();
    // TODO: We should switch from using the internal compiler class 
//    final static private Var CLOJURE_READ_STRING = RT.var(""clojure.core"", ""read-string"");
//    final static private Var CLOJURE_EVAL = RT.var(""clojure.core"", ""eval"");
    static {
        registerLanguageParser(""grel"", ""General Refine Expression Language (GREL)"", new LanguageSpecificParser() {
            @Override
            public Evaluable parse(String s) throws ParsingException {
                return parseGREL(s);
            }
        }, ""value"");
        registerLanguageParser(""clojure"", ""Clojure"", new LanguageSpecificParser() {
            @Override
            public Evaluable parse(String s) throws ParsingException {
                try {
//                    RT.load(""clojure/core""); // Make sure RT is initialized
                    Object foo = RT.CURRENT_NS; // Make sure RT is initialized
                    IFn fn = (IFn) clojure.lang.Compiler.load(new StringReader(
                            ""(fn [value cell cells row rowIndex] "" + s + "")""
                        ));
                    // TODO: We should to switch from using Compiler.load
                    // because it's technically an internal interface
//                    Object code = CLOJURE_READ_STRING.invoke(
//                            ""(fn [value cell cells row rowIndex] "" + s + "")""
//                            );
                    return new Evaluable() {
                        private IFn _fn;
                        public Evaluable init(IFn fn) {
                            _fn = fn;
                            return this;
                        }
                        @Override
                        public Object evaluate(Properties bindings) {
                            try {
                                return _fn.invoke(
                                    bindings.get(""value""),
                                    bindings.get(""cell""),
                                    bindings.get(""cells""),
                                    bindings.get(""row""),
                                    bindings.get(""rowIndex"")
                                );
                            } catch (Exception e) {
                                return new EvalError(e.getMessage());
                            }
                        }
                    }.init(fn);
                } catch (Exception e) {
                    throw new ParsingException(e.getMessage());
                }
            }
        }, ""value"");
    }
    static public void registerLanguageParser(String languagePrefix, String name, LanguageSpecificParser parser, String defaultExpression) {
        s_languages.put(languagePrefix, new LanguageInfo(name, parser, defaultExpression));
    }
    static public LanguageInfo getLanguageInfo(String languagePrefix) {
        return s_languages.get(languagePrefix.toLowerCase());
    }
    static public Set<String> getLanguagePrefixes() {
        return s_languages.keySet();
    }
    static public Evaluable parse(String s) throws ParsingException {
        String language = ""grel"";
        int colon = s.indexOf(':');
        if (colon >= 0) {
            language = s.substring(0, colon).toLowerCase();
            if (""gel"".equals(language)) {
                language = ""grel"";
            }
        }
        LanguageInfo info = s_languages.get(language.toLowerCase());
        if (info != null) {
            return info.parser.parse(s.substring(colon + 1));
        } else {
            return parseGREL(s);
        }
    }
    static protected Evaluable parseGREL(String s) throws ParsingException {
        Parser parser = new Parser(s);
        return parser.getExpression();
    }
}",class,
"    static public class LanguageInfo {
        final public String                 name;
        final public LanguageSpecificParser parser;
        final public String                 defaultExpression;
        LanguageInfo(String name, LanguageSpecificParser parser, String defaultExpression) {
            this.name = name;
            this.parser = parser;
            this.defaultExpression = defaultExpression;
        }
    }",class,
"public class ParsingException extends Exception {
    private static final long serialVersionUID = 155004505172098755L;
    public ParsingException(String message) {
        super(message);
    }
    public ParsingException(String message, Throwable cause) {
        super(message, cause);
    }
}",class,
"        LanguageInfo(String name, LanguageSpecificParser parser, String defaultExpression) {
            this.name = name;
            this.parser = parser;
            this.defaultExpression = defaultExpression;
        }",method,
"            @Override
            public Evaluable parse(String s) throws ParsingException {
                return parseGREL(s);
            }",method,
"        registerLanguageParser(""clojure"", ""Clojure"", new LanguageSpecificParser() {
            @Override
            public Evaluable parse(String s) throws ParsingException {
                try {
//                    RT.load(""clojure/core""); // Make sure RT is initialized
                    Object foo = RT.CURRENT_NS; // Make sure RT is initialized
                    IFn fn = (IFn) clojure.lang.Compiler.load(new StringReader(
                            ""(fn [value cell cells row rowIndex] "" + s + "")""
                        ));
                    // TODO: We should to switch from using Compiler.load
                    // because it's technically an internal interface
//                    Object code = CLOJURE_READ_STRING.invoke(
//                            ""(fn [value cell cells row rowIndex] "" + s + "")""
//                            );
                    return new Evaluable() {
                        private IFn _fn;
                        public Evaluable init(IFn fn) {
                            _fn = fn;
                            return this;
                        }
                        @Override
                        public Object evaluate(Properties bindings) {
                            try {
                                return _fn.invoke(
                                    bindings.get(""value""),
                                    bindings.get(""cell""),
                                    bindings.get(""cells""),
                                    bindings.get(""row""),
                                    bindings.get(""rowIndex"")
                                );
                            } catch (Exception e) {
                                return new EvalError(e.getMessage());
                            }
                        }
                    }.init(fn);
                } catch (Exception e) {
                    throw new ParsingException(e.getMessage());
                }
            }
        }",method,
"            @Override
            public Evaluable parse(String s) throws ParsingException {
                try {
//                    RT.load(""clojure/core""); // Make sure RT is initialized
                    Object foo = RT.CURRENT_NS; // Make sure RT is initialized
                    IFn fn = (IFn) clojure.lang.Compiler.load(new StringReader(
                            ""(fn [value cell cells row rowIndex] "" + s + "")""
                        ));
                    // TODO: We should to switch from using Compiler.load
                    // because it's technically an internal interface
//                    Object code = CLOJURE_READ_STRING.invoke(
//                            ""(fn [value cell cells row rowIndex] "" + s + "")""
//                            );
                    return new Evaluable() {
                        private IFn _fn;
                        public Evaluable init(IFn fn) {
                            _fn = fn;
                            return this;
                        }
                        @Override
                        public Object evaluate(Properties bindings) {
                            try {
                                return _fn.invoke(
                                    bindings.get(""value""),
                                    bindings.get(""cell""),
                                    bindings.get(""cells""),
                                    bindings.get(""row""),
                                    bindings.get(""rowIndex"")
                                );
                            } catch (Exception e) {
                                return new EvalError(e.getMessage());
                            }
                        }
                    }.init(fn);
                } catch (Exception e) {
                    throw new ParsingException(e.getMessage());
                }
            }",method,
"                    return new Evaluable() {
                        private IFn _fn;
                        public Evaluable init(IFn fn) {
                            _fn = fn;
                            return this;
                        }
                        @Override
                        public Object evaluate(Properties bindings) {
                            try {
                                return _fn.invoke(
                                    bindings.get(""value""),
                                    bindings.get(""cell""),
                                    bindings.get(""cells""),
                                    bindings.get(""row""),
                                    bindings.get(""rowIndex"")
                                );
                            } catch (Exception e) {
                                return new EvalError(e.getMessage());
                            }
                        }
                    }",method,
"                        public Evaluable init(IFn fn) {
                            _fn = fn;
                            return this;
                        }",method,
"                        @Override
                        public Object evaluate(Properties bindings) {
                            try {
                                return _fn.invoke(
                                    bindings.get(""value""),
                                    bindings.get(""cell""),
                                    bindings.get(""cells""),
                                    bindings.get(""row""),
                                    bindings.get(""rowIndex"")
                                );
                            } catch (Exception e) {
                                return new EvalError(e.getMessage());
                            }
                        }",method,
"    static public void registerLanguageParser(String languagePrefix, String name, LanguageSpecificParser parser, String defaultExpression) {
        s_languages.put(languagePrefix, new LanguageInfo(name, parser, defaultExpression));
    }",method,
"    static public LanguageInfo getLanguageInfo(String languagePrefix) {
        return s_languages.get(languagePrefix.toLowerCase());
    }",method,
"    static public Set<String> getLanguagePrefixes() {
        return s_languages.keySet();
    }",method,
"    static public Evaluable parse(String s) throws ParsingException {
        String language = ""grel"";
        int colon = s.indexOf(':');
        if (colon >= 0) {
            language = s.substring(0, colon).toLowerCase();
            if (""gel"".equals(language)) {
                language = ""grel"";
            }
        }
        LanguageInfo info = s_languages.get(language.toLowerCase());
        if (info != null) {
            return info.parser.parse(s.substring(colon + 1));
        } else {
            return parseGREL(s);
        }
    }",method,
"        if (colon >= 0) {
            language = s.substring(0, colon).toLowerCase();
            if (""gel"".equals(language)) {
                language = ""grel"";
            }
        }",method,
"        if (info != null) {
            return info.parser.parse(s.substring(colon + 1));
        }",method,
"    static protected Evaluable parseGREL(String s) throws ParsingException {
        Parser parser = new Parser(s);
        return parser.getExpression();
    }",method,
"    public ParsingException(String message) {
        super(message);
    }",method,
"    public ParsingException(String message, Throwable cause) {
        super(message, cause);
    }",method,
"public class SingleClassHierarchy extends ClassHierarchy {
  private final BitSet myCoveredFiles;
  private final BitSet myAmbiguousSupers;
  private final BitSet myAnonymous;
  private final AnchorRepository myClassAnchors;
  private final int[] myClassAnchorsByFileIds;
  private int[] mySubtypes;
  private int[] mySubtypeStarts;
  public SingleClassHierarchy(ClassSymbol[] classSymbols, AnchorRepository classAnchors) {
    classAnchors.trimToSize();
    myClassAnchors = classAnchors;
    myCoveredFiles = calcCoveredFiles(classSymbols);
    myClassAnchorsByFileIds = mkByFileId();
    excludeUncoveredFiles(classSymbols);
    connectSubTypes(classSymbols);
    myAmbiguousSupers = calcAmbiguousSupers(classSymbols);
    myAnonymous = calcAnonymous(classSymbols);
  }
  @NotNull
  private static BitSet calcAmbiguousSupers(ClassSymbol[] classSymbols) {
    BitSet ambiguousSupers = new BitSet();
    for (ClassSymbol symbol : classSymbols) {
      if (!symbol.isHierarchyIncomplete() && symbol.hasAmbiguousSupers()) {
        ambiguousSupers.set(symbol.myAnchorId);
      }
    }
    return ambiguousSupers;
  }
  @NotNull
  private static BitSet calcAnonymous(ClassSymbol[] classSymbols) {
    BitSet answer = new BitSet();
    for (ClassSymbol symbol : classSymbols) {
      if (!symbol.isHierarchyIncomplete() && symbol.myShortName == NameEnvironment.NO_NAME) {
        answer.set(symbol.myAnchorId);
      }
    }
    return answer;
  }
  @NotNull
  private BitSet calcCoveredFiles(ClassSymbol[] classSymbols) {
    BitSet problematicFiles = new BitSet();
    BitSet coveredFiles = new BitSet();
    for (ClassSymbol symbol : classSymbols) {
      int fileId = myClassAnchors.getFileId(symbol.myAnchorId);
      coveredFiles.set(fileId);
      if (symbol.isHierarchyIncomplete()) {
        problematicFiles.set(fileId);
      }
    }
    coveredFiles.andNot(problematicFiles);
    return coveredFiles;
  }
  private boolean isCovered(@NotNull StubClassAnchor anchor) {
    return myCoveredFiles.get(anchor.myFileId);
  }
  @Override
  @NotNull
  public List<StubClassAnchor> getCoveredClasses() {
    return ContainerUtil.filter(getAllClasses(), this::isCovered);
  }
  @Override
  @NotNull
  public List<StubClassAnchor> getAllClasses() {
    return IntStream.range(0, myClassAnchors.size()).boxed().map(myClassAnchors::getAnchor).collect(Collectors.toList());
  }
  @NotNull
  @Override
  public SmartClassAnchor[] getDirectSubtypeCandidates(@NotNull PsiClass psiClass) {
    SmartClassAnchor anchor = findAnchor(psiClass);
    return anchor == null ? StubClassAnchor.EMPTY_ARRAY : getDirectSubtypeCandidates(anchor);
  }
  @Override
  @Nullable
  public SmartClassAnchor findAnchor(@NotNull PsiClass psiClass) {
    VirtualFile vFile = psiClass.getContainingFile().getVirtualFile();
    return vFile instanceof VirtualFileWithId ? forPsiClass(((VirtualFileWithId)vFile).getId(), psiClass) : null;
  }
  @NotNull
  @Override
  public SmartClassAnchor[] getDirectSubtypeCandidates(@NotNull SmartClassAnchor anchor) {
    int symbolId = ((StubClassAnchor)anchor).myId;
    int start = subtypeStart(symbolId);
    int end = subtypeEnd(symbolId);
    int length = end - start;
    if (length == 0) {
      return StubClassAnchor.EMPTY_ARRAY;
    }
    StubClassAnchor[] result = new StubClassAnchor[length];
    for (int i = 0; i < length; i++) {
      result[i] = myClassAnchors.getAnchor(mySubtypes[start + i]);
    }
    return result;
  }
  @Override
  public boolean hasAmbiguousSupers(@NotNull SmartClassAnchor anchor) {
    return myAmbiguousSupers.get(((StubClassAnchor)anchor).myId);
  }
  @Override
  public boolean isAnonymous(@NotNull SmartClassAnchor anchor) {
    return myAnonymous.get(((StubClassAnchor)anchor).myId);
  }
  @NotNull
  @Override
  public GlobalSearchScope restrictToUncovered(@NotNull GlobalSearchScope scope) {
    if (myCoveredFiles.isEmpty()) {
      return scope;
    }
    return new DelegatingGlobalSearchScope(scope, this) {
      @Override
      public boolean contains(@NotNull VirtualFile file) {
        if (file instanceof VirtualFileWithId && myCoveredFiles.get(((VirtualFileWithId)file).getId())) {
          return false;
        }
        return super.contains(file);
      }
    };
  }
  @NotNull
  private Integer[] getAnchorsFromDistinctFiles() {
    if (myClassAnchors.size() == 0) return new Integer[0];
    Integer[] result = new Integer[myClassAnchors.size()];
    result[0] = 0;
    int i = 1;
    for (int classAnchor = 1; classAnchor < result.length; classAnchor++) {
      if (myClassAnchors.getFileId(classAnchor - 1) != myClassAnchors.getFileId(classAnchor)) {
        result[i++] = classAnchor;
      }
    }
    return Arrays.copyOf(result, i);
  }
  private int[] mkByFileId() {
    // using a boxed array since there seems to be no easy way to sort int[] with custom comparator
    Integer[] ids = getAnchorsFromDistinctFiles();
    Arrays.sort(ids, (a1, a2) -> Integer.compare(myClassAnchors.getFileId(a1), myClassAnchors.getFileId(a2)));
    return ArrayUtils.toPrimitive(ids);
  }
  private void connectSubTypes(ClassSymbol[] classSymbols) {
    int[] sizes = calculateSizes(classSymbols);
    int[] starts = new int[classSymbols.length];
    int count = 0;
    for (int i = 0; i < sizes.length; i++) {
      starts[i] = count;
      count += sizes[i];
    }
    int[] subtypes = new int[count];
    int[] filled = new int[sizes.length];
    for (int subTypeId = 0; subTypeId < classSymbols.length; subTypeId++) {
      ClassSymbol subType = classSymbols[subTypeId];
      for (ClassSymbol superType : subType.rawSuperClasses()) {
        int superTypeId = superType.myAnchorId;
        subtypes[starts[superTypeId] + filled[superTypeId]] = subTypeId;
        filled[superTypeId] += 1;
      }
    }
    this.mySubtypes = subtypes;
    this.mySubtypeStarts = starts;
  }
  private void excludeUncoveredFiles(ClassSymbol[] classSymbols) {
    for (ClassSymbol symbol : classSymbols) {
      if (!myCoveredFiles.get(myClassAnchors.getFileId(symbol.myAnchorId))) {
        symbol.markHierarchyIncomplete();
      }
    }
  }
  private static int[] calculateSizes(ClassSymbol[] classSymbols) {
    int[] sizes = new int[classSymbols.length];
    for (ClassSymbol subType : classSymbols) {
      for (ClassSymbol superType : subType.rawSuperClasses()) {
        sizes[superType.myAnchorId] += 1;
      }
    }
    return sizes;
  }
  private int subtypeStart(int nameId) {
    return mySubtypeStarts[nameId];
  }
  private int subtypeEnd(int nameId) {
    return (nameId + 1 >= mySubtypeStarts.length) ? mySubtypes.length : mySubtypeStarts[nameId + 1];
  }
  private StubClassAnchor forPsiClass(int fileId, PsiClass psiClass) {
    int id = getFirst(fileId);
    if (id == -1) {
      return null;
    }
    while (id < myClassAnchors.size() && myClassAnchors.getFileId(id) == fileId) {
      if (psiClass.isEquivalentTo(myClassAnchors.retrieveClass(psiClass.getProject(), id))) {
        return myClassAnchors.getAnchor(id);
      }
      id++;
    }
    return null;
  }
  private int getFirst(int fileId) {
    int lo = 0;
    int hi = myClassAnchorsByFileIds.length - 1;
    while (lo <= hi) {
      int mid = lo + (hi - lo) / 2;
      int midFileId = myClassAnchors.getFileId(myClassAnchorsByFileIds[mid]);
      if      (fileId < midFileId) hi = mid - 1;
      else if (fileId > midFileId) lo = mid + 1;
      else return myClassAnchorsByFileIds[mid];
    }
    return -1;
  }
}",class,
"  public SingleClassHierarchy(ClassSymbol[] classSymbols, AnchorRepository classAnchors) {
    classAnchors.trimToSize();
    myClassAnchors = classAnchors;
    myCoveredFiles = calcCoveredFiles(classSymbols);
    myClassAnchorsByFileIds = mkByFileId();
    excludeUncoveredFiles(classSymbols);
    connectSubTypes(classSymbols);
    myAmbiguousSupers = calcAmbiguousSupers(classSymbols);
    myAnonymous = calcAnonymous(classSymbols);
  }",method,
"  @NotNull
  private static BitSet calcAmbiguousSupers(ClassSymbol[] classSymbols) {
    BitSet ambiguousSupers = new BitSet();
    for (ClassSymbol symbol : classSymbols) {
      if (!symbol.isHierarchyIncomplete() && symbol.hasAmbiguousSupers()) {
        ambiguousSupers.set(symbol.myAnchorId);
      }
    }
    return ambiguousSupers;
  }",method,

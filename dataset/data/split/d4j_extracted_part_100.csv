code_snippet,type,score
"        if (obj instanceof Fixnum) {
                try {
            elements[index] = ((Fixnum)obj).value;
        }
        catch (ArrayIndexOutOfBoundsException e) {
            badIndex(index, capacity);
        }
        }",method,
"        catch (ArrayIndexOutOfBoundsException e) {
            badIndex(index, capacity);
        }",method,
"    @Override
    public LispObject subseq(int start, int end)
    {
        BasicVector_UnsignedByte16 v = new BasicVector_UnsignedByte16(end - start);
        int i = start, j = 0;
        try {
            while (i < end)
                v.elements[j++] = elements[i++];
            return v;
        }
        catch (ArrayIndexOutOfBoundsException e) {
            return error(new TypeError(""Array index out of bounds: "" + i + "".""));
        }
    }",method,
"        catch (ArrayIndexOutOfBoundsException e) {
            return error(new TypeError(""Array index out of bounds: "" + i + "".""));
        }",method,
"    @Override
    public void fill(LispObject obj)
    {
        int n = Fixnum.getValue(obj);
        for (int i = capacity; i-- > 0;)
            elements[i] = n;
    }",method,
"    @Override
    public void shrink(int n)
    {
        if (n < capacity) {
            int[] newArray = new int[n];
            System.arraycopy(elements, 0, newArray, 0, n);
            elements = newArray;
            capacity = n;
            return;
        }
        if (n == capacity)
            return;
        error(new LispError());
    }",method,
"        if (n < capacity) {
            int[] newArray = new int[n];
            System.arraycopy(elements, 0, newArray, 0, n);
            elements = newArray;
            capacity = n;
            return;
        }",method,
"    @Override
    public LispObject reverse()
    {
        BasicVector_UnsignedByte16 result = new BasicVector_UnsignedByte16(capacity);
        int i, j;
        for (i = 0, j = capacity - 1; i < capacity; i++, j--)
            result.elements[i] = elements[j];
        return result;
    }",method,
"    @Override
    public LispObject nreverse()
    {
        int i = 0;
        int j = capacity - 1;
        while (i < j) {
            int temp = elements[i];
            elements[i] = elements[j];
            elements[j] = temp;
            ++i;
            --j;
        }
        return this;
    }",method,
"        while (i < j) {
            int temp = elements[i];
            elements[i] = elements[j];
            elements[j] = temp;
            ++i;
            --j;
        }",method,
"    @Override
    public AbstractVector adjustArray(int newCapacity,
                                       LispObject initialElement,
                                       LispObject initialContents)
    {
        if (initialContents != null) {
            LispObject[] newElements = new LispObject[newCapacity];
            if (initialContents.listp()) {
                LispObject list = initialContents;
                for (int i = 0; i < newCapacity; i++) {
                    newElements[i] = list.car();
                    list = list.cdr();
                }
            } else if (initialContents.vectorp()) {
                for (int i = 0; i < newCapacity; i++)
                    newElements[i] = initialContents.elt(i);
            } else
                type_error(initialContents, Symbol.SEQUENCE);
            return new BasicVector_UnsignedByte16(newElements);
        }
        if (capacity != newCapacity) {
            LispObject[] newElements = new LispObject[newCapacity];
            System.arraycopy(elements, 0, newElements, 0,
                             Math.min(capacity, newCapacity));
            if (initialElement != null)
                for (int i = capacity; i < newCapacity; i++)
                    newElements[i] = initialElement;
            return new BasicVector_UnsignedByte16(newElements);
        }
        // No change.
        return this;
    }",method,
"        if (initialContents != null) {
            LispObject[] newElements = new LispObject[newCapacity];
            if (initialContents.listp()) {
                LispObject list = initialContents;
                for (int i = 0; i < newCapacity; i++) {
                    newElements[i] = list.car();
                    list = list.cdr();
                }
            } else if (initialContents.vectorp()) {
                for (int i = 0; i < newCapacity; i++)
                    newElements[i] = initialContents.elt(i);
            } else
                type_error(initialContents, Symbol.SEQUENCE);
            return new BasicVector_UnsignedByte16(newElements);
        }",method,
"                for (int i = 0; i < newCapacity; i++) {
                    newElements[i] = list.car();
                    list = list.cdr();
                }",method,
"        if (capacity != newCapacity) {
            LispObject[] newElements = new LispObject[newCapacity];
            System.arraycopy(elements, 0, newElements, 0,
                             Math.min(capacity, newCapacity));
            if (initialElement != null)
                for (int i = capacity; i < newCapacity; i++)
                    newElements[i] = initialElement;
            return new BasicVector_UnsignedByte16(newElements);
        }",method,
"    @Override
    public AbstractVector adjustArray(int newCapacity,
                                       AbstractArray displacedTo,
                                       int displacement)
    {
        return new ComplexVector(newCapacity, displacedTo, displacement);
    }",method,
"public class OracleSelectTest7 extends OracleTest {
    public void test_0() throws Exception {
        String sql = ""SELECT * FROM employees "" + //
                     ""   WHERE department_id NOT IN "" + //
                     ""   (SELECT department_id FROM departments "" + //
                     ""       WHERE location_id = 1700)"" + //
                     ""   ORDER BY last_name;"";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement stmt = statementList.get(0);
        print(statementList);
        Assert.assertEquals(1, statementList.size());
        OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
        stmt.accept(visitor);
        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
        System.out.println(""coditions : "" + visitor.getConditions());
        System.out.println(""relationships : "" + visitor.getRelationships());
        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
        Assert.assertEquals(2, visitor.getTables().size());
        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name(""departments"")));
        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name(""employees"")));
        Assert.assertEquals(5, visitor.getColumns().size());
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""departments"", ""department_id"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""employees"", ""last_name"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""departments"", ""location_id"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""employees"", ""*"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""employees"", ""department_id"")));
        Assert.assertTrue(visitor.getOrderByColumns().contains(new TableStat.Column(""employees"", ""last_name"")));
    }
}",class,
"    public void test_0() throws Exception {
        String sql = ""SELECT * FROM employees "" + //
                     ""   WHERE department_id NOT IN "" + //
                     ""   (SELECT department_id FROM departments "" + //
                     ""       WHERE location_id = 1700)"" + //
                     ""   ORDER BY last_name;"";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement stmt = statementList.get(0);
        print(statementList);
        Assert.assertEquals(1, statementList.size());
        OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
        stmt.accept(visitor);
        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
        System.out.println(""coditions : "" + visitor.getConditions());
        System.out.println(""relationships : "" + visitor.getRelationships());
        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
        Assert.assertEquals(2, visitor.getTables().size());
        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name(""departments"")));
        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name(""employees"")));
        Assert.assertEquals(5, visitor.getColumns().size());
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""departments"", ""department_id"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""employees"", ""last_name"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""departments"", ""location_id"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""employees"", ""*"")));
        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""employees"", ""department_id"")));
        Assert.assertTrue(visitor.getOrderByColumns().contains(new TableStat.Column(""employees"", ""last_name"")));
    }",method,
"public class ExecutionEnvironment extends UserDataHolderBase implements Disposable {
  private static final AtomicLong myIdHolder = new AtomicLong(1L);
  @NotNull private final Project myProject;
  @NotNull private RunProfile myRunProfile;
  @NotNull private final Executor myExecutor;
  @NotNull private ExecutionTarget myTarget;
  @Nullable private RunnerSettings myRunnerSettings;
  @Nullable private ConfigurationPerRunnerSettings myConfigurationSettings;
  @Nullable private final RunnerAndConfigurationSettings myRunnerAndConfigurationSettings;
  @Nullable private RunContentDescriptor myContentToReuse;
  private final ProgramRunner<?> myRunner;
  private long myExecutionId = 0;
  @Nullable private DataContext myDataContext;
  @TestOnly
  public ExecutionEnvironment() {
    myProject = null;
    myContentToReuse = null;
    myRunnerAndConfigurationSettings = null;
    myExecutor = null;
    myRunner = null;
  }
  public ExecutionEnvironment(@NotNull Executor executor,
                              @NotNull ProgramRunner runner,
                              @NotNull RunnerAndConfigurationSettings settings,
                              @NotNull Project project) {
    this(settings.getConfiguration(),
         executor,
         DefaultExecutionTarget.INSTANCE,
         project,
         settings.getRunnerSettings(runner),
         settings.getConfigurationSettings(runner),
         null,
         settings,
         runner);
  }
  ExecutionEnvironment(@NotNull RunProfile runProfile,
                       @NotNull Executor executor,
                       @NotNull ExecutionTarget target,
                       @NotNull Project project,
                       @Nullable RunnerSettings runnerSettings,
                       @Nullable ConfigurationPerRunnerSettings configurationSettings,
                       @Nullable RunContentDescriptor contentToReuse,
                       @Nullable RunnerAndConfigurationSettings settings,
                       @NotNull ProgramRunner<?> runner) {
    myExecutor = executor;
    myTarget = target;
    myRunProfile = runProfile;
    myRunnerSettings = runnerSettings;
    myConfigurationSettings = configurationSettings;
    myProject = project;
    setContentToReuse(contentToReuse);
    myRunnerAndConfigurationSettings = settings;
    myRunner = runner;
  }
  @Override
  public void dispose() {
    myContentToReuse = null;
  }
  @NotNull
  public Project getProject() {
    return myProject;
  }
  @NotNull
  public ExecutionTarget getExecutionTarget() {
    return myTarget;
  }
  @NotNull
  public RunProfile getRunProfile() {
    return myRunProfile;
  }
  @Nullable
  public RunnerAndConfigurationSettings getRunnerAndConfigurationSettings() {
    return myRunnerAndConfigurationSettings;
  }
  @Nullable
  public RunContentDescriptor getContentToReuse() {
    return myContentToReuse;
  }
  public void setContentToReuse(@Nullable RunContentDescriptor contentToReuse) {
    myContentToReuse = contentToReuse;
    if (contentToReuse != null) {
      Disposer.register(contentToReuse, this);
    }
  }
  @NotNull
  public ProgramRunner<?> getRunner() {
    return myRunner;
  }
  @Nullable
  public RunnerSettings getRunnerSettings() {
    return myRunnerSettings;
  }
  @Nullable
  public ConfigurationPerRunnerSettings getConfigurationSettings() {
    return myConfigurationSettings;
  }
  @Nullable
  public RunProfileState getState() throws ExecutionException {
    return myRunProfile.getState(myExecutor, this);
  }
  public long assignNewExecutionId() {
    myExecutionId = myIdHolder.incrementAndGet();
    return myExecutionId;
  }
  public void setExecutionId(long executionId) {
    myExecutionId = executionId;
  }
  public long getExecutionId() {
    return myExecutionId;
  }
  @NotNull
  public Executor getExecutor() {
    return myExecutor;
  }
  @Override
  public String toString() {
    if (myRunnerAndConfigurationSettings != null) {
      return myRunnerAndConfigurationSettings.getName();
    }
    else if (myRunProfile != null) {
      return myRunProfile.getName();
    }
    else if (myContentToReuse != null) {
      return myContentToReuse.getDisplayName();
    }
    return super.toString();
  }
  void setDataContext(@NotNull DataContext dataContext) {
    myDataContext = CachingDataContext.cacheIfNeed(dataContext);
  }
  @Nullable
  public DataContext getDataContext() {
    return myDataContext;
  }
  private static class CachingDataContext implements DataContext {
    private static final DataKey[] keys = {PROJECT, PROJECT_FILE_DIRECTORY, EDITOR, VIRTUAL_FILE, MODULE, PSI_FILE};
    private final Map<String, Object> values = new HashMap<>();
    @NotNull
    static CachingDataContext cacheIfNeed(@NotNull DataContext context) {
      if (context instanceof CachingDataContext)
        return (CachingDataContext)context;
      return new CachingDataContext(context);
    }
    private CachingDataContext(DataContext context) {
      for (DataKey key : keys) {
        values.put(key.getName(), key.getData(context));
      }
    }
    @Override
    public Object getData(@NonNls String dataId) {
        return values.get(dataId);
    }
  }
}",class,
"  private static class CachingDataContext implements DataContext {
    private static final DataKey[] keys = {PROJECT, PROJECT_FILE_DIRECTORY, EDITOR, VIRTUAL_FILE, MODULE, PSI_FILE};
    private final Map<String, Object> values = new HashMap<>();
    @NotNull
    static CachingDataContext cacheIfNeed(@NotNull DataContext context) {
      if (context instanceof CachingDataContext)
        return (CachingDataContext)context;
      return new CachingDataContext(context);
    }
    private CachingDataContext(DataContext context) {
      for (DataKey key : keys) {
        values.put(key.getName(), key.getData(context));
      }
    }
    @Override
    public Object getData(@NonNls String dataId) {
        return values.get(dataId);
    }
  }",class,
"  @Nullable private DataContext myDataContext;
  @TestOnly
  public ExecutionEnvironment() {
    myProject = null;
    myContentToReuse = null;
    myRunnerAndConfigurationSettings = null;
    myExecutor = null;
    myRunner = null;
  }",method,
"  public ExecutionEnvironment(@NotNull Executor executor,
                              @NotNull ProgramRunner runner,
                              @NotNull RunnerAndConfigurationSettings settings,
                              @NotNull Project project) {
    this(settings.getConfiguration(),
         executor,
         DefaultExecutionTarget.INSTANCE,
         project,
         settings.getRunnerSettings(runner),
         settings.getConfigurationSettings(runner),
         null,
         settings,
         runner);
  }",method,
"  ExecutionEnvironment(@NotNull RunProfile runProfile,
                       @NotNull Executor executor,
                       @NotNull ExecutionTarget target,
                       @NotNull Project project,
                       @Nullable RunnerSettings runnerSettings,
                       @Nullable ConfigurationPerRunnerSettings configurationSettings,
                       @Nullable RunContentDescriptor contentToReuse,
                       @Nullable RunnerAndConfigurationSettings settings,
                       @NotNull ProgramRunner<?> runner) {
    myExecutor = executor;
    myTarget = target;
    myRunProfile = runProfile;
    myRunnerSettings = runnerSettings;
    myConfigurationSettings = configurationSettings;
    myProject = project;
    setContentToReuse(contentToReuse);
    myRunnerAndConfigurationSettings = settings;
    myRunner = runner;
  }",method,
"  @Override
  public void dispose() {
    myContentToReuse = null;
  }",method,
"  @NotNull
  public Project getProject() {
    return myProject;
  }",method,
"  @NotNull
  public ExecutionTarget getExecutionTarget() {
    return myTarget;
  }",method,
"  @NotNull
  public RunProfile getRunProfile() {
    return myRunProfile;
  }",method,
"  @Nullable
  public RunnerAndConfigurationSettings getRunnerAndConfigurationSettings() {
    return myRunnerAndConfigurationSettings;
  }",method,
"  @Nullable
  public RunContentDescriptor getContentToReuse() {
    return myContentToReuse;
  }",method,
"  public void setContentToReuse(@Nullable RunContentDescriptor contentToReuse) {
    myContentToReuse = contentToReuse;
    if (contentToReuse != null) {
      Disposer.register(contentToReuse, this);
    }
  }",method,
"    if (contentToReuse != null) {
      Disposer.register(contentToReuse, this);
    }",method,
"  @NotNull
  public ProgramRunner<?> getRunner() {
    return myRunner;
  }",method,
"  @Nullable
  public RunnerSettings getRunnerSettings() {
    return myRunnerSettings;
  }",method,
"  @Nullable
  public ConfigurationPerRunnerSettings getConfigurationSettings() {
    return myConfigurationSettings;
  }",method,
"  @Nullable
  public RunProfileState getState() throws ExecutionException {
    return myRunProfile.getState(myExecutor, this);
  }",method,
"  public long assignNewExecutionId() {
    myExecutionId = myIdHolder.incrementAndGet();
    return myExecutionId;
  }",method,
"  public void setExecutionId(long executionId) {
    myExecutionId = executionId;
  }",method,
"  public long getExecutionId() {
    return myExecutionId;
  }",method,
"  @NotNull
  public Executor getExecutor() {
    return myExecutor;
  }",method,
"  @Override
  public String toString() {
    if (myRunnerAndConfigurationSettings != null) {
      return myRunnerAndConfigurationSettings.getName();
    }
    else if (myRunProfile != null) {
      return myRunProfile.getName();
    }
    else if (myContentToReuse != null) {
      return myContentToReuse.getDisplayName();
    }
    return super.toString();
  }",method,
"    if (myRunnerAndConfigurationSettings != null) {
      return myRunnerAndConfigurationSettings.getName();
    }",method,
"    else if (myRunProfile != null) {
      return myRunProfile.getName();
    }",method,
"    else if (myContentToReuse != null) {
      return myContentToReuse.getDisplayName();
    }",method,
"  void setDataContext(@NotNull DataContext dataContext) {
    myDataContext = CachingDataContext.cacheIfNeed(dataContext);
  }",method,
"  @Nullable
  public DataContext getDataContext() {
    return myDataContext;
  }",method,
"    @NotNull
    static CachingDataContext cacheIfNeed(@NotNull DataContext context) {
      if (context instanceof CachingDataContext)
        return (CachingDataContext)context;
      return new CachingDataContext(context);
    }",method,
"    private CachingDataContext(DataContext context) {
      for (DataKey key : keys) {
        values.put(key.getName(), key.getData(context));
      }
    }",method,
"      for (DataKey key : keys) {
        values.put(key.getName(), key.getData(context));
      }",method,
"    @Override
    public Object getData(@NonNls String dataId) {
        return values.get(dataId);
    }",method,
"public class MappingFileProvider implements Externalizable {
  private int numOfEntries = 0;
  private int[] countryCallingCodes;
  private List<Set<String>> availableLanguages;
  private static final Map<String, String> LOCALE_NORMALIZATION_MAP;
  static {
    Map<String, String> normalizationMap = new HashMap<String, String>();
    normalizationMap.put(""zh_TW"", ""zh_Hant"");
    normalizationMap.put(""zh_HK"", ""zh_Hant"");
    normalizationMap.put(""zh_MO"", ""zh_Hant"");
    LOCALE_NORMALIZATION_MAP = Collections.unmodifiableMap(normalizationMap);
  }
  public MappingFileProvider() {
  }
  public void readFileConfigs(SortedMap<Integer, Set<String>> availableDataFiles) {
    numOfEntries = availableDataFiles.size();
    countryCallingCodes = new int[numOfEntries];
    availableLanguages = new ArrayList<Set<String>>(numOfEntries);
    int index = 0;
    for (int countryCallingCode : availableDataFiles.keySet()) {
      countryCallingCodes[index++] = countryCallingCode;
      availableLanguages.add(new HashSet<String>(availableDataFiles.get(countryCallingCode)));
    }
  }
  public void readExternal(ObjectInput objectInput) throws IOException {
    numOfEntries = objectInput.readInt();
    if (countryCallingCodes == null || countryCallingCodes.length < numOfEntries) {
      countryCallingCodes = new int[numOfEntries];
    }
    if (availableLanguages == null) {
      availableLanguages = new ArrayList<Set<String>>();
    }
    for (int i = 0; i < numOfEntries; i++) {
      countryCallingCodes[i] = objectInput.readInt();
      int numOfLangs = objectInput.readInt();
      Set<String> setOfLangs = new HashSet<String>();
      for (int j = 0; j < numOfLangs; j++) {
        setOfLangs.add(objectInput.readUTF());
      }
      availableLanguages.add(setOfLangs);
    }
  }
  public void writeExternal(ObjectOutput objectOutput) throws IOException {
    objectOutput.writeInt(numOfEntries);
    for (int i = 0; i < numOfEntries; i++) {
      objectOutput.writeInt(countryCallingCodes[i]);
      Set<String> setOfLangs = availableLanguages.get(i);
      int numOfLangs = setOfLangs.size();
      objectOutput.writeInt(numOfLangs);
      for (String lang : setOfLangs) {
        objectOutput.writeUTF(lang);
      }
    }
  }
  @Override
  public String toString() {
    StringBuilder output = new StringBuilder();
    for (int i = 0; i < numOfEntries; i++) {
      output.append(countryCallingCodes[i]);
      output.append('|');
      SortedSet<String> sortedSetOfLangs = new TreeSet<String>(availableLanguages.get(i));
      for (String lang : sortedSetOfLangs) {
        output.append(lang);
        output.append(',');
      }
      output.append('\n');
    }
    return output.toString();
  }
  String getFileName(int countryCallingCode, String language, String script, String region) {
    if (language.length() == 0) {
      return """";
    }
    int index = Arrays.binarySearch(countryCallingCodes, countryCallingCode);
    if (index < 0) {
      return """";
    }
    Set<String> setOfLangs = availableLanguages.get(index);
    if (setOfLangs.size() > 0) {
      String languageCode = findBestMatchingLanguageCode(setOfLangs, language, script, region);
      if (languageCode.length() > 0) {
        StringBuilder fileName = new StringBuilder();
        fileName.append(countryCallingCode).append('_').append(languageCode);
        return fileName.toString();
      }
    }
    return """";
  }
  private String findBestMatchingLanguageCode(
      Set<String> setOfLangs, String language, String script, String region) {
    StringBuilder fullLocale = constructFullLocale(language, script, region);
    String fullLocaleStr = fullLocale.toString();
    String normalizedLocale = LOCALE_NORMALIZATION_MAP.get(fullLocaleStr);
    if (normalizedLocale != null) {
      if (setOfLangs.contains(normalizedLocale)) {
        return normalizedLocale;
      }
    }
    if (setOfLangs.contains(fullLocaleStr)) {
      return fullLocaleStr;
    }
    if (onlyOneOfScriptOrRegionIsEmpty(script, region)) {
      if (setOfLangs.contains(language)) {
        return language;
      }
    } else if (script.length() > 0 && region.length() > 0) {
      StringBuilder langWithScript = new StringBuilder(language).append('_').append(script);
      String langWithScriptStr = langWithScript.toString();
      if (setOfLangs.contains(langWithScriptStr)) {
        return langWithScriptStr;
      }
      StringBuilder langWithRegion = new StringBuilder(language).append('_').append(region);
      String langWithRegionStr = langWithRegion.toString();
      if (setOfLangs.contains(langWithRegionStr)) {
        return langWithRegionStr;
      }
      if (setOfLangs.contains(language)) {
        return language;
      }
    }
    return """";
  }
  private boolean onlyOneOfScriptOrRegionIsEmpty(String script, String region) {
    return (script.length() == 0 && region.length() > 0)
        || (region.length() == 0 && script.length() > 0);
  }
  private StringBuilder constructFullLocale(String language, String script, String region) {
    StringBuilder fullLocale = new StringBuilder(language);
    appendSubsequentLocalePart(script, fullLocale);
    appendSubsequentLocalePart(region, fullLocale);
    return fullLocale;
  }
  private void appendSubsequentLocalePart(String subsequentLocalePart, StringBuilder fullLocale) {
    if (subsequentLocalePart.length() > 0) {
      fullLocale.append('_').append(subsequentLocalePart);
    }
  }
}",class,
"  public MappingFileProvider() {
  }",method,
"  public void readFileConfigs(SortedMap<Integer, Set<String>> availableDataFiles) {
    numOfEntries = availableDataFiles.size();
    countryCallingCodes = new int[numOfEntries];
    availableLanguages = new ArrayList<Set<String>>(numOfEntries);
    int index = 0;
    for (int countryCallingCode : availableDataFiles.keySet()) {
      countryCallingCodes[index++] = countryCallingCode;
      availableLanguages.add(new HashSet<String>(availableDataFiles.get(countryCallingCode)));
    }
  }",method,
"  public void readExternal(ObjectInput objectInput) throws IOException {
    numOfEntries = objectInput.readInt();
    if (countryCallingCodes == null || countryCallingCodes.length < numOfEntries) {
      countryCallingCodes = new int[numOfEntries];
    }
    if (availableLanguages == null) {
      availableLanguages = new ArrayList<Set<String>>();
    }
    for (int i = 0; i < numOfEntries; i++) {
      countryCallingCodes[i] = objectInput.readInt();
      int numOfLangs = objectInput.readInt();
      Set<String> setOfLangs = new HashSet<String>();
      for (int j = 0; j < numOfLangs; j++) {
        setOfLangs.add(objectInput.readUTF());
      }
      availableLanguages.add(setOfLangs);
    }
  }",method,
"    if (countryCallingCodes == null || countryCallingCodes.length < numOfEntries) {
      countryCallingCodes = new int[numOfEntries];
    }",method,
"    if (availableLanguages == null) {
      availableLanguages = new ArrayList<Set<String>>();
    }",method,
"    for (int i = 0; i < numOfEntries; i++) {
      countryCallingCodes[i] = objectInput.readInt();
      int numOfLangs = objectInput.readInt();
      Set<String> setOfLangs = new HashSet<String>();
      for (int j = 0; j < numOfLangs; j++) {
        setOfLangs.add(objectInput.readUTF());
      }
      availableLanguages.add(setOfLangs);
    }",method,
"      for (int j = 0; j < numOfLangs; j++) {
        setOfLangs.add(objectInput.readUTF());
      }",method,
"  public void writeExternal(ObjectOutput objectOutput) throws IOException {
    objectOutput.writeInt(numOfEntries);
    for (int i = 0; i < numOfEntries; i++) {
      objectOutput.writeInt(countryCallingCodes[i]);
      Set<String> setOfLangs = availableLanguages.get(i);
      int numOfLangs = setOfLangs.size();
      objectOutput.writeInt(numOfLangs);
      for (String lang : setOfLangs) {
        objectOutput.writeUTF(lang);
      }
    }
  }",method,
"    for (int i = 0; i < numOfEntries; i++) {
      objectOutput.writeInt(countryCallingCodes[i]);
      Set<String> setOfLangs = availableLanguages.get(i);
      int numOfLangs = setOfLangs.size();
      objectOutput.writeInt(numOfLangs);
      for (String lang : setOfLangs) {
        objectOutput.writeUTF(lang);
      }
    }",method,
"      for (String lang : setOfLangs) {
        objectOutput.writeUTF(lang);
      }",method,
"  @Override
  public String toString() {
    StringBuilder output = new StringBuilder();
    for (int i = 0; i < numOfEntries; i++) {
      output.append(countryCallingCodes[i]);
      output.append('|');
      SortedSet<String> sortedSetOfLangs = new TreeSet<String>(availableLanguages.get(i));
      for (String lang : sortedSetOfLangs) {
        output.append(lang);
        output.append(',');
      }
      output.append('\n');
    }
    return output.toString();
  }",method,
"    for (int i = 0; i < numOfEntries; i++) {
      output.append(countryCallingCodes[i]);
      output.append('|');
      SortedSet<String> sortedSetOfLangs = new TreeSet<String>(availableLanguages.get(i));
      for (String lang : sortedSetOfLangs) {
        output.append(lang);
        output.append(',');
      }
      output.append('\n');
    }",method,
"      for (String lang : sortedSetOfLangs) {
        output.append(lang);
        output.append(',');
      }",method,
"  String getFileName(int countryCallingCode, String language, String script, String region) {
    if (language.length() == 0) {
      return """";
    }
    int index = Arrays.binarySearch(countryCallingCodes, countryCallingCode);
    if (index < 0) {
      return """";
    }
    Set<String> setOfLangs = availableLanguages.get(index);
    if (setOfLangs.size() > 0) {
      String languageCode = findBestMatchingLanguageCode(setOfLangs, language, script, region);
      if (languageCode.length() > 0) {
        StringBuilder fileName = new StringBuilder();
        fileName.append(countryCallingCode).append('_').append(languageCode);
        return fileName.toString();
      }
    }
    return """";
  }",method,
"    if (index < 0) {
      return """";
    }",method,
"  private String findBestMatchingLanguageCode(
      Set<String> setOfLangs, String language, String script, String region) {
    StringBuilder fullLocale = constructFullLocale(language, script, region);
    String fullLocaleStr = fullLocale.toString();
    String normalizedLocale = LOCALE_NORMALIZATION_MAP.get(fullLocaleStr);
    if (normalizedLocale != null) {
      if (setOfLangs.contains(normalizedLocale)) {
        return normalizedLocale;
      }
    }
    if (setOfLangs.contains(fullLocaleStr)) {
      return fullLocaleStr;
    }
    if (onlyOneOfScriptOrRegionIsEmpty(script, region)) {
      if (setOfLangs.contains(language)) {
        return language;
      }
    } else if (script.length() > 0 && region.length() > 0) {
      StringBuilder langWithScript = new StringBuilder(language).append('_').append(script);
      String langWithScriptStr = langWithScript.toString();
      if (setOfLangs.contains(langWithScriptStr)) {
        return langWithScriptStr;
      }
      StringBuilder langWithRegion = new StringBuilder(language).append('_').append(region);
      String langWithRegionStr = langWithRegion.toString();
      if (setOfLangs.contains(langWithRegionStr)) {
        return langWithRegionStr;
      }
      if (setOfLangs.contains(language)) {
        return language;
      }
    }
    return """";
  }",method,
"    if (normalizedLocale != null) {
      if (setOfLangs.contains(normalizedLocale)) {
        return normalizedLocale;
      }
    }",method,
"  private boolean onlyOneOfScriptOrRegionIsEmpty(String script, String region) {
    return (script.length() == 0 && region.length() > 0)
        || (region.length() == 0 && script.length() > 0);
  }",method,
"  private StringBuilder constructFullLocale(String language, String script, String region) {
    StringBuilder fullLocale = new StringBuilder(language);
    appendSubsequentLocalePart(script, fullLocale);
    appendSubsequentLocalePart(region, fullLocale);
    return fullLocale;
  }",method,
"  private void appendSubsequentLocalePart(String subsequentLocalePart, StringBuilder fullLocale) {
    if (subsequentLocalePart.length() > 0) {
      fullLocale.append('_').append(subsequentLocalePart);
    }
  }",method,
"public class PageHistoryResult extends Result {
    public Page page = null;
    public List<ShortRevision> revisions = null;
    public boolean not_existing = false;
    public PageHistoryResult(Page page, List<ShortRevision> revisions) {
        super();
        this.page = page;
        this.revisions = revisions;
    }
    public PageHistoryResult(Page page, List<ShortRevision> revisions,
            String name, long time) {
        super();
        this.page = page;
        this.revisions = revisions;
        addStat(name, time);
    }
    public PageHistoryResult(boolean success, String message,
            boolean connectFailed) {
        super(success, message, connectFailed);
    }
    public PageHistoryResult(boolean success, String message,
            boolean connectFailed, String name, long time) {
        super(success, message, connectFailed);
        addStat(name, time);
    }
}",class,
"public class Result {
    public boolean success;
    public String message;
    public boolean connect_failed;
    public LinkedMultiHashMap<String, Long> stats = new LinkedMultiHashMap<String, Long>();
    public Result() {
        this.success = true;
        this.message = """";
        this.connect_failed = false;
    }
    public Result(boolean success, String message, boolean connectFailed) {
        this.success = success;
        this.message = message;
        this.connect_failed = connectFailed;
    }
    public void addStat(String name, long time) {
        stats.put(name, time);
    }
}",class,
"    public PageHistoryResult(Page page, List<ShortRevision> revisions) {
        super();
        this.page = page;
        this.revisions = revisions;
    }",method,
"    public PageHistoryResult(Page page, List<ShortRevision> revisions,
            String name, long time) {
        super();
        this.page = page;
        this.revisions = revisions;
        addStat(name, time);
    }",method,
"    public PageHistoryResult(boolean success, String message,
            boolean connectFailed) {
        super(success, message, connectFailed);
    }",method,
"    public PageHistoryResult(boolean success, String message,
            boolean connectFailed, String name, long time) {
        super(success, message, connectFailed);
        addStat(name, time);
    }",method,
"    public Result() {
        this.success = true;
        this.message = """";
        this.connect_failed = false;
    }",method,
"    public Result(boolean success, String message, boolean connectFailed) {
        this.success = success;
        this.message = message;
        this.connect_failed = connectFailed;
    }",method,
"    public void addStat(String name, long time) {
        stats.put(name, time);
    }",method,
"public final class FieldId implements Comparable<FieldId> {
    private final Dex dex;
    private final int declaringClassIndex;
    private final int typeIndex;
    private final int nameIndex;
    public FieldId(Dex dex, int declaringClassIndex, int typeIndex, int nameIndex) {
        this.dex = dex;
        this.declaringClassIndex = declaringClassIndex;
        this.typeIndex = typeIndex;
        this.nameIndex = nameIndex;
    }
    public int getDeclaringClassIndex() {
        return declaringClassIndex;
    }
    public int getTypeIndex() {
        return typeIndex;
    }
    public int getNameIndex() {
        return nameIndex;
    }
    public int compareTo(FieldId other) {
        if (declaringClassIndex != other.declaringClassIndex) {
            return Unsigned.compare(declaringClassIndex, other.declaringClassIndex);
        }
        if (nameIndex != other.nameIndex) {
            return Unsigned.compare(nameIndex, other.nameIndex);
        }
        return Unsigned.compare(typeIndex, other.typeIndex); // should always be 0
    }
    public void writeTo(Dex.Section out) {
        out.writeUnsignedShort(declaringClassIndex);
        out.writeUnsignedShort(typeIndex);
        out.writeInt(nameIndex);
    }
    @Override public String toString() {
        if (dex == null) {
            return declaringClassIndex + "" "" + typeIndex + "" "" + nameIndex;
        }
        return dex.typeNames().get(typeIndex) + ""."" + dex.strings().get(nameIndex);
    }
}",class,
"    public FieldId(Dex dex, int declaringClassIndex, int typeIndex, int nameIndex) {
        this.dex = dex;
        this.declaringClassIndex = declaringClassIndex;
        this.typeIndex = typeIndex;
        this.nameIndex = nameIndex;
    }",method,
"    public int getDeclaringClassIndex() {
        return declaringClassIndex;
    }",method,
"    public int getTypeIndex() {
        return typeIndex;
    }",method,
"    public int getNameIndex() {
        return nameIndex;
    }",method,
"    public int compareTo(FieldId other) {
        if (declaringClassIndex != other.declaringClassIndex) {
            return Unsigned.compare(declaringClassIndex, other.declaringClassIndex);
        }
        if (nameIndex != other.nameIndex) {
            return Unsigned.compare(nameIndex, other.nameIndex);
        }
        return Unsigned.compare(typeIndex, other.typeIndex); // should always be 0
    }",method,
"        if (declaringClassIndex != other.declaringClassIndex) {
            return Unsigned.compare(declaringClassIndex, other.declaringClassIndex);
        }",method,
"        if (nameIndex != other.nameIndex) {
            return Unsigned.compare(nameIndex, other.nameIndex);
        }",method,
"    public void writeTo(Dex.Section out) {
        out.writeUnsignedShort(declaringClassIndex);
        out.writeUnsignedShort(typeIndex);
        out.writeInt(nameIndex);
    }",method,
"    @Override public String toString() {
        if (dex == null) {
            return declaringClassIndex + "" "" + typeIndex + "" "" + nameIndex;
        }",method,
"public abstract class JdkVersionDetector {
  public static JdkVersionDetector getInstance() {
    return JpsServiceManager.getInstance().getService(JdkVersionDetector.class);
  }
  @Nullable
  public abstract String detectJdkVersion(@NotNull String homePath);
  @Nullable
  public abstract String detectJdkVersion(@NotNull String homePath, @NotNull ActionRunner actionRunner);
  @Nullable
  public abstract JdkVersionInfo detectJdkVersionInfo(@NotNull String homePath);
  @Nullable
  public abstract JdkVersionInfo detectJdkVersionInfo(@NotNull String homePath, @NotNull ActionRunner actionRunner);
  //todo[nik] replace with a service with different implementations for IDE process and for JPS process (need to exclude jps-builders module from IDEA classpath)
  public interface ActionRunner {
    Future<?> run(Runnable runnable);
  }
  public static final class JdkVersionInfo {
    private final String myVersion;
    private final Bitness myBitness;
    public JdkVersionInfo(@NotNull String version, @NotNull Bitness bitness) {
      myVersion = version;
      myBitness = bitness;
    }
    @NotNull
    public String getVersion() {
      return myVersion;
    }
    @NotNull
    public Bitness getBitness() {
      return myBitness;
    }
  }
}",class,
"  public static final class JdkVersionInfo {
    private final String myVersion;
    private final Bitness myBitness;
    public JdkVersionInfo(@NotNull String version, @NotNull Bitness bitness) {
      myVersion = version;
      myBitness = bitness;
    }
    @NotNull
    public String getVersion() {
      return myVersion;
    }
    @NotNull
    public Bitness getBitness() {
      return myBitness;
    }
  }",class,
"  public static JdkVersionDetector getInstance() {
    return JpsServiceManager.getInstance().getService(JdkVersionDetector.class);
  }",method,
"    public JdkVersionInfo(@NotNull String version, @NotNull Bitness bitness) {
      myVersion = version;
      myBitness = bitness;
    }",method,
"    @NotNull
    public String getVersion() {
      return myVersion;
    }",method,
"    @NotNull
    public Bitness getBitness() {
      return myBitness;
    }",method,
"public abstract class WriteGlobalVariableNode extends RubyNode {
    private final String name;
    @Child protected ReferenceEqualNode referenceEqualNode = ReferenceEqualNode.create();
    @Child protected WriteBarrierNode writeBarrierNode = WriteBarrierNode.create();
    public WriteGlobalVariableNode(String name) {
        this.name = name;
    }
    @Specialization(guards = { ""storage.isSimple()"", ""referenceEqualNode.executeReferenceEqual(value, previousValue)"" },
                    assumptions = ""storage.getUnchangedAssumption()"")
    public Object writeTryToKeepConstant(Object value,
                    @Cached(""getStorage()"") GlobalVariableStorage storage,
                    @Cached(""storage.getValue()"") Object previousValue) {
        // NOTE: we still do the volatile write to get the proper memory barrier,
        // as the global variable could be used as a publication mechanism.
        storage.setValueInternal(value);
        return previousValue;
    }
    @Specialization(guards = { ""storage.isSimple()"", ""storage.isAssumeConstant()"" },
                    assumptions = ""storage.getUnchangedAssumption()"")
    public Object writeAssumeConstant(Object value,
                    @Cached(""getStorage()"") GlobalVariableStorage storage) {
        if (getContext().getSharedObjects().isSharing()) {
            writeBarrierNode.executeWriteBarrier(value);
        }
        storage.setValueInternal(value);
        storage.updateAssumeConstant(getContext());
        return value;
    }
    @Specialization(guards = { ""storage.isSimple()"", ""!storage.isAssumeConstant()"" }, replaces = ""writeAssumeConstant"")
    public Object write(Object value,
                    @Cached(""getStorage()"") GlobalVariableStorage storage) {
        if (getContext().getSharedObjects().isSharing()) {
            writeBarrierNode.executeWriteBarrier(value);
        }
        storage.setValueInternal(value);
        return value;
    }
    @Specialization(guards = ""storage.hasHooks()"")
    public Object writeHooks(Object value,
                             @Cached(""getStorage()"") GlobalVariableStorage storage,
                             @Cached(""new()"") YieldNode yieldNode) {
        yieldNode.dispatch(storage.getSetter(), value);
        return value;
    }
    protected GlobalVariableStorage getStorage() {
        return getContext().getCoreLibrary().getGlobalVariables().getStorage(name);
    }
    @Override
    public Object isDefined(VirtualFrame frame) {
        return coreStrings().ASSIGNMENT.createInstance();
    }
}",class,
"    @Child protected ReferenceEqualNode referenceEqualNode = ReferenceEqualNode.create();
    @Child protected WriteBarrierNode writeBarrierNode = WriteBarrierNode.create();
    public WriteGlobalVariableNode(String name) {
        this.name = name;
    }",method,
"    protected GlobalVariableStorage getStorage() {
        return getContext().getCoreLibrary().getGlobalVariables().getStorage(name);
    }",method,
"    @Override
    public Object isDefined(VirtualFrame frame) {
        return coreStrings().ASSIGNMENT.createInstance();
    }",method,
"public class OracleSetTransactionTest extends OracleTest {
    public void test_0() throws Exception {
        String sql = ""set transaction name 'IGNORED_TRANS'  "";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement statemen = statementList.get(0);
        print(statementList);
        Assert.assertEquals(1, statementList.size());
        OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
        statemen.accept(visitor);
        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
        System.out.println(""coditions : "" + visitor.getConditions());
        System.out.println(""relationships : "" + visitor.getRelationships());
        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
        Assert.assertEquals(0, visitor.getTables().size());
//        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name(""employees"")));
        Assert.assertEquals(0, visitor.getColumns().size());
//        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""departments"", ""department_id"")));
    }
}",class,
"    public void test_0() throws Exception {
        String sql = ""set transaction name 'IGNORED_TRANS'  "";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement statemen = statementList.get(0);
        print(statementList);
        Assert.assertEquals(1, statementList.size());
        OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
        statemen.accept(visitor);
        System.out.println(""Tables : "" + visitor.getTables());
        System.out.println(""fields : "" + visitor.getColumns());
        System.out.println(""coditions : "" + visitor.getConditions());
        System.out.println(""relationships : "" + visitor.getRelationships());
        System.out.println(""orderBy : "" + visitor.getOrderByColumns());
        Assert.assertEquals(0, visitor.getTables().size());
//        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name(""employees"")));
        Assert.assertEquals(0, visitor.getColumns().size());
//        Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column(""departments"", ""department_id"")));
    }",method,
"public class DefaultPartitioner implements Partitioner {
    private final ConcurrentMap<String, AtomicInteger> topicCounterMap = new ConcurrentHashMap<>();
    public void configure(Map<String, ?> configs) {}
    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
        List<PartitionInfo> partitions = cluster.partitionsForTopic(topic);
        int numPartitions = partitions.size();
        if (keyBytes == null) {
            int nextValue = nextValue(topic);
            List<PartitionInfo> availablePartitions = cluster.availablePartitionsForTopic(topic);
            if (availablePartitions.size() > 0) {
                int part = Utils.toPositive(nextValue) % availablePartitions.size();
                return availablePartitions.get(part).partition();
            } else {
                // no partitions are available, give a non-available partition
                return Utils.toPositive(nextValue) % numPartitions;
            }
        } else {
            // hash the keyBytes to choose a partition
            return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;
        }
    }
    private int nextValue(String topic) {
        AtomicInteger counter = topicCounterMap.get(topic);
        if (null == counter) {
            counter = new AtomicInteger(ThreadLocalRandom.current().nextInt());
            AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);
            if (currentCounter != null) {
                counter = currentCounter;
            }
        }
        return counter.getAndIncrement();
    }
    public void close() {}
}",class,

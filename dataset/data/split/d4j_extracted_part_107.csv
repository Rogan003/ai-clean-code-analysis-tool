code_snippet,type,score
"                @Override
                public boolean continueReading() {
                    return config.isAutoRead();
                }",method,
"                @Override
                public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {
                    return config.isAutoRead();
                }",method,
"                @Override
                public void readComplete() {
                    // Nothing needs to be done or adjusted after each read cycle is completed.
                }",method,
"public class MainActivity extends Activity {
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		loadScreen();
	}
	private Button.OnClickListener MyRestartButtonOnClickListener = new Button.OnClickListener() {
		@Override
		public void onClick(View v) {
			// TODO Auto-generated method stub
			loadScreen();
		}
	};
	private void loadScreen() {
		setContentView(R.layout.activity_main);
		SetupListView();
		Button MyRestartButton = (Button) findViewById(R.id.myRestartButton);
		MyRestartButton.setOnClickListener(MyRestartButtonOnClickListener);
	}
	private void SetupListView() {
		String[] listItems = new String[] { ""Hello!"",
				""It's a Demo to use Layout Animation"", ""Is it Great?"",
				""android-er.blogspot.com"" };
		ArrayAdapter<String> listItemAdapter = new ArrayAdapter<String>(this,
				android.R.layout.simple_list_item_1, listItems);
		ListView lv = (ListView) this.findViewById(R.id.myListView);
		lv.setAdapter(listItemAdapter);
	}
}",class,
"public final class BuildConfig {
    public final static boolean DEBUG = true;
}",class,
"public final class R {
    public static final class attr {
    }
    public static final class dimen {
        public static final int activity_horizontal_margin=0x7f040000;
        public static final int activity_vertical_margin=0x7f040001;
    }
    public static final class drawable {
        public static final int ic_launcher=0x7f020000;
    }
    public static final class id {
        public static final int action_settings=0x7f080001;
        public static final int mygallery=0x7f080000;
    }
    public static final class layout {
        public static final int activity_main=0x7f030000;
    }
    public static final class menu {
        public static final int main=0x7f070000;
    }
    public static final class string {
        public static final int action_settings=0x7f050001;
        public static final int app_name=0x7f050000;
        public static final int hello_world=0x7f050002;
    }
    public static final class style {
        public static final int AppBaseTheme=0x7f060000;
        public static final int AppTheme=0x7f060001;
    }
}",class,
"    public static final class attr {
    }",class,
"    public static final class dimen {
        public static final int activity_horizontal_margin=0x7f040000;
        public static final int activity_vertical_margin=0x7f040001;
    }",class,
"    public static final class drawable {
        public static final int ic_launcher=0x7f020000;
    }",class,
"    public static final class id {
        public static final int action_settings=0x7f080001;
        public static final int mygallery=0x7f080000;
    }",class,
"    public static final class layout {
        public static final int activity_main=0x7f030000;
    }",class,
"    public static final class menu {
        public static final int main=0x7f070000;
    }",class,
"    public static final class string {
        public static final int action_settings=0x7f050001;
        public static final int app_name=0x7f050000;
        public static final int hello_world=0x7f050002;
    }",class,
"    public static final class style {
        public static final int AppBaseTheme=0x7f060000;
        public static final int AppTheme=0x7f060001;
    }",class,
"	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		loadScreen();
	}",method,
"		@Override
		public void onClick(View v) {
			// TODO Auto-generated method stub
			loadScreen();
		}",method,
"	private void loadScreen() {
		setContentView(R.layout.activity_main);
		SetupListView();
		Button MyRestartButton = (Button) findViewById(R.id.myRestartButton);
		MyRestartButton.setOnClickListener(MyRestartButtonOnClickListener);
	}",method,
"	private void SetupListView() {
		String[] listItems = new String[] { ""Hello!"",
				""It's a Demo to use Layout Animation"", ""Is it Great?"",
				""android-er.blogspot.com"" };
		ArrayAdapter<String> listItemAdapter = new ArrayAdapter<String>(this,
				android.R.layout.simple_list_item_1, listItems);
		ListView lv = (ListView) this.findViewById(R.id.myListView);
		lv.setAdapter(listItemAdapter);
	}",method,
"import java.awt.event.ActionListener;
class OptionsPanel extends EditorPanel {
	JCheckBox attachedCheckBox;
	JCheckBox continuousCheckbox;
	JCheckBox alignedCheckbox;
	JCheckBox additiveCheckbox;
	JCheckBox behindCheckbox;
	JCheckBox premultipliedAlphaCheckbox;
	public OptionsPanel (final ParticleEditor editor, String name, String description) {
		super(null, name, description);
		initializeComponents();
		attachedCheckBox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAttached(attachedCheckBox.isSelected());
			}
		});
		continuousCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setContinuous(continuousCheckbox.isSelected());
			}
		});
		alignedCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAligned(alignedCheckbox.isSelected());
			}
		});
		additiveCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAdditive(additiveCheckbox.isSelected());
			}
		});
		behindCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setBehind(behindCheckbox.isSelected());
			}
		});
		premultipliedAlphaCheckbox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setPremultipliedAlpha(premultipliedAlphaCheckbox.isSelected());
			}
		});
		ParticleEmitter emitter = editor.getEmitter();
		attachedCheckBox.setSelected(emitter.isAttached());
		continuousCheckbox.setSelected(emitter.isContinuous());
		alignedCheckbox.setSelected(emitter.isAligned());
		additiveCheckbox.setSelected(emitter.isAdditive());
		behindCheckbox.setSelected(emitter.isBehind());
		premultipliedAlphaCheckbox.setSelected(emitter.isPremultipliedAlpha());
	}
	private void initializeComponents () {
		JPanel contentPanel = getContentPanel();
		{
			JLabel label = new JLabel(""Additive:"");
			contentPanel.add(label, new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			additiveCheckbox = new JCheckBox();
			contentPanel.add(additiveCheckbox, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Attached:"");
			contentPanel.add(label, new GridBagConstraints(0, 2, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			attachedCheckBox = new JCheckBox();
			contentPanel.add(attachedCheckBox, new GridBagConstraints(1, 2, 1, 1, 1, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Continuous:"");
			contentPanel.add(label, new GridBagConstraints(0, 3, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			continuousCheckbox = new JCheckBox();
			contentPanel.add(continuousCheckbox, new GridBagConstraints(1, 3, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Aligned:"");
			contentPanel.add(label, new GridBagConstraints(0, 4, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			alignedCheckbox = new JCheckBox();
			contentPanel.add(alignedCheckbox, new GridBagConstraints(1, 4, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Behind:"");
			contentPanel.add(label, new GridBagConstraints(0, 5, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			behindCheckbox = new JCheckBox();
			contentPanel.add(behindCheckbox, new GridBagConstraints(1, 5, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Premultiplied Alpha:"");
			contentPanel.add(label, new GridBagConstraints(0, 6, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			premultipliedAlphaCheckbox = new JCheckBox();
			contentPanel.add(premultipliedAlphaCheckbox, new GridBagConstraints(1, 6, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
	}
}",class,
"	public OptionsPanel (final ParticleEditor editor, String name, String description) {
		super(null, name, description);
		initializeComponents();
		attachedCheckBox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAttached(attachedCheckBox.isSelected());
			}
		});
		continuousCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setContinuous(continuousCheckbox.isSelected());
			}
		});
		alignedCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAligned(alignedCheckbox.isSelected());
			}
		});
		additiveCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAdditive(additiveCheckbox.isSelected());
			}
		});
		behindCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setBehind(behindCheckbox.isSelected());
			}
		});
		premultipliedAlphaCheckbox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setPremultipliedAlpha(premultipliedAlphaCheckbox.isSelected());
			}
		});
		ParticleEmitter emitter = editor.getEmitter();
		attachedCheckBox.setSelected(emitter.isAttached());
		continuousCheckbox.setSelected(emitter.isContinuous());
		alignedCheckbox.setSelected(emitter.isAligned());
		additiveCheckbox.setSelected(emitter.isAdditive());
		behindCheckbox.setSelected(emitter.isBehind());
		premultipliedAlphaCheckbox.setSelected(emitter.isPremultipliedAlpha());
	}",method,
"		attachedCheckBox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAttached(attachedCheckBox.isSelected());
			}
		}",method,
"			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAttached(attachedCheckBox.isSelected());
			}",method,
"		continuousCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setContinuous(continuousCheckbox.isSelected());
			}
		}",method,
"			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setContinuous(continuousCheckbox.isSelected());
			}",method,
"		alignedCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAligned(alignedCheckbox.isSelected());
			}
		}",method,
"			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAligned(alignedCheckbox.isSelected());
			}",method,
"		additiveCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAdditive(additiveCheckbox.isSelected());
			}
		}",method,
"			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setAdditive(additiveCheckbox.isSelected());
			}",method,
"		behindCheckbox.addActionListener(new ActionListener() {
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setBehind(behindCheckbox.isSelected());
			}
		}",method,
"			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setBehind(behindCheckbox.isSelected());
			}",method,
"		premultipliedAlphaCheckbox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setPremultipliedAlpha(premultipliedAlphaCheckbox.isSelected());
			}
		}",method,
"			@Override
			public void actionPerformed (ActionEvent event) {
				editor.getEmitter().setPremultipliedAlpha(premultipliedAlphaCheckbox.isSelected());
			}",method,
"	private void initializeComponents () {
		JPanel contentPanel = getContentPanel();
		{
			JLabel label = new JLabel(""Additive:"");
			contentPanel.add(label, new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			additiveCheckbox = new JCheckBox();
			contentPanel.add(additiveCheckbox, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Attached:"");
			contentPanel.add(label, new GridBagConstraints(0, 2, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			attachedCheckBox = new JCheckBox();
			contentPanel.add(attachedCheckBox, new GridBagConstraints(1, 2, 1, 1, 1, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Continuous:"");
			contentPanel.add(label, new GridBagConstraints(0, 3, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			continuousCheckbox = new JCheckBox();
			contentPanel.add(continuousCheckbox, new GridBagConstraints(1, 3, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Aligned:"");
			contentPanel.add(label, new GridBagConstraints(0, 4, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			alignedCheckbox = new JCheckBox();
			contentPanel.add(alignedCheckbox, new GridBagConstraints(1, 4, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Behind:"");
			contentPanel.add(label, new GridBagConstraints(0, 5, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			behindCheckbox = new JCheckBox();
			contentPanel.add(behindCheckbox, new GridBagConstraints(1, 5, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
		{
			JLabel label = new JLabel(""Premultiplied Alpha:"");
			contentPanel.add(label, new GridBagConstraints(0, 6, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
				new Insets(6, 0, 0, 0), 0, 0));
		}
		{
			premultipliedAlphaCheckbox = new JCheckBox();
			contentPanel.add(premultipliedAlphaCheckbox, new GridBagConstraints(1, 6, 1, 1, 0, 0, GridBagConstraints.WEST,
				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
		}
	}",method,
"import java.awt.*;
class DebuggerLaunchingConfigurable implements ConfigurableUi<DebuggerSettings> {
  private JRadioButton myRbSocket;
  private JRadioButton myRbShmem;
  private StateRestoringCheckBox myCbForceClassicVM;
  private JCheckBox myCbDisableJIT;
  private JCheckBox myCbShowAlternativeSource;
  private JCheckBox myCbKillImmediately;
  @Override
  public void reset(@NotNull DebuggerSettings settings) {
    if (!SystemInfo.isWindows) {
      myRbSocket.setSelected(true);
      myRbShmem.setEnabled(false);
    }
    else {
      if (settings.DEBUGGER_TRANSPORT == DebuggerSettings.SHMEM_TRANSPORT) {
        myRbShmem.setSelected(true);
      }
      else {
        myRbSocket.setSelected(true);
      }
      myRbShmem.setEnabled(true);
    }
    myCbForceClassicVM.setSelected(settings.FORCE_CLASSIC_VM);
    myCbDisableJIT.setSelected(settings.DISABLE_JIT);
    myCbShowAlternativeSource.setSelected(settings.SHOW_ALTERNATIVE_SOURCE);
    myCbKillImmediately.setSelected(settings.KILL_PROCESS_IMMEDIATELY);
  }
  @Override
  public void apply(@NotNull DebuggerSettings settings) {
    getSettingsTo(settings);
  }
  private void getSettingsTo(DebuggerSettings settings) {
    if (myRbShmem.isSelected()) {
      settings.DEBUGGER_TRANSPORT = DebuggerSettings.SHMEM_TRANSPORT;
    }
    else {
      settings.DEBUGGER_TRANSPORT = DebuggerSettings.SOCKET_TRANSPORT;
    }
    settings.FORCE_CLASSIC_VM = myCbForceClassicVM.isSelectedWhenSelectable();
    settings.DISABLE_JIT = myCbDisableJIT.isSelected();
    settings.SHOW_ALTERNATIVE_SOURCE = myCbShowAlternativeSource.isSelected();
    settings.KILL_PROCESS_IMMEDIATELY = myCbKillImmediately.isSelected();
  }
  @Override
  public boolean isModified(@NotNull DebuggerSettings currentSettings) {
    DebuggerSettings debuggerSettings = currentSettings.clone();
    getSettingsTo(debuggerSettings);
    return !debuggerSettings.equals(currentSettings);
  }
  @NotNull
  @Override
  public JComponent getComponent() {
    myCbForceClassicVM = new StateRestoringCheckBox(DebuggerBundle.message(""label.debugger.launching.configurable.force.classic.vm""));
    myCbDisableJIT = new JCheckBox(DebuggerBundle.message(""label.debugger.launching.configurable.disable.jit""));
    myCbShowAlternativeSource = new JCheckBox(DebuggerBundle.message(""label.debugger.general.configurable.show.alternative.source""));
    myRbSocket = new JRadioButton(DebuggerBundle.message(""label.debugger.launching.configurable.socket""));
    myRbShmem = new JRadioButton(DebuggerBundle.message(""label.debugger.launching.configurable.shmem""));
    myCbKillImmediately = new JCheckBox(DebuggerBundle.message(""label.debugger.general.configurable.kill.immediately""));
    final ButtonGroup gr = new ButtonGroup();
    gr.add(myRbSocket);
    gr.add(myRbShmem);
    final Box box = Box.createHorizontalBox();
    box.add(myRbSocket);
    box.add(myRbShmem);
    final JPanel transportPanel = new JPanel(new BorderLayout());
    transportPanel.add(new JLabel(DebuggerBundle.message(""label.debugger.launching.configurable.debugger.transport"")), BorderLayout.WEST);
    transportPanel.add(box, BorderLayout.CENTER);
    VerticalBox panel = new VerticalBox();
    panel.setOpaque(false);
    panel.add(transportPanel);
    panel.add(myCbForceClassicVM);
    panel.add(myCbDisableJIT);
    panel.add(myCbShowAlternativeSource);
    panel.add(myCbKillImmediately);
    JPanel result = new JPanel(new BorderLayout());
    result.add(panel, BorderLayout.NORTH);
    return result;
  }
}",class,
"  @Override
  public void reset(@NotNull DebuggerSettings settings) {
    if (!SystemInfo.isWindows) {
      myRbSocket.setSelected(true);
      myRbShmem.setEnabled(false);
    }
    else {
      if (settings.DEBUGGER_TRANSPORT == DebuggerSettings.SHMEM_TRANSPORT) {
        myRbShmem.setSelected(true);
      }
      else {
        myRbSocket.setSelected(true);
      }
      myRbShmem.setEnabled(true);
    }
    myCbForceClassicVM.setSelected(settings.FORCE_CLASSIC_VM);
    myCbDisableJIT.setSelected(settings.DISABLE_JIT);
    myCbShowAlternativeSource.setSelected(settings.SHOW_ALTERNATIVE_SOURCE);
    myCbKillImmediately.setSelected(settings.KILL_PROCESS_IMMEDIATELY);
  }",method,
"    if (!SystemInfo.isWindows) {
      myRbSocket.setSelected(true);
      myRbShmem.setEnabled(false);
    }",method,
"      if (settings.DEBUGGER_TRANSPORT == DebuggerSettings.SHMEM_TRANSPORT) {
        myRbShmem.setSelected(true);
      }",method,
"  @Override
  public void apply(@NotNull DebuggerSettings settings) {
    getSettingsTo(settings);
  }",method,
"  private void getSettingsTo(DebuggerSettings settings) {
    if (myRbShmem.isSelected()) {
      settings.DEBUGGER_TRANSPORT = DebuggerSettings.SHMEM_TRANSPORT;
    }
    else {
      settings.DEBUGGER_TRANSPORT = DebuggerSettings.SOCKET_TRANSPORT;
    }
    settings.FORCE_CLASSIC_VM = myCbForceClassicVM.isSelectedWhenSelectable();
    settings.DISABLE_JIT = myCbDisableJIT.isSelected();
    settings.SHOW_ALTERNATIVE_SOURCE = myCbShowAlternativeSource.isSelected();
    settings.KILL_PROCESS_IMMEDIATELY = myCbKillImmediately.isSelected();
  }",method,
"  @Override
  public boolean isModified(@NotNull DebuggerSettings currentSettings) {
    DebuggerSettings debuggerSettings = currentSettings.clone();
    getSettingsTo(debuggerSettings);
    return !debuggerSettings.equals(currentSettings);
  }",method,
"  @NotNull
  @Override
  public JComponent getComponent() {
    myCbForceClassicVM = new StateRestoringCheckBox(DebuggerBundle.message(""label.debugger.launching.configurable.force.classic.vm""));
    myCbDisableJIT = new JCheckBox(DebuggerBundle.message(""label.debugger.launching.configurable.disable.jit""));
    myCbShowAlternativeSource = new JCheckBox(DebuggerBundle.message(""label.debugger.general.configurable.show.alternative.source""));
    myRbSocket = new JRadioButton(DebuggerBundle.message(""label.debugger.launching.configurable.socket""));
    myRbShmem = new JRadioButton(DebuggerBundle.message(""label.debugger.launching.configurable.shmem""));
    myCbKillImmediately = new JCheckBox(DebuggerBundle.message(""label.debugger.general.configurable.kill.immediately""));
    final ButtonGroup gr = new ButtonGroup();
    gr.add(myRbSocket);
    gr.add(myRbShmem);
    final Box box = Box.createHorizontalBox();
    box.add(myRbSocket);
    box.add(myRbShmem);
    final JPanel transportPanel = new JPanel(new BorderLayout());
    transportPanel.add(new JLabel(DebuggerBundle.message(""label.debugger.launching.configurable.debugger.transport"")), BorderLayout.WEST);
    transportPanel.add(box, BorderLayout.CENTER);
    VerticalBox panel = new VerticalBox();
    panel.setOpaque(false);
    panel.add(transportPanel);
    panel.add(myCbForceClassicVM);
    panel.add(myCbDisableJIT);
    panel.add(myCbShowAlternativeSource);
    panel.add(myCbKillImmediately);
    JPanel result = new JPanel(new BorderLayout());
    result.add(panel, BorderLayout.NORTH);
    return result;
  }",method,
"public class JavaUdpMulticast {
    //#inet6-protocol-family
    public static class Inet6ProtocolFamily extends Inet.DatagramChannelCreator {
        @Override
        public DatagramChannel create() throws Exception {
            return DatagramChannel.open(StandardProtocolFamily.INET6);
        }
    }
    //#inet6-protocol-family
    //#multicast-group
    public static class MulticastGroup extends Inet.AbstractSocketOptionV2 {
        private String address;
        private String interf;
        public MulticastGroup(String address, String interf) {
            this.address = address;
            this.interf = interf;
        }
        @Override
        public void afterBind(DatagramSocket s) {
            try {
                InetAddress group = InetAddress.getByName(address);
                NetworkInterface networkInterface = NetworkInterface.getByName(interf);
                s.getChannel().join(group, networkInterface);
            } catch (Exception ex) {
                System.out.println(""Unable to join multicast group."");
            }
        }
    }
    //#multicast-group
    public static class Listener extends AbstractActor {
        LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);
        ActorRef sink;
        public Listener(String iface, String group, Integer port, ActorRef sink) {
            this.sink = sink;
            //#bind
            List<Inet.SocketOption> options = new ArrayList<>();
            options.add(new Inet6ProtocolFamily());
            options.add(new MulticastGroup(group, iface));
            final ActorRef mgr = Udp.get(getContext().getSystem()).getManager();
            // listen for datagrams on this address
            InetSocketAddress endpoint = new InetSocketAddress(port);
            mgr.tell(UdpMessage.bind(getSelf(), endpoint, options), getSelf());
            //#bind
        }
        @Override
        public Receive createReceive() {
            return receiveBuilder()
                .match(Udp.Bound.class, bound -> {
                  log.info(""Bound to {}"", bound.localAddress());
                  sink.tell(bound, getSelf());
                })
                .match(Udp.Received.class, received -> {
                  final String txt = received.data().decodeString(""utf-8"");
                  log.info(""Received '{}' from {}"", txt, received.sender());
                  sink.tell(txt, getSelf());
                })
                .build();
        }
    }
    public static class Sender extends AbstractActor {
        LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);
        String iface;
        String group;
        Integer port;
        String message;
        public Sender(String iface, String group, Integer port, String msg) {
            this.iface = iface;
            this.group = group;
            this.port = port;
            this.message = msg;
            List<Inet.SocketOption> options = new ArrayList<>();
            options.add(new Inet6ProtocolFamily());
            final ActorRef mgr = Udp.get(getContext().getSystem()).getManager();
            mgr.tell(UdpMessage.simpleSender(options), getSelf());
        }
        @Override
        public Receive createReceive() {
            return receiveBuilder()
                .match(Udp.SimpleSenderReady.class, x -> {
                    InetSocketAddress remote = new InetSocketAddress(group + ""%"" + iface, port);
                    log.info(""Sending message to "" + remote);
                    getSender().tell(UdpMessage.send(ByteString.fromString(message), remote), getSelf());
                })
                .build();
        }
    }
}",class,
"    public static class Inet6ProtocolFamily extends Inet.DatagramChannelCreator {
        @Override
        public DatagramChannel create() throws Exception {
            return DatagramChannel.open(StandardProtocolFamily.INET6);
        }
    }",class,
"    public static class MulticastGroup extends Inet.AbstractSocketOptionV2 {
        private String address;
        private String interf;
        public MulticastGroup(String address, String interf) {
            this.address = address;
            this.interf = interf;
        }
        @Override
        public void afterBind(DatagramSocket s) {
            try {
                InetAddress group = InetAddress.getByName(address);
                NetworkInterface networkInterface = NetworkInterface.getByName(interf);
                s.getChannel().join(group, networkInterface);
            } catch (Exception ex) {
                System.out.println(""Unable to join multicast group."");
            }
        }
    }",class,
"    public static class Listener extends AbstractActor {
        LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);
        ActorRef sink;
        public Listener(String iface, String group, Integer port, ActorRef sink) {
            this.sink = sink;
            //#bind
            List<Inet.SocketOption> options = new ArrayList<>();
            options.add(new Inet6ProtocolFamily());
            options.add(new MulticastGroup(group, iface));
            final ActorRef mgr = Udp.get(getContext().getSystem()).getManager();
            // listen for datagrams on this address
            InetSocketAddress endpoint = new InetSocketAddress(port);
            mgr.tell(UdpMessage.bind(getSelf(), endpoint, options), getSelf());
            //#bind
        }
        @Override
        public Receive createReceive() {
            return receiveBuilder()
                .match(Udp.Bound.class, bound -> {
                  log.info(""Bound to {}"", bound.localAddress());
                  sink.tell(bound, getSelf());
                })
                .match(Udp.Received.class, received -> {
                  final String txt = received.data().decodeString(""utf-8"");
                  log.info(""Received '{}' from {}"", txt, received.sender());
                  sink.tell(txt, getSelf());
                })
                .build();
        }
    }",class,
"    public static class Sender extends AbstractActor {
        LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);
        String iface;
        String group;
        Integer port;
        String message;
        public Sender(String iface, String group, Integer port, String msg) {
            this.iface = iface;
            this.group = group;
            this.port = port;
            this.message = msg;
            List<Inet.SocketOption> options = new ArrayList<>();
            options.add(new Inet6ProtocolFamily());
            final ActorRef mgr = Udp.get(getContext().getSystem()).getManager();
            mgr.tell(UdpMessage.simpleSender(options), getSelf());
        }
        @Override
        public Receive createReceive() {
            return receiveBuilder()
                .match(Udp.SimpleSenderReady.class, x -> {
                    InetSocketAddress remote = new InetSocketAddress(group + ""%"" + iface, port);
                    log.info(""Sending message to "" + remote);
                    getSender().tell(UdpMessage.send(ByteString.fromString(message), remote), getSelf());
                })
                .build();
        }
    }",class,
"        @Override
        public DatagramChannel create() throws Exception {
            return DatagramChannel.open(StandardProtocolFamily.INET6);
        }",method,
"        public MulticastGroup(String address, String interf) {
            this.address = address;
            this.interf = interf;
        }",method,
"        @Override
        public void afterBind(DatagramSocket s) {
            try {
                InetAddress group = InetAddress.getByName(address);
                NetworkInterface networkInterface = NetworkInterface.getByName(interf);
                s.getChannel().join(group, networkInterface);
            } catch (Exception ex) {
                System.out.println(""Unable to join multicast group."");
            }
        }",method,
"        public Listener(String iface, String group, Integer port, ActorRef sink) {
            this.sink = sink;
            //#bind
            List<Inet.SocketOption> options = new ArrayList<>();
            options.add(new Inet6ProtocolFamily());
            options.add(new MulticastGroup(group, iface));
            final ActorRef mgr = Udp.get(getContext().getSystem()).getManager();
            // listen for datagrams on this address
            InetSocketAddress endpoint = new InetSocketAddress(port);
            mgr.tell(UdpMessage.bind(getSelf(), endpoint, options), getSelf());
            //#bind
        }",method,
"        @Override
        public Receive createReceive() {
            return receiveBuilder()
                .match(Udp.Bound.class, bound -> {
                  log.info(""Bound to {}"", bound.localAddress());
                  sink.tell(bound, getSelf());
                })
                .match(Udp.Received.class, received -> {
                  final String txt = received.data().decodeString(""utf-8"");
                  log.info(""Received '{}' from {}"", txt, received.sender());
                  sink.tell(txt, getSelf());
                })
                .build();
        }",method,
"        public Sender(String iface, String group, Integer port, String msg) {
            this.iface = iface;
            this.group = group;
            this.port = port;
            this.message = msg;
            List<Inet.SocketOption> options = new ArrayList<>();
            options.add(new Inet6ProtocolFamily());
            final ActorRef mgr = Udp.get(getContext().getSystem()).getManager();
            mgr.tell(UdpMessage.simpleSender(options), getSelf());
        }",method,
"        @Override
        public Receive createReceive() {
            return receiveBuilder()
                .match(Udp.SimpleSenderReady.class, x -> {
                    InetSocketAddress remote = new InetSocketAddress(group + ""%"" + iface, port);
                    log.info(""Sending message to "" + remote);
                    getSender().tell(UdpMessage.send(ByteString.fromString(message), remote), getSelf());
                })
                .build();
        }",method,
"public class JDBCResourceInspection extends ResourceInspection {
  private static final String[] creationMethodClassName =
    {
      ""java.sql.Driver"",
      ""java.sql.DriverManager"",
      ""javax.sql.DataSource"",
      ""java.sql.Connection"",
      ""java.sql.Connection"",
      ""java.sql.Connection"",
      ""java.sql.Statement"",
      ""java.sql.Statement"",
      ""java.sql.Statement"",
    };
  @NonNls
  private static final String[] creationMethodName =
    {
      ""connect"",
      ""getConnection"",
      ""getConnection"",
      ""createStatement"",
      ""prepareStatement"",
      ""prepareCall"",
      ""executeQuery"",
      ""getResultSet"",
      ""getGeneratedKeys""
    };
  @SuppressWarnings({""StaticCollection""})
  private static final Set<String> creationMethodNameSet = new HashSet<>(9);
  static {
    ContainerUtil.addAll(creationMethodNameSet, creationMethodName);
  }
  @Override
  @NotNull
  public String getID() {
    return ""JDBCResourceOpenedButNotSafelyClosed"";
  }
  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""jdbc.resource.opened.not.closed.display.name"");
  }
  protected boolean isResourceCreation(PsiExpression expression) {
    if (!(expression instanceof PsiMethodCallExpression)) {
      return false;
    }
    final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;
    final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();
    final String name = methodExpression.getReferenceName();
    if (name == null || !creationMethodNameSet.contains(name)) {
      return false;
    }
    final PsiMethod method = methodCallExpression.resolveMethod();
    if (method == null) {
      return false;
    }
    for (int i = 0; i < creationMethodName.length; i++) {
      if (!name.equals(creationMethodName[i])) {
        continue;
      }
      final PsiClass containingClass = method.getContainingClass();
      final String expectedClassName = creationMethodClassName[i];
      if (InheritanceUtil.isInheritor(containingClass, false, expectedClassName)) {
        return true;
      }
    }
    return false;
  }
}",class,
"  @Override
  @NotNull
  public String getID() {
    return ""JDBCResourceOpenedButNotSafelyClosed"";
  }",method,
"  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""jdbc.resource.opened.not.closed.display.name"");
  }",method,
"  protected boolean isResourceCreation(PsiExpression expression) {
    if (!(expression instanceof PsiMethodCallExpression)) {
      return false;
    }
    final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;
    final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();
    final String name = methodExpression.getReferenceName();
    if (name == null || !creationMethodNameSet.contains(name)) {
      return false;
    }
    final PsiMethod method = methodCallExpression.resolveMethod();
    if (method == null) {
      return false;
    }
    for (int i = 0; i < creationMethodName.length; i++) {
      if (!name.equals(creationMethodName[i])) {
        continue;
      }
      final PsiClass containingClass = method.getContainingClass();
      final String expectedClassName = creationMethodClassName[i];
      if (InheritanceUtil.isInheritor(containingClass, false, expectedClassName)) {
        return true;
      }
    }
    return false;
  }",method,
"    if (method == null) {
      return false;
    }",method,
"    for (int i = 0; i < creationMethodName.length; i++) {
      if (!name.equals(creationMethodName[i])) {
        continue;
      }
      final PsiClass containingClass = method.getContainingClass();
      final String expectedClassName = creationMethodClassName[i];
      if (InheritanceUtil.isInheritor(containingClass, false, expectedClassName)) {
        return true;
      }
    }",method,
"public class ImportedTestConsoleProperties extends SMTRunnerConsoleProperties implements SMCustomMessagesParsing {
  private final @Nullable SMTRunnerConsoleProperties myProperties;
  private final File myFile;
  private final ProcessHandler myHandler;
  public ImportedTestConsoleProperties(@Nullable SMTRunnerConsoleProperties properties,
                                       File file,
                                       ProcessHandler handler,
                                       Project project, RunProfile runConfiguration,
                                       String frameworkName,
                                       Executor executor) {
    super(project, runConfiguration, frameworkName, executor);
    myProperties = properties;
    myFile = file;
    myHandler = handler;
  }
  @Override
  public OutputToGeneralTestEventsConverter createTestEventsConverter(@NotNull String testFrameworkName,
                                                                      @NotNull TestConsoleProperties consoleProperties) {
    return new ImportedToGeneralTestEventsConverter(testFrameworkName, consoleProperties, myFile, myHandler);
  }
  @Override
  public boolean isIdBasedTestTree() {
    return false;
  }
  @Override
  public boolean isPrintTestingStartedTime() {
    return false;
  }
  @Nullable
  @Override
  public Navigatable getErrorNavigatable(@NotNull Location<?> location,
                                         @NotNull String stacktrace) {
    return myProperties == null ? null : myProperties.getErrorNavigatable(location, stacktrace);
  }
  @Nullable
  @Override
  public Navigatable getErrorNavigatable(@NotNull Project project,
                                         @NotNull String stacktrace) {
    return myProperties == null ? null : myProperties.getErrorNavigatable(project, stacktrace);
  }
  @Override
  public void addStackTraceFilter(Filter filter) {
    if (myProperties != null) {
      myProperties.addStackTraceFilter(filter);
    }
  }
  @Override
  public boolean fixEmptySuite() {
    return myProperties != null && myProperties.fixEmptySuite();
  }
  @Override
  @Nullable
  public SMTestLocator getTestLocator() {
    return myProperties == null ? null : myProperties.getTestLocator();
  }
  @Override
  @Nullable
  public TestProxyFilterProvider getFilterProvider() {
    return myProperties == null ? null : myProperties.getFilterProvider();
  }
  @Override
  @Nullable
  public AbstractRerunFailedTestsAction createRerunFailedTestsAction(ConsoleView consoleView) {
    return myProperties == null ? null : myProperties.createRerunFailedTestsAction(consoleView);
  }
  @Override
  public void appendAdditionalActions(DefaultActionGroup actionGroup, JComponent parent, TestConsoleProperties target) {
    if (myProperties != null) {
      myProperties.appendAdditionalActions(actionGroup, parent, this);
    }
  }
  @Override
  public int getSelectionMode() {
    return myProperties != null ? myProperties.getSelectionMode() : super.getSelectionMode();
  }
}",class,
"  public ImportedTestConsoleProperties(@Nullable SMTRunnerConsoleProperties properties,
                                       File file,
                                       ProcessHandler handler,
                                       Project project, RunProfile runConfiguration,
                                       String frameworkName,
                                       Executor executor) {
    super(project, runConfiguration, frameworkName, executor);
    myProperties = properties;
    myFile = file;
    myHandler = handler;
  }",method,
"  @Override
  public OutputToGeneralTestEventsConverter createTestEventsConverter(@NotNull String testFrameworkName,
                                                                      @NotNull TestConsoleProperties consoleProperties) {
    return new ImportedToGeneralTestEventsConverter(testFrameworkName, consoleProperties, myFile, myHandler);
  }",method,
"  @Override
  public boolean isIdBasedTestTree() {
    return false;
  }",method,
"  @Override
  public boolean isPrintTestingStartedTime() {
    return false;
  }",method,
"  @Nullable
  @Override
  public Navigatable getErrorNavigatable(@NotNull Location<?> location,
                                         @NotNull String stacktrace) {
    return myProperties == null ? null : myProperties.getErrorNavigatable(location, stacktrace);
  }",method,
"  @Nullable
  @Override
  public Navigatable getErrorNavigatable(@NotNull Project project,
                                         @NotNull String stacktrace) {
    return myProperties == null ? null : myProperties.getErrorNavigatable(project, stacktrace);
  }",method,
"  @Override
  public void addStackTraceFilter(Filter filter) {
    if (myProperties != null) {
      myProperties.addStackTraceFilter(filter);
    }
  }",method,
"    if (myProperties != null) {
      myProperties.addStackTraceFilter(filter);
    }",method,
"  @Override
  public boolean fixEmptySuite() {
    return myProperties != null && myProperties.fixEmptySuite();
  }",method,
"  @Override
  @Nullable
  public SMTestLocator getTestLocator() {
    return myProperties == null ? null : myProperties.getTestLocator();
  }",method,
"  @Override
  @Nullable
  public TestProxyFilterProvider getFilterProvider() {
    return myProperties == null ? null : myProperties.getFilterProvider();
  }",method,
"  @Override
  @Nullable
  public AbstractRerunFailedTestsAction createRerunFailedTestsAction(ConsoleView consoleView) {
    return myProperties == null ? null : myProperties.createRerunFailedTestsAction(consoleView);
  }",method,
"  @Override
  public void appendAdditionalActions(DefaultActionGroup actionGroup, JComponent parent, TestConsoleProperties target) {
    if (myProperties != null) {
      myProperties.appendAdditionalActions(actionGroup, parent, this);
    }
  }",method,
"    if (myProperties != null) {
      myProperties.appendAdditionalActions(actionGroup, parent, this);
    }",method,
"  @Override
  public int getSelectionMode() {
    return myProperties != null ? myProperties.getSelectionMode() : super.getSelectionMode();
  }",method,
"public class JNDI {
  public static final String TABLE_NAME = ""JNDI"";
  private static final class JNDITable extends Table {
    private final StringColumn myName = new StringColumn(""Name"");
    public JNDITable() {
      super(JNDI.class, TABLE_NAME, Table.MASK_FOR_LASTING_EVENTS);
    }
  }
  private static final JNDITable T_JNDI = new JNDITable();
  @MethodPattern(
    {
      ""*C*t*x*:list(javax.naming.Name) javax.naming.NamingEnumeration"",
      ""*C*t*x*:lookup(javax.naming.Name) Object"",
      ""*C*t*x*:bind(javax.naming.Name, Object) void"",
      ""*C*t*x*:listBindings(javax.naming.Name) javax.naming.NamingEnumeration"",
      ""*C*t*x*:lookupLink(javax.naming.Name) Object"",
      ""*C*t*x*:rebind(javax.naming.Name, Object) void"",
      ""*C*t*x*:unbind(javax.naming.Name) void"",
      ""*C*t*x*:rename(javax.naming.Name, javax.naming.Name) void"",
      ""*C*t*x*:composeName(javax.naming.Name, javax.naming.Name) javax.naming.Name"",
      ""*C*t*x*:createSubcontext(javax.naming.Name) javax.naming.Context"",
      ""*C*t*x*:destroySubcontext(javax.naming.Name) void"",
      ""*C*t*x*:getNameParser(javax.naming.Name) javax.naming.NameParser""
    }
  )
  @InstanceOf(""javax.naming.Context"")
  public static final class NamingContext_1 {
    public static int onEnter() {
      return T_JNDI.createRow();
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }
  @MethodPattern(
    {
      ""*C*t*x*:list(String) javax.naming.NamingEnumeration"",
      ""*C*t*x*:lookup(String) Object"",
      ""*C*t*x*:bind(String, Object) void"",
      ""*C*t*x*:listBindings(String) javax.naming.NamingEnumeration"",
      ""*C*t*x*:lookupLink(String) Object"",
      ""*C*t*x*:rebind(String, Object) void"",
      ""*C*t*x*:unbind(String) void""
    }
  )
  @InstanceOf(""javax.naming.Context"")
  public static final class NamingContext_2 {
    public static int onEnter(@Param(1) final String str) {
      final int rowIndex = T_JNDI.createRow();
      if (str != null && str.length() > 0) {
        T_JNDI.myName.setValue(rowIndex, str);
      }
      return rowIndex;
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }
  @MethodPattern(
    {
      ""*C*t*x*:search(String, *) javax.naming.NamingEnumeration"",
      ""*C*t*x*:getAttributes(String) javax.naming.directory.Attributes"",
      ""*C*t*x*:getAttributes(String, String[]) javax.naming.directory.Attributes"",
      ""*C*t*x*:bind(String, Object, javax.naming.directory.Attributes) void"",
      ""*C*t*x*:createSubcontext(String, javax.naming.directory.Attributes) javax.naming.directory.DirContext"",
      ""*C*t*x*:rebind(String, Object, javax.naming.directory.Attributes) void"",
      ""*C*t*x*:getSchema(String) javax.naming.directory.DirContext"",
      ""*C*t*x*:getSchemaClassDefinition(String) javax.naming.directory.DirContext"",
      ""*C*t*x*:modifyAttributes(String, *) void""
    }
  )
  @InstanceOf(""javax.naming.directory.DirContext"")
  public static final class DirContext_1 {
    public static int onEnter(@Param(1) final String str) {
      final int rowIndex = T_JNDI.createRow();
      if (str != null && str.length() > 0) {
        T_JNDI.myName.setValue(rowIndex, str);
      }
      return rowIndex;
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }
  @MethodPattern(
    {
      ""*C*t*x*:search(javax.naming.Name, *) javax.naming.NamingEnumeration"",
      ""*C*t*x*:getAttributes(javax.naming.Name, String[]) javax.naming.directory.Attributes"",
      ""*C*t*x*:getAttributes(javax.naming.Name) javax.naming.directory.Attributes"",
      ""*C*t*x*:bind(javax.naming.Name, Object, javax.naming.directory.Attributes) void"",
      ""*C*t*x*:createSubcontext(javax.naming.Name, javax.naming.directory.Attributes) javax.naming.directory.DirContext"",
      ""*C*t*x*:rebind(javax.naming.Name, Object, javax.naming.directory.Attributes) void"",
      ""*C*t*x*:getSchema(javax.naming.Name) javax.naming.directory.DirContext"",
      ""*C*t*x*:getSchemaClassDefinition(javax.naming.Name) javax.naming.directory.DirContext"",
      ""*C*t*x*:modifyAttributes(javax.naming.Name, *) void""
    }
  )
  @InstanceOf(""javax.naming.directory.DirContext"")
  public static final class DirContext_2 {
    public static int onEnter() {
      return T_JNDI.createRow();
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }
}",class,
"  private static final class JNDITable extends Table {
    private final StringColumn myName = new StringColumn(""Name"");
    public JNDITable() {
      super(JNDI.class, TABLE_NAME, Table.MASK_FOR_LASTING_EVENTS);
    }
  }",class,
"  public static final class NamingContext_1 {
    public static int onEnter() {
      return T_JNDI.createRow();
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }",class,
"  public static final class NamingContext_2 {
    public static int onEnter(@Param(1) final String str) {
      final int rowIndex = T_JNDI.createRow();
      if (str != null && str.length() > 0) {
        T_JNDI.myName.setValue(rowIndex, str);
      }
      return rowIndex;
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }",class,
"  public static final class DirContext_1 {
    public static int onEnter(@Param(1) final String str) {
      final int rowIndex = T_JNDI.createRow();
      if (str != null && str.length() > 0) {
        T_JNDI.myName.setValue(rowIndex, str);
      }
      return rowIndex;
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }",class,
"  public static final class DirContext_2 {
    public static int onEnter() {
      return T_JNDI.createRow();
    }
    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }
  }",class,
"    public JNDITable() {
      super(JNDI.class, TABLE_NAME, Table.MASK_FOR_LASTING_EVENTS);
    }",method,
"    public static int onEnter() {
      return T_JNDI.createRow();
    }",method,
"    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }",method,
"    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }",method,
"    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }",method,
"    public static int onEnter() {
      return T_JNDI.createRow();
    }",method,
"    public static void onExit(
      @OnEnterResult final int rowIndex,
      @ThrownException  final Throwable e
    ) {
      T_JNDI.closeRow(rowIndex, e);
    }",method,
"public class MqttSSLTest extends TestCase implements MqttCallback {
    private final int port = 8883;
    private final String brokerUrl = ""ssl://"" + getHost() + "":"" + port;
    private String clientId;
    private String clientId2;
    private MqttClient client;
    private MqttClient client2;
    private MqttConnectOptions conOpt;
    private ArrayList<MqttMessage> receivedMessages;
    private long lastReceipt;
    private boolean expectConnectionFailure;
    private static final String getHost() {
        Object host = System.getProperty(""hostname"");
        assertNotNull(host);
        return host.toString();
    }
    // override 10s limit
    private class MyConnOpts extends MqttConnectOptions {
        private int keepAliveInterval = 60;
        @Override
        public void setKeepAliveInterval(int keepAliveInterval) {
            this.keepAliveInterval = keepAliveInterval;
        }
        @Override
        public int getKeepAliveInterval() {
            return keepAliveInterval;
        }
    }
    @Override
    public void setUp() throws MqttException, IOException {
        clientId = getClass().getSimpleName() + ((int) (10000 * Math.random()));
        clientId2 = clientId + ""-2"";
        client = new MqttClient(brokerUrl, clientId, null);
        client2 = new MqttClient(brokerUrl, clientId2, null);
        conOpt = new MyConnOpts();
        conOpt.setSocketFactory(MutualAuth.getSSLContextWithoutCert().getSocketFactory());
        setConOpts(conOpt);
        receivedMessages = new ArrayList<MqttMessage>();
        expectConnectionFailure = false;
    }
    @Override
    public void tearDown() throws MqttException {
        // clean any sticky sessions
        setConOpts(conOpt);
        client = new MqttClient(brokerUrl, clientId, null);
        try {
            client.connect(conOpt);
            client.disconnect();
        } catch (Exception _) {
        }
        client2 = new MqttClient(brokerUrl, clientId2, null);
        try {
            client2.connect(conOpt);
            client2.disconnect();
        } catch (Exception _) {
        }
    }
    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }",class,
"    private class MyConnOpts extends MqttConnectOptions {
        private int keepAliveInterval = 60;
        @Override
        public void setKeepAliveInterval(int keepAliveInterval) {
            this.keepAliveInterval = keepAliveInterval;
        }
        @Override
        public int getKeepAliveInterval() {
            return keepAliveInterval;
        }
    }
    @Override
    public void setUp() throws MqttException, IOException {
        clientId = getClass().getSimpleName() + ((int) (10000 * Math.random()));
        clientId2 = clientId + ""-2"";
        client = new MqttClient(brokerUrl, clientId, null);
        client2 = new MqttClient(brokerUrl, clientId2, null);
        conOpt = new MyConnOpts();
        conOpt.setSocketFactory(MutualAuth.getSSLContextWithoutCert().getSocketFactory());
        setConOpts(conOpt);
        receivedMessages = new ArrayList<MqttMessage>();
        expectConnectionFailure = false;
    }
    @Override
    public void tearDown() throws MqttException {
        // clean any sticky sessions
        setConOpts(conOpt);
        client = new MqttClient(brokerUrl, clientId, null);
        try {
            client.connect(conOpt);
            client.disconnect();
        } catch (Exception _) {
        }
        client2 = new MqttClient(brokerUrl, clientId2, null);
        try {
            client2.connect(conOpt);
            client2.disconnect();
        } catch (Exception _) {
        }
    }
    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",class,
"    private static final String getHost() {
        Object host = System.getProperty(""hostname"");
        assertNotNull(host);
        return host.toString();
    }
    // override 10s limit
    private class MyConnOpts extends MqttConnectOptions {
        private int keepAliveInterval = 60;
        @Override
        public void setKeepAliveInterval(int keepAliveInterval) {
            this.keepAliveInterval = keepAliveInterval;
        }
        @Override
        public int getKeepAliveInterval() {
            return keepAliveInterval;
        }
    }
    @Override
    public void setUp() throws MqttException, IOException {
        clientId = getClass().getSimpleName() + ((int) (10000 * Math.random()));
        clientId2 = clientId + ""-2"";
        client = new MqttClient(brokerUrl, clientId, null);
        client2 = new MqttClient(brokerUrl, clientId2, null);
        conOpt = new MyConnOpts();
        conOpt.setSocketFactory(MutualAuth.getSSLContextWithoutCert().getSocketFactory());
        setConOpts(conOpt);
        receivedMessages = new ArrayList<MqttMessage>();
        expectConnectionFailure = false;
    }
    @Override
    public void tearDown() throws MqttException {
        // clean any sticky sessions
        setConOpts(conOpt);
        client = new MqttClient(brokerUrl, clientId, null);
        try {
            client.connect(conOpt);
            client.disconnect();
        } catch (Exception _) {
        }
        client2 = new MqttClient(brokerUrl, clientId2, null);
        try {
            client2.connect(conOpt);
            client2.disconnect();
        } catch (Exception _) {
        }
    }
    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"        @Override
        public void setKeepAliveInterval(int keepAliveInterval) {
            this.keepAliveInterval = keepAliveInterval;
        }
        @Override
        public int getKeepAliveInterval() {
            return keepAliveInterval;
        }
    }
    @Override
    public void setUp() throws MqttException, IOException {
        clientId = getClass().getSimpleName() + ((int) (10000 * Math.random()));
        clientId2 = clientId + ""-2"";
        client = new MqttClient(brokerUrl, clientId, null);
        client2 = new MqttClient(brokerUrl, clientId2, null);
        conOpt = new MyConnOpts();
        conOpt.setSocketFactory(MutualAuth.getSSLContextWithoutCert().getSocketFactory());
        setConOpts(conOpt);
        receivedMessages = new ArrayList<MqttMessage>();
        expectConnectionFailure = false;
    }
    @Override
    public void tearDown() throws MqttException {
        // clean any sticky sessions
        setConOpts(conOpt);
        client = new MqttClient(brokerUrl, clientId, null);
        try {
            client.connect(conOpt);
            client.disconnect();
        } catch (Exception _) {
        }
        client2 = new MqttClient(brokerUrl, clientId2, null);
        try {
            client2.connect(conOpt);
            client2.disconnect();
        } catch (Exception _) {
        }
    }
    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"        @Override
        public int getKeepAliveInterval() {
            return keepAliveInterval;
        }
    }
    @Override
    public void setUp() throws MqttException, IOException {
        clientId = getClass().getSimpleName() + ((int) (10000 * Math.random()));
        clientId2 = clientId + ""-2"";
        client = new MqttClient(brokerUrl, clientId, null);
        client2 = new MqttClient(brokerUrl, clientId2, null);
        conOpt = new MyConnOpts();
        conOpt.setSocketFactory(MutualAuth.getSSLContextWithoutCert().getSocketFactory());
        setConOpts(conOpt);
        receivedMessages = new ArrayList<MqttMessage>();
        expectConnectionFailure = false;
    }
    @Override
    public void tearDown() throws MqttException {
        // clean any sticky sessions
        setConOpts(conOpt);
        client = new MqttClient(brokerUrl, clientId, null);
        try {
            client.connect(conOpt);
            client.disconnect();
        } catch (Exception _) {
        }
        client2 = new MqttClient(brokerUrl, clientId2, null);
        try {
            client2.connect(conOpt);
            client2.disconnect();
        } catch (Exception _) {
        }
    }
    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    @Override
    public void setUp() throws MqttException, IOException {
        clientId = getClass().getSimpleName() + ((int) (10000 * Math.random()));
        clientId2 = clientId + ""-2"";
        client = new MqttClient(brokerUrl, clientId, null);
        client2 = new MqttClient(brokerUrl, clientId2, null);
        conOpt = new MyConnOpts();
        conOpt.setSocketFactory(MutualAuth.getSSLContextWithoutCert().getSocketFactory());
        setConOpts(conOpt);
        receivedMessages = new ArrayList<MqttMessage>();
        expectConnectionFailure = false;
    }
    @Override
    public void tearDown() throws MqttException {
        // clean any sticky sessions
        setConOpts(conOpt);
        client = new MqttClient(brokerUrl, clientId, null);
        try {
            client.connect(conOpt);
            client.disconnect();
        } catch (Exception _) {
        }
        client2 = new MqttClient(brokerUrl, clientId2, null);
        try {
            client2.connect(conOpt);
            client2.disconnect();
        } catch (Exception _) {
        }
    }
    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    @Override
    public void tearDown() throws MqttException {
        // clean any sticky sessions
        setConOpts(conOpt);
        client = new MqttClient(brokerUrl, clientId, null);
        try {
            client.connect(conOpt);
            client.disconnect();
        } catch (Exception _) {
        }
        client2 = new MqttClient(brokerUrl, clientId2, null);
        try {
            client2.connect(conOpt);
            client2.disconnect();
        } catch (Exception _) {
        }
    }
    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    private void setConOpts(MqttConnectOptions conOpts) {
        // provide authentication if the broker needs it
        // conOpts.setUserName(""guest"");
        // conOpts.setPassword(""guest"".toCharArray());
        conOpts.setCleanSession(true);
        conOpts.setKeepAliveInterval(60);
    }
    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    public void testCertLogin() throws MqttException {
        try {
            conOpt.setSocketFactory(MutualAuth.getSSLContextWithClientCert().getSocketFactory());
            client.connect(conOpt);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    public void testInvalidUser() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    public void testInvalidPassword() throws MqttException {
        conOpt.setUserName(""invalid-user"");
        conOpt.setPassword(""invalid-password"".toCharArray());
        try {
            client.connect(conOpt);
            fail(""Authentication failure expected"");
        } catch (MqttException ex) {
            Assert.assertEquals(MqttException.REASON_CODE_FAILED_AUTHENTICATION, ex.getReasonCode());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Exception: "" + e.getMessage());
        }
    }
    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    public void connectionLost(Throwable cause) {
        if (!expectConnectionFailure)
            fail(""Connection unexpectedly lost"");
    }
    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,
"    public void messageArrived(String topic, MqttMessage message) throws Exception {
        lastReceipt = System.currentTimeMillis();
        receivedMessages.add(message);
    }",method,

code_snippet,type,score
"  @NotNull
  private LanguageLevel getLanguageLevelOrDefault() {
    return ObjectUtils.chooseNotNull(myLanguageLevel, LanguageLevel.HIGHEST);
  }",method,
"  @Override
  public void setLanguageLevel(@NotNull LanguageLevel languageLevel) {
    // we don't use here getLanguageLevelOrDefault() - if null, just set to provided value, because our default (LanguageLevel.HIGHEST) is changed every java release
    if (myLanguageLevel != languageLevel) {
      myLanguageLevel = languageLevel;
      languageLevelsChanged();
    }
  }",method,
"    if (myLanguageLevel != languageLevel) {
      myLanguageLevel = languageLevel;
      languageLevelsChanged();
    }",method,
"  @Override
  public void languageLevelsChanged() {
    if (!myProject.isDefault()) {
      ProjectRootManager.getInstance(myProject).incModificationCount();
      JavaLanguageLevelPusher.pushLanguageLevel(myProject);
    }
  }",method,
"  private void projectSdkChanged(@Nullable Sdk sdk) {
    if (isDefault() && sdk != null) {
      JavaSdkVersion version = JavaSdk.getInstance().getVersion(sdk);
      if (version != null) {
        setLanguageLevel(version.getMaxLanguageLevel());
      }
    }
  }",method,
"      if (version != null) {
        setLanguageLevel(version.getMaxLanguageLevel());
      }",method,
"  public void setCurrentLevel(LanguageLevel level) {
    myCurrentLevel = level;
  }",method,
"  public LanguageLevel getCurrentLevel() {
    return myCurrentLevel;
  }",method,
"    public MyProjectExtension(final Project project) {
      myInstance = ((LanguageLevelProjectExtensionImpl)getInstance(project));
    }",method,
"    @Override
    public void readExternal(@NotNull Element element) {
      myInstance.readExternal(element);
    }",method,
"    @Override
    public void writeExternal(@NotNull Element element) {
      myInstance.writeExternal(element);
    }",method,
"    @Override
    public void projectSdkChanged(@Nullable Sdk sdk) {
      myInstance.projectSdkChanged(sdk);
    }",method,
"public class FreeMarkerViewTests {
	@Rule
	public final ExpectedException exception = ExpectedException.none();
	@Test
	public void noFreeMarkerConfig() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		WebApplicationContext wac = mock(WebApplicationContext.class);
		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(new HashMap<>());
		given(wac.getServletContext()).willReturn(new MockServletContext());
		fv.setUrl(""anythingButNull"");
		exception.expect(ApplicationContextException.class);
		exception.expectMessage(containsString(""FreeMarkerConfig""));
		fv.setApplicationContext(wac);
	}
	@Test
	public void noTemplateName() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		exception.expect(IllegalArgumentException.class);
		exception.expectMessage(containsString(""url""));
		fv.afterPropertiesSet();
	}
	@Test
	public void validTemplateName() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		WebApplicationContext wac = mock(WebApplicationContext.class);
		MockServletContext sc = new MockServletContext();
		Map<String, FreeMarkerConfig> configs = new HashMap<>();
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setConfiguration(new TestConfiguration());
		configurer.setServletContext(sc);
		configs.put(""configurer"", configurer);
		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(configs);
		given(wac.getServletContext()).willReturn(sc);
		fv.setUrl(""templateName"");
		fv.setApplicationContext(wac);
		MockHttpServletRequest request = new MockHttpServletRequest();
		request.addPreferredLocale(Locale.US);
		request.setAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
		request.setAttribute(DispatcherServlet.LOCALE_RESOLVER_ATTRIBUTE, new AcceptHeaderLocaleResolver());
		HttpServletResponse response = new MockHttpServletResponse();
		Map<String, Object> model = new HashMap<>();
		model.put(""myattr"", ""myvalue"");
		fv.render(model, request, response);
		assertEquals(AbstractView.DEFAULT_CONTENT_TYPE, response.getContentType());
	}
	@Test
	public void keepExistingContentType() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		WebApplicationContext wac = mock(WebApplicationContext.class);
		MockServletContext sc = new MockServletContext();
		Map<String, FreeMarkerConfig> configs = new HashMap<>();
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setConfiguration(new TestConfiguration());
		configurer.setServletContext(sc);
		configs.put(""configurer"", configurer);
		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(configs);
		given(wac.getServletContext()).willReturn(sc);
		fv.setUrl(""templateName"");
		fv.setApplicationContext(wac);
		MockHttpServletRequest request = new MockHttpServletRequest();
		request.addPreferredLocale(Locale.US);
		request.setAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
		request.setAttribute(DispatcherServlet.LOCALE_RESOLVER_ATTRIBUTE, new AcceptHeaderLocaleResolver());
		HttpServletResponse response = new MockHttpServletResponse();
		response.setContentType(""myContentType"");
		Map<String, Object> model = new HashMap<>();
		model.put(""myattr"", ""myvalue"");
		fv.render(model, request, response);
		assertEquals(""myContentType"", response.getContentType());
	}
	@Test
	public void freeMarkerViewResolver() throws Exception {
		MockServletContext sc = new MockServletContext();
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setConfiguration(new TestConfiguration());
		configurer.setServletContext(sc);
		StaticWebApplicationContext wac = new StaticWebApplicationContext();
		wac.setServletContext(sc);
		wac.getBeanFactory().registerSingleton(""configurer"", configurer);
		wac.refresh();
		FreeMarkerViewResolver vr = new FreeMarkerViewResolver(""prefix_"", ""_suffix"");
		vr.setApplicationContext(wac);
		View view = vr.resolveViewName(""test"", Locale.CANADA);
		assertEquals(""Correct view class"", FreeMarkerView.class, view.getClass());
		assertEquals(""Correct URL"", ""prefix_test_suffix"", ((FreeMarkerView) view).getUrl());
		view = vr.resolveViewName(""non-existing"", Locale.CANADA);
		assertNull(view);
		view = vr.resolveViewName(""redirect:myUrl"", Locale.getDefault());
		assertEquals(""Correct view class"", RedirectView.class, view.getClass());
		assertEquals(""Correct URL"", ""myUrl"", ((RedirectView) view).getUrl());
		view = vr.resolveViewName(""forward:myUrl"", Locale.getDefault());
		assertEquals(""Correct view class"", InternalResourceView.class, view.getClass());
		assertEquals(""Correct URL"", ""myUrl"", ((InternalResourceView) view).getUrl());
	}
	private class TestConfiguration extends Configuration {
		TestConfiguration() {
			super(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
		}
		@Override
		public Template getTemplate(String name, final Locale locale) throws IOException {
			if (name.equals(""templateName"") || name.equals(""prefix_test_suffix"")) {
				return new Template(name, new StringReader(""test""), this) {
					@Override
					public void process(Object model, Writer writer) throws TemplateException, IOException {
						assertEquals(Locale.US, locale);
						assertTrue(model instanceof AllHttpScopesHashModel);
						AllHttpScopesHashModel fmModel = (AllHttpScopesHashModel) model;
						assertEquals(""myvalue"", fmModel.get(""myattr"").toString());
					}
				};
			}
			else {
				throw new FileNotFoundException();
			}
		}
	}
}",class,
"	private class TestConfiguration extends Configuration {
		TestConfiguration() {
			super(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
		}
		@Override
		public Template getTemplate(String name, final Locale locale) throws IOException {
			if (name.equals(""templateName"") || name.equals(""prefix_test_suffix"")) {
				return new Template(name, new StringReader(""test""), this) {
					@Override
					public void process(Object model, Writer writer) throws TemplateException, IOException {
						assertEquals(Locale.US, locale);
						assertTrue(model instanceof AllHttpScopesHashModel);
						AllHttpScopesHashModel fmModel = (AllHttpScopesHashModel) model;
						assertEquals(""myvalue"", fmModel.get(""myattr"").toString());
					}
				};
			}
			else {
				throw new FileNotFoundException();
			}
		}
	}",class,
"	@Test
	public void noFreeMarkerConfig() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		WebApplicationContext wac = mock(WebApplicationContext.class);
		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(new HashMap<>());
		given(wac.getServletContext()).willReturn(new MockServletContext());
		fv.setUrl(""anythingButNull"");
		exception.expect(ApplicationContextException.class);
		exception.expectMessage(containsString(""FreeMarkerConfig""));
		fv.setApplicationContext(wac);
	}",method,
"	@Test
	public void noTemplateName() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		exception.expect(IllegalArgumentException.class);
		exception.expectMessage(containsString(""url""));
		fv.afterPropertiesSet();
	}",method,
"	@Test
	public void validTemplateName() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		WebApplicationContext wac = mock(WebApplicationContext.class);
		MockServletContext sc = new MockServletContext();
		Map<String, FreeMarkerConfig> configs = new HashMap<>();
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setConfiguration(new TestConfiguration());
		configurer.setServletContext(sc);
		configs.put(""configurer"", configurer);
		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(configs);
		given(wac.getServletContext()).willReturn(sc);
		fv.setUrl(""templateName"");
		fv.setApplicationContext(wac);
		MockHttpServletRequest request = new MockHttpServletRequest();
		request.addPreferredLocale(Locale.US);
		request.setAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
		request.setAttribute(DispatcherServlet.LOCALE_RESOLVER_ATTRIBUTE, new AcceptHeaderLocaleResolver());
		HttpServletResponse response = new MockHttpServletResponse();
		Map<String, Object> model = new HashMap<>();
		model.put(""myattr"", ""myvalue"");
		fv.render(model, request, response);
		assertEquals(AbstractView.DEFAULT_CONTENT_TYPE, response.getContentType());
	}",method,
"	@Test
	public void keepExistingContentType() throws Exception {
		FreeMarkerView fv = new FreeMarkerView();
		WebApplicationContext wac = mock(WebApplicationContext.class);
		MockServletContext sc = new MockServletContext();
		Map<String, FreeMarkerConfig> configs = new HashMap<>();
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setConfiguration(new TestConfiguration());
		configurer.setServletContext(sc);
		configs.put(""configurer"", configurer);
		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(configs);
		given(wac.getServletContext()).willReturn(sc);
		fv.setUrl(""templateName"");
		fv.setApplicationContext(wac);
		MockHttpServletRequest request = new MockHttpServletRequest();
		request.addPreferredLocale(Locale.US);
		request.setAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
		request.setAttribute(DispatcherServlet.LOCALE_RESOLVER_ATTRIBUTE, new AcceptHeaderLocaleResolver());
		HttpServletResponse response = new MockHttpServletResponse();
		response.setContentType(""myContentType"");
		Map<String, Object> model = new HashMap<>();
		model.put(""myattr"", ""myvalue"");
		fv.render(model, request, response);
		assertEquals(""myContentType"", response.getContentType());
	}",method,
"	@Test
	public void freeMarkerViewResolver() throws Exception {
		MockServletContext sc = new MockServletContext();
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setConfiguration(new TestConfiguration());
		configurer.setServletContext(sc);
		StaticWebApplicationContext wac = new StaticWebApplicationContext();
		wac.setServletContext(sc);
		wac.getBeanFactory().registerSingleton(""configurer"", configurer);
		wac.refresh();
		FreeMarkerViewResolver vr = new FreeMarkerViewResolver(""prefix_"", ""_suffix"");
		vr.setApplicationContext(wac);
		View view = vr.resolveViewName(""test"", Locale.CANADA);
		assertEquals(""Correct view class"", FreeMarkerView.class, view.getClass());
		assertEquals(""Correct URL"", ""prefix_test_suffix"", ((FreeMarkerView) view).getUrl());
		view = vr.resolveViewName(""non-existing"", Locale.CANADA);
		assertNull(view);
		view = vr.resolveViewName(""redirect:myUrl"", Locale.getDefault());
		assertEquals(""Correct view class"", RedirectView.class, view.getClass());
		assertEquals(""Correct URL"", ""myUrl"", ((RedirectView) view).getUrl());
		view = vr.resolveViewName(""forward:myUrl"", Locale.getDefault());
		assertEquals(""Correct view class"", InternalResourceView.class, view.getClass());
		assertEquals(""Correct URL"", ""myUrl"", ((InternalResourceView) view).getUrl());
	}",method,
"		TestConfiguration() {
			super(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
		}",method,
"		@Override
		public Template getTemplate(String name, final Locale locale) throws IOException {
			if (name.equals(""templateName"") || name.equals(""prefix_test_suffix"")) {
				return new Template(name, new StringReader(""test""), this) {
					@Override
					public void process(Object model, Writer writer) throws TemplateException, IOException {
						assertEquals(Locale.US, locale);
						assertTrue(model instanceof AllHttpScopesHashModel);
						AllHttpScopesHashModel fmModel = (AllHttpScopesHashModel) model;
						assertEquals(""myvalue"", fmModel.get(""myattr"").toString());
					}
				};
			}
			else {
				throw new FileNotFoundException();
			}
		}",method,
"					@Override
					public void process(Object model, Writer writer) throws TemplateException, IOException {
						assertEquals(Locale.US, locale);
						assertTrue(model instanceof AllHttpScopesHashModel);
						AllHttpScopesHashModel fmModel = (AllHttpScopesHashModel) model;
						assertEquals(""myvalue"", fmModel.get(""myattr"").toString());
					}",method,
"public class Bug_for_happyday517 extends TestCase {
    private DruidDataSource dataSource;
    private MockDriver      driver;
    private int originalDataSourceCount = 0;
    protected void setUp() throws Exception {
        originalDataSourceCount = DruidDataSourceStatManager.getInstance().getDataSourceList().size();
        driver = new MockDriver();
        dataSource = new DruidDataSource();
        dataSource.setUrl(""jdbc:mock:xxx"");
        dataSource.setFilters(""stat,trace,log4j,encoding"");
    }
    protected void tearDown() throws Exception {
        dataSource.close();
        Assert.assertEquals(originalDataSourceCount, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
    }
    public void test_for_happyday517_0() throws Exception {
        Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
        MockStatement mockStmt = stmt.unwrap(MockStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        stmt.close();
        conn.close();
    }
    public void test_for_happyday517_1() throws Exception {
        Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
                                              ResultSet.CLOSE_CURSORS_AT_COMMIT);
        MockStatement mockStmt = stmt.unwrap(MockStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
        stmt.close();
        conn.close();
    }
    public void test_for_happyday517_2() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
        MockPreparedStatement mockStmt = stmt.unwrap(MockPreparedStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        stmt.close();
        conn.close();
    }
    public void test_for_happyday517_3() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
                                               ResultSet.CLOSE_CURSORS_AT_COMMIT);
        MockPreparedStatement mockStmt = stmt.unwrap(MockPreparedStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
        stmt.close();
        conn.close();
    }
    public void test_for_happyday517_4() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareCall(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
        Statement mockStmt = stmt.unwrap(Statement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        stmt.close();
        conn.close();
    }
    public void test_for_happyday517_5() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareCall(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
                                          ResultSet.CLOSE_CURSORS_AT_COMMIT);
        Statement mockStmt = stmt.unwrap(Statement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
        stmt.close();
        conn.close();
    }
}",class,
"    protected void setUp() throws Exception {
        originalDataSourceCount = DruidDataSourceStatManager.getInstance().getDataSourceList().size();
        driver = new MockDriver();
        dataSource = new DruidDataSource();
        dataSource.setUrl(""jdbc:mock:xxx"");
        dataSource.setFilters(""stat,trace,log4j,encoding"");
    }",method,
"    protected void tearDown() throws Exception {
        dataSource.close();
        Assert.assertEquals(originalDataSourceCount, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
    }",method,
"    public void test_for_happyday517_0() throws Exception {
        Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
        MockStatement mockStmt = stmt.unwrap(MockStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        stmt.close();
        conn.close();
    }",method,
"    public void test_for_happyday517_1() throws Exception {
        Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
                                              ResultSet.CLOSE_CURSORS_AT_COMMIT);
        MockStatement mockStmt = stmt.unwrap(MockStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
        stmt.close();
        conn.close();
    }",method,
"    public void test_for_happyday517_2() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
        MockPreparedStatement mockStmt = stmt.unwrap(MockPreparedStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        stmt.close();
        conn.close();
    }",method,
"    public void test_for_happyday517_3() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
                                               ResultSet.CLOSE_CURSORS_AT_COMMIT);
        MockPreparedStatement mockStmt = stmt.unwrap(MockPreparedStatement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
        stmt.close();
        conn.close();
    }",method,
"    public void test_for_happyday517_4() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareCall(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
        Statement mockStmt = stmt.unwrap(Statement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        stmt.close();
        conn.close();
    }",method,
"    public void test_for_happyday517_5() throws Exception {
        Connection conn = dataSource.getConnection();
        String sql = ""select 1"";
        Statement stmt = conn.prepareCall(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
                                          ResultSet.CLOSE_CURSORS_AT_COMMIT);
        Statement mockStmt = stmt.unwrap(Statement.class);
        Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
        Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
        Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
        stmt.close();
        conn.close();
    }",method,
"public class MainClassConventionTests {
	@Rule
	public final TemporaryFolder temp = new TemporaryFolder();
	private Project project;
	private MainClassConvention convention;
	@Before
	public void createConvention() throws IOException {
		this.project = ProjectBuilder.builder().withProjectDir(this.temp.newFolder())
				.build();
		this.convention = new MainClassConvention(this.project, () -> null);
	}
	@Test
	public void mainClassNameProjectPropertyIsUsed() throws Exception {
		this.project.getExtensions().getByType(ExtraPropertiesExtension.class)
				.set(""mainClassName"", ""com.example.MainClass"");
		assertThat(this.convention.call()).isEqualTo(""com.example.MainClass"");
	}
	@Test
	public void springBootExtensionMainClassNameIsUsed() throws Exception {
		SpringBootExtension extension = this.project.getExtensions().create(""springBoot"",
				SpringBootExtension.class, this.project);
		extension.setMainClassName(""com.example.MainClass"");
		assertThat(this.convention.call()).isEqualTo(""com.example.MainClass"");
	}
	@Test
	public void springBootExtensionMainClassNameIsUsedInPreferenceToMainClassNameProjectProperty()
			throws Exception {
		this.project.getExtensions().getByType(ExtraPropertiesExtension.class)
				.set(""mainClassName"", ""com.example.ProjectPropertyMainClass"");
		SpringBootExtension extension = this.project.getExtensions().create(""springBoot"",
				SpringBootExtension.class, this.project);
		extension.setMainClassName(""com.example.SpringBootExtensionMainClass"");
		assertThat(this.convention.call())
				.isEqualTo(""com.example.SpringBootExtensionMainClass"");
	}
}",class,
"	@Before
	public void createConvention() throws IOException {
		this.project = ProjectBuilder.builder().withProjectDir(this.temp.newFolder())
				.build();
		this.convention = new MainClassConvention(this.project, () -> null);
	}",method,
"	@Test
	public void mainClassNameProjectPropertyIsUsed() throws Exception {
		this.project.getExtensions().getByType(ExtraPropertiesExtension.class)
				.set(""mainClassName"", ""com.example.MainClass"");
		assertThat(this.convention.call()).isEqualTo(""com.example.MainClass"");
	}",method,
"	@Test
	public void springBootExtensionMainClassNameIsUsed() throws Exception {
		SpringBootExtension extension = this.project.getExtensions().create(""springBoot"",
				SpringBootExtension.class, this.project);
		extension.setMainClassName(""com.example.MainClass"");
		assertThat(this.convention.call()).isEqualTo(""com.example.MainClass"");
	}",method,
"	@Test
	public void springBootExtensionMainClassNameIsUsedInPreferenceToMainClassNameProjectProperty()
			throws Exception {
		this.project.getExtensions().getByType(ExtraPropertiesExtension.class)
				.set(""mainClassName"", ""com.example.ProjectPropertyMainClass"");
		SpringBootExtension extension = this.project.getExtensions().create(""springBoot"",
				SpringBootExtension.class, this.project);
		extension.setMainClassName(""com.example.SpringBootExtensionMainClass"");
		assertThat(this.convention.call())
				.isEqualTo(""com.example.SpringBootExtensionMainClass"");
	}",method,
"public class WashingMachine {
  private static final Logger LOGGER = LoggerFactory.getLogger(WashingMachine.class);
  private WashingMachineState washingMachineState;
  public WashingMachine() {
    washingMachineState = WashingMachineState.ENABLED;
  }
  public WashingMachineState getWashingMachineState() {
    return washingMachineState;
  }
  public void wash() {
    synchronized (this) {
      LOGGER.info(""{}: Actual machine state: {}"", Thread.currentThread().getName(), getWashingMachineState());
      if (washingMachineState == WashingMachineState.WASHING) {
        LOGGER.error(""ERROR: Cannot wash if the machine has been already washing!"");
        return;
      }
      washingMachineState = WashingMachineState.WASHING;
    }
    LOGGER.info(""{}: Doing the washing"", Thread.currentThread().getName());
    try {
      Thread.sleep(50);
    } catch (InterruptedException ie) {
      ie.printStackTrace();
    }
    endOfWashing();
  }
  public synchronized void endOfWashing() {
    washingMachineState = WashingMachineState.ENABLED;
    LOGGER.info(""{}: Washing completed."", Thread.currentThread().getId());
  }
}",class,
"  public WashingMachine() {
    washingMachineState = WashingMachineState.ENABLED;
  }",method,
"  public WashingMachineState getWashingMachineState() {
    return washingMachineState;
  }",method,
"  public void wash() {
    synchronized (this) {
      LOGGER.info(""{}: Actual machine state: {}"", Thread.currentThread().getName(), getWashingMachineState());
      if (washingMachineState == WashingMachineState.WASHING) {
        LOGGER.error(""ERROR: Cannot wash if the machine has been already washing!"");
        return;
      }
      washingMachineState = WashingMachineState.WASHING;
    }
    LOGGER.info(""{}: Doing the washing"", Thread.currentThread().getName());
    try {
      Thread.sleep(50);
    } catch (InterruptedException ie) {
      ie.printStackTrace();
    }
    endOfWashing();
  }",method,
"    synchronized (this) {
      LOGGER.info(""{}: Actual machine state: {}"", Thread.currentThread().getName(), getWashingMachineState());
      if (washingMachineState == WashingMachineState.WASHING) {
        LOGGER.error(""ERROR: Cannot wash if the machine has been already washing!"");
        return;
      }
      washingMachineState = WashingMachineState.WASHING;
    }",method,
"      if (washingMachineState == WashingMachineState.WASHING) {
        LOGGER.error(""ERROR: Cannot wash if the machine has been already washing!"");
        return;
      }",method,
"  public synchronized void endOfWashing() {
    washingMachineState = WashingMachineState.ENABLED;
    LOGGER.info(""{}: Washing completed."", Thread.currentThread().getId());
  }",method,
"public abstract class AbstractMenuActivity extends Activity{
	private NumberPicker picker;
	public abstract boolean willItSaveTimes();
	public abstract void onRateButtonClick();
	public abstract void onShowChronometerButtonClick();
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.menu_layout);
		picker = (NumberPicker) findViewById(R.id.num_picker);
		picker.setRange(1, ChronoList.MAX_CHRONO_NUMBER);
		picker.setWrap(false);
		Button showChronoBT = (Button) findViewById(R.id.show_chronometers_bt);
		showChronoBT.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				onShowChronometerButtonClick();
			}
		});
		Button savedTimes = (Button) findViewById(R.id.saved_times_bt);
		if (willItSaveTimes()){
			savedTimes = (Button) findViewById(R.id.saved_times_bt);
			savedTimes.setOnClickListener(new OnClickListener() {
				public void onClick(View arg0) {
					onSavedTimesButtonClick();
				}
			});
		}else{
			savedTimes.setVisibility(Button.GONE);
		}
		Button market = (Button) findViewById(R.id.email_bt);
		market.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				Intent sendMailIntent = new Intent(Intent.ACTION_SEND); 
				sendMailIntent.putExtra(Intent.EXTRA_SUBJECT, ""Sugestions and Critics"");
				sendMailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{""forcoaches@gmail.com""});
				sendMailIntent.setType(""message/rfc822"");
				startActivity(Intent.createChooser(sendMailIntent, ""Send e-mail""));
			}
		});
		Button rate = (Button) findViewById(R.id.rate_bt);
		rate.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				onRateButtonClick();
			}
		});
	}
	protected void onSavedTimesButtonClick(){
	}
	protected int getSelectedNumberOfChronos(){
		return picker.getCurrent();
	}
}",class,
"	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.menu_layout);
		picker = (NumberPicker) findViewById(R.id.num_picker);
		picker.setRange(1, ChronoList.MAX_CHRONO_NUMBER);
		picker.setWrap(false);
		Button showChronoBT = (Button) findViewById(R.id.show_chronometers_bt);
		showChronoBT.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				onShowChronometerButtonClick();
			}
		});
		Button savedTimes = (Button) findViewById(R.id.saved_times_bt);
		if (willItSaveTimes()){
			savedTimes = (Button) findViewById(R.id.saved_times_bt);
			savedTimes.setOnClickListener(new OnClickListener() {
				public void onClick(View arg0) {
					onSavedTimesButtonClick();
				}
			});
		}else{
			savedTimes.setVisibility(Button.GONE);
		}
		Button market = (Button) findViewById(R.id.email_bt);
		market.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				Intent sendMailIntent = new Intent(Intent.ACTION_SEND); 
				sendMailIntent.putExtra(Intent.EXTRA_SUBJECT, ""Sugestions and Critics"");
				sendMailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{""forcoaches@gmail.com""});
				sendMailIntent.setType(""message/rfc822"");
				startActivity(Intent.createChooser(sendMailIntent, ""Send e-mail""));
			}
		});
		Button rate = (Button) findViewById(R.id.rate_bt);
		rate.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				onRateButtonClick();
			}
		});
	}",method,
"		showChronoBT.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				onShowChronometerButtonClick();
			}
		}",method,
"			public void onClick(View v) {
				onShowChronometerButtonClick();
			}",method,
"			savedTimes.setOnClickListener(new OnClickListener() {
				public void onClick(View arg0) {
					onSavedTimesButtonClick();
				}
			}",method,
"				public void onClick(View arg0) {
					onSavedTimesButtonClick();
				}",method,
"		market.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				Intent sendMailIntent = new Intent(Intent.ACTION_SEND); 
				sendMailIntent.putExtra(Intent.EXTRA_SUBJECT, ""Sugestions and Critics"");
				sendMailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{""forcoaches@gmail.com""});
				sendMailIntent.setType(""message/rfc822"");
				startActivity(Intent.createChooser(sendMailIntent, ""Send e-mail""));
			}
		}",method,
"			public void onClick(View v) {
				Intent sendMailIntent = new Intent(Intent.ACTION_SEND); 
				sendMailIntent.putExtra(Intent.EXTRA_SUBJECT, ""Sugestions and Critics"");
				sendMailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{""forcoaches@gmail.com""});
				sendMailIntent.setType(""message/rfc822"");
				startActivity(Intent.createChooser(sendMailIntent, ""Send e-mail""));
			}",method,
"		rate.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				onRateButtonClick();
			}
		}",method,
"			public void onClick(View v) {
				onRateButtonClick();
			}",method,
"	protected void onSavedTimesButtonClick(){
	}",method,
"	protected int getSelectedNumberOfChronos(){
		return picker.getCurrent();
	}",method,
"public class BuildAndDecodeJarTest {
    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, ""testjar-orig"");
        sTestNewDir = new ExtFile(sTmpDir, ""testjar-new"");
        LOGGER.info(""Unpacking testjar..."");
        TestUtils.copyResourceDir(BuildAndDecodeJarTest.class, ""brut/apktool/testjar/"", sTestOrigDir);
        LOGGER.info(""Building testjar.jar..."");
        File testJar = new File(sTmpDir, ""testjar.jar"");
        new Androlib().build(sTestOrigDir, testJar);
        LOGGER.info(""Decoding testjar.jar..."");
        ApkDecoder apkDecoder = new ApkDecoder(testJar);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }
    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }
    @Test
    public void buildAndDecodeTest() throws BrutException {
        assertTrue(sTestNewDir.isDirectory());
    }
    private static ExtFile sTmpDir;
    private static ExtFile sTestOrigDir;
    private static ExtFile sTestNewDir;
    private final static Logger LOGGER = Logger.getLogger(BuildAndDecodeJarTest.class.getName());
}",class,
"    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, ""testjar-orig"");
        sTestNewDir = new ExtFile(sTmpDir, ""testjar-new"");
        LOGGER.info(""Unpacking testjar..."");
        TestUtils.copyResourceDir(BuildAndDecodeJarTest.class, ""brut/apktool/testjar/"", sTestOrigDir);
        LOGGER.info(""Building testjar.jar..."");
        File testJar = new File(sTmpDir, ""testjar.jar"");
        new Androlib().build(sTestOrigDir, testJar);
        LOGGER.info(""Decoding testjar.jar..."");
        ApkDecoder apkDecoder = new ApkDecoder(testJar);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }",method,
"    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }",method,
"    @Test
    public void buildAndDecodeTest() throws BrutException {
        assertTrue(sTestNewDir.isDirectory());
    }",method,
"public final class OneToOneSequencedLongArrayThroughputTest extends AbstractPerfTestDisruptor
{
    private static final int BUFFER_SIZE = 1024 * 1;
    private static final long ITERATIONS = 1000L * 1000L * 1L;
    private static final int ARRAY_SIZE = 2 * 1024;
    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
    private static final EventFactory<long[]> FACTORY = new EventFactory<long[]>()
    {
        @Override
        public long[] newInstance()
        {
            return new long[ARRAY_SIZE];
        }
    };
    ///////////////////////////////////////////////////////////////////////////////////////////////
    private final RingBuffer<long[]> ringBuffer =
        createSingleProducer(FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
    private final LongArrayEventHandler handler = new LongArrayEventHandler();
    private final BatchEventProcessor<long[]> batchEventProcessor =
        new BatchEventProcessor<long[]>(ringBuffer, sequenceBarrier, handler);
    {
        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////
    @Override
    protected int getRequiredProcessorCount()
    {
        return 2;
    }
    @Override
    protected long runDisruptorPass() throws InterruptedException
    {
        final CountDownLatch latch = new CountDownLatch(1);
        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;
        handler.reset(latch, ITERATIONS);
        executor.submit(batchEventProcessor);
        long start = System.currentTimeMillis();
        final RingBuffer<long[]> rb = ringBuffer;
        for (long i = 0; i < ITERATIONS; i++)
        {
            long next = rb.next();
            long[] event = rb.get(next);
            for (int j = 0; j < event.length; j++)
            {
                event[j] = i;
            }
            rb.publish(next);
        }
        latch.await();
        long opsPerSecond = (ITERATIONS * ARRAY_SIZE * 1000L) / (System.currentTimeMillis() - start);
        waitForEventProcessorSequence(expectedCount);
        batchEventProcessor.halt();
        PerfTestUtil.failIf(0, handler.getValue());
        return opsPerSecond;
    }
    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
    {
        while (batchEventProcessor.getSequence().get() != expectedCount)
        {
            Thread.sleep(1);
        }
    }
    public static void main(String[] args) throws Exception
    {
        OneToOneSequencedLongArrayThroughputTest test = new OneToOneSequencedLongArrayThroughputTest();
        test.testImplementations();
    }
}",class,
"        @Override
        public long[] newInstance()
        {
            return new long[ARRAY_SIZE];
        }",method,
"    @Override
    protected int getRequiredProcessorCount()
    {
        return 2;
    }",method,
"    @Override
    protected long runDisruptorPass() throws InterruptedException
    {
        final CountDownLatch latch = new CountDownLatch(1);
        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;
        handler.reset(latch, ITERATIONS);
        executor.submit(batchEventProcessor);
        long start = System.currentTimeMillis();
        final RingBuffer<long[]> rb = ringBuffer;
        for (long i = 0; i < ITERATIONS; i++)
        {
            long next = rb.next();
            long[] event = rb.get(next);
            for (int j = 0; j < event.length; j++)
            {
                event[j] = i;
            }
            rb.publish(next);
        }
        latch.await();
        long opsPerSecond = (ITERATIONS * ARRAY_SIZE * 1000L) / (System.currentTimeMillis() - start);
        waitForEventProcessorSequence(expectedCount);
        batchEventProcessor.halt();
        PerfTestUtil.failIf(0, handler.getValue());
        return opsPerSecond;
    }",method,
"        for (long i = 0; i < ITERATIONS; i++)
        {
            long next = rb.next();
            long[] event = rb.get(next);
            for (int j = 0; j < event.length; j++)
            {
                event[j] = i;
            }
            rb.publish(next);
        }",method,
"            for (int j = 0; j < event.length; j++)
            {
                event[j] = i;
            }",method,
"    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
    {
        while (batchEventProcessor.getSequence().get() != expectedCount)
        {
            Thread.sleep(1);
        }
    }",method,
"    public static void main(String[] args) throws Exception
    {
        OneToOneSequencedLongArrayThroughputTest test = new OneToOneSequencedLongArrayThroughputTest();
        test.testImplementations();
    }",method,
"public class EditorTracker implements ITextFileBufferOwner, IDocumentOwner, ITextEditorWatcher
 {
	private final static Logger LOGGER = Logger.getLogger(EditorTracker.class);
	public Logger getLOGGER() {
		return LOGGER;
	}
	private IWorkbenchPage page;
	public IWorkbenchPage getPage() {
		return page;
	}
	public EditorTracker(IWorkbenchPage page) {
		this.page = page;
	}
	///////////////////// Listeners ////////////////////
	private DocumentListener documentListener = new DocumentListener(this);
	private TextEditorWatcherPartListener textEditorWatcherPartListener = new TextEditorWatcherPartListener(this);
	private TextFileBufferListener textFileBufferListener = new TextFileBufferListener(this);
	public void installListeners() {
		page.addPartListener(textEditorWatcherPartListener);
		FileBuffers.getTextFileBufferManager().addFileBufferListener(textFileBufferListener);
		editorContentListeners = Collections.unmodifiableList(loadEditorContentListeners());
	}
	private List<IEditorContentListener> editorContentListeners;
	public List<IEditorContentListener> getEditorContentListeners() {
		return editorContentListeners;
	}
	private static final String XP_EDITOR_CONTENT_LISTENERS = 
		Activator.getPluginId() + "".editorContentListeners"";
	private List<IEditorContentListener> loadEditorContentListeners() {
		List<IEditorContentListener> providers = new ArrayList<IEditorContentListener>();
		IExtensionPoint p = Platform.getExtensionRegistry().getExtensionPoint(XP_EDITOR_CONTENT_LISTENERS);
		for (IExtension extension: p.getExtensions()) {
			for (IConfigurationElement ce: extension.getConfigurationElements()) {
				String attribute = ce.getAttribute(""class"");
				try {
					Class<IEditorContentListener> providerClass = Generics.asT(Class.forName(attribute));
					providers.add(providerClass.newInstance());
				} catch (InstantiationException e) {
					getLOGGER().error(""Failed to instantiate "" + attribute + ""; ignoring"", e);
				} catch (IllegalAccessException e) {
					getLOGGER().error(""Failed to instantiate "" + attribute + ""; ignoring"", e);
				} catch (ClassNotFoundException e) {
					getLOGGER().error(""Failed to instantiate "" + attribute + ""; ignoring"", e);
				}
			}
		}
		return providers;
	}
	///////////////////// State ////////////////////
	public void setInput(EditorContent editorContent) {
		if (editorContent == null) {
			if (document != null) {
				document.removeDocumentListener(documentListener);
			}
			editor = null;
			openable = null;
			parsedCompilationUnit = null;
			document = null;
		} else {
			editor = editorContent.getEditor();
			openable = editorContent.getOpenable();
			parsedCompilationUnit = editorContent.getParsedCompilationUnit();
			document = editor.getDocumentProvider().getDocument(editor.getEditorInput());
			document.addDocumentListener(documentListener);
		}
	}
	private ITextEditor editor;
	public ITextEditor getEditor() {
		return editor;
	}
	private IOpenable openable;
	private IDocument document;
	public ICompilationUnit getCompilationUnit() {
		if (openable instanceof ICompilationUnit) {
			return (ICompilationUnit)openable;
		}
		return null;
	}
	private CompilationUnit parsedCompilationUnit;
	public CompilationUnit getParsedCompilationUnit() {
		return parsedCompilationUnit;
	}
	public void setParsedCompilationUnit(CompilationUnit parsedCompilationUnit) {
		this.parsedCompilationUnit = parsedCompilationUnit;
	}
	public void bufferDisposed(ITextFileBuffer buffer) {
		setInput(null);
	}
	public void documentChanged(DocumentEvent event) {
		IEditorPart part= EditorUtil.getActiveEditor();
		if (part instanceof ITextEditor) {
			ITextEditor textEditor = (ITextEditor) part;
			scheduleAstJob(textEditor, null);
		}
	}
	public void textEditorActivated(ITextEditor textEditor) {
		scheduleAstJob(textEditor, null);
	}
	public void textEditorClosed() {
		scheduleAstJob(null, null);
	}
    private WeakHashMap<Object, AstJob> scheduledJobs = new WeakHashMap<Object, AstJob>();
    private Object KEY_NULL_JOB = new Object();
	public void scheduleAstJob(ITextEditor editor, IStructuredSelection selectionHint) {
		EditorContent editorContent = new EditorContent(editor);
		AstJob astJob = new AstJob(editorContent, selectionHint);
        // hold job in weak map, and cancel any already there.
        Object jobKey = editorContent.isValid()?editorContent.getOpenable():KEY_NULL_JOB;
        AstJob previouslyScheduledJob = scheduledJobs.get(jobKey);
        if (previouslyScheduledJob != null) {
            getLOGGER().debug(""Cancelling previous job "" + previouslyScheduledJob + "" (scheduled at "" + previouslyScheduledJob.getScheduledAt() + "")"");
            previouslyScheduledJob.cancelIfPossible(); // if running
        }
        scheduledJobs.put(jobKey, astJob);
		astJob.addJobChangeListener(new JobChangeAdapter() {
			@Override
			public void aboutToRun(IJobChangeEvent event) {
				astJobAboutToRun(asAstJob(event));
			}
			@Override
			public void done(IJobChangeEvent event) {
				astJobDone(asAstJob(event));
			}
			private AstJob asAstJob(IJobChangeEvent event) {
				return (AstJob)event.getJob();
			}
		});
		astJob.schedule();
	}
	public void astJobAboutToRun(final AstJob astJob) {
		setInput(null);
		final EditorContent editorContent = astJob.getEditorContent();
		Display defaultDisplay = Display.getDefault();
		defaultDisplay.syncExec(new Runnable() {
			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentAboutToChange(editorContent);
				}
			}
		});
	}
	public void astJobDone(final AstJob astJob) {
		final EditorContent editorContent = astJob.getEditorContent();
		if ( editorContent.isValid() && 
			!editorContent.isNull()) {
			setInput(editorContent);
		} else {
			setInput(null);
		}
		final IStructuredSelection selectionHint = astJob.getSelectionHint();
		Display defaultDisplay = Display.getDefault();
		defaultDisplay.asyncExec(new Runnable() {
			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentChanged(editorContent, selectionHint);
				}
			}
		});
	}
}",class,
"	public Logger getLOGGER() {
		return LOGGER;
	}",method,
"	public IWorkbenchPage getPage() {
		return page;
	}",method,
"	public EditorTracker(IWorkbenchPage page) {
		this.page = page;
	}",method,
"	public void installListeners() {
		page.addPartListener(textEditorWatcherPartListener);
		FileBuffers.getTextFileBufferManager().addFileBufferListener(textFileBufferListener);
		editorContentListeners = Collections.unmodifiableList(loadEditorContentListeners());
	}",method,
"	public List<IEditorContentListener> getEditorContentListeners() {
		return editorContentListeners;
	}",method,
"	private List<IEditorContentListener> loadEditorContentListeners() {
		List<IEditorContentListener> providers = new ArrayList<IEditorContentListener>();
		IExtensionPoint p = Platform.getExtensionRegistry().getExtensionPoint(XP_EDITOR_CONTENT_LISTENERS);
		for (IExtension extension: p.getExtensions()) {
			for (IConfigurationElement ce: extension.getConfigurationElements()) {
				String attribute = ce.getAttribute(""class"");
				try {
					Class<IEditorContentListener> providerClass = Generics.asT(Class.forName(attribute));
					providers.add(providerClass.newInstance());
				} catch (InstantiationException e) {
					getLOGGER().error(""Failed to instantiate "" + attribute + ""; ignoring"", e);
				} catch (IllegalAccessException e) {
					getLOGGER().error(""Failed to instantiate "" + attribute + ""; ignoring"", e);
				} catch (ClassNotFoundException e) {
					getLOGGER().error(""Failed to instantiate "" + attribute + ""; ignoring"", e);
				}
			}
		}
		return providers;
	}",method,
"	public void setInput(EditorContent editorContent) {
		if (editorContent == null) {
			if (document != null) {
				document.removeDocumentListener(documentListener);
			}
			editor = null;
			openable = null;
			parsedCompilationUnit = null;
			document = null;
		} else {
			editor = editorContent.getEditor();
			openable = editorContent.getOpenable();
			parsedCompilationUnit = editorContent.getParsedCompilationUnit();
			document = editor.getDocumentProvider().getDocument(editor.getEditorInput());
			document.addDocumentListener(documentListener);
		}
	}",method,
"		if (editorContent == null) {
			if (document != null) {
				document.removeDocumentListener(documentListener);
			}
			editor = null;
			openable = null;
			parsedCompilationUnit = null;
			document = null;
		}",method,
"			if (document != null) {
				document.removeDocumentListener(documentListener);
			}",method,
"	public ITextEditor getEditor() {
		return editor;
	}",method,
"	public ICompilationUnit getCompilationUnit() {
		if (openable instanceof ICompilationUnit) {
			return (ICompilationUnit)openable;
		}
		return null;
	}",method,
"		if (openable instanceof ICompilationUnit) {
			return (ICompilationUnit)openable;
		}",method,
"	public CompilationUnit getParsedCompilationUnit() {
		return parsedCompilationUnit;
	}",method,
"	public void setParsedCompilationUnit(CompilationUnit parsedCompilationUnit) {
		this.parsedCompilationUnit = parsedCompilationUnit;
	}",method,
"	public void bufferDisposed(ITextFileBuffer buffer) {
		setInput(null);
	}",method,
"	public void documentChanged(DocumentEvent event) {
		IEditorPart part= EditorUtil.getActiveEditor();
		if (part instanceof ITextEditor) {
			ITextEditor textEditor = (ITextEditor) part;
			scheduleAstJob(textEditor, null);
		}
	}",method,
"		if (part instanceof ITextEditor) {
			ITextEditor textEditor = (ITextEditor) part;
			scheduleAstJob(textEditor, null);
		}",method,
"	public void textEditorActivated(ITextEditor textEditor) {
		scheduleAstJob(textEditor, null);
	}",method,
"	public void textEditorClosed() {
		scheduleAstJob(null, null);
	}",method,
"	public void scheduleAstJob(ITextEditor editor, IStructuredSelection selectionHint) {
		EditorContent editorContent = new EditorContent(editor);
		AstJob astJob = new AstJob(editorContent, selectionHint);
        // hold job in weak map, and cancel any already there.
        Object jobKey = editorContent.isValid()?editorContent.getOpenable():KEY_NULL_JOB;
        AstJob previouslyScheduledJob = scheduledJobs.get(jobKey);
        if (previouslyScheduledJob != null) {
            getLOGGER().debug(""Cancelling previous job "" + previouslyScheduledJob + "" (scheduled at "" + previouslyScheduledJob.getScheduledAt() + "")"");
            previouslyScheduledJob.cancelIfPossible(); // if running
        }
        scheduledJobs.put(jobKey, astJob);
		astJob.addJobChangeListener(new JobChangeAdapter() {
			@Override
			public void aboutToRun(IJobChangeEvent event) {
				astJobAboutToRun(asAstJob(event));
			}
			@Override
			public void done(IJobChangeEvent event) {
				astJobDone(asAstJob(event));
			}
			private AstJob asAstJob(IJobChangeEvent event) {
				return (AstJob)event.getJob();
			}
		});
		astJob.schedule();
	}",method,
"        if (previouslyScheduledJob != null) {
            getLOGGER().debug(""Cancelling previous job "" + previouslyScheduledJob + "" (scheduled at "" + previouslyScheduledJob.getScheduledAt() + "")"");
            previouslyScheduledJob.cancelIfPossible(); // if running
        }",method,
"		astJob.addJobChangeListener(new JobChangeAdapter() {
			@Override
			public void aboutToRun(IJobChangeEvent event) {
				astJobAboutToRun(asAstJob(event));
			}
			@Override
			public void done(IJobChangeEvent event) {
				astJobDone(asAstJob(event));
			}
			private AstJob asAstJob(IJobChangeEvent event) {
				return (AstJob)event.getJob();
			}
		}",method,
"			@Override
			public void aboutToRun(IJobChangeEvent event) {
				astJobAboutToRun(asAstJob(event));
			}",method,
"			@Override
			public void done(IJobChangeEvent event) {
				astJobDone(asAstJob(event));
			}",method,
"			private AstJob asAstJob(IJobChangeEvent event) {
				return (AstJob)event.getJob();
			}",method,
"	public void astJobAboutToRun(final AstJob astJob) {
		setInput(null);
		final EditorContent editorContent = astJob.getEditorContent();
		Display defaultDisplay = Display.getDefault();
		defaultDisplay.syncExec(new Runnable() {
			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentAboutToChange(editorContent);
				}
			}
		});
	}",method,
"		defaultDisplay.syncExec(new Runnable() {
			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentAboutToChange(editorContent);
				}
			}
		}",method,
"			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentAboutToChange(editorContent);
				}
			}",method,
"				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentAboutToChange(editorContent);
				}",method,
"	public void astJobDone(final AstJob astJob) {
		final EditorContent editorContent = astJob.getEditorContent();
		if ( editorContent.isValid() && 
			!editorContent.isNull()) {
			setInput(editorContent);
		} else {
			setInput(null);
		}
		final IStructuredSelection selectionHint = astJob.getSelectionHint();
		Display defaultDisplay = Display.getDefault();
		defaultDisplay.asyncExec(new Runnable() {
			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentChanged(editorContent, selectionHint);
				}
			}
		});
	}",method,
"		defaultDisplay.asyncExec(new Runnable() {
			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentChanged(editorContent, selectionHint);
				}
			}
		}",method,
"			public void run() {
				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentChanged(editorContent, selectionHint);
				}
			}",method,
"				for(IEditorContentListener listener: editorContentListeners) {
					listener.editorContentChanged(editorContent, selectionHint);
				}",method,

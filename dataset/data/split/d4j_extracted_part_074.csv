code_snippet,type,score
"        if (hints == null) {
            hints = new ArrayList<SQLCommentHint>(1);
        }",method,
"    public int getHintsSize() {
        if (hints == null) {
            return 0;
        }
        return hints.size();
    }",method,
"        if (hints == null) {
            return 0;
        }",method,
"    public boolean isSkipLocked() {
        return skipLocked;
    }",method,
"    public void setSkipLocked(boolean skipLocked) {
        this.skipLocked = skipLocked;
    }",method,
"    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor instanceof OracleASTVisitor) {
            accept0((OracleASTVisitor) visitor);
            return;
        }
        super.accept0(visitor);
    }",method,
"        if (visitor instanceof OracleASTVisitor) {
            accept0((OracleASTVisitor) visitor);
            return;
        }",method,
"    public void accept0(OracleASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, this.hints);
            acceptChild(visitor, this.selectList);
            acceptChild(visitor, this.into);
            acceptChild(visitor, this.from);
            acceptChild(visitor, this.where);
            acceptChild(visitor, this.startWith);
            acceptChild(visitor, this.connectBy);
            acceptChild(visitor, this.groupBy);
            acceptChild(visitor, this.orderBy);
            acceptChild(visitor, this.waitTime);
            acceptChild(visitor, this.limit);
            acceptChild(visitor, this.modelClause);
            acceptChild(visitor, this.forUpdateOf);
        }
        visitor.endVisit(this);
    }",method,
"    public String toString() {
        return SQLUtils.toOracleString(this);
    }",method,
"    public void limit(int rowCount, int offset) {
        if (offset <= 0) {
            SQLExpr rowCountExpr = new SQLIntegerExpr(rowCount);
            SQLExpr newCondition = SQLUtils.buildCondition(SQLBinaryOperator.BooleanAnd, rowCountExpr, false,
                    where);
            setWhere(newCondition);
        } else {
            throw new UnsupportedOperationException(""not support offset"");
        }
    }",method,
"        if (offset <= 0) {
            SQLExpr rowCountExpr = new SQLIntegerExpr(rowCount);
            SQLExpr newCondition = SQLUtils.buildCondition(SQLBinaryOperator.BooleanAnd, rowCountExpr, false,
                    where);
            setWhere(newCondition);
        }",method,
"    public void setFrom(String tableName) {
        SQLExprTableSource from;
        if (tableName == null || tableName.length() == 0) {
            from = null;
        } else {
            from = new OracleSelectTableReference(new SQLIdentifierExpr(tableName));
        }
        this.setFrom(from);
    }",method,
"public class FormatTest {
  @SerializedName(""integer"")
  private Integer integer = null;
  @SerializedName(""int32"")
  private Integer int32 = null;
  @SerializedName(""int64"")
  private Long int64 = null;
  @SerializedName(""number"")
  private BigDecimal number = null;
  @SerializedName(""float"")
  private Float _float = null;
  @SerializedName(""double"")
  private Double _double = null;
  @SerializedName(""string"")
  private String string = null;
  @SerializedName(""byte"")
  private byte[] _byte = null;
  @SerializedName(""binary"")
  private byte[] binary = null;
  @SerializedName(""date"")
  private LocalDate date = null;
  @SerializedName(""dateTime"")
  private DateTime dateTime = null;
  @SerializedName(""uuid"")
  private UUID uuid = null;
  @SerializedName(""password"")
  private String password = null;
  public FormatTest integer(Integer integer) {
    this.integer = integer;
    return this;
  }
  @ApiModelProperty(value = """")
  public Integer getInteger() {
    return integer;
  }
  public void setInteger(Integer integer) {
    this.integer = integer;
  }
  public FormatTest int32(Integer int32) {
    this.int32 = int32;
    return this;
  }
  @ApiModelProperty(value = """")
  public Integer getInt32() {
    return int32;
  }
  public void setInt32(Integer int32) {
    this.int32 = int32;
  }
  public FormatTest int64(Long int64) {
    this.int64 = int64;
    return this;
  }
  @ApiModelProperty(value = """")
  public Long getInt64() {
    return int64;
  }
  public void setInt64(Long int64) {
    this.int64 = int64;
  }
  public FormatTest number(BigDecimal number) {
    this.number = number;
    return this;
  }
  @ApiModelProperty(required = true, value = """")
  public BigDecimal getNumber() {
    return number;
  }
  public void setNumber(BigDecimal number) {
    this.number = number;
  }
  public FormatTest _float(Float _float) {
    this._float = _float;
    return this;
  }
  @ApiModelProperty(value = """")
  public Float getFloat() {
    return _float;
  }
  public void setFloat(Float _float) {
    this._float = _float;
  }
  public FormatTest _double(Double _double) {
    this._double = _double;
    return this;
  }
  @ApiModelProperty(value = """")
  public Double getDouble() {
    return _double;
  }
  public void setDouble(Double _double) {
    this._double = _double;
  }
  public FormatTest string(String string) {
    this.string = string;
    return this;
  }
  @ApiModelProperty(value = """")
  public String getString() {
    return string;
  }
  public void setString(String string) {
    this.string = string;
  }
  public FormatTest _byte(byte[] _byte) {
    this._byte = _byte;
    return this;
  }
  @ApiModelProperty(required = true, value = """")
  public byte[] getByte() {
    return _byte;
  }
  public void setByte(byte[] _byte) {
    this._byte = _byte;
  }
  public FormatTest binary(byte[] binary) {
    this.binary = binary;
    return this;
  }
  @ApiModelProperty(value = """")
  public byte[] getBinary() {
    return binary;
  }
  public void setBinary(byte[] binary) {
    this.binary = binary;
  }
  public FormatTest date(LocalDate date) {
    this.date = date;
    return this;
  }
  @ApiModelProperty(required = true, value = """")
  public LocalDate getDate() {
    return date;
  }
  public void setDate(LocalDate date) {
    this.date = date;
  }
  public FormatTest dateTime(DateTime dateTime) {
    this.dateTime = dateTime;
    return this;
  }
  @ApiModelProperty(value = """")
  public DateTime getDateTime() {
    return dateTime;
  }
  public void setDateTime(DateTime dateTime) {
    this.dateTime = dateTime;
  }
  public FormatTest uuid(UUID uuid) {
    this.uuid = uuid;
    return this;
  }
  @ApiModelProperty(value = """")
  public UUID getUuid() {
    return uuid;
  }
  public void setUuid(UUID uuid) {
    this.uuid = uuid;
  }
  public FormatTest password(String password) {
    this.password = password;
    return this;
  }
  @ApiModelProperty(required = true, value = """")
  public String getPassword() {
    return password;
  }
  public void setPassword(String password) {
    this.password = password;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FormatTest formatTest = (FormatTest) o;
    return Objects.equals(this.integer, formatTest.integer) &&
        Objects.equals(this.int32, formatTest.int32) &&
        Objects.equals(this.int64, formatTest.int64) &&
        Objects.equals(this.number, formatTest.number) &&
        Objects.equals(this._float, formatTest._float) &&
        Objects.equals(this._double, formatTest._double) &&
        Objects.equals(this.string, formatTest.string) &&
        Objects.equals(this._byte, formatTest._byte) &&
        Objects.equals(this.binary, formatTest.binary) &&
        Objects.equals(this.date, formatTest.date) &&
        Objects.equals(this.dateTime, formatTest.dateTime) &&
        Objects.equals(this.uuid, formatTest.uuid) &&
        Objects.equals(this.password, formatTest.password);
  }
  @Override
  public int hashCode() {
    return Objects.hash(integer, int32, int64, number, _float, _double, string, _byte, binary, date, dateTime, uuid, password);
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class FormatTest {\n"");
    sb.append(""    integer: "").append(toIndentedString(integer)).append(""\n"");
    sb.append(""    int32: "").append(toIndentedString(int32)).append(""\n"");
    sb.append(""    int64: "").append(toIndentedString(int64)).append(""\n"");
    sb.append(""    number: "").append(toIndentedString(number)).append(""\n"");
    sb.append(""    _float: "").append(toIndentedString(_float)).append(""\n"");
    sb.append(""    _double: "").append(toIndentedString(_double)).append(""\n"");
    sb.append(""    string: "").append(toIndentedString(string)).append(""\n"");
    sb.append(""    _byte: "").append(toIndentedString(_byte)).append(""\n"");
    sb.append(""    binary: "").append(toIndentedString(binary)).append(""\n"");
    sb.append(""    date: "").append(toIndentedString(date)).append(""\n"");
    sb.append(""    dateTime: "").append(toIndentedString(dateTime)).append(""\n"");
    sb.append(""    uuid: "").append(toIndentedString(uuid)).append(""\n"");
    sb.append(""    password: "").append(toIndentedString(password)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
}",class,
"    sb.append(""class FormatTest {\n"");
    sb.append(""    integer: "").append(toIndentedString(integer)).append(""\n"");
    sb.append(""    int32: "").append(toIndentedString(int32)).append(""\n"");
    sb.append(""    int64: "").append(toIndentedString(int64)).append(""\n"");
    sb.append(""    number: "").append(toIndentedString(number)).append(""\n"");
    sb.append(""    _float: "").append(toIndentedString(_float)).append(""\n"");
    sb.append(""    _double: "").append(toIndentedString(_double)).append(""\n"");
    sb.append(""    string: "").append(toIndentedString(string)).append(""\n"");
    sb.append(""    _byte: "").append(toIndentedString(_byte)).append(""\n"");
    sb.append(""    binary: "").append(toIndentedString(binary)).append(""\n"");
    sb.append(""    date: "").append(toIndentedString(date)).append(""\n"");
    sb.append(""    dateTime: "").append(toIndentedString(dateTime)).append(""\n"");
    sb.append(""    uuid: "").append(toIndentedString(uuid)).append(""\n"");
    sb.append(""    password: "").append(toIndentedString(password)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"  public FormatTest integer(Integer integer) {
    this.integer = integer;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public Integer getInteger() {
    return integer;
  }",method,
"  public void setInteger(Integer integer) {
    this.integer = integer;
  }",method,
"  public FormatTest int32(Integer int32) {
    this.int32 = int32;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public Integer getInt32() {
    return int32;
  }",method,
"  public void setInt32(Integer int32) {
    this.int32 = int32;
  }",method,
"  public FormatTest int64(Long int64) {
    this.int64 = int64;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public Long getInt64() {
    return int64;
  }",method,
"  public void setInt64(Long int64) {
    this.int64 = int64;
  }",method,
"  public FormatTest number(BigDecimal number) {
    this.number = number;
    return this;
  }",method,
"  @ApiModelProperty(required = true, value = """")
  public BigDecimal getNumber() {
    return number;
  }",method,
"  public void setNumber(BigDecimal number) {
    this.number = number;
  }",method,
"  public FormatTest _float(Float _float) {
    this._float = _float;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public Float getFloat() {
    return _float;
  }",method,
"  public void setFloat(Float _float) {
    this._float = _float;
  }",method,
"  public FormatTest _double(Double _double) {
    this._double = _double;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public Double getDouble() {
    return _double;
  }",method,
"  public void setDouble(Double _double) {
    this._double = _double;
  }",method,
"  public FormatTest string(String string) {
    this.string = string;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public String getString() {
    return string;
  }",method,
"  public void setString(String string) {
    this.string = string;
  }",method,
"  public FormatTest _byte(byte[] _byte) {
    this._byte = _byte;
    return this;
  }",method,
"  @ApiModelProperty(required = true, value = """")
  public byte[] getByte() {
    return _byte;
  }",method,
"  public void setByte(byte[] _byte) {
    this._byte = _byte;
  }",method,
"  public FormatTest binary(byte[] binary) {
    this.binary = binary;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public byte[] getBinary() {
    return binary;
  }",method,
"  public void setBinary(byte[] binary) {
    this.binary = binary;
  }",method,
"  public FormatTest date(LocalDate date) {
    this.date = date;
    return this;
  }",method,
"  @ApiModelProperty(required = true, value = """")
  public LocalDate getDate() {
    return date;
  }",method,
"  public void setDate(LocalDate date) {
    this.date = date;
  }",method,
"  public FormatTest dateTime(DateTime dateTime) {
    this.dateTime = dateTime;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public DateTime getDateTime() {
    return dateTime;
  }",method,
"  public void setDateTime(DateTime dateTime) {
    this.dateTime = dateTime;
  }",method,
"  public FormatTest uuid(UUID uuid) {
    this.uuid = uuid;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public UUID getUuid() {
    return uuid;
  }",method,
"  public void setUuid(UUID uuid) {
    this.uuid = uuid;
  }",method,
"  public FormatTest password(String password) {
    this.password = password;
    return this;
  }",method,
"  @ApiModelProperty(required = true, value = """")
  public String getPassword() {
    return password;
  }",method,
"  public void setPassword(String password) {
    this.password = password;
  }",method,
"  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FormatTest formatTest = (FormatTest) o;
    return Objects.equals(this.integer, formatTest.integer) &&
        Objects.equals(this.int32, formatTest.int32) &&
        Objects.equals(this.int64, formatTest.int64) &&
        Objects.equals(this.number, formatTest.number) &&
        Objects.equals(this._float, formatTest._float) &&
        Objects.equals(this._double, formatTest._double) &&
        Objects.equals(this.string, formatTest.string) &&
        Objects.equals(this._byte, formatTest._byte) &&
        Objects.equals(this.binary, formatTest.binary) &&
        Objects.equals(this.date, formatTest.date) &&
        Objects.equals(this.dateTime, formatTest.dateTime) &&
        Objects.equals(this.uuid, formatTest.uuid) &&
        Objects.equals(this.password, formatTest.password);
  }",method,
"    if (this == o) {
      return true;
    }",method,
"  @Override
  public int hashCode() {
    return Objects.hash(integer, int32, int64, number, _float, _double, string, _byte, binary, date, dateTime, uuid, password);
  }",method,
"  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class FormatTest {\n"");
    sb.append(""    integer: "").append(toIndentedString(integer)).append(""\n"");
    sb.append(""    int32: "").append(toIndentedString(int32)).append(""\n"");
    sb.append(""    int64: "").append(toIndentedString(int64)).append(""\n"");
    sb.append(""    number: "").append(toIndentedString(number)).append(""\n"");
    sb.append(""    _float: "").append(toIndentedString(_float)).append(""\n"");
    sb.append(""    _double: "").append(toIndentedString(_double)).append(""\n"");
    sb.append(""    string: "").append(toIndentedString(string)).append(""\n"");
    sb.append(""    _byte: "").append(toIndentedString(_byte)).append(""\n"");
    sb.append(""    binary: "").append(toIndentedString(binary)).append(""\n"");
    sb.append(""    date: "").append(toIndentedString(date)).append(""\n"");
    sb.append(""    dateTime: "").append(toIndentedString(dateTime)).append(""\n"");
    sb.append(""    uuid: "").append(toIndentedString(uuid)).append(""\n"");
    sb.append(""    password: "").append(toIndentedString(password)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }",method,
"  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",method,
"    if (o == null) {
      return ""null"";
    }",method,
"public class ClassFinalizer
extends      SimplifiedVisitor
implements   ClassVisitor
{
    private final ClassVisitor extraClassVisitor;
    public ClassFinalizer()
    {
        this(null);
    }
    public ClassFinalizer(ClassVisitor  extraClassVisitor)
    {
        this.extraClassVisitor = extraClassVisitor;
    }
    // Implementations for ClassVisitor.
    public void visitProgramClass(ProgramClass programClass)
    {
        // If the class is not final/interface/abstract,
        // and it is not being kept,
        // and it doesn't have any subclasses,
        // then make it final.
        if ((programClass.u2accessFlags & (ClassConstants.ACC_FINAL     |
                                           ClassConstants.ACC_INTERFACE |
                                           ClassConstants.ACC_ABSTRACT)) == 0 &&
            !KeepMarker.isKept(programClass)                                           &&
            programClass.subClasses == null)
        {
            programClass.u2accessFlags |= ClassConstants.ACC_FINAL;
            // Visit the class, if required.
            if (extraClassVisitor != null)
            {
                extraClassVisitor.visitProgramClass(programClass);
            }
        }
    }
}",class,
"        // If the class is not final/interface/abstract,
        // and it is not being kept,
        // and it doesn't have any subclasses,
        // then make it final.
        if ((programClass.u2accessFlags & (ClassConstants.ACC_FINAL     |
                                           ClassConstants.ACC_INTERFACE |
                                           ClassConstants.ACC_ABSTRACT)) == 0 &&
            !KeepMarker.isKept(programClass)                                           &&
            programClass.subClasses == null)
        {
            programClass.u2accessFlags |= ClassConstants.ACC_FINAL;
            // Visit the class, if required.
            if (extraClassVisitor != null)
            {
                extraClassVisitor.visitProgramClass(programClass);
            }
        }",class,
"    public ClassFinalizer()
    {
        this(null);
    }",method,
"    public ClassFinalizer(ClassVisitor  extraClassVisitor)
    {
        this.extraClassVisitor = extraClassVisitor;
    }",method,
"    public void visitProgramClass(ProgramClass programClass)
    {
        // If the class is not final/interface/abstract,
        // and it is not being kept,
        // and it doesn't have any subclasses,
        // then make it final.
        if ((programClass.u2accessFlags & (ClassConstants.ACC_FINAL     |
                                           ClassConstants.ACC_INTERFACE |
                                           ClassConstants.ACC_ABSTRACT)) == 0 &&
            !KeepMarker.isKept(programClass)                                           &&
            programClass.subClasses == null)
        {
            programClass.u2accessFlags |= ClassConstants.ACC_FINAL;
            // Visit the class, if required.
            if (extraClassVisitor != null)
            {
                extraClassVisitor.visitProgramClass(programClass);
            }
        }
    }",method,
"            if (extraClassVisitor != null)
            {
                extraClassVisitor.visitProgramClass(programClass);
            }",method,
"public class RefConditionGenerator implements ConditionGenerator {
  private final GimpleOp op;
  private final JExpr x;
  private final JExpr y;
  public RefConditionGenerator(GimpleOp op, JExpr x, JExpr y) {
    this.op = op;
    this.x = x;
    this.y = y;
  }
  @Override
  public void emitJump(MethodGenerator mv, Label trueLabel, Label falseLabel) {
    switch (op) {
      case EQ_EXPR:
        x.load(mv);
        y.load(mv);
        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, trueLabel);
        mv.visitJumpInsn(Opcodes.GOTO, falseLabel);
        break;
      case NE_EXPR:
        x.load(mv);
        y.load(mv);
        mv.visitJumpInsn(Opcodes.IF_ACMPNE, trueLabel);
        mv.visitJumpInsn(Opcodes.GOTO, falseLabel);
        break;
      case LT_EXPR:
      case GT_EXPR:
        PrimitiveCmpGenerator hashCmpGenerator = new PrimitiveCmpGenerator(op, identityHash(x), identityHash(y));
        hashCmpGenerator.emitJump(mv, trueLabel, falseLabel);
        break;
      default:  
        throw new UnsupportedOperationException(""Unsupported pointer comparison: "" + op);
    }
  }
}",class,
"  public RefConditionGenerator(GimpleOp op, JExpr x, JExpr y) {
    this.op = op;
    this.x = x;
    this.y = y;
  }",method,
"  @Override
  public void emitJump(MethodGenerator mv, Label trueLabel, Label falseLabel) {
    switch (op) {
      case EQ_EXPR:
        x.load(mv);
        y.load(mv);
        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, trueLabel);
        mv.visitJumpInsn(Opcodes.GOTO, falseLabel);
        break;
      case NE_EXPR:
        x.load(mv);
        y.load(mv);
        mv.visitJumpInsn(Opcodes.IF_ACMPNE, trueLabel);
        mv.visitJumpInsn(Opcodes.GOTO, falseLabel);
        break;
      case LT_EXPR:
      case GT_EXPR:
        PrimitiveCmpGenerator hashCmpGenerator = new PrimitiveCmpGenerator(op, identityHash(x), identityHash(y));
        hashCmpGenerator.emitJump(mv, trueLabel, falseLabel);
        break;
      default:  
        throw new UnsupportedOperationException(""Unsupported pointer comparison: "" + op);
    }
  }",method,
"    switch (op) {
      case EQ_EXPR:
        x.load(mv);
        y.load(mv);
        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, trueLabel);
        mv.visitJumpInsn(Opcodes.GOTO, falseLabel);
        break;
      case NE_EXPR:
        x.load(mv);
        y.load(mv);
        mv.visitJumpInsn(Opcodes.IF_ACMPNE, trueLabel);
        mv.visitJumpInsn(Opcodes.GOTO, falseLabel);
        break;
      case LT_EXPR:
      case GT_EXPR:
        PrimitiveCmpGenerator hashCmpGenerator = new PrimitiveCmpGenerator(op, identityHash(x), identityHash(y));
        hashCmpGenerator.emitJump(mv, trueLabel, falseLabel);
        break;
      default:  
        throw new UnsupportedOperationException(""Unsupported pointer comparison: "" + op);
    }",method,
"public class ReflectionTest extends GdxTest {
	String message = """";
	BitmapFont font;
	SpriteBatch batch;
	@Override
	public void create () {
		font = new BitmapFont();
		batch = new SpriteBatch();
		try {
			Vector2 fromDefaultConstructor = ClassReflection.newInstance(Vector2.class);
			println(""From default constructor: "" + fromDefaultConstructor);
			Method mSet = ClassReflection.getMethod(Vector2.class, ""set"", float.class, float.class);
			mSet.invoke(fromDefaultConstructor, 10, 11);
			println(""Set to 10/11: "" + fromDefaultConstructor);
			Constructor copyConstroctor = ClassReflection.getConstructor(Vector2.class, Vector2.class);
			Vector2 fromCopyConstructor = (Vector2)copyConstroctor.newInstance(fromDefaultConstructor);
			println(""From copy constructor: "" + fromCopyConstructor);
			Method mMul = ClassReflection.getMethod(Vector2.class, ""scl"", float.class);
			println(""Multiplied by 2; "" + mMul.invoke(fromCopyConstructor, 2));
			Method mNor = ClassReflection.getMethod(Vector2.class, ""nor"");
			println(""Normalized: "" + mNor.invoke(fromCopyConstructor));
			Vector2 fieldCopy = new Vector2();
			Field fx = ClassReflection.getField(Vector2.class, ""x"");
			Field fy = ClassReflection.getField(Vector2.class, ""y"");
			fx.set(fieldCopy, fx.get(fromCopyConstructor));
			fy.set(fieldCopy, fy.get(fromCopyConstructor));
			println(""Copied field by field: "" + fieldCopy);
			Json json = new Json();
			String jsonString = json.toJson(fromCopyConstructor);
			Vector2 fromJson = json.fromJson(Vector2.class, jsonString);
			println(""JSON serialized: "" + jsonString);
			println(""JSON deserialized: "" + fromJson);
			fromJson.x += 1;
			fromJson.y += 1;
			println(""JSON deserialized + 1/1: "" + fromJson);
			Object array = ArrayReflection.newInstance(int.class, 5);
			ArrayReflection.set(array, 0, 42);
			println(""Array int: length="" + ArrayReflection.getLength(array) + "", access="" + ArrayReflection.get(array, 0));
			array = ArrayReflection.newInstance(String.class, 5);
			ArrayReflection.set(array, 0, ""test string"");
			println(""Array String: length="" + ArrayReflection.getLength(array) + "", access="" + ArrayReflection.get(array, 0));
		} catch (Exception e) {
			message = ""FAILED: "" + e.getMessage() + ""\n"";
			message += e.getClass();
		}
	}
	private void println (String line) {
		message += line + ""\n"";
	}
	@Override
	public void render () {
		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
		batch.begin();
		font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);
		batch.end();
	}
	@Override
	public void dispose () {
		batch.dispose();
		font.dispose();
	}
}",class,
"	@Override
	public void create () {
		font = new BitmapFont();
		batch = new SpriteBatch();
		try {
			Vector2 fromDefaultConstructor = ClassReflection.newInstance(Vector2.class);
			println(""From default constructor: "" + fromDefaultConstructor);
			Method mSet = ClassReflection.getMethod(Vector2.class, ""set"", float.class, float.class);
			mSet.invoke(fromDefaultConstructor, 10, 11);
			println(""Set to 10/11: "" + fromDefaultConstructor);
			Constructor copyConstroctor = ClassReflection.getConstructor(Vector2.class, Vector2.class);
			Vector2 fromCopyConstructor = (Vector2)copyConstroctor.newInstance(fromDefaultConstructor);
			println(""From copy constructor: "" + fromCopyConstructor);
			Method mMul = ClassReflection.getMethod(Vector2.class, ""scl"", float.class);
			println(""Multiplied by 2; "" + mMul.invoke(fromCopyConstructor, 2));
			Method mNor = ClassReflection.getMethod(Vector2.class, ""nor"");
			println(""Normalized: "" + mNor.invoke(fromCopyConstructor));
			Vector2 fieldCopy = new Vector2();
			Field fx = ClassReflection.getField(Vector2.class, ""x"");
			Field fy = ClassReflection.getField(Vector2.class, ""y"");
			fx.set(fieldCopy, fx.get(fromCopyConstructor));
			fy.set(fieldCopy, fy.get(fromCopyConstructor));
			println(""Copied field by field: "" + fieldCopy);
			Json json = new Json();
			String jsonString = json.toJson(fromCopyConstructor);
			Vector2 fromJson = json.fromJson(Vector2.class, jsonString);
			println(""JSON serialized: "" + jsonString);
			println(""JSON deserialized: "" + fromJson);
			fromJson.x += 1;
			fromJson.y += 1;
			println(""JSON deserialized + 1/1: "" + fromJson);
			Object array = ArrayReflection.newInstance(int.class, 5);
			ArrayReflection.set(array, 0, 42);
			println(""Array int: length="" + ArrayReflection.getLength(array) + "", access="" + ArrayReflection.get(array, 0));
			array = ArrayReflection.newInstance(String.class, 5);
			ArrayReflection.set(array, 0, ""test string"");
			println(""Array String: length="" + ArrayReflection.getLength(array) + "", access="" + ArrayReflection.get(array, 0));
		} catch (Exception e) {
			message = ""FAILED: "" + e.getMessage() + ""\n"";
			message += e.getClass();
		}
	}",method,
"	private void println (String line) {
		message += line + ""\n"";
	}",method,
"	@Override
	public void render () {
		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
		batch.begin();
		font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);
		batch.end();
	}",method,
"	@Override
	public void dispose () {
		batch.dispose();
		font.dispose();
	}",method,
"public class InternalTable
{
    private final Map<String, Integer> columnIndexes;
    private final List<Page> pages;
    public InternalTable(Map<String, Integer> columnIndexes, Iterable<Page> pages)
    {
        this.columnIndexes = ImmutableMap.copyOf(requireNonNull(columnIndexes, ""columnIndexes is null""));
        this.pages = ImmutableList.copyOf(requireNonNull(pages, ""pages is null""));
    }
    public int getColumnIndex(String columnName)
    {
        Integer index = columnIndexes.get(columnName);
        checkArgument(index != null, ""Column %s not found"", columnName);
        return index;
    }
    public List<Page> getPages()
    {
        return pages;
    }
    public static Builder builder(ColumnMetadata... columns)
    {
        return builder(ImmutableList.copyOf(columns));
    }
    public static Builder builder(List<ColumnMetadata> columns)
    {
        ImmutableList.Builder<String> names = ImmutableList.builder();
        ImmutableList.Builder<Type> types = ImmutableList.builder();
        for (ColumnMetadata column : columns) {
            names.add(column.getName());
            types.add(column.getType());
        }
        return new Builder(names.build(), types.build());
    }
    public static class Builder
    {
        private final Map<String, Integer> columnIndexes;
        private final List<Type> types;
        private final List<Page> pages;
        private PageBuilder pageBuilder;
        public Builder(List<String> columnNames, List<Type> types)
        {
            requireNonNull(columnNames, ""columnNames is null"");
            ImmutableMap.Builder<String, Integer> columnIndexes = ImmutableMap.builder();
            int columnIndex = 0;
            for (String columnName : columnNames) {
                columnIndexes.put(columnName, columnIndex++);
            }
            this.columnIndexes = columnIndexes.build();
            this.types = ImmutableList.copyOf(requireNonNull(types, ""types is null""));
            checkArgument(columnNames.size() == types.size(),
                    ""Column name count does not match type count: columnNames=%s, types=%s"", columnNames, types.size());
            pages = new ArrayList<>();
            pageBuilder = new PageBuilder(types);
        }
        public Builder add(Object... values)
        {
            pageBuilder.declarePosition();
            for (int i = 0; i < types.size(); i++) {
                writeNativeValue(types.get(i), pageBuilder.getBlockBuilder(i), values[i]);
            }
            if (pageBuilder.isFull()) {
                flushPage();
            }
            return this;
        }
        public InternalTable build()
        {
            flushPage();
            return new InternalTable(columnIndexes, pages);
        }
        private void flushPage()
        {
            if (!pageBuilder.isEmpty()) {
                pages.add(pageBuilder.build());
                pageBuilder.reset();
            }
        }
    }
}",class,
"    public static class Builder
    {
        private final Map<String, Integer> columnIndexes;
        private final List<Type> types;
        private final List<Page> pages;
        private PageBuilder pageBuilder;
        public Builder(List<String> columnNames, List<Type> types)
        {
            requireNonNull(columnNames, ""columnNames is null"");
            ImmutableMap.Builder<String, Integer> columnIndexes = ImmutableMap.builder();
            int columnIndex = 0;
            for (String columnName : columnNames) {
                columnIndexes.put(columnName, columnIndex++);
            }
            this.columnIndexes = columnIndexes.build();
            this.types = ImmutableList.copyOf(requireNonNull(types, ""types is null""));
            checkArgument(columnNames.size() == types.size(),
                    ""Column name count does not match type count: columnNames=%s, types=%s"", columnNames, types.size());
            pages = new ArrayList<>();
            pageBuilder = new PageBuilder(types);
        }
        public Builder add(Object... values)
        {
            pageBuilder.declarePosition();
            for (int i = 0; i < types.size(); i++) {
                writeNativeValue(types.get(i), pageBuilder.getBlockBuilder(i), values[i]);
            }
            if (pageBuilder.isFull()) {
                flushPage();
            }
            return this;
        }
        public InternalTable build()
        {
            flushPage();
            return new InternalTable(columnIndexes, pages);
        }
        private void flushPage()
        {
            if (!pageBuilder.isEmpty()) {
                pages.add(pageBuilder.build());
                pageBuilder.reset();
            }
        }
    }",class,
"    public InternalTable(Map<String, Integer> columnIndexes, Iterable<Page> pages)
    {
        this.columnIndexes = ImmutableMap.copyOf(requireNonNull(columnIndexes, ""columnIndexes is null""));
        this.pages = ImmutableList.copyOf(requireNonNull(pages, ""pages is null""));
    }",method,
"    public int getColumnIndex(String columnName)
    {
        Integer index = columnIndexes.get(columnName);
        checkArgument(index != null, ""Column %s not found"", columnName);
        return index;
    }",method,
"    public List<Page> getPages()
    {
        return pages;
    }",method,
"    public static Builder builder(ColumnMetadata... columns)
    {
        return builder(ImmutableList.copyOf(columns));
    }",method,
"    public static Builder builder(List<ColumnMetadata> columns)
    {
        ImmutableList.Builder<String> names = ImmutableList.builder();
        ImmutableList.Builder<Type> types = ImmutableList.builder();
        for (ColumnMetadata column : columns) {
            names.add(column.getName());
            types.add(column.getType());
        }
        return new Builder(names.build(), types.build());
    }",method,
"        for (ColumnMetadata column : columns) {
            names.add(column.getName());
            types.add(column.getType());
        }",method,
"        public Builder(List<String> columnNames, List<Type> types)
        {
            requireNonNull(columnNames, ""columnNames is null"");
            ImmutableMap.Builder<String, Integer> columnIndexes = ImmutableMap.builder();
            int columnIndex = 0;
            for (String columnName : columnNames) {
                columnIndexes.put(columnName, columnIndex++);
            }
            this.columnIndexes = columnIndexes.build();
            this.types = ImmutableList.copyOf(requireNonNull(types, ""types is null""));
            checkArgument(columnNames.size() == types.size(),
                    ""Column name count does not match type count: columnNames=%s, types=%s"", columnNames, types.size());
            pages = new ArrayList<>();
            pageBuilder = new PageBuilder(types);
        }",method,
"            for (String columnName : columnNames) {
                columnIndexes.put(columnName, columnIndex++);
            }",method,
"        public Builder add(Object... values)
        {
            pageBuilder.declarePosition();
            for (int i = 0; i < types.size(); i++) {
                writeNativeValue(types.get(i), pageBuilder.getBlockBuilder(i), values[i]);
            }
            if (pageBuilder.isFull()) {
                flushPage();
            }
            return this;
        }",method,
"        public InternalTable build()
        {
            flushPage();
            return new InternalTable(columnIndexes, pages);
        }",method,
"        private void flushPage()
        {
            if (!pageBuilder.isEmpty()) {
                pages.add(pageBuilder.build());
                pageBuilder.reset();
            }
        }",method,
"public class SSPIJNIClient {
    private static SSPIJNIClient thisInstance;
    private static boolean libraryLoaded;
    private boolean initialized;
    private native void initialize();
    private native void unInitialize();
    private native byte[] prepareSSORequest();
    private native byte[] prepareSSOSubmit(byte[] buf, long size);
    static {
        try {
            System.loadLibrary(""ntlmauth"");
            SSPIJNIClient.libraryLoaded = true;
        } catch (UnsatisfiedLinkError err) {
            Logger.println(""Unable to load library: "" + err);
        }
    }
    private SSPIJNIClient() {
        //empty constructor
    }
    public static SSPIJNIClient getInstance() throws Exception {
        if (thisInstance == null) {
            if (!libraryLoaded) {
                throw new Exception(""Native SSPI library not loaded. ""
                        + ""Check the java.library.path system property."");
            }
            thisInstance = new SSPIJNIClient();
            thisInstance.invokeInitialize();
        }
        return thisInstance;
    }
    public void invokeInitialize() {
        if (!initialized) {
            initialize();
            initialized = true;
        }
    }
    public void invokeUnInitialize() {
        if (initialized) {
            unInitialize();
            initialized = false;
        }
    }
    public byte[] invokePrepareSSORequest() throws Exception {
        if (!initialized) {
            throw new Exception(""SSPI Not Initialized"");
        }
        return prepareSSORequest();
    }
    public byte[] invokePrepareSSOSubmit(byte[] buf) throws Exception {
        if (!initialized) {
            throw new Exception(""SSPI Not Initialized"");
        }
        return prepareSSOSubmit(buf, buf.length);
    }
}",class,
"    private SSPIJNIClient() {
        //empty constructor
    }",method,
"    public static SSPIJNIClient getInstance() throws Exception {
        if (thisInstance == null) {
            if (!libraryLoaded) {
                throw new Exception(""Native SSPI library not loaded. ""
                        + ""Check the java.library.path system property."");
            }
            thisInstance = new SSPIJNIClient();
            thisInstance.invokeInitialize();
        }
        return thisInstance;
    }",method,
"        if (thisInstance == null) {
            if (!libraryLoaded) {
                throw new Exception(""Native SSPI library not loaded. ""
                        + ""Check the java.library.path system property."");
            }
            thisInstance = new SSPIJNIClient();
            thisInstance.invokeInitialize();
        }",method,
"            if (!libraryLoaded) {
                throw new Exception(""Native SSPI library not loaded. ""
                        + ""Check the java.library.path system property."");
            }",method,
"    public void invokeInitialize() {
        if (!initialized) {
            initialize();
            initialized = true;
        }
    }",method,
"        if (!initialized) {
            initialize();
            initialized = true;
        }",method,
"    public void invokeUnInitialize() {
        if (initialized) {
            unInitialize();
            initialized = false;
        }
    }",method,
"        if (initialized) {
            unInitialize();
            initialized = false;
        }",method,
"    public byte[] invokePrepareSSORequest() throws Exception {
        if (!initialized) {
            throw new Exception(""SSPI Not Initialized"");
        }
        return prepareSSORequest();
    }",method,
"        if (!initialized) {
            throw new Exception(""SSPI Not Initialized"");
        }",method,
"    public byte[] invokePrepareSSOSubmit(byte[] buf) throws Exception {
        if (!initialized) {
            throw new Exception(""SSPI Not Initialized"");
        }
        return prepareSSOSubmit(buf, buf.length);
    }",method,
"        if (!initialized) {
            throw new Exception(""SSPI Not Initialized"");
        }",method,
"public class InvalidCoordinatesException extends WebDriverException {
  public InvalidCoordinatesException(String message) {
    super(message);
  }
}",class,

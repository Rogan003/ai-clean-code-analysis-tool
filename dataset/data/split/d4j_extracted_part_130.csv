code_snippet,type,score
"      if (item != null) {
        for(ParameterInfoHandler handler:handlers) {
          if (handler.couldShowInLookup()) {
            final Object[] items = handler.getParametersForLookup(item, context);
            if (items != null && items.length > 0) {
              showLookupEditorHint(items, editor, project, handler, requestFocus);
            }
            return;
          }
        }
      }",method,
"        for(ParameterInfoHandler handler:handlers) {
          if (handler.couldShowInLookup()) {
            final Object[] items = handler.getParametersForLookup(item, context);
            if (items != null && items.length > 0) {
              showLookupEditorHint(items, editor, project, handler, requestFocus);
            }
            return;
          }
        }",method,
"            if (items != null && items.length > 0) {
              showLookupEditorHint(items, editor, project, handler, requestFocus);
            }",method,
"      for (ParameterInfoHandler<Object, ?> handler : handlers) {
        Object element = handler.findElementForParameterInfo(context);
        if (element != null) {
          handler.showParameterInfo(element, context);
        }
      }",method,
"        if (element != null) {
          handler.showParameterInfo(element, context);
        }",method,
"  private static void showLookupEditorHint(Object[] descriptors,
                                           final Editor editor,
                                           final Project project,
                                           ParameterInfoHandler handler,
                                           boolean requestFocus) {
    ParameterInfoComponent component = new ParameterInfoComponent(descriptors, editor, handler, requestFocus, false);
    component.update(false);
    final LightweightHint hint = new LightweightHint(component);
    hint.setSelectingHint(true);
    final HintManagerImpl hintManager = HintManagerImpl.getInstanceImpl();
    final Pair<Point, Short> pos = ParameterInfoController.chooseBestHintPosition(project, editor, null, hint, true, HintManager.DEFAULT, true);
    ApplicationManager.getApplication().invokeLater(() -> {
      if (!editor.getComponent().isShowing()) return;
      hintManager.showEditorHint(hint, editor, pos.getFirst(),
                                 HintManager.HIDE_BY_ANY_KEY | HintManager.HIDE_BY_LOOKUP_ITEM_CHANGE | HintManager.UPDATE_BY_SCROLLING,
                                 0, false, pos.getSecond());
    });
  }",method,
"  @Nullable
  public static ParameterInfoHandler[] getHandlers(Project project, final Language... languages) {
    Set<ParameterInfoHandler> handlers = new THashSet<>();
    for (final Language language : languages) {
      handlers.addAll(DumbService.getInstance(project).filterByDumbAwareness(LanguageParameterInfo.INSTANCE.allForLanguage(language)));
    }
    if (handlers.isEmpty()) return null;
    return handlers.toArray(new ParameterInfoHandler[handlers.size()]);
  }",method,
"    for (final Language language : languages) {
      handlers.addAll(DumbService.getInstance(project).filterByDumbAwareness(LanguageParameterInfo.INSTANCE.allForLanguage(language)));
    }",method,
"public class PsiImportStaticStatementImpl extends PsiImportStatementBaseImpl implements PsiImportStaticStatement {
  public static final PsiImportStaticStatementImpl[] EMPTY_ARRAY = new PsiImportStaticStatementImpl[0];
  public static final ArrayFactory<PsiImportStaticStatementImpl> ARRAY_FACTORY =
    count -> count == 0 ? EMPTY_ARRAY : new PsiImportStaticStatementImpl[count];
  public PsiImportStaticStatementImpl(final PsiImportStatementStub stub) {
    super(stub, JavaStubElementTypes.IMPORT_STATIC_STATEMENT);
  }
  public PsiImportStaticStatementImpl(final ASTNode node) {
    super(node);
  }
  @Override
  public PsiClass resolveTargetClass() {
    final PsiJavaCodeReferenceElement classReference = getClassReference();
    if (classReference == null) return null;
    final PsiElement result = classReference.resolve();
    if (result instanceof PsiClass) {
      return (PsiClass) result;
    }
    else {
      return null;
    }
  }
  @Override
  public String getReferenceName() {
    if (isOnDemand()) return null;
    final PsiImportStaticReferenceElement memberReference = getMemberReference();
    if (memberReference != null) {
      return memberReference.getReferenceName();
    }
    else {
      return null;
    }
  }
  @Nullable
  private PsiImportStaticReferenceElement getMemberReference() {
    if (isOnDemand()) {
      return null;
    }
    else {
      return (PsiImportStaticReferenceElement) getImportReference();
    }
  }
  @Nullable
  public PsiJavaCodeReferenceElement getClassReference() {
    if (isOnDemand()) {
      return getImportReference();
    }
    else {
      final PsiImportStaticReferenceElement memberReference = getMemberReference();
      if (memberReference != null) {
        return memberReference.getClassReference();
      }
      else {
        return null;
      }
    }
  }
  @Override
  public void accept(@NotNull PsiElementVisitor visitor){
    if (visitor instanceof JavaElementVisitor) {
      ((JavaElementVisitor)visitor).visitImportStaticStatement(this);
    }
    else {
      visitor.visitElement(this);
    }
  }
  public String toString(){
    return ""PsiImportStaticStatement"";
  }
}",class,
"  public PsiImportStaticStatementImpl(final PsiImportStatementStub stub) {
    super(stub, JavaStubElementTypes.IMPORT_STATIC_STATEMENT);
  }",method,
"  public PsiImportStaticStatementImpl(final ASTNode node) {
    super(node);
  }",method,
"  @Override
  public PsiClass resolveTargetClass() {
    final PsiJavaCodeReferenceElement classReference = getClassReference();
    if (classReference == null) return null;
    final PsiElement result = classReference.resolve();
    if (result instanceof PsiClass) {
      return (PsiClass) result;
    }
    else {
      return null;
    }
  }",method,
"    if (result instanceof PsiClass) {
      return (PsiClass) result;
    }",method,
"  @Override
  public String getReferenceName() {
    if (isOnDemand()) return null;
    final PsiImportStaticReferenceElement memberReference = getMemberReference();
    if (memberReference != null) {
      return memberReference.getReferenceName();
    }
    else {
      return null;
    }
  }",method,
"    if (memberReference != null) {
      return memberReference.getReferenceName();
    }",method,
"  @Nullable
  private PsiImportStaticReferenceElement getMemberReference() {
    if (isOnDemand()) {
      return null;
    }
    else {
      return (PsiImportStaticReferenceElement) getImportReference();
    }
  }",method,
"  @Nullable
  public PsiJavaCodeReferenceElement getClassReference() {
    if (isOnDemand()) {
      return getImportReference();
    }
    else {
      final PsiImportStaticReferenceElement memberReference = getMemberReference();
      if (memberReference != null) {
        return memberReference.getClassReference();
      }
      else {
        return null;
      }
    }
  }",method,
"      if (memberReference != null) {
        return memberReference.getClassReference();
      }",method,
"  @Override
  public void accept(@NotNull PsiElementVisitor visitor){
    if (visitor instanceof JavaElementVisitor) {
      ((JavaElementVisitor)visitor).visitImportStaticStatement(this);
    }
    else {
      visitor.visitElement(this);
    }
  }",method,
"    if (visitor instanceof JavaElementVisitor) {
      ((JavaElementVisitor)visitor).visitImportStaticStatement(this);
    }",method,
"  public String toString(){
    return ""PsiImportStaticStatement"";
  }",method,
"public class FactTemplateExtractor {
  public final List<Pair<Pattern, List<FactTemplate>>> patterns = new ArrayList<>();
  public FactTemplateExtractor(FactSource facts, String relation) throws IOException {
    this(new FactCollection(facts), relation);
  }
  public FactTemplateExtractor(FactCollection facts, String relation) {
    Announce.doing(""Loading fact templates of"", relation);
    for (Fact fact : facts.getFactsWithRelation(relation)) {
      patterns.add(new Pair<Pattern, List<FactTemplate>>(fact.getArgPattern(1), FactTemplate.create(fact.getArgJavaString(2))));
    }
    if (patterns.isEmpty()) {
      Announce.warning(""No patterns found for relation "" + relation);
    }
    Announce.done();
  }
  public Collection<Fact> extract(String string, String dollarZero) {
    return extract(string, dollarZero, ""eng"");
  }
  public Collection<Fact> extract(String string, String dollarZero, String language) {
    Map<String, String> languageMap = null;
    try {
      languageMap = PatternHardExtractor.LANGUAGECODEMAPPING.factCollection().getStringMap(""<hasThreeLetterLanguageCode>"");
    } catch (IOException e) {
      e.printStackTrace();
    }
    Map<String, String> variables = new TreeMap<>();
    variables.put(""$0"", dollarZero);
    List<List<FactTemplate>> templateGroups = makeTemplateGroups(string, language);
    List<Fact> facts = new ArrayList<>();
    for (List<FactTemplate> template : templateGroups) {
      facts.addAll(FactTemplate.instantiate(template, variables, language, languageMap));
    }
    return facts;
  }
  public List<List<FactTemplate>> makeTemplateGroups(String string, String language) {
    Map<String, String> languageMap = null;
    try {
      languageMap = PatternHardExtractor.LANGUAGECODEMAPPING.factCollection().getStringMap(""<hasThreeLetterLanguageCode>"");
    } catch (IOException e) {
      e.printStackTrace();
    }
    List<List<FactTemplate>> result = new ArrayList<>();
    for (Pair<Pattern, List<FactTemplate>> pattern : patterns) {
      Matcher m = pattern.first().matcher(string);
      while (m.find()) {
        Map<String, String> variables = new TreeMap<>();
        for (int i = 1; i <= m.groupCount(); i++) {
          // somehow a NullPointerException occurred in the next line
          if (m.group(i) == null || m.group(i).trim().isEmpty()) {
            Announce.debug(""$"" + i + "" was empty, skipping fact for pattern: "" + pattern);
            continue;
          } else {
            variables.put(""$"" + i, m.group(i));
          }
        }
        List<FactTemplate> templates = FactTemplate.instantiatePartially(pattern.second(), variables, language, languageMap);
        result.add(templates);
      }
    }
    return (result);
  }
  @Deprecated
  public Collection<Pair<Fact, String>> extractWithProvenance(String string, String dollarZero) {
    Map<String, String> languageMap = null;
    try {
      languageMap = PatternHardExtractor.LANGUAGECODEMAPPING.factCollection().getStringMap(""<hasThreeLetterLanguageCode>"");
    } catch (IOException e) {
      e.printStackTrace();
    }
    List<Pair<Fact, String>> result = new LinkedList<>();
    for (Pair<Pattern, List<FactTemplate>> pattern : patterns) {
      Matcher m = pattern.first().matcher(string);
      while (m.find()) {
        Map<String, String> variables = new TreeMap<>();
        variables.put(""$0"", dollarZero);
        for (int i = 1; i <= m.groupCount(); i++) {
          if (m.group(i).trim().isEmpty()) {
            Announce.debug(""$"" + i + "" was empty, skipping fact for pattern: "" + pattern);
            continue;
          } else {
            variables.put(""$"" + i, m.group(i));
          }
        }
        for (Fact f : FactTemplate.instantiate(pattern.second(), variables, ""eng"", languageMap)) {
          result.add(new Pair<Fact, String>(f, pattern.first.toString() + "" -> "" + pattern.second.toString()));
        }
      }
    }
    return (result);
  }
}",class,
"  public FactTemplateExtractor(FactSource facts, String relation) throws IOException {
    this(new FactCollection(facts), relation);
  }",method,
"  public FactTemplateExtractor(FactCollection facts, String relation) {
    Announce.doing(""Loading fact templates of"", relation);
    for (Fact fact : facts.getFactsWithRelation(relation)) {
      patterns.add(new Pair<Pattern, List<FactTemplate>>(fact.getArgPattern(1), FactTemplate.create(fact.getArgJavaString(2))));
    }
    if (patterns.isEmpty()) {
      Announce.warning(""No patterns found for relation "" + relation);
    }
    Announce.done();
  }",method,
"  public Collection<Fact> extract(String string, String dollarZero) {
    return extract(string, dollarZero, ""eng"");
  }",method,
"  public Collection<Fact> extract(String string, String dollarZero, String language) {
    Map<String, String> languageMap = null;
    try {
      languageMap = PatternHardExtractor.LANGUAGECODEMAPPING.factCollection().getStringMap(""<hasThreeLetterLanguageCode>"");
    } catch (IOException e) {
      e.printStackTrace();
    }
    Map<String, String> variables = new TreeMap<>();
    variables.put(""$0"", dollarZero);
    List<List<FactTemplate>> templateGroups = makeTemplateGroups(string, language);
    List<Fact> facts = new ArrayList<>();
    for (List<FactTemplate> template : templateGroups) {
      facts.addAll(FactTemplate.instantiate(template, variables, language, languageMap));
    }
    return facts;
  }",method,
"    for (List<FactTemplate> template : templateGroups) {
      facts.addAll(FactTemplate.instantiate(template, variables, language, languageMap));
    }",method,
"  public List<List<FactTemplate>> makeTemplateGroups(String string, String language) {
    Map<String, String> languageMap = null;
    try {
      languageMap = PatternHardExtractor.LANGUAGECODEMAPPING.factCollection().getStringMap(""<hasThreeLetterLanguageCode>"");
    } catch (IOException e) {
      e.printStackTrace();
    }
    List<List<FactTemplate>> result = new ArrayList<>();
    for (Pair<Pattern, List<FactTemplate>> pattern : patterns) {
      Matcher m = pattern.first().matcher(string);
      while (m.find()) {
        Map<String, String> variables = new TreeMap<>();
        for (int i = 1; i <= m.groupCount(); i++) {
          // somehow a NullPointerException occurred in the next line
          if (m.group(i) == null || m.group(i).trim().isEmpty()) {
            Announce.debug(""$"" + i + "" was empty, skipping fact for pattern: "" + pattern);
            continue;
          } else {
            variables.put(""$"" + i, m.group(i));
          }
        }
        List<FactTemplate> templates = FactTemplate.instantiatePartially(pattern.second(), variables, language, languageMap);
        result.add(templates);
      }
    }
    return (result);
  }",method,
"    for (Pair<Pattern, List<FactTemplate>> pattern : patterns) {
      Matcher m = pattern.first().matcher(string);
      while (m.find()) {
        Map<String, String> variables = new TreeMap<>();
        for (int i = 1; i <= m.groupCount(); i++) {
          // somehow a NullPointerException occurred in the next line
          if (m.group(i) == null || m.group(i).trim().isEmpty()) {
            Announce.debug(""$"" + i + "" was empty, skipping fact for pattern: "" + pattern);
            continue;
          } else {
            variables.put(""$"" + i, m.group(i));
          }
        }
        List<FactTemplate> templates = FactTemplate.instantiatePartially(pattern.second(), variables, language, languageMap);
        result.add(templates);
      }
    }",method,
"  @Deprecated
  public Collection<Pair<Fact, String>> extractWithProvenance(String string, String dollarZero) {
    Map<String, String> languageMap = null;
    try {
      languageMap = PatternHardExtractor.LANGUAGECODEMAPPING.factCollection().getStringMap(""<hasThreeLetterLanguageCode>"");
    } catch (IOException e) {
      e.printStackTrace();
    }
    List<Pair<Fact, String>> result = new LinkedList<>();
    for (Pair<Pattern, List<FactTemplate>> pattern : patterns) {
      Matcher m = pattern.first().matcher(string);
      while (m.find()) {
        Map<String, String> variables = new TreeMap<>();
        variables.put(""$0"", dollarZero);
        for (int i = 1; i <= m.groupCount(); i++) {
          if (m.group(i).trim().isEmpty()) {
            Announce.debug(""$"" + i + "" was empty, skipping fact for pattern: "" + pattern);
            continue;
          } else {
            variables.put(""$"" + i, m.group(i));
          }
        }
        for (Fact f : FactTemplate.instantiate(pattern.second(), variables, ""eng"", languageMap)) {
          result.add(new Pair<Fact, String>(f, pattern.first.toString() + "" -> "" + pattern.second.toString()));
        }
      }
    }
    return (result);
  }",method,
"    for (Pair<Pattern, List<FactTemplate>> pattern : patterns) {
      Matcher m = pattern.first().matcher(string);
      while (m.find()) {
        Map<String, String> variables = new TreeMap<>();
        variables.put(""$0"", dollarZero);
        for (int i = 1; i <= m.groupCount(); i++) {
          if (m.group(i).trim().isEmpty()) {
            Announce.debug(""$"" + i + "" was empty, skipping fact for pattern: "" + pattern);
            continue;
          } else {
            variables.put(""$"" + i, m.group(i));
          }
        }
        for (Fact f : FactTemplate.instantiate(pattern.second(), variables, ""eng"", languageMap)) {
          result.add(new Pair<Fact, String>(f, pattern.first.toString() + "" -> "" + pattern.second.toString()));
        }
      }
    }",method,
"public class CommittedChangesTableModel extends ListTableModel<CommittedChangeList> {
  private final boolean myAsynchLoad;
  private static final ChangeListColumn[] ourDefaultColumns = new ChangeListColumn[] { ChangeListColumn.DATE, ChangeListColumn.NAME };
  private RowSorter.SortKey mySortKey;
  public CommittedChangesTableModel(final List<CommittedChangeList> changeLists, boolean asynchLoad) {
    super(buildColumnInfos(ourDefaultColumns), changeLists, 0);
    myAsynchLoad = asynchLoad;
  }
  public CommittedChangesTableModel(final List<CommittedChangeList> changeLists, final ChangeListColumn[] columns, boolean asynchLoad) {
    super(buildColumnInfos(columns), changeLists, 0);
    myAsynchLoad = asynchLoad;
  }
  protected void setSortKey(final RowSorter.SortKey sortKey) {
    mySortKey = sortKey;
  }
  @Override
  public RowSorter.SortKey getDefaultSortKey() {
    return mySortKey;
  }
  private static ColumnInfo[] buildColumnInfos(final ChangeListColumn[] columns) {
    ColumnInfo[] result = new ColumnInfo[columns.length];
    for(int i=0; i<columns.length; i++) {
      result [i] = new ColumnInfoAdapter(columns [i]);
    }
    return result;
  }
  private static class ColumnInfoAdapter extends ColumnInfo {
    private final ChangeListColumn myColumn;
    public ColumnInfoAdapter(ChangeListColumn column) {
      super(column.getTitle());
      myColumn = column;
    }
    public Object valueOf(final Object o) {
      //noinspection unchecked
      return myColumn.getValue((ChangeList)o);
    }
    @Override
    public Comparator getComparator() {
      return myColumn.getComparator();
    }
    public ChangeListColumn getColumn() {
      return myColumn;
    }
  }
  public boolean isAsynchLoad() {
    return myAsynchLoad;
  }
}",class,
"  private static class ColumnInfoAdapter extends ColumnInfo {
    private final ChangeListColumn myColumn;
    public ColumnInfoAdapter(ChangeListColumn column) {
      super(column.getTitle());
      myColumn = column;
    }
    public Object valueOf(final Object o) {
      //noinspection unchecked
      return myColumn.getValue((ChangeList)o);
    }
    @Override
    public Comparator getComparator() {
      return myColumn.getComparator();
    }
    public ChangeListColumn getColumn() {
      return myColumn;
    }
  }",class,
"  public CommittedChangesTableModel(final List<CommittedChangeList> changeLists, boolean asynchLoad) {
    super(buildColumnInfos(ourDefaultColumns), changeLists, 0);
    myAsynchLoad = asynchLoad;
  }",method,
"  public CommittedChangesTableModel(final List<CommittedChangeList> changeLists, final ChangeListColumn[] columns, boolean asynchLoad) {
    super(buildColumnInfos(columns), changeLists, 0);
    myAsynchLoad = asynchLoad;
  }",method,
"  protected void setSortKey(final RowSorter.SortKey sortKey) {
    mySortKey = sortKey;
  }",method,
"  @Override
  public RowSorter.SortKey getDefaultSortKey() {
    return mySortKey;
  }",method,
"  private static ColumnInfo[] buildColumnInfos(final ChangeListColumn[] columns) {
    ColumnInfo[] result = new ColumnInfo[columns.length];
    for(int i=0; i<columns.length; i++) {
      result [i] = new ColumnInfoAdapter(columns [i]);
    }
    return result;
  }",method,
"    for(int i=0; i<columns.length; i++) {
      result [i] = new ColumnInfoAdapter(columns [i]);
    }",method,
"    public ColumnInfoAdapter(ChangeListColumn column) {
      super(column.getTitle());
      myColumn = column;
    }",method,
"    public Object valueOf(final Object o) {
      //noinspection unchecked
      return myColumn.getValue((ChangeList)o);
    }",method,
"    @Override
    public Comparator getComparator() {
      return myColumn.getComparator();
    }",method,
"    public ChangeListColumn getColumn() {
      return myColumn;
    }",method,
"  public boolean isAsynchLoad() {
    return myAsynchLoad;
  }",method,
"import java.util.List;
class EpollSocketTestPermutation extends SocketTestPermutation {
    static final EpollSocketTestPermutation INSTANCE = new EpollSocketTestPermutation();
    static final EventLoopGroup EPOLL_BOSS_GROUP =
            new EpollEventLoopGroup(BOSSES, new DefaultThreadFactory(""testsuite-epoll-boss"", true));
    static final EventLoopGroup EPOLL_WORKER_GROUP =
            new EpollEventLoopGroup(WORKERS, new DefaultThreadFactory(""testsuite-epoll-worker"", true));
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(EpollSocketTestPermutation.class);
    @Override
    public List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> socket() {
        List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> list =
                combo(serverSocket(), clientSocket());
        list.remove(list.size() - 1); // Exclude NIO x NIO test
        return list;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public List<BootstrapFactory<ServerBootstrap>> serverSocket() {
        List<BootstrapFactory<ServerBootstrap>> toReturn = new ArrayList<BootstrapFactory<ServerBootstrap>>();
        toReturn.add(new BootstrapFactory<ServerBootstrap>() {
            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                            .channel(EpollServerSocketChannel.class);
            }
        });
        if (isServerFastOpen()) {
            toReturn.add(new BootstrapFactory<ServerBootstrap>() {
                @Override
                public ServerBootstrap newInstance() {
                    ServerBootstrap serverBootstrap = new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                                                           .channel(EpollServerSocketChannel.class);
                    serverBootstrap.option(EpollChannelOption.TCP_FASTOPEN, 5);
                    return serverBootstrap;
                }
            });
        }
        toReturn.add(new BootstrapFactory<ServerBootstrap>() {
            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(nioBossGroup, nioWorkerGroup)
                                            .channel(NioServerSocketChannel.class);
            }
        });
        return toReturn;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public List<BootstrapFactory<Bootstrap>> clientSocket() {
        return Arrays.asList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollSocketChannel.class);
                    }
                },
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(nioWorkerGroup).channel(NioSocketChannel.class);
                    }
                }
        );
    }
    @Override
    public List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>> datagram() {
        // Make the list of Bootstrap factories.
        @SuppressWarnings(""unchecked"")
        List<BootstrapFactory<Bootstrap>> bfs = Arrays.asList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(nioWorkerGroup).channelFactory(new ChannelFactory<Channel>() {
                            @Override
                            public Channel newChannel() {
                                return new NioDatagramChannel(InternetProtocolFamily.IPv4);
                            }
                            @Override
                            public String toString() {
                                return NioDatagramChannel.class.getSimpleName() + "".class"";
                            }
                        });
                    }
                },
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
                    }
                }
        );
        return combo(bfs, bfs);
    }
    public List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> domainSocket() {
        List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> list =
                combo(serverDomainSocket(), clientDomainSocket());
        return list;
    }
    public List<BootstrapFactory<ServerBootstrap>> serverDomainSocket() {
        return Collections.<BootstrapFactory<ServerBootstrap>>singletonList(
                new BootstrapFactory<ServerBootstrap>() {
                    @Override
                    public ServerBootstrap newInstance() {
                        return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                .channel(EpollServerDomainSocketChannel.class);
                    }
                }
        );
    }
    public List<BootstrapFactory<Bootstrap>> clientDomainSocket() {
        return Collections.<BootstrapFactory<Bootstrap>>singletonList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDomainSocketChannel.class);
                    }
                }
        );
    }
    @Override
    public List<BootstrapFactory<Bootstrap>> datagramSocket() {
        return Collections.<BootstrapFactory<Bootstrap>>singletonList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
                    }
                }
        );
    }
    public boolean isServerFastOpen() {
        return AccessController.doPrivileged(new PrivilegedAction<Integer>() {
            @Override
            public Integer run() {
                int fastopen = 0;
                File file = new File(""/proc/sys/net/ipv4/tcp_fastopen"");
                if (file.exists()) {
                    BufferedReader in = null;
                    try {
                        in = new BufferedReader(new FileReader(file));
                        fastopen = Integer.parseInt(in.readLine());
                        if (logger.isDebugEnabled()) {
                            logger.debug(""{}: {}"", file, fastopen);
                        }
                    } catch (Exception e) {
                        logger.debug(""Failed to get TCP_FASTOPEN from: {}"", file, e);
                    } finally {
                        if (in != null) {
                            try {
                                in.close();
                            } catch (Exception e) {
                                // Ignored.
                            }
                        }
                    }
                } else {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""{}: {} (non-existent)"", file, fastopen);
                    }
                }
                return fastopen;
            }
        }) == 3;
    }
    public static DomainSocketAddress newSocketAddress() {
        return UnixTestUtils.newSocketAddress();
    }
}",class,
"    @Override
    public List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> socket() {
        List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> list =
                combo(serverSocket(), clientSocket());
        list.remove(list.size() - 1); // Exclude NIO x NIO test
        return list;
    }",method,
"    @SuppressWarnings(""unchecked"")
    @Override
    public List<BootstrapFactory<ServerBootstrap>> serverSocket() {
        List<BootstrapFactory<ServerBootstrap>> toReturn = new ArrayList<BootstrapFactory<ServerBootstrap>>();
        toReturn.add(new BootstrapFactory<ServerBootstrap>() {
            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                            .channel(EpollServerSocketChannel.class);
            }
        });
        if (isServerFastOpen()) {
            toReturn.add(new BootstrapFactory<ServerBootstrap>() {
                @Override
                public ServerBootstrap newInstance() {
                    ServerBootstrap serverBootstrap = new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                                                           .channel(EpollServerSocketChannel.class);
                    serverBootstrap.option(EpollChannelOption.TCP_FASTOPEN, 5);
                    return serverBootstrap;
                }
            });
        }
        toReturn.add(new BootstrapFactory<ServerBootstrap>() {
            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(nioBossGroup, nioWorkerGroup)
                                            .channel(NioServerSocketChannel.class);
            }
        });
        return toReturn;
    }",method,
"        toReturn.add(new BootstrapFactory<ServerBootstrap>() {
            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                            .channel(EpollServerSocketChannel.class);
            }
        }",method,
"            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                            .channel(EpollServerSocketChannel.class);
            }",method,
"            toReturn.add(new BootstrapFactory<ServerBootstrap>() {
                @Override
                public ServerBootstrap newInstance() {
                    ServerBootstrap serverBootstrap = new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                                                           .channel(EpollServerSocketChannel.class);
                    serverBootstrap.option(EpollChannelOption.TCP_FASTOPEN, 5);
                    return serverBootstrap;
                }
            }",method,
"                @Override
                public ServerBootstrap newInstance() {
                    ServerBootstrap serverBootstrap = new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                                                           .channel(EpollServerSocketChannel.class);
                    serverBootstrap.option(EpollChannelOption.TCP_FASTOPEN, 5);
                    return serverBootstrap;
                }",method,
"        toReturn.add(new BootstrapFactory<ServerBootstrap>() {
            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(nioBossGroup, nioWorkerGroup)
                                            .channel(NioServerSocketChannel.class);
            }
        }",method,
"            @Override
            public ServerBootstrap newInstance() {
                return new ServerBootstrap().group(nioBossGroup, nioWorkerGroup)
                                            .channel(NioServerSocketChannel.class);
            }",method,
"    @SuppressWarnings(""unchecked"")
    @Override
    public List<BootstrapFactory<Bootstrap>> clientSocket() {
        return Arrays.asList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollSocketChannel.class);
                    }
                },
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(nioWorkerGroup).channel(NioSocketChannel.class);
                    }
                }
        );
    }",method,
"        return Arrays.asList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollSocketChannel.class);
                    }
                }",method,
"                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollSocketChannel.class);
                    }",method,
"                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(nioWorkerGroup).channel(NioSocketChannel.class);
                    }",method,
"    @Override
    public List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>> datagram() {
        // Make the list of Bootstrap factories.
        @SuppressWarnings(""unchecked"")
        List<BootstrapFactory<Bootstrap>> bfs = Arrays.asList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(nioWorkerGroup).channelFactory(new ChannelFactory<Channel>() {
                            @Override
                            public Channel newChannel() {
                                return new NioDatagramChannel(InternetProtocolFamily.IPv4);
                            }
                            @Override
                            public String toString() {
                                return NioDatagramChannel.class.getSimpleName() + "".class"";
                            }
                        });
                    }
                },
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
                    }
                }
        );
        return combo(bfs, bfs);
    }",method,
"                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(nioWorkerGroup).channelFactory(new ChannelFactory<Channel>() {
                            @Override
                            public Channel newChannel() {
                                return new NioDatagramChannel(InternetProtocolFamily.IPv4);
                            }
                            @Override
                            public String toString() {
                                return NioDatagramChannel.class.getSimpleName() + "".class"";
                            }
                        });
                    }",method,
"                            @Override
                            public Channel newChannel() {
                                return new NioDatagramChannel(InternetProtocolFamily.IPv4);
                            }",method,
"                            @Override
                            public String toString() {
                                return NioDatagramChannel.class.getSimpleName() + "".class"";
                            }",method,
"                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
                    }",method,
"    public List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> domainSocket() {
        List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> list =
                combo(serverDomainSocket(), clientDomainSocket());
        return list;
    }",method,
"    public List<BootstrapFactory<ServerBootstrap>> serverDomainSocket() {
        return Collections.<BootstrapFactory<ServerBootstrap>>singletonList(
                new BootstrapFactory<ServerBootstrap>() {
                    @Override
                    public ServerBootstrap newInstance() {
                        return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                .channel(EpollServerDomainSocketChannel.class);
                    }
                }
        );
    }",method,
"        return Collections.<BootstrapFactory<ServerBootstrap>>singletonList(
                new BootstrapFactory<ServerBootstrap>() {
                    @Override
                    public ServerBootstrap newInstance() {
                        return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                .channel(EpollServerDomainSocketChannel.class);
                    }
                }",method,
"                    @Override
                    public ServerBootstrap newInstance() {
                        return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
                                .channel(EpollServerDomainSocketChannel.class);
                    }",method,
"    public List<BootstrapFactory<Bootstrap>> clientDomainSocket() {
        return Collections.<BootstrapFactory<Bootstrap>>singletonList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDomainSocketChannel.class);
                    }
                }
        );
    }",method,
"        return Collections.<BootstrapFactory<Bootstrap>>singletonList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDomainSocketChannel.class);
                    }
                }",method,
"                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDomainSocketChannel.class);
                    }",method,
"    @Override
    public List<BootstrapFactory<Bootstrap>> datagramSocket() {
        return Collections.<BootstrapFactory<Bootstrap>>singletonList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
                    }
                }
        );
    }",method,
"        return Collections.<BootstrapFactory<Bootstrap>>singletonList(
                new BootstrapFactory<Bootstrap>() {
                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
                    }
                }",method,
"                    @Override
                    public Bootstrap newInstance() {
                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
                    }",method,
"    public boolean isServerFastOpen() {
        return AccessController.doPrivileged(new PrivilegedAction<Integer>() {
            @Override
            public Integer run() {
                int fastopen = 0;
                File file = new File(""/proc/sys/net/ipv4/tcp_fastopen"");
                if (file.exists()) {
                    BufferedReader in = null;
                    try {
                        in = new BufferedReader(new FileReader(file));
                        fastopen = Integer.parseInt(in.readLine());
                        if (logger.isDebugEnabled()) {
                            logger.debug(""{}: {}"", file, fastopen);
                        }
                    } catch (Exception e) {
                        logger.debug(""Failed to get TCP_FASTOPEN from: {}"", file, e);
                    } finally {
                        if (in != null) {
                            try {
                                in.close();
                            } catch (Exception e) {
                                // Ignored.
                            }
                        }
                    }
                } else {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""{}: {} (non-existent)"", file, fastopen);
                    }
                }
                return fastopen;
            }
        }) == 3;
    }",method,
"        return AccessController.doPrivileged(new PrivilegedAction<Integer>() {
            @Override
            public Integer run() {
                int fastopen = 0;
                File file = new File(""/proc/sys/net/ipv4/tcp_fastopen"");
                if (file.exists()) {
                    BufferedReader in = null;
                    try {
                        in = new BufferedReader(new FileReader(file));
                        fastopen = Integer.parseInt(in.readLine());
                        if (logger.isDebugEnabled()) {
                            logger.debug(""{}: {}"", file, fastopen);
                        }
                    } catch (Exception e) {
                        logger.debug(""Failed to get TCP_FASTOPEN from: {}"", file, e);
                    } finally {
                        if (in != null) {
                            try {
                                in.close();
                            } catch (Exception e) {
                                // Ignored.
                            }
                        }
                    }
                } else {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""{}: {} (non-existent)"", file, fastopen);
                    }
                }
                return fastopen;
            }
        }",method,
"            @Override
            public Integer run() {
                int fastopen = 0;
                File file = new File(""/proc/sys/net/ipv4/tcp_fastopen"");
                if (file.exists()) {
                    BufferedReader in = null;
                    try {
                        in = new BufferedReader(new FileReader(file));
                        fastopen = Integer.parseInt(in.readLine());
                        if (logger.isDebugEnabled()) {
                            logger.debug(""{}: {}"", file, fastopen);
                        }
                    } catch (Exception e) {
                        logger.debug(""Failed to get TCP_FASTOPEN from: {}"", file, e);
                    } finally {
                        if (in != null) {
                            try {
                                in.close();
                            } catch (Exception e) {
                                // Ignored.
                            }
                        }
                    }
                } else {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""{}: {} (non-existent)"", file, fastopen);
                    }
                }
                return fastopen;
            }",method,
"                        if (in != null) {
                            try {
                                in.close();
                            } catch (Exception e) {
                                // Ignored.
                            }
                        }",method,
"    public static DomainSocketAddress newSocketAddress() {
        return UnixTestUtils.newSocketAddress();
    }",method,
"public class ShouldNotDeadlockAnswerExecutionTest {
    @Test
    public void failIfMockIsSharedBetweenThreads() throws Exception {
        Service service = Mockito.mock(Service.class);
        ExecutorService threads = Executors.newCachedThreadPool();
        AtomicInteger counter = new AtomicInteger(2);
        // registed answer on verySlowMethod
        Mockito.when(service.verySlowMethod()).thenAnswer(new LockingAnswer(counter));
        // execute verySlowMethod twice in separate threads
        threads.execute(new ServiceRunner(service));
        threads.execute(new ServiceRunner(service));
        // waiting for threads to finish
        threads.shutdown();
        if (!threads.awaitTermination(1000, TimeUnit.MILLISECONDS)) {
            // threads were timed-out
            fail();
        }
    }
    @Test
    public void successIfEveryThreadHasItsOwnMock() throws Exception {
        Service service1 = Mockito.mock(Service.class);
        Service service2 = Mockito.mock(Service.class);
        ExecutorService threads = Executors.newCachedThreadPool();
        AtomicInteger counter = new AtomicInteger(2);
        // registed answer on verySlowMethod
        Mockito.when(service1.verySlowMethod()).thenAnswer(new LockingAnswer(counter));
        Mockito.when(service2.verySlowMethod()).thenAnswer(new LockingAnswer(counter));
        // execute verySlowMethod twice in separate threads
        threads.execute(new ServiceRunner(service1));
        threads.execute(new ServiceRunner(service2));
        // waiting for threads to finish
        threads.shutdown();
        if (!threads.awaitTermination(500, TimeUnit.MILLISECONDS)) {
            // threads were timed-out
            fail();
        }
    }
    static class LockingAnswer implements Answer<String> {
        private AtomicInteger counter;
        public LockingAnswer(AtomicInteger counter) {
            this.counter = counter;
        }
        public String answer(InvocationOnMock invocation) throws Throwable {
            counter.decrementAndGet();
            while (counter.get() != 0) {
                Thread.sleep(10);
            }
            return null;
        }
    }
    static class ServiceRunner implements Runnable {
        private Service service;
        public ServiceRunner(Service service) {
            this.service = service;
        }
        public void run() {
            service.verySlowMethod();
        }
    }
    interface Service {
        String verySlowMethod();
    }
}",class,
"    static class LockingAnswer implements Answer<String> {
        private AtomicInteger counter;
        public LockingAnswer(AtomicInteger counter) {
            this.counter = counter;
        }
        public String answer(InvocationOnMock invocation) throws Throwable {
            counter.decrementAndGet();
            while (counter.get() != 0) {
                Thread.sleep(10);
            }
            return null;
        }
    }",class,
"    static class ServiceRunner implements Runnable {
        private Service service;
        public ServiceRunner(Service service) {
            this.service = service;
        }
        public void run() {
            service.verySlowMethod();
        }
    }",class,
"    @Test
    public void failIfMockIsSharedBetweenThreads() throws Exception {
        Service service = Mockito.mock(Service.class);
        ExecutorService threads = Executors.newCachedThreadPool();
        AtomicInteger counter = new AtomicInteger(2);
        // registed answer on verySlowMethod
        Mockito.when(service.verySlowMethod()).thenAnswer(new LockingAnswer(counter));
        // execute verySlowMethod twice in separate threads
        threads.execute(new ServiceRunner(service));
        threads.execute(new ServiceRunner(service));
        // waiting for threads to finish
        threads.shutdown();
        if (!threads.awaitTermination(1000, TimeUnit.MILLISECONDS)) {
            // threads were timed-out
            fail();
        }
    }",method,
"    @Test
    public void successIfEveryThreadHasItsOwnMock() throws Exception {
        Service service1 = Mockito.mock(Service.class);
        Service service2 = Mockito.mock(Service.class);
        ExecutorService threads = Executors.newCachedThreadPool();
        AtomicInteger counter = new AtomicInteger(2);
        // registed answer on verySlowMethod
        Mockito.when(service1.verySlowMethod()).thenAnswer(new LockingAnswer(counter));
        Mockito.when(service2.verySlowMethod()).thenAnswer(new LockingAnswer(counter));
        // execute verySlowMethod twice in separate threads
        threads.execute(new ServiceRunner(service1));
        threads.execute(new ServiceRunner(service2));
        // waiting for threads to finish
        threads.shutdown();
        if (!threads.awaitTermination(500, TimeUnit.MILLISECONDS)) {
            // threads were timed-out
            fail();
        }
    }",method,
"        public LockingAnswer(AtomicInteger counter) {
            this.counter = counter;
        }",method,
"        public String answer(InvocationOnMock invocation) throws Throwable {
            counter.decrementAndGet();
            while (counter.get() != 0) {
                Thread.sleep(10);
            }
            return null;
        }",method,
"        public ServiceRunner(Service service) {
            this.service = service;
        }",method,
"        public void run() {
            service.verySlowMethod();
        }",method,
"public class ParquetAvroSink<T> extends HadoopFileBasedSink<T> {
  private final String schemaString;
  private final SerializableConfiguration conf;
  public ParquetAvroSink(ValueProvider<ResourceId> baseOutputDirectoryProvider,
                         FileBasedSink.FilenamePolicy filenamePolicy,
                         Schema schema,
                         Configuration conf) {
    super(baseOutputDirectoryProvider, filenamePolicy);
    schemaString = schema.toString();
    this.conf = new SerializableConfiguration(conf);
  }
  @Override
  public HadoopFileBasedSink.WriteOperation<T> createWriteOperation() {
    return new ParquetAvroWriteOperation<T>(this, schemaString, conf);
  }
  // =======================================================================
  // WriteOperation
  // =======================================================================
  static class ParquetAvroWriteOperation<T> extends WriteOperation<T> {
    private final String schemaString;
    private final SerializableConfiguration conf;
    public ParquetAvroWriteOperation(HadoopFileBasedSink<T> sink,
                                     String schemaString,
                                     SerializableConfiguration conf) {
      super(sink);
      this.schemaString = schemaString;
      this.conf = conf;
    }
    @Override
    public HadoopFileBasedSink.Writer<T> createWriter() throws Exception {
      return new ParquetAvroWriter<>(this, new Schema.Parser().parse(schemaString), conf);
    }
  }
  // =======================================================================
  // Writer
  // =======================================================================
  static class ParquetAvroWriter<T> extends Writer<T> {
    private final Schema schema;
    private final SerializableConfiguration conf;
    private ParquetWriter<T> writer;
    public ParquetAvroWriter(WriteOperation<T> writeOperation,
                             Schema schema,
                             SerializableConfiguration conf) {
      super(writeOperation);
      this.schema = schema;
      this.conf = conf;
    }
    @Override
    protected void prepareWrite(Path path) throws Exception {
      writer = org.apache.parquet.avro.AvroParquetWriter.<T>builder(path)
          .withSchema(schema)
          .withConf(conf.get())
          .build();
    }
    @Override
    public void write(T value) throws Exception {
      writer.write(value);
    }
    @Override
    protected void finishWrite() throws Exception {
      writer.close();
    }
  }
}",class,
"  static class ParquetAvroWriteOperation<T> extends WriteOperation<T> {
    private final String schemaString;
    private final SerializableConfiguration conf;
    public ParquetAvroWriteOperation(HadoopFileBasedSink<T> sink,
                                     String schemaString,
                                     SerializableConfiguration conf) {
      super(sink);
      this.schemaString = schemaString;
      this.conf = conf;
    }
    @Override
    public HadoopFileBasedSink.Writer<T> createWriter() throws Exception {
      return new ParquetAvroWriter<>(this, new Schema.Parser().parse(schemaString), conf);
    }
  }",class,
"  static class ParquetAvroWriter<T> extends Writer<T> {
    private final Schema schema;
    private final SerializableConfiguration conf;
    private ParquetWriter<T> writer;
    public ParquetAvroWriter(WriteOperation<T> writeOperation,
                             Schema schema,
                             SerializableConfiguration conf) {
      super(writeOperation);
      this.schema = schema;
      this.conf = conf;
    }
    @Override
    protected void prepareWrite(Path path) throws Exception {
      writer = org.apache.parquet.avro.AvroParquetWriter.<T>builder(path)
          .withSchema(schema)
          .withConf(conf.get())
          .build();
    }
    @Override
    public void write(T value) throws Exception {
      writer.write(value);
    }
    @Override
    protected void finishWrite() throws Exception {
      writer.close();
    }
  }",class,
"  public ParquetAvroSink(ValueProvider<ResourceId> baseOutputDirectoryProvider,
                         FileBasedSink.FilenamePolicy filenamePolicy,
                         Schema schema,
                         Configuration conf) {
    super(baseOutputDirectoryProvider, filenamePolicy);
    schemaString = schema.toString();
    this.conf = new SerializableConfiguration(conf);
  }",method,
"  @Override
  public HadoopFileBasedSink.WriteOperation<T> createWriteOperation() {
    return new ParquetAvroWriteOperation<T>(this, schemaString, conf);
  }",method,
"    public ParquetAvroWriteOperation(HadoopFileBasedSink<T> sink,
                                     String schemaString,
                                     SerializableConfiguration conf) {
      super(sink);
      this.schemaString = schemaString;
      this.conf = conf;
    }",method,
"    @Override
    public HadoopFileBasedSink.Writer<T> createWriter() throws Exception {
      return new ParquetAvroWriter<>(this, new Schema.Parser().parse(schemaString), conf);
    }",method,
"    public ParquetAvroWriter(WriteOperation<T> writeOperation,
                             Schema schema,
                             SerializableConfiguration conf) {
      super(writeOperation);
      this.schema = schema;
      this.conf = conf;
    }",method,
"    @Override
    protected void prepareWrite(Path path) throws Exception {
      writer = org.apache.parquet.avro.AvroParquetWriter.<T>builder(path)
          .withSchema(schema)
          .withConf(conf.get())
          .build();
    }",method,
"    @Override
    public void write(T value) throws Exception {
      writer.write(value);
    }",method,
"    @Override
    protected void finishWrite() throws Exception {
      writer.close();
    }",method,
"public class Timeout extends Plugin 
  implements FilterPlugin, SocketListener, Runnable {
  private final static int debug = 0;
  protected int timeout = 0;
  protected String timeoutCommand = null;
  protected String timeoutWarning = null;
  protected Thread timeoutThread = null;
  private PluginBus pluginBus;
  public Timeout(final PluginBus bus, final String id) {
    super(bus, id);
    // register socket listener
    bus.registerPluginListener(this);
     bus.registerPluginListener(new ConfigurationListener() {
       public void setConfiguration(PluginConfig config) {
	 String tos = config.getProperty(""Timeout"", id, ""seconds"");
	 if(tos != null) {
	   try {
	     timeout = Integer.parseInt(tos);
           } catch(Exception e) {
	     Timeout.this.error(""timeout (""+timeout+"") ""
	                       +""is not an integer, timeout disabled"");
	   }
	   timeoutCommand = 
	     config.getProperty(""Timeout"", id, ""command"");
	   timeoutWarning = 
	     config.getProperty(""Timeout"", id, ""warning"");
	 }
       }
     });
     pluginBus = bus; 
  }
  public void run() {
    boolean ok = false;
    // loop around until the thread is kicked down the stream ...
    while(timeoutThread != null) {
      try {
        ok = false;
        timeoutThread.sleep(1000*timeout);
      } catch(InterruptedException e) {
	ok = true;
      }
      // if the timeout finished sucessfully close the connection
      if(!ok) {
        error(""data connection timeout, shutting down"");
	// first try it gracefully by sending the configured exit command
	if(timeoutCommand != null) {
	  error(""sending graceful exit command ..."");
	  try {
	    write(timeoutCommand.getBytes());
	  } catch(IOException e) {
	    error(""could not send exit command"");
	  }
	  timeoutThread = null;
	  final Thread grace = new Thread(new Runnable() {
	    public void run() {
	      try {
                Thread.currentThread().sleep(1000*timeout); 
	        Timeout.this.pluginBus.broadcast(new SocketRequest());
              } catch(InterruptedException e) {
	        // ignore exception
	      }
	    }
	  });
	  grace.start();
	} else // if not graceful exit exists, be rude
	  bus.broadcast(new SocketRequest());
      }
    }
  }
  public void connect(String host, int port) throws IOException {
    if(timeout > 0) {
      timeoutThread = new Thread(Timeout.this);
      timeoutThread.start();
    }
  }  
  public void disconnect() throws IOException {
    if(timeoutThread != null) {
      Thread tmp = timeoutThread;
      timeoutThread = null;
      tmp.interrupt();
    }
  }
  FilterPlugin source;
  public void setFilterSource(FilterPlugin plugin) {
    source = plugin;
  }
  public FilterPlugin getFilterSource() {
    return source;
  }
  public int read(byte[] b) throws IOException {
    int n = source.read(b);
    if(n > 0 && timeoutThread != null) timeoutThread.interrupt();
    return n;
  }
  public void write(byte[] b) throws IOException {
      source.write(b);
      if(timeoutThread != null) timeoutThread.interrupt();
  }
}",class,
"  public Timeout(final PluginBus bus, final String id) {
    super(bus, id);
    // register socket listener
    bus.registerPluginListener(this);
     bus.registerPluginListener(new ConfigurationListener() {
       public void setConfiguration(PluginConfig config) {
	 String tos = config.getProperty(""Timeout"", id, ""seconds"");
	 if(tos != null) {
	   try {
	     timeout = Integer.parseInt(tos);
           } catch(Exception e) {
	     Timeout.this.error(""timeout (""+timeout+"") ""
	                       +""is not an integer, timeout disabled"");
	   }
	   timeoutCommand = 
	     config.getProperty(""Timeout"", id, ""command"");
	   timeoutWarning = 
	     config.getProperty(""Timeout"", id, ""warning"");
	 }
       }
     });
     pluginBus = bus; 
  }",method,
"     bus.registerPluginListener(new ConfigurationListener() {
       public void setConfiguration(PluginConfig config) {
	 String tos = config.getProperty(""Timeout"", id, ""seconds"");
	 if(tos != null) {
	   try {
	     timeout = Integer.parseInt(tos);
           } catch(Exception e) {
	     Timeout.this.error(""timeout (""+timeout+"") ""
	                       +""is not an integer, timeout disabled"");
	   }
	   timeoutCommand = 
	     config.getProperty(""Timeout"", id, ""command"");
	   timeoutWarning = 
	     config.getProperty(""Timeout"", id, ""warning"");
	 }
       }
     }",method,
"       public void setConfiguration(PluginConfig config) {
	 String tos = config.getProperty(""Timeout"", id, ""seconds"");
	 if(tos != null) {
	   try {
	     timeout = Integer.parseInt(tos);
           } catch(Exception e) {
	     Timeout.this.error(""timeout (""+timeout+"") ""
	                       +""is not an integer, timeout disabled"");
	   }
	   timeoutCommand = 
	     config.getProperty(""Timeout"", id, ""command"");
	   timeoutWarning = 
	     config.getProperty(""Timeout"", id, ""warning"");
	 }
       }",method,

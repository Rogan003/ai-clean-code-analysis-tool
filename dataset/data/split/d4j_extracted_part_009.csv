code_snippet,type,score
"    public void finishPullLoad() {
        if (swipeLayout != null)
            swipeLayout.finishPullLoad();
    }",method,good
"    private WXSwipeLayout createBounceView(Context context) {
        swipeLayout = new WXSwipeLayout(context);
        swipeLayout.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));
        mInnerView = setInnerView(context);
        if (mInnerView == null)
            return null;
        swipeLayout.addTargetView(mInnerView);
        addView(swipeLayout, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
        return swipeLayout;
    }",method,good
"    public T getInnerView() {
        return mInnerView;
    }",method,good
"    public void setHeaderView(WXComponent refresh) {
        setRefreshEnable(true);
        if (swipeLayout != null) {
            WXRefreshView refreshView = swipeLayout.getHeaderView();
            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = refresh.getDomObject();
                if (immutableDomObject != null) {
                    int refreshHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setRefreshHeight(refreshHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setRefreshBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(refresh.getHostView());
                }
            }
        }
    }",method,changes_recommended
"        if (swipeLayout != null) {
            WXRefreshView refreshView = swipeLayout.getHeaderView();
            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = refresh.getDomObject();
                if (immutableDomObject != null) {
                    int refreshHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setRefreshHeight(refreshHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setRefreshBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(refresh.getHostView());
                }
            }
        }",method,changes_recommended
"            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = refresh.getDomObject();
                if (immutableDomObject != null) {
                    int refreshHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setRefreshHeight(refreshHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setRefreshBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(refresh.getHostView());
                }
            }",method,changes_recommended
"                if (immutableDomObject != null) {
                    int refreshHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setRefreshHeight(refreshHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setRefreshBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(refresh.getHostView());
                }",method,good
"                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setRefreshBgColor(colorInt);
                            }
                        }
                    }",method,good
"    public void setFooterView(WXComponent loading) {
        setLoadmoreEnable(true);
        if (swipeLayout != null) {
            WXRefreshView refreshView = swipeLayout.getFooterView();
            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = loading.getDomObject();
                if (immutableDomObject != null) {
                    int loadingHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setLoadingHeight(loadingHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setLoadingBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(loading.getHostView());
                }
            }
        }
    }",method,changes_recommended
"        if (swipeLayout != null) {
            WXRefreshView refreshView = swipeLayout.getFooterView();
            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = loading.getDomObject();
                if (immutableDomObject != null) {
                    int loadingHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setLoadingHeight(loadingHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setLoadingBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(loading.getHostView());
                }
            }
        }",method,changes_recommended
"            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = loading.getDomObject();
                if (immutableDomObject != null) {
                    int loadingHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setLoadingHeight(loadingHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setLoadingBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(loading.getHostView());
                }
            }",method,changes_recommended
"                if (immutableDomObject != null) {
                    int loadingHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setLoadingHeight(loadingHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setLoadingBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(loading.getHostView());
                }",method,good
"                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setLoadingBgColor(colorInt);
                            }
                        }
                    }",method,good
"    public void removeFooterView(WXComponent loading){
        setLoadmoreEnable(false);
        if(swipeLayout!=null){
            if(swipeLayout.getFooterView()!=null){
                swipeLayout.setLoadingHeight(0);
                swipeLayout.getFooterView().removeView(loading.getHostView());
                swipeLayout.finishPullLoad();
            }
        }
    }",method,good
"        if(swipeLayout!=null){
            if(swipeLayout.getFooterView()!=null){
                swipeLayout.setLoadingHeight(0);
                swipeLayout.getFooterView().removeView(loading.getHostView());
                swipeLayout.finishPullLoad();
            }
        }",method,good
"    public void removeHeaderView(WXComponent refresh){
        setRefreshEnable(false);
        if(swipeLayout!=null){
            if(swipeLayout.getHeaderView()!=null){
                swipeLayout.setRefreshHeight(0);
                swipeLayout.getHeaderView().removeView(refresh.getHostView());
                swipeLayout.finishPullRefresh();
            }
        }
    }",method,good
"        if(swipeLayout!=null){
            if(swipeLayout.getHeaderView()!=null){
                swipeLayout.setRefreshHeight(0);
                swipeLayout.getHeaderView().removeView(refresh.getHostView());
                swipeLayout.finishPullRefresh();
            }
        }",method,good
"    public void setRefreshEnable(boolean enable) {
        if (swipeLayout != null)
            swipeLayout.setPullRefreshEnable(enable);
    }",method,good
"    public void setLoadmoreEnable(boolean enable) {
        if (swipeLayout != null)
            swipeLayout.setPullLoadEnable(enable);
    }",method,good
"  @Override
  public void removeView(View view) {
    if (view instanceof WXLoadingLayout) {
      finishPullLoad();
      setLoadmoreEnable(false);
      if (swipeLayout != null) {
        swipeLayout.removeView(swipeLayout.getFooterView());
      }
    } else if (view instanceof WXRefreshLayout) {
      finishPullRefresh();
      setRefreshEnable(false);
      if (swipeLayout != null) {
        swipeLayout.removeView(swipeLayout.getHeaderView());
      }
    } else {
      super.removeView(view);
    }
  }",method,good
"    if (view instanceof WXLoadingLayout) {
      finishPullLoad();
      setLoadmoreEnable(false);
      if (swipeLayout != null) {
        swipeLayout.removeView(swipeLayout.getFooterView());
      }
    }",method,good
"      if (swipeLayout != null) {
        swipeLayout.removeView(swipeLayout.getFooterView());
      }",method,good
"      if (swipeLayout != null) {
        swipeLayout.removeView(swipeLayout.getHeaderView());
      }",method,good
"    public WXSwipeLayout getSwipeLayout() {
        return swipeLayout;
    }",method,good
"public final class ExternalPtr<T> extends AbstractSEXP {
  private T instance;
  private ClassBinding binding;
  private SEXP tag;
  private SEXP _protected;
  public ExternalPtr(T instance, AttributeMap attributes) {
    super(attributes);
    unsafeSetAddress(instance);
  }
  public ExternalPtr(T instance, SEXP tag, SEXP prot) {
    this(instance);
    this.tag = tag;
    this._protected = prot;
  }
  public ExternalPtr(T instance) {
    this(instance, AttributeMap.EMPTY);
  }
  @Override
  public String getTypeName() {
    return ""externalptr"";
  }
  private MemberBinding getMemberBinding(Symbol name) {
    if(binding == null) {
      throw new EvalException(""ExternalPtr is NULL for name ""+name.getPrintName());
    }
    return binding.getMemberBinding(name);
  }
  public SEXP getMember(Symbol name) {
    return getMemberBinding(name).getValue(instance);
  }
  public void setMember(Symbol name, SEXP value) {
    getMemberBinding(name).setValue(instance, value);
  }
  public T getInstance() {
    return instance;
  }
  public SEXP getTag() {
    return tag;
  }
  public SEXP getProtected() {
    return _protected;
  }
  @Override
  public void accept(SexpVisitor visitor) {
    visitor.visit(this);
  }
  @Override
  protected SEXP cloneWithNewAttributes(AttributeMap attributes) {
    this.unsafeSetAttributes(attributes);
    return this;
  }
  public void unsafeSetAddress(T address) {
    this.instance = address;
    if(instance == null) {
      this.binding = null;
    } else {
      if(instance instanceof Class) {
        this.binding = ClassBindings.getClassDefinitionBinding((Class) instance);
      } else {
        this.binding = ClassBindings.getClassBinding(instance.getClass());
      }
    }
  }
  public void unsafeSetTag(SEXP tag) {
    this.tag = tag;
  }
  public void unsafeSetProtected(SEXP _protected) {
    this._protected = _protected;
  }
}",class,good
"  public ExternalPtr(T instance, AttributeMap attributes) {
    super(attributes);
    unsafeSetAddress(instance);
  }",method,good
"  public ExternalPtr(T instance, SEXP tag, SEXP prot) {
    this(instance);
    this.tag = tag;
    this._protected = prot;
  }",method,good
"  public ExternalPtr(T instance) {
    this(instance, AttributeMap.EMPTY);
  }",method,good
"  @Override
  public String getTypeName() {
    return ""externalptr"";
  }",method,good
"  private MemberBinding getMemberBinding(Symbol name) {
    if(binding == null) {
      throw new EvalException(""ExternalPtr is NULL for name ""+name.getPrintName());
    }
    return binding.getMemberBinding(name);
  }",method,good
"    if(binding == null) {
      throw new EvalException(""ExternalPtr is NULL for name ""+name.getPrintName());
    }",method,good
"  public SEXP getMember(Symbol name) {
    return getMemberBinding(name).getValue(instance);
  }",method,good
"  public void setMember(Symbol name, SEXP value) {
    getMemberBinding(name).setValue(instance, value);
  }",method,good
"  public T getInstance() {
    return instance;
  }",method,good
"  public SEXP getTag() {
    return tag;
  }",method,good
"  public SEXP getProtected() {
    return _protected;
  }",method,good
"  @Override
  public void accept(SexpVisitor visitor) {
    visitor.visit(this);
  }",method,good
"  @Override
  protected SEXP cloneWithNewAttributes(AttributeMap attributes) {
    this.unsafeSetAttributes(attributes);
    return this;
  }",method,good
"  public void unsafeSetAddress(T address) {
    this.instance = address;
    if(instance == null) {
      this.binding = null;
    } else {
      if(instance instanceof Class) {
        this.binding = ClassBindings.getClassDefinitionBinding((Class) instance);
      } else {
        this.binding = ClassBindings.getClassBinding(instance.getClass());
      }
    }
  }",method,good
"    if(instance == null) {
      this.binding = null;
    }",method,good
"      if(instance instanceof Class) {
        this.binding = ClassBindings.getClassDefinitionBinding((Class) instance);
      }",method,good
"  public void unsafeSetTag(SEXP tag) {
    this.tag = tag;
  }",method,good
"  public void unsafeSetProtected(SEXP _protected) {
    this._protected = _protected;
  }",method,good
"public class BasicBranchUnit
implements   BranchUnit
{
    private boolean                wasCalled;
    private InstructionOffsetValue traceBranchTargets;
    public void resetCalled()
    {
        wasCalled = false;
    }
    protected void setCalled()
    {
        wasCalled = true;
    }
    public boolean wasCalled()
    {
        return wasCalled;
    }
    public void setTraceBranchTargets(InstructionOffsetValue branchTargets)
    {
        this.traceBranchTargets = branchTargets;
    }
    public InstructionOffsetValue getTraceBranchTargets()
    {
        return traceBranchTargets;
    }
    // Implementations for BranchUnit.
    public void branch(Clazz         clazz,
                       CodeAttribute codeAttribute,
                       int           offset,
                       int           branchTarget)
    {
        // Override the branch targets.
        traceBranchTargets = new InstructionOffsetValue(branchTarget);
        wasCalled = true;
    }
    public void branchConditionally(Clazz         clazz,
                                    CodeAttribute codeAttribute,
                                    int           offset,
                                    int           branchTarget,
                                    int           conditional)
    {
        // Accumulate the branch targets.
        traceBranchTargets =
            traceBranchTargets.generalize(new InstructionOffsetValue(branchTarget)).instructionOffsetValue();
        wasCalled = true;
    }
    public void returnFromMethod()
    {
        // Stop processing this block.
        traceBranchTargets = InstructionOffsetValue.EMPTY_VALUE;
        wasCalled = true;
    }
    public void throwException()
    {
        // Stop processing this block.
        traceBranchTargets = InstructionOffsetValue.EMPTY_VALUE;
        wasCalled = true;
    }
}",class,changes_required
"    public void resetCalled()
    {
        wasCalled = false;
    }",method,good
"    protected void setCalled()
    {
        wasCalled = true;
    }",method,good
"    public boolean wasCalled()
    {
        return wasCalled;
    }",method,good
"    public void setTraceBranchTargets(InstructionOffsetValue branchTargets)
    {
        this.traceBranchTargets = branchTargets;
    }",method,good
"    public InstructionOffsetValue getTraceBranchTargets()
    {
        return traceBranchTargets;
    }",method,good
"    public void branch(Clazz         clazz,
                       CodeAttribute codeAttribute,
                       int           offset,
                       int           branchTarget)
    {
        // Override the branch targets.
        traceBranchTargets = new InstructionOffsetValue(branchTarget);
        wasCalled = true;
    }",method,good
"    public void branchConditionally(Clazz         clazz,
                                    CodeAttribute codeAttribute,
                                    int           offset,
                                    int           branchTarget,
                                    int           conditional)
    {
        // Accumulate the branch targets.
        traceBranchTargets =
            traceBranchTargets.generalize(new InstructionOffsetValue(branchTarget)).instructionOffsetValue();
        wasCalled = true;
    }",method,changes_recommended
"    public void returnFromMethod()
    {
        // Stop processing this block.
        traceBranchTargets = InstructionOffsetValue.EMPTY_VALUE;
        wasCalled = true;
    }",method,good
"    public void throwException()
    {
        // Stop processing this block.
        traceBranchTargets = InstructionOffsetValue.EMPTY_VALUE;
        wasCalled = true;
    }",method,good
"public class SSLTest extends TestCase {
    //This test relies on network resources.
    @Suppress
    public void testCertificate() throws Exception {
        // test www.fortify.net/sslcheck.html
        Socket ssl = SSLCertificateSocketFactory.getDefault().createSocket(""www.fortify.net"",443);
        assertNotNull(ssl);
        OutputStream out = ssl.getOutputStream();
        assertNotNull(out);
        InputStream in = ssl.getInputStream();
        assertNotNull(in);
        String get = ""GET /sslcheck.html HTTP/1.1\r\nHost: 68.178.217.222\r\n\r\n"";
        // System.out.println(""going for write..."");
        out.write(get.getBytes());
        byte[] b = new byte[1024];
        // System.out.println(""going for read..."");
        int ret = in.read(b);
        // System.out.println(new String(b));
    }
    public void testStringsToLengthPrefixedBytes() {
        byte[] expected = {
                6, 's', 'p', 'd', 'y', '/', '2',
                8, 'h', 't', 't', 'p', '/', '1', '.', '1',
        };
        assertTrue(Arrays.equals(expected, SSLCertificateSocketFactory.toLengthPrefixedList(
                new byte[] { 's', 'p', 'd', 'y', '/', '2' },
                new byte[] { 'h', 't', 't', 'p', '/', '1', '.', '1' })));
    }
    public void testStringsToLengthPrefixedBytesEmptyArray() {
        try {
            SSLCertificateSocketFactory.toLengthPrefixedList();
            fail();
        } catch (IllegalArgumentException expected) {
        }
    }
    public void testStringsToLengthPrefixedBytesEmptyByteArray() {
        try {
            SSLCertificateSocketFactory.toLengthPrefixedList(new byte[0]);
            fail();
        } catch (IllegalArgumentException expected) {
        }
    }
    public void testStringsToLengthPrefixedBytesOversizedInput() {
        try {
            SSLCertificateSocketFactory.toLengthPrefixedList(new byte[256]);
            fail();
        } catch (IllegalArgumentException expected) {
        }
    }
}",class,changes_recommended
"    @Suppress
    public void testCertificate() throws Exception {
        // test www.fortify.net/sslcheck.html
        Socket ssl = SSLCertificateSocketFactory.getDefault().createSocket(""www.fortify.net"",443);
        assertNotNull(ssl);
        OutputStream out = ssl.getOutputStream();
        assertNotNull(out);
        InputStream in = ssl.getInputStream();
        assertNotNull(in);
        String get = ""GET /sslcheck.html HTTP/1.1\r\nHost: 68.178.217.222\r\n\r\n"";
        // System.out.println(""going for write..."");
        out.write(get.getBytes());
        byte[] b = new byte[1024];
        // System.out.println(""going for read..."");
        int ret = in.read(b);
        // System.out.println(new String(b));
    }",method,good
"    public void testStringsToLengthPrefixedBytes() {
        byte[] expected = {
                6, 's', 'p', 'd', 'y', '/', '2',
                8, 'h', 't', 't', 'p', '/', '1', '.', '1',
        };
        assertTrue(Arrays.equals(expected, SSLCertificateSocketFactory.toLengthPrefixedList(
                new byte[] { 's', 'p', 'd', 'y', '/', '2' },
                new byte[] { 'h', 't', 't', 'p', '/', '1', '.', '1' })));
    }",method,good
"    public void testStringsToLengthPrefixedBytesEmptyArray() {
        try {
            SSLCertificateSocketFactory.toLengthPrefixedList();
            fail();
        } catch (IllegalArgumentException expected) {
        }
    }",method,good
"    public void testStringsToLengthPrefixedBytesEmptyByteArray() {
        try {
            SSLCertificateSocketFactory.toLengthPrefixedList(new byte[0]);
            fail();
        } catch (IllegalArgumentException expected) {
        }
    }",method,good
"    public void testStringsToLengthPrefixedBytesOversizedInput() {
        try {
            SSLCertificateSocketFactory.toLengthPrefixedList(new byte[256]);
            fail();
        } catch (IllegalArgumentException expected) {
        }
    }",method,good
"public class GitPreservingProcess {
  private static final Logger LOG = Logger.getInstance(GitPreservingProcess.class);
  @NotNull private final Project myProject;
  @NotNull private final Git myGit;
  @NotNull private final Collection<VirtualFile> myRootsToSave;
  @NotNull private final String myOperationTitle;
  @NotNull private final String myDestinationName;
  @NotNull private final ProgressIndicator myProgressIndicator;
  @NotNull private final Runnable myOperation;
  @NotNull private final String myStashMessage;
  @NotNull private final GitChangesSaver mySaver;
  @NotNull private final AtomicBoolean myLoaded = new AtomicBoolean();
  public GitPreservingProcess(@NotNull Project project,
                              @NotNull Git git,
                              @NotNull Collection<VirtualFile> rootsToSave,
                              @NotNull String operationTitle,
                              @NotNull String destinationName,
                              @NotNull GitVcsSettings.UpdateChangesPolicy saveMethod,
                              @NotNull ProgressIndicator indicator,
                              @NotNull Runnable operation) {
    myProject = project;
    myGit = git;
    myRootsToSave = rootsToSave;
    myOperationTitle = operationTitle;
    myDestinationName = destinationName;
    myProgressIndicator = indicator;
    myOperation = operation;
    myStashMessage = VcsBundle.message(""stash.changes.message"", StringUtil.capitalize(myOperationTitle)) +
                                       "" at "" +DateFormatUtil.formatDateTime(Clock.getTime());
    mySaver = configureSaver(saveMethod);
  }
  public void execute() {
    execute(null);
  }
  public void execute(@Nullable final Computable<Boolean> autoLoadDecision) {
    Runnable operation = () -> {
      LOG.debug(""starting"");
      boolean savedSuccessfully = save();
      LOG.debug(""save result: "" + savedSuccessfully);
      if (savedSuccessfully) {
        try {
          LOG.debug(""running operation"");
          myOperation.run();
          LOG.debug(""operation completed."");
        }
        finally {
          if (autoLoadDecision == null || autoLoadDecision.compute()) {
            LOG.debug(""loading"");
            load();
          }
          else {
            mySaver.notifyLocalChangesAreNotRestored();
          }
        }
      }
      LOG.debug(""finished."");
    };
    new GitFreezingProcess(myProject, myOperationTitle, operation).execute();
  }
  @NotNull
  private GitChangesSaver configureSaver(@NotNull GitVcsSettings.UpdateChangesPolicy saveMethod) {
    GitChangesSaver saver = GitChangesSaver.getSaver(myProject, myGit, myProgressIndicator, myStashMessage, saveMethod);
    MergeDialogCustomizer mergeDialogCustomizer = new MergeDialogCustomizer() {
      @Override
      public String getMultipleFileMergeDescription(@NotNull Collection<VirtualFile> files) {
        return String.format(
          ""<html>Uncommitted changes that were saved before %s have conflicts with files from <code>%s</code></html>"",
          myOperationTitle, myDestinationName);
      }
      @Override
      public String getLeftPanelTitle(@NotNull VirtualFile file) {
        return ""Uncommitted changes from stash"";
      }
      @Override
      public String getRightPanelTitle(@NotNull VirtualFile file, VcsRevisionNumber revisionNumber) {
        return String.format(""<html>Changes from <b><code>%s</code></b></html>"", myDestinationName);
      }
    };
    GitConflictResolver.Params params = new GitConflictResolver.Params().
      setReverse(true).
      setMergeDialogCustomizer(mergeDialogCustomizer).
      setErrorNotificationTitle(""Local changes were not restored"");
    saver.setConflictResolverParams(params);
    return saver;
  }
  private boolean save() {
    try {
      mySaver.saveLocalChanges(myRootsToSave);
      return true;
    } catch (VcsException e) {
      LOG.info(""Couldn't save local changes"", e);
      VcsNotifier.getInstance(myProject).notifyError(
        ""Couldn't save uncommitted changes."",
        String.format(""Tried to save uncommitted changes in stash before %s, but failed with an error.<br/>%s"",
                      myOperationTitle, join(e.getMessages())));
      return false;
    }
  }
  public void load() {
    if (myLoaded.compareAndSet(false, true)) {
      mySaver.load();
    }
    else {
      LOG.warn(""The changes were already loaded"", new Throwable());
    }
  }
}",class,changes_required
"  @NotNull private final Project myProject;
  @NotNull private final Git myGit;
  @NotNull private final Collection<VirtualFile> myRootsToSave;
  @NotNull private final String myOperationTitle;
  @NotNull private final String myDestinationName;
  @NotNull private final ProgressIndicator myProgressIndicator;
  @NotNull private final Runnable myOperation;
  @NotNull private final String myStashMessage;
  @NotNull private final GitChangesSaver mySaver;
  @NotNull private final AtomicBoolean myLoaded = new AtomicBoolean();
  public GitPreservingProcess(@NotNull Project project,
                              @NotNull Git git,
                              @NotNull Collection<VirtualFile> rootsToSave,
                              @NotNull String operationTitle,
                              @NotNull String destinationName,
                              @NotNull GitVcsSettings.UpdateChangesPolicy saveMethod,
                              @NotNull ProgressIndicator indicator,
                              @NotNull Runnable operation) {
    myProject = project;
    myGit = git;
    myRootsToSave = rootsToSave;
    myOperationTitle = operationTitle;
    myDestinationName = destinationName;
    myProgressIndicator = indicator;
    myOperation = operation;
    myStashMessage = VcsBundle.message(""stash.changes.message"", StringUtil.capitalize(myOperationTitle)) +
                                       "" at "" +DateFormatUtil.formatDateTime(Clock.getTime());
    mySaver = configureSaver(saveMethod);
  }",method,changes_recommended
"  public void execute() {
    execute(null);
  }",method,good
"  public void execute(@Nullable final Computable<Boolean> autoLoadDecision) {
    Runnable operation = () -> {
      LOG.debug(""starting"");
      boolean savedSuccessfully = save();
      LOG.debug(""save result: "" + savedSuccessfully);
      if (savedSuccessfully) {
        try {
          LOG.debug(""running operation"");
          myOperation.run();
          LOG.debug(""operation completed."");
        }
        finally {
          if (autoLoadDecision == null || autoLoadDecision.compute()) {
            LOG.debug(""loading"");
            load();
          }
          else {
            mySaver.notifyLocalChangesAreNotRestored();
          }
        }
      }
      LOG.debug(""finished."");
    };
    new GitFreezingProcess(myProject, myOperationTitle, operation).execute();
  }",method,good
"      if (savedSuccessfully) {
        try {
          LOG.debug(""running operation"");
          myOperation.run();
          LOG.debug(""operation completed."");
        }
        finally {
          if (autoLoadDecision == null || autoLoadDecision.compute()) {
            LOG.debug(""loading"");
            load();
          }
          else {
            mySaver.notifyLocalChangesAreNotRestored();
          }
        }
      }",method,good
"  @NotNull
  private GitChangesSaver configureSaver(@NotNull GitVcsSettings.UpdateChangesPolicy saveMethod) {
    GitChangesSaver saver = GitChangesSaver.getSaver(myProject, myGit, myProgressIndicator, myStashMessage, saveMethod);
    MergeDialogCustomizer mergeDialogCustomizer = new MergeDialogCustomizer() {
      @Override
      public String getMultipleFileMergeDescription(@NotNull Collection<VirtualFile> files) {
        return String.format(
          ""<html>Uncommitted changes that were saved before %s have conflicts with files from <code>%s</code></html>"",
          myOperationTitle, myDestinationName);
      }
      @Override
      public String getLeftPanelTitle(@NotNull VirtualFile file) {
        return ""Uncommitted changes from stash"";
      }
      @Override
      public String getRightPanelTitle(@NotNull VirtualFile file, VcsRevisionNumber revisionNumber) {
        return String.format(""<html>Changes from <b><code>%s</code></b></html>"", myDestinationName);
      }
    };
    GitConflictResolver.Params params = new GitConflictResolver.Params().
      setReverse(true).
      setMergeDialogCustomizer(mergeDialogCustomizer).
      setErrorNotificationTitle(""Local changes were not restored"");
    saver.setConflictResolverParams(params);
    return saver;
  }",method,good
"      @Override
      public String getMultipleFileMergeDescription(@NotNull Collection<VirtualFile> files) {
        return String.format(
          ""<html>Uncommitted changes that were saved before %s have conflicts with files from <code>%s</code></html>"",
          myOperationTitle, myDestinationName);
      }",method,good
"      @Override
      public String getLeftPanelTitle(@NotNull VirtualFile file) {
        return ""Uncommitted changes from stash"";
      }",method,good
"      @Override
      public String getRightPanelTitle(@NotNull VirtualFile file, VcsRevisionNumber revisionNumber) {
        return String.format(""<html>Changes from <b><code>%s</code></b></html>"", myDestinationName);
      }",method,good
"  private boolean save() {
    try {
      mySaver.saveLocalChanges(myRootsToSave);
      return true;
    } catch (VcsException e) {
      LOG.info(""Couldn't save local changes"", e);
      VcsNotifier.getInstance(myProject).notifyError(
        ""Couldn't save uncommitted changes."",
        String.format(""Tried to save uncommitted changes in stash before %s, but failed with an error.<br/>%s"",
                      myOperationTitle, join(e.getMessages())));
      return false;
    }
  }",method,changes_recommended
"  public void load() {
    if (myLoaded.compareAndSet(false, true)) {
      mySaver.load();
    }
    else {
      LOG.warn(""The changes were already loaded"", new Throwable());
    }
  }",method,good
"public class JobScheduler {
  static final String QUEUE_TIME_KEY = ""queueTime"";
  @VisibleForTesting
  static class JobStartExecutorSupplier {
    private static ScheduledExecutorService sJobStarterExecutor;
    static ScheduledExecutorService get() {
      if (sJobStarterExecutor == null) {
        sJobStarterExecutor = Executors.newSingleThreadScheduledExecutor();
      }
      return sJobStarterExecutor;
    }
  }
  public interface JobRunnable {
    void run(EncodedImage encodedImage, @Consumer.Status int status);
  }
  private final Executor mExecutor;
  private final JobRunnable mJobRunnable;
  private final Runnable mDoJobRunnable;
  private final Runnable mSubmitJobRunnable;
  private final int mMinimumJobIntervalMs;
  @VisibleForTesting
  enum JobState { IDLE, QUEUED, RUNNING, RUNNING_AND_PENDING }
  // job data
  @GuardedBy(""this"")
  @VisibleForTesting EncodedImage mEncodedImage;
  @GuardedBy(""this"")
  @VisibleForTesting @Consumer.Status int mStatus;
  // job state
  @GuardedBy(""this"")
  @VisibleForTesting JobState mJobState;
  @GuardedBy(""this"")
  @VisibleForTesting long mJobSubmitTime;
  @GuardedBy(""this"")
  @VisibleForTesting long mJobStartTime;
  public JobScheduler(Executor executor, JobRunnable jobRunnable, int minimumJobIntervalMs) {
    mExecutor = executor;
    mJobRunnable = jobRunnable;
    mMinimumJobIntervalMs = minimumJobIntervalMs;
    mDoJobRunnable = new Runnable() {
      @Override
      public void run() {
        doJob();
      }
    };
    mSubmitJobRunnable = new Runnable() {
      @Override
      public void run() {
        submitJob();
      }
    };
    mEncodedImage = null;
    mStatus = 0;
    mJobState = JobState.IDLE;
    mJobSubmitTime = 0;
    mJobStartTime = 0;
  }
  public void clearJob() {
    EncodedImage oldEncodedImage;
    synchronized (this) {
      oldEncodedImage = mEncodedImage;
      mEncodedImage = null;
      mStatus = 0;
    }
    EncodedImage.closeSafely(oldEncodedImage);
  }
  public boolean updateJob(EncodedImage encodedImage, @Consumer.Status int status) {
    if (!shouldProcess(encodedImage, status)) {
      return false;
    }
    EncodedImage oldEncodedImage;
    synchronized (this) {
      oldEncodedImage = mEncodedImage;
      mEncodedImage = EncodedImage.cloneOrNull(encodedImage);
      mStatus = status;
    }
    EncodedImage.closeSafely(oldEncodedImage);
    return true;
  }
  public boolean scheduleJob() {
    long now = SystemClock.uptimeMillis();
    long when = 0;
    boolean shouldEnqueue = false;
    synchronized (this) {
      if (!shouldProcess(mEncodedImage, mStatus)) {
        return false;
      }
      switch (mJobState) {
        case IDLE:
          when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
          shouldEnqueue = true;
          mJobSubmitTime = now;
          mJobState = JobState.QUEUED;
          break;
        case QUEUED:
          // do nothing, the job is already queued
          break;
        case RUNNING:
          mJobState = JobState.RUNNING_AND_PENDING;
          break;
        case RUNNING_AND_PENDING:
          // do nothing, the next job is already pending
          break;
      }
    }
    if (shouldEnqueue) {
      enqueueJob(when - now);
    }
    return true;
  }
  private void enqueueJob(long delay) {
    // If we make mExecutor be a {@link ScheduledexecutorService}, we could just have
    // `mExecutor.schedule(mDoJobRunnable, delay)` and avoid mSubmitJobRunnable and
    // JobStartExecutorSupplier altogether. That would require some refactoring though.
    if (delay > 0) {
      JobStartExecutorSupplier.get().schedule(mSubmitJobRunnable, delay, TimeUnit.MILLISECONDS);
    } else {
      mSubmitJobRunnable.run();
    }
  }
  private void submitJob() {
    mExecutor.execute(mDoJobRunnable);
  }
  private void doJob() {
    long now = SystemClock.uptimeMillis();
    EncodedImage input;
    int status;
    synchronized (this) {
      input = mEncodedImage;
      status = mStatus;
      mEncodedImage = null;
      mStatus = 0;
      mJobState = JobState.RUNNING;
      mJobStartTime = now;
    }
    try {
      // we need to do a check in case the job got cleared in the meantime
      if (shouldProcess(input, status)) {
        mJobRunnable.run(input, status);
      }
    } finally {
      EncodedImage.closeSafely(input);
      onJobFinished();
    }
  }
  private void onJobFinished() {
    long now = SystemClock.uptimeMillis();
    long when = 0;
    boolean shouldEnqueue = false;
    synchronized (this) {
      if (mJobState == JobState.RUNNING_AND_PENDING) {
        when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
        shouldEnqueue = true;
        mJobSubmitTime = now;
        mJobState = JobState.QUEUED;
      } else {
        mJobState = JobState.IDLE;
      }
    }
    if (shouldEnqueue) {
      enqueueJob(when - now);
    }
  }
  private static boolean shouldProcess(EncodedImage encodedImage, @Consumer.Status int status) {
    // the last result should always be processed, whereas
    // an intermediate result should be processed only if valid
    return BaseConsumer.isLast(status)
        || BaseConsumer.statusHasFlag(status, Consumer.IS_PLACEHOLDER)
        || EncodedImage.isValid(encodedImage);
  }
  public synchronized long getQueuedTime() {
    return mJobStartTime - mJobSubmitTime;
  }
}",class,changes_recommended
"  static class JobStartExecutorSupplier {
    private static ScheduledExecutorService sJobStarterExecutor;
    static ScheduledExecutorService get() {
      if (sJobStarterExecutor == null) {
        sJobStarterExecutor = Executors.newSingleThreadScheduledExecutor();
      }
      return sJobStarterExecutor;
    }
  }",class,good
"    static ScheduledExecutorService get() {
      if (sJobStarterExecutor == null) {
        sJobStarterExecutor = Executors.newSingleThreadScheduledExecutor();
      }
      return sJobStarterExecutor;
    }",method,good
"      if (sJobStarterExecutor == null) {
        sJobStarterExecutor = Executors.newSingleThreadScheduledExecutor();
      }",method,good
"  @GuardedBy(""this"")
  @VisibleForTesting JobState mJobState;
  @GuardedBy(""this"")
  @VisibleForTesting long mJobSubmitTime;
  @GuardedBy(""this"")
  @VisibleForTesting long mJobStartTime;
  public JobScheduler(Executor executor, JobRunnable jobRunnable, int minimumJobIntervalMs) {
    mExecutor = executor;
    mJobRunnable = jobRunnable;
    mMinimumJobIntervalMs = minimumJobIntervalMs;
    mDoJobRunnable = new Runnable() {
      @Override
      public void run() {
        doJob();
      }
    };
    mSubmitJobRunnable = new Runnable() {
      @Override
      public void run() {
        submitJob();
      }
    };
    mEncodedImage = null;
    mStatus = 0;
    mJobState = JobState.IDLE;
    mJobSubmitTime = 0;
    mJobStartTime = 0;
  }",method,good
"      @Override
      public void run() {
        doJob();
      }",method,good
"      @Override
      public void run() {
        submitJob();
      }",method,good
"  public void clearJob() {
    EncodedImage oldEncodedImage;
    synchronized (this) {
      oldEncodedImage = mEncodedImage;
      mEncodedImage = null;
      mStatus = 0;
    }
    EncodedImage.closeSafely(oldEncodedImage);
  }",method,good
"    synchronized (this) {
      oldEncodedImage = mEncodedImage;
      mEncodedImage = null;
      mStatus = 0;
    }",method,good
"  public boolean updateJob(EncodedImage encodedImage, @Consumer.Status int status) {
    if (!shouldProcess(encodedImage, status)) {
      return false;
    }
    EncodedImage oldEncodedImage;
    synchronized (this) {
      oldEncodedImage = mEncodedImage;
      mEncodedImage = EncodedImage.cloneOrNull(encodedImage);
      mStatus = status;
    }
    EncodedImage.closeSafely(oldEncodedImage);
    return true;
  }",method,good
"    synchronized (this) {
      oldEncodedImage = mEncodedImage;
      mEncodedImage = EncodedImage.cloneOrNull(encodedImage);
      mStatus = status;
    }",method,good
"  public boolean scheduleJob() {
    long now = SystemClock.uptimeMillis();
    long when = 0;
    boolean shouldEnqueue = false;
    synchronized (this) {
      if (!shouldProcess(mEncodedImage, mStatus)) {
        return false;
      }
      switch (mJobState) {
        case IDLE:
          when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
          shouldEnqueue = true;
          mJobSubmitTime = now;
          mJobState = JobState.QUEUED;
          break;
        case QUEUED:
          // do nothing, the job is already queued
          break;
        case RUNNING:
          mJobState = JobState.RUNNING_AND_PENDING;
          break;
        case RUNNING_AND_PENDING:
          // do nothing, the next job is already pending
          break;
      }
    }
    if (shouldEnqueue) {
      enqueueJob(when - now);
    }
    return true;
  }",method,good
"    synchronized (this) {
      if (!shouldProcess(mEncodedImage, mStatus)) {
        return false;
      }
      switch (mJobState) {
        case IDLE:
          when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
          shouldEnqueue = true;
          mJobSubmitTime = now;
          mJobState = JobState.QUEUED;
          break;
        case QUEUED:
          // do nothing, the job is already queued
          break;
        case RUNNING:
          mJobState = JobState.RUNNING_AND_PENDING;
          break;
        case RUNNING_AND_PENDING:
          // do nothing, the next job is already pending
          break;
      }
    }",method,good
"      switch (mJobState) {
        case IDLE:
          when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
          shouldEnqueue = true;
          mJobSubmitTime = now;
          mJobState = JobState.QUEUED;
          break;
        case QUEUED:
          // do nothing, the job is already queued
          break;
        case RUNNING:
          mJobState = JobState.RUNNING_AND_PENDING;
          break;
        case RUNNING_AND_PENDING:
          // do nothing, the next job is already pending
          break;
      }",method,good
"    if (shouldEnqueue) {
      enqueueJob(when - now);
    }",method,good
"  private void enqueueJob(long delay) {
    // If we make mExecutor be a {@link ScheduledexecutorService}, we could just have
    // `mExecutor.schedule(mDoJobRunnable, delay)` and avoid mSubmitJobRunnable and
    // JobStartExecutorSupplier altogether. That would require some refactoring though.
    if (delay > 0) {
      JobStartExecutorSupplier.get().schedule(mSubmitJobRunnable, delay, TimeUnit.MILLISECONDS);
    } else {
      mSubmitJobRunnable.run();
    }
  }",method,good
"    if (delay > 0) {
      JobStartExecutorSupplier.get().schedule(mSubmitJobRunnable, delay, TimeUnit.MILLISECONDS);
    }",method,good
"  private void submitJob() {
    mExecutor.execute(mDoJobRunnable);
  }",method,good
"  private void doJob() {
    long now = SystemClock.uptimeMillis();
    EncodedImage input;
    int status;
    synchronized (this) {
      input = mEncodedImage;
      status = mStatus;
      mEncodedImage = null;
      mStatus = 0;
      mJobState = JobState.RUNNING;
      mJobStartTime = now;
    }
    try {
      // we need to do a check in case the job got cleared in the meantime
      if (shouldProcess(input, status)) {
        mJobRunnable.run(input, status);
      }
    } finally {
      EncodedImage.closeSafely(input);
      onJobFinished();
    }
  }",method,good
"    synchronized (this) {
      input = mEncodedImage;
      status = mStatus;
      mEncodedImage = null;
      mStatus = 0;
      mJobState = JobState.RUNNING;
      mJobStartTime = now;
    }",method,good
"  private void onJobFinished() {
    long now = SystemClock.uptimeMillis();
    long when = 0;
    boolean shouldEnqueue = false;
    synchronized (this) {
      if (mJobState == JobState.RUNNING_AND_PENDING) {
        when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
        shouldEnqueue = true;
        mJobSubmitTime = now;
        mJobState = JobState.QUEUED;
      } else {
        mJobState = JobState.IDLE;
      }
    }
    if (shouldEnqueue) {
      enqueueJob(when - now);
    }
  }",method,good
"    synchronized (this) {
      if (mJobState == JobState.RUNNING_AND_PENDING) {
        when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
        shouldEnqueue = true;
        mJobSubmitTime = now;
        mJobState = JobState.QUEUED;
      } else {
        mJobState = JobState.IDLE;
      }
    }",method,good
"      if (mJobState == JobState.RUNNING_AND_PENDING) {
        when = Math.max(mJobStartTime + mMinimumJobIntervalMs, now);
        shouldEnqueue = true;
        mJobSubmitTime = now;
        mJobState = JobState.QUEUED;
      }",method,good
"    if (shouldEnqueue) {
      enqueueJob(when - now);
    }",method,good
"  private static boolean shouldProcess(EncodedImage encodedImage, @Consumer.Status int status) {
    // the last result should always be processed, whereas
    // an intermediate result should be processed only if valid
    return BaseConsumer.isLast(status)
        || BaseConsumer.statusHasFlag(status, Consumer.IS_PLACEHOLDER)
        || EncodedImage.isValid(encodedImage);
  }",method,good
"  public synchronized long getQueuedTime() {
    return mJobStartTime - mJobSubmitTime;
  }",method,good
"public final class RenameSchema
        extends Statement
{
    private final QualifiedName source;
    private final Identifier target;
    public RenameSchema(QualifiedName source, Identifier target)
    {
        this(Optional.empty(), source, target);
    }
    public RenameSchema(NodeLocation location, QualifiedName source, Identifier target)
    {
        this(Optional.of(location), source, target);
    }
    private RenameSchema(Optional<NodeLocation> location, QualifiedName source, Identifier target)
    {
        super(location);
        this.source = requireNonNull(source, ""source is null"");
        this.target = requireNonNull(target, ""target is null"");
    }
    public QualifiedName getSource()
    {
        return source;
    }
    public Identifier getTarget()
    {
        return target;
    }
    @Override
    public <R, C> R accept(AstVisitor<R, C> visitor, C context)
    {
        return visitor.visitRenameSchema(this, context);
    }
    @Override
    public List<Node> getChildren()
    {
        return ImmutableList.of();
    }
    @Override
    public int hashCode()
    {
        return Objects.hash(source, target);
    }
    @Override
    public boolean equals(Object obj)
    {
        if (this == obj) {
            return true;
        }
        if ((obj == null) || (getClass() != obj.getClass())) {
            return false;
        }
        RenameSchema o = (RenameSchema) obj;
        return Objects.equals(source, o.source) &&
                Objects.equals(target, o.target);
    }
    @Override
    public String toString()
    {
        return toStringHelper(this)
                .add(""source"", source)
                .add(""target"", target)
                .toString();
    }
}",class,changes_recommended
"    public RenameSchema(QualifiedName source, Identifier target)
    {
        this(Optional.empty(), source, target);
    }",method,good
"    public RenameSchema(NodeLocation location, QualifiedName source, Identifier target)
    {
        this(Optional.of(location), source, target);
    }",method,good
"    private RenameSchema(Optional<NodeLocation> location, QualifiedName source, Identifier target)
    {
        super(location);
        this.source = requireNonNull(source, ""source is null"");
        this.target = requireNonNull(target, ""target is null"");
    }",method,good
"    public QualifiedName getSource()
    {
        return source;
    }",method,good

code_snippet,type,score
"    private static Block longBlock(Integer... values)
    {
        BlockBuilder blockBuilder = BIGINT.createBlockBuilder(new BlockBuilderStatus(), values.length);
        for (Integer value : values) {
            if (value == null) {
                blockBuilder.appendNull();
            }
            else {
                blockBuilder.writeLong(value).closeEntry();
            }
        }
        return blockBuilder.build();
    }",method,
"        for (Integer value : values) {
            if (value == null) {
                blockBuilder.appendNull();
            }
            else {
                blockBuilder.writeLong(value).closeEntry();
            }
        }",method,
"            if (value == null) {
                blockBuilder.appendNull();
            }",method,
"    private static PrestoThriftBlock longColumn(boolean[] nulls, long[] longs)
    {
        return bigintData(new PrestoThriftBigint(nulls, longs));
    }",method,
"    private static List<Long> list(Long... values)
    {
        return unmodifiableList(Arrays.asList(values));
    }",method,
"public class OptionDescription implements Comparable{
  private final String myOption;
  private final String myHit;
  private final String myPath;
  private final String myConfigurableId;
  private final String myGroupName;
  public OptionDescription(String hit) {
    this(null, hit, null);
  }
  public OptionDescription(final String option, final String hit, final String path) {
    this(option, null, hit, path);
  }
  public OptionDescription(final String option, final String configurableId, final String hit, final String path) {
    this(option, configurableId, hit, path, null);
  }
  public OptionDescription(final String option, final String configurableId, final String hit, final String path, String groupName) {
    myOption = option;
    myHit = hit;
    myPath = path;
    myConfigurableId = configurableId;
    myGroupName = groupName;
  }
  public String getOption() {
    return myOption;
  }
  @Nullable
  public String getHit() {
    return myHit;
  }
  @Nullable
  public String getPath() {
    return myPath;
  }
  public String getConfigurableId() {
    return myConfigurableId;
  }
  public String getGroupName() {
    return myGroupName;
  }
  public String getValue() {
    return null;
  }
  public boolean hasExternalEditor() {
    return false;
  }
  public void invokeInternalEditor() {
  }
  public String toString() {
    return myHit;
  }
  public boolean equals(final Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    final OptionDescription that = (OptionDescription)o;
    if (myConfigurableId != null ? !myConfigurableId.equals(that.myConfigurableId) : that.myConfigurableId != null) return false;
    if (myHit != null ? !myHit.equals(that.myHit) : that.myHit != null) return false;
    if (myOption != null ? !myOption.equals(that.myOption) : that.myOption != null) return false;
    if (myPath != null ? !myPath.equals(that.myPath) : that.myPath != null) return false;
    return true;
  }
  public int hashCode() {
    int result;
    result = (myOption != null ? myOption.hashCode() : 0);
    result = 31 * result + (myHit != null ? myHit.hashCode() : 0);
    result = 31 * result + (myPath != null ? myPath.hashCode() : 0);
    result = 31 * result + (myConfigurableId != null ? myConfigurableId.hashCode() : 0);
    return result;
  }
  public int compareTo(final Object o) {
    final OptionDescription description = ((OptionDescription)o);
    if (Comparing.strEqual(myHit, description.getHit())){
      return myOption != null ? myOption.compareTo(description.getOption()) : 0;
    }
    if (myHit != null && description.getHit() != null){
      return myHit.compareTo(description.getHit());
    }
    return 0;
  }
}",class,
"  public OptionDescription(String hit) {
    this(null, hit, null);
  }",method,
"  public OptionDescription(final String option, final String hit, final String path) {
    this(option, null, hit, path);
  }",method,
"  public OptionDescription(final String option, final String configurableId, final String hit, final String path) {
    this(option, configurableId, hit, path, null);
  }",method,
"  public OptionDescription(final String option, final String configurableId, final String hit, final String path, String groupName) {
    myOption = option;
    myHit = hit;
    myPath = path;
    myConfigurableId = configurableId;
    myGroupName = groupName;
  }",method,
"  public String getOption() {
    return myOption;
  }",method,
"  @Nullable
  public String getHit() {
    return myHit;
  }",method,
"  @Nullable
  public String getPath() {
    return myPath;
  }",method,
"  public String getConfigurableId() {
    return myConfigurableId;
  }",method,
"  public String getGroupName() {
    return myGroupName;
  }",method,
"  public String getValue() {
    return null;
  }",method,
"  public boolean hasExternalEditor() {
    return false;
  }",method,
"  public void invokeInternalEditor() {
  }",method,
"  public String toString() {
    return myHit;
  }",method,
"  public boolean equals(final Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    final OptionDescription that = (OptionDescription)o;
    if (myConfigurableId != null ? !myConfigurableId.equals(that.myConfigurableId) : that.myConfigurableId != null) return false;
    if (myHit != null ? !myHit.equals(that.myHit) : that.myHit != null) return false;
    if (myOption != null ? !myOption.equals(that.myOption) : that.myOption != null) return false;
    if (myPath != null ? !myPath.equals(that.myPath) : that.myPath != null) return false;
    return true;
  }",method,
"  public int hashCode() {
    int result;
    result = (myOption != null ? myOption.hashCode() : 0);
    result = 31 * result + (myHit != null ? myHit.hashCode() : 0);
    result = 31 * result + (myPath != null ? myPath.hashCode() : 0);
    result = 31 * result + (myConfigurableId != null ? myConfigurableId.hashCode() : 0);
    return result;
  }",method,
"  public int compareTo(final Object o) {
    final OptionDescription description = ((OptionDescription)o);
    if (Comparing.strEqual(myHit, description.getHit())){
      return myOption != null ? myOption.compareTo(description.getOption()) : 0;
    }
    if (myHit != null && description.getHit() != null){
      return myHit.compareTo(description.getHit());
    }
    return 0;
  }",method,
"abstract class ByteBufChecksum implements Checksum {
    private static final Method ADLER32_UPDATE_METHOD;
    private static final Method CRC32_UPDATE_METHOD;
    static {
        // See if we can use fast-path when using ByteBuf that is not heap based as Adler32 and CRC32 added support
        // for update(ByteBuffer) in JDK8.
        ADLER32_UPDATE_METHOD = updateByteBuffer(new Adler32());
        CRC32_UPDATE_METHOD = updateByteBuffer(new CRC32());
    }
    private final ByteProcessor updateProcessor = new ByteProcessor() {
        @Override
        public boolean process(byte value) throws Exception {
            update(value);
            return true;
        }
    };
    private static Method updateByteBuffer(Checksum checksum) {
        if (PlatformDependent.javaVersion() >= 8) {
            try {
                Method method = checksum.getClass().getDeclaredMethod(""update"", ByteBuffer.class);
                method.invoke(method, ByteBuffer.allocate(1));
                return method;
            } catch (Throwable ignore) {
                return null;
            }
        }
        return null;
    }
    static ByteBufChecksum wrapChecksum(Checksum checksum) {
        ObjectUtil.checkNotNull(checksum, ""checksum"");
        if (checksum instanceof Adler32 && ADLER32_UPDATE_METHOD != null) {
            return new ReflectiveByteBufChecksum(checksum, ADLER32_UPDATE_METHOD);
        }
        if (checksum instanceof CRC32 && CRC32_UPDATE_METHOD != null) {
            return new ReflectiveByteBufChecksum(checksum, CRC32_UPDATE_METHOD);
        }
        return new SlowByteBufChecksum(checksum);
    }
    public void update(ByteBuf b, int off, int len) {
        if (b.hasArray()) {
            update(b.array(), b.arrayOffset() + off, len);
        } else {
            b.forEachByte(off, len, updateProcessor);
        }
    }
    private static final class ReflectiveByteBufChecksum extends SlowByteBufChecksum {
        private final Method method;
        ReflectiveByteBufChecksum(Checksum checksum, Method method) {
            super(checksum);
            this.method = method;
        }
        @Override
        public void update(ByteBuf b, int off, int len) {
            if (b.hasArray()) {
                update(b.array(), b.arrayOffset() + off, len);
            } else {
                try {
                    method.invoke(checksum, CompressionUtil.safeNioBuffer(b));
                } catch (Throwable cause) {
                    throw new Error();
                }
            }
        }
    }
    private static class SlowByteBufChecksum extends ByteBufChecksum {
        protected final Checksum checksum;
        SlowByteBufChecksum(Checksum checksum) {
            this.checksum = checksum;
        }
        @Override
        public void update(int b) {
            checksum.update(b);
        }
        @Override
        public void update(byte[] b, int off, int len) {
            checksum.update(b, off, len);
        }
        @Override
        public long getValue() {
            return checksum.getValue();
        }
        @Override
        public void reset() {
            checksum.reset();
        }
    }
}",class,
"    private static final class ReflectiveByteBufChecksum extends SlowByteBufChecksum {
        private final Method method;
        ReflectiveByteBufChecksum(Checksum checksum, Method method) {
            super(checksum);
            this.method = method;
        }
        @Override
        public void update(ByteBuf b, int off, int len) {
            if (b.hasArray()) {
                update(b.array(), b.arrayOffset() + off, len);
            } else {
                try {
                    method.invoke(checksum, CompressionUtil.safeNioBuffer(b));
                } catch (Throwable cause) {
                    throw new Error();
                }
            }
        }
    }",class,
"    private static class SlowByteBufChecksum extends ByteBufChecksum {
        protected final Checksum checksum;
        SlowByteBufChecksum(Checksum checksum) {
            this.checksum = checksum;
        }
        @Override
        public void update(int b) {
            checksum.update(b);
        }
        @Override
        public void update(byte[] b, int off, int len) {
            checksum.update(b, off, len);
        }
        @Override
        public long getValue() {
            return checksum.getValue();
        }
        @Override
        public void reset() {
            checksum.reset();
        }
    }",class,
"        @Override
        public boolean process(byte value) throws Exception {
            update(value);
            return true;
        }",method,
"    private static Method updateByteBuffer(Checksum checksum) {
        if (PlatformDependent.javaVersion() >= 8) {
            try {
                Method method = checksum.getClass().getDeclaredMethod(""update"", ByteBuffer.class);
                method.invoke(method, ByteBuffer.allocate(1));
                return method;
            } catch (Throwable ignore) {
                return null;
            }
        }
        return null;
    }",method,
"    static ByteBufChecksum wrapChecksum(Checksum checksum) {
        ObjectUtil.checkNotNull(checksum, ""checksum"");
        if (checksum instanceof Adler32 && ADLER32_UPDATE_METHOD != null) {
            return new ReflectiveByteBufChecksum(checksum, ADLER32_UPDATE_METHOD);
        }
        if (checksum instanceof CRC32 && CRC32_UPDATE_METHOD != null) {
            return new ReflectiveByteBufChecksum(checksum, CRC32_UPDATE_METHOD);
        }
        return new SlowByteBufChecksum(checksum);
    }",method,
"        if (checksum instanceof Adler32 && ADLER32_UPDATE_METHOD != null) {
            return new ReflectiveByteBufChecksum(checksum, ADLER32_UPDATE_METHOD);
        }",method,
"        if (checksum instanceof CRC32 && CRC32_UPDATE_METHOD != null) {
            return new ReflectiveByteBufChecksum(checksum, CRC32_UPDATE_METHOD);
        }",method,
"    public void update(ByteBuf b, int off, int len) {
        if (b.hasArray()) {
            update(b.array(), b.arrayOffset() + off, len);
        } else {
            b.forEachByte(off, len, updateProcessor);
        }
    }",method,
"        ReflectiveByteBufChecksum(Checksum checksum, Method method) {
            super(checksum);
            this.method = method;
        }",method,
"        @Override
        public void update(ByteBuf b, int off, int len) {
            if (b.hasArray()) {
                update(b.array(), b.arrayOffset() + off, len);
            } else {
                try {
                    method.invoke(checksum, CompressionUtil.safeNioBuffer(b));
                } catch (Throwable cause) {
                    throw new Error();
                }
            }
        }",method,
"        SlowByteBufChecksum(Checksum checksum) {
            this.checksum = checksum;
        }",method,
"        @Override
        public void update(int b) {
            checksum.update(b);
        }",method,
"        @Override
        public void update(byte[] b, int off, int len) {
            checksum.update(b, off, len);
        }",method,
"        @Override
        public long getValue() {
            return checksum.getValue();
        }",method,
"        @Override
        public void reset() {
            checksum.reset();
        }",method,
"    final class MountPointName {
        public static final String None = ""none"";
        public static final String Any = ""any"";
        public static final String TopLeft = ""top_left"";
        public static final String TopRight = ""top_right"";
        public static final String TopBack = ""top_back"";
        public static final String BottomLeft = ""bottom_left"";
        public static final String BottomRight = ""bottom_right"";
        public static final String BottomBack = ""bottom_back"";
        public static final String BottomFront = ""bottom_front"";
        private MountPointName() {
        }
    }",class,
"        private MountPointName() {
        }",method,
"public class LocalVariableTableParameterNameDiscoverer implements ParameterNameDiscoverer {
	private static final Log logger = LogFactory.getLog(LocalVariableTableParameterNameDiscoverer.class);
	// marker object for classes that do not have any debug info
	private static final Map<Member, String[]> NO_DEBUG_INFO_MAP = Collections.emptyMap();
	// the cache uses a nested index (value is a map) to keep the top level cache relatively small in size
	private final Map<Class<?>, Map<Member, String[]>> parameterNamesCache = new ConcurrentHashMap<>(32);
	@Override
	@Nullable
	public String[] getParameterNames(Method method) {
		Method originalMethod = BridgeMethodResolver.findBridgedMethod(method);
		Class<?> declaringClass = originalMethod.getDeclaringClass();
		Map<Member, String[]> map = this.parameterNamesCache.get(declaringClass);
		if (map == null) {
			map = inspectClass(declaringClass);
			this.parameterNamesCache.put(declaringClass, map);
		}
		if (map != NO_DEBUG_INFO_MAP) {
			return map.get(originalMethod);
		}
		return null;
	}
	@Override
	@Nullable
	public String[] getParameterNames(Constructor<?> ctor) {
		Class<?> declaringClass = ctor.getDeclaringClass();
		Map<Member, String[]> map = this.parameterNamesCache.get(declaringClass);
		if (map == null) {
			map = inspectClass(declaringClass);
			this.parameterNamesCache.put(declaringClass, map);
		}
		if (map != NO_DEBUG_INFO_MAP) {
			return map.get(ctor);
		}
		return null;
	}
	private Map<Member, String[]> inspectClass(Class<?> clazz) {
		InputStream is = clazz.getResourceAsStream(ClassUtils.getClassFileName(clazz));
		if (is == null) {
			// We couldn't load the class file, which is not fatal as it
			// simply means this method of discovering parameter names won't work.
			if (logger.isDebugEnabled()) {
				logger.debug(""Cannot find '.class' file for class ["" + clazz +
						""] - unable to determine constructor/method parameter names"");
			}
			return NO_DEBUG_INFO_MAP;
		}
		try {
			ClassReader classReader = new ClassReader(is);
			Map<Member, String[]> map = new ConcurrentHashMap<>(32);
			classReader.accept(new ParameterNameDiscoveringVisitor(clazz, map), 0);
			return map;
		}
		catch (IOException ex) {
			if (logger.isDebugEnabled()) {
				logger.debug(""Exception thrown while reading '.class' file for class ["" + clazz +
						""] - unable to determine constructor/method parameter names"", ex);
			}
		}
		catch (IllegalArgumentException ex) {
			if (logger.isDebugEnabled()) {
				logger.debug(""ASM ClassReader failed to parse class file ["" + clazz +
						""], probably due to a new Java class file version that isn't supported yet "" +
						""- unable to determine constructor/method parameter names"", ex);
			}
		}
		finally {
			try {
				is.close();
			}
			catch (IOException ex) {
				// ignore
			}
		}
		return NO_DEBUG_INFO_MAP;
	}
	private static class ParameterNameDiscoveringVisitor extends ClassVisitor {
		private static final String STATIC_CLASS_INIT = ""<clinit>"";
		private final Class<?> clazz;
		private final Map<Member, String[]> memberMap;
		public ParameterNameDiscoveringVisitor(Class<?> clazz, Map<Member, String[]> memberMap) {
			super(SpringAsmInfo.ASM_VERSION);
			this.clazz = clazz;
			this.memberMap = memberMap;
		}
		@Override
		@Nullable
		public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
			// exclude synthetic + bridged && static class initialization
			if (!isSyntheticOrBridged(access) && !STATIC_CLASS_INIT.equals(name)) {
				return new LocalVariableTableVisitor(clazz, memberMap, name, desc, isStatic(access));
			}
			return null;
		}
		private static boolean isSyntheticOrBridged(int access) {
			return (((access & Opcodes.ACC_SYNTHETIC) | (access & Opcodes.ACC_BRIDGE)) > 0);
		}
		private static boolean isStatic(int access) {
			return ((access & Opcodes.ACC_STATIC) > 0);
		}
	}
	private static class LocalVariableTableVisitor extends MethodVisitor {
		private static final String CONSTRUCTOR = ""<init>"";
		private final Class<?> clazz;
		private final Map<Member, String[]> memberMap;
		private final String name;
		private final Type[] args;
		private final String[] parameterNames;
		private final boolean isStatic;
		private boolean hasLvtInfo = false;
		private final int[] lvtSlotIndex;
		public LocalVariableTableVisitor(Class<?> clazz, Map<Member, String[]> map, String name, String desc, boolean isStatic) {
			super(SpringAsmInfo.ASM_VERSION);
			this.clazz = clazz;
			this.memberMap = map;
			this.name = name;
			this.args = Type.getArgumentTypes(desc);
			this.parameterNames = new String[this.args.length];
			this.isStatic = isStatic;
			this.lvtSlotIndex = computeLvtSlotIndices(isStatic, this.args);
		}
		@Override
		public void visitLocalVariable(String name, String description, String signature, Label start, Label end, int index) {
			this.hasLvtInfo = true;
			for (int i = 0; i < this.lvtSlotIndex.length; i++) {
				if (this.lvtSlotIndex[i] == index) {
					this.parameterNames[i] = name;
				}
			}
		}
		@Override
		public void visitEnd() {
			if (this.hasLvtInfo || (this.isStatic && this.parameterNames.length == 0)) {
				// visitLocalVariable will never be called for static no args methods
				// which doesn't use any local variables.
				// This means that hasLvtInfo could be false for that kind of methods
				// even if the class has local variable info.
				this.memberMap.put(resolveMember(), this.parameterNames);
			}
		}
		private Member resolveMember() {
			ClassLoader loader = this.clazz.getClassLoader();
			Class<?>[] argTypes = new Class<?>[this.args.length];
			for (int i = 0; i < this.args.length; i++) {
				argTypes[i] = ClassUtils.resolveClassName(this.args[i].getClassName(), loader);
			}
			try {
				if (CONSTRUCTOR.equals(this.name)) {
					return this.clazz.getDeclaredConstructor(argTypes);
				}
				return this.clazz.getDeclaredMethod(this.name, argTypes);
			}
			catch (NoSuchMethodException ex) {
				throw new IllegalStateException(""Method ["" + this.name +
						""] was discovered in the .class file but cannot be resolved in the class object"", ex);
			}
		}
		private static int[] computeLvtSlotIndices(boolean isStatic, Type[] paramTypes) {
			int[] lvtIndex = new int[paramTypes.length];
			int nextIndex = (isStatic ? 0 : 1);
			for (int i = 0; i < paramTypes.length; i++) {
				lvtIndex[i] = nextIndex;
				if (isWideType(paramTypes[i])) {
					nextIndex += 2;
				}
				else {
					nextIndex++;
				}
			}
			return lvtIndex;
		}
		private static boolean isWideType(Type aType) {
			// float is not a wide type
			return (aType == Type.LONG_TYPE || aType == Type.DOUBLE_TYPE);
		}
	}
}",class,
"			// We couldn't load the class file, which is not fatal as it
			// simply means this method of discovering parameter names won't work.
			if (logger.isDebugEnabled()) {
				logger.debug(""Cannot find '.class' file for class ["" + clazz +
						""] - unable to determine constructor/method parameter names"");
			}",class,
"				logger.debug(""ASM ClassReader failed to parse class file ["" + clazz +
						""], probably due to a new Java class file version that isn't supported yet "" +
						""- unable to determine constructor/method parameter names"", ex);
			}
		}
		finally {
			try {
				is.close();
			}
			catch (IOException ex) {
				// ignore
			}
		}",class,
"	private static class ParameterNameDiscoveringVisitor extends ClassVisitor {
		private static final String STATIC_CLASS_INIT = ""<clinit>"";
		private final Class<?> clazz;
		private final Map<Member, String[]> memberMap;
		public ParameterNameDiscoveringVisitor(Class<?> clazz, Map<Member, String[]> memberMap) {
			super(SpringAsmInfo.ASM_VERSION);
			this.clazz = clazz;
			this.memberMap = memberMap;
		}
		@Override
		@Nullable
		public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
			// exclude synthetic + bridged && static class initialization
			if (!isSyntheticOrBridged(access) && !STATIC_CLASS_INIT.equals(name)) {
				return new LocalVariableTableVisitor(clazz, memberMap, name, desc, isStatic(access));
			}
			return null;
		}
		private static boolean isSyntheticOrBridged(int access) {
			return (((access & Opcodes.ACC_SYNTHETIC) | (access & Opcodes.ACC_BRIDGE)) > 0);
		}
		private static boolean isStatic(int access) {
			return ((access & Opcodes.ACC_STATIC) > 0);
		}
	}",class,
"			// exclude synthetic + bridged && static class initialization
			if (!isSyntheticOrBridged(access) && !STATIC_CLASS_INIT.equals(name)) {
				return new LocalVariableTableVisitor(clazz, memberMap, name, desc, isStatic(access));
			}",class,
"	private static class LocalVariableTableVisitor extends MethodVisitor {
		private static final String CONSTRUCTOR = ""<init>"";
		private final Class<?> clazz;
		private final Map<Member, String[]> memberMap;
		private final String name;
		private final Type[] args;
		private final String[] parameterNames;
		private final boolean isStatic;
		private boolean hasLvtInfo = false;
		private final int[] lvtSlotIndex;
		public LocalVariableTableVisitor(Class<?> clazz, Map<Member, String[]> map, String name, String desc, boolean isStatic) {
			super(SpringAsmInfo.ASM_VERSION);
			this.clazz = clazz;
			this.memberMap = map;
			this.name = name;
			this.args = Type.getArgumentTypes(desc);
			this.parameterNames = new String[this.args.length];
			this.isStatic = isStatic;
			this.lvtSlotIndex = computeLvtSlotIndices(isStatic, this.args);
		}
		@Override
		public void visitLocalVariable(String name, String description, String signature, Label start, Label end, int index) {
			this.hasLvtInfo = true;
			for (int i = 0; i < this.lvtSlotIndex.length; i++) {
				if (this.lvtSlotIndex[i] == index) {
					this.parameterNames[i] = name;
				}
			}
		}
		@Override
		public void visitEnd() {
			if (this.hasLvtInfo || (this.isStatic && this.parameterNames.length == 0)) {
				// visitLocalVariable will never be called for static no args methods
				// which doesn't use any local variables.
				// This means that hasLvtInfo could be false for that kind of methods
				// even if the class has local variable info.
				this.memberMap.put(resolveMember(), this.parameterNames);
			}
		}
		private Member resolveMember() {
			ClassLoader loader = this.clazz.getClassLoader();
			Class<?>[] argTypes = new Class<?>[this.args.length];
			for (int i = 0; i < this.args.length; i++) {
				argTypes[i] = ClassUtils.resolveClassName(this.args[i].getClassName(), loader);
			}
			try {
				if (CONSTRUCTOR.equals(this.name)) {
					return this.clazz.getDeclaredConstructor(argTypes);
				}
				return this.clazz.getDeclaredMethod(this.name, argTypes);
			}
			catch (NoSuchMethodException ex) {
				throw new IllegalStateException(""Method ["" + this.name +
						""] was discovered in the .class file but cannot be resolved in the class object"", ex);
			}
		}
		private static int[] computeLvtSlotIndices(boolean isStatic, Type[] paramTypes) {
			int[] lvtIndex = new int[paramTypes.length];
			int nextIndex = (isStatic ? 0 : 1);
			for (int i = 0; i < paramTypes.length; i++) {
				lvtIndex[i] = nextIndex;
				if (isWideType(paramTypes[i])) {
					nextIndex += 2;
				}
				else {
					nextIndex++;
				}
			}
			return lvtIndex;
		}
		private static boolean isWideType(Type aType) {
			// float is not a wide type
			return (aType == Type.LONG_TYPE || aType == Type.DOUBLE_TYPE);
		}
	}",class,
"				// even if the class has local variable info.
				this.memberMap.put(resolveMember(), this.parameterNames);
			}
		}
		private Member resolveMember() {
			ClassLoader loader = this.clazz.getClassLoader();
			Class<?>[] argTypes = new Class<?>[this.args.length];
			for (int i = 0; i < this.args.length; i++) {
				argTypes[i] = ClassUtils.resolveClassName(this.args[i].getClassName(), loader);
			}
			try {
				if (CONSTRUCTOR.equals(this.name)) {
					return this.clazz.getDeclaredConstructor(argTypes);
				}
				return this.clazz.getDeclaredMethod(this.name, argTypes);
			}
			catch (NoSuchMethodException ex) {
				throw new IllegalStateException(""Method ["" + this.name +
						""] was discovered in the .class file but cannot be resolved in the class object"", ex);
			}
		}",class,
"						""] was discovered in the .class file but cannot be resolved in the class object"", ex);
			}
		}
		private static int[] computeLvtSlotIndices(boolean isStatic, Type[] paramTypes) {
			int[] lvtIndex = new int[paramTypes.length];
			int nextIndex = (isStatic ? 0 : 1);
			for (int i = 0; i < paramTypes.length; i++) {
				lvtIndex[i] = nextIndex;
				if (isWideType(paramTypes[i])) {
					nextIndex += 2;
				}
				else {
					nextIndex++;
				}
			}
			return lvtIndex;
		}",class,
"	@Override
	@Nullable
	public String[] getParameterNames(Method method) {
		Method originalMethod = BridgeMethodResolver.findBridgedMethod(method);
		Class<?> declaringClass = originalMethod.getDeclaringClass();
		Map<Member, String[]> map = this.parameterNamesCache.get(declaringClass);
		if (map == null) {
			map = inspectClass(declaringClass);
			this.parameterNamesCache.put(declaringClass, map);
		}
		if (map != NO_DEBUG_INFO_MAP) {
			return map.get(originalMethod);
		}
		return null;
	}",method,
"		if (map == null) {
			map = inspectClass(declaringClass);
			this.parameterNamesCache.put(declaringClass, map);
		}",method,
"		if (map != NO_DEBUG_INFO_MAP) {
			return map.get(originalMethod);
		}",method,
"	@Override
	@Nullable
	public String[] getParameterNames(Constructor<?> ctor) {
		Class<?> declaringClass = ctor.getDeclaringClass();
		Map<Member, String[]> map = this.parameterNamesCache.get(declaringClass);
		if (map == null) {
			map = inspectClass(declaringClass);
			this.parameterNamesCache.put(declaringClass, map);
		}
		if (map != NO_DEBUG_INFO_MAP) {
			return map.get(ctor);
		}
		return null;
	}",method,
"		if (map == null) {
			map = inspectClass(declaringClass);
			this.parameterNamesCache.put(declaringClass, map);
		}",method,
"		if (map != NO_DEBUG_INFO_MAP) {
			return map.get(ctor);
		}",method,
"	private Map<Member, String[]> inspectClass(Class<?> clazz) {
		InputStream is = clazz.getResourceAsStream(ClassUtils.getClassFileName(clazz));
		if (is == null) {
			// We couldn't load the class file, which is not fatal as it
			// simply means this method of discovering parameter names won't work.
			if (logger.isDebugEnabled()) {
				logger.debug(""Cannot find '.class' file for class ["" + clazz +
						""] - unable to determine constructor/method parameter names"");
			}
			return NO_DEBUG_INFO_MAP;
		}
		try {
			ClassReader classReader = new ClassReader(is);
			Map<Member, String[]> map = new ConcurrentHashMap<>(32);
			classReader.accept(new ParameterNameDiscoveringVisitor(clazz, map), 0);
			return map;
		}
		catch (IOException ex) {
			if (logger.isDebugEnabled()) {
				logger.debug(""Exception thrown while reading '.class' file for class ["" + clazz +
						""] - unable to determine constructor/method parameter names"", ex);
			}
		}
		catch (IllegalArgumentException ex) {
			if (logger.isDebugEnabled()) {
				logger.debug(""ASM ClassReader failed to parse class file ["" + clazz +
						""], probably due to a new Java class file version that isn't supported yet "" +
						""- unable to determine constructor/method parameter names"", ex);
			}
		}
		finally {
			try {
				is.close();
			}
			catch (IOException ex) {
				// ignore
			}
		}
		return NO_DEBUG_INFO_MAP;
	}",method,
"		if (is == null) {
			// We couldn't load the class file, which is not fatal as it
			// simply means this method of discovering parameter names won't work.
			if (logger.isDebugEnabled()) {
				logger.debug(""Cannot find '.class' file for class ["" + clazz +
						""] - unable to determine constructor/method parameter names"");
			}
			return NO_DEBUG_INFO_MAP;
		}",method,
"		catch (IOException ex) {
			if (logger.isDebugEnabled()) {
				logger.debug(""Exception thrown while reading '.class' file for class ["" + clazz +
						""] - unable to determine constructor/method parameter names"", ex);
			}
		}",method,
"		catch (IllegalArgumentException ex) {
			if (logger.isDebugEnabled()) {
				logger.debug(""ASM ClassReader failed to parse class file ["" + clazz +
						""], probably due to a new Java class file version that isn't supported yet "" +
						""- unable to determine constructor/method parameter names"", ex);
			}
		}",method,
"			catch (IOException ex) {
				// ignore
			}",method,
"		public ParameterNameDiscoveringVisitor(Class<?> clazz, Map<Member, String[]> memberMap) {
			super(SpringAsmInfo.ASM_VERSION);
			this.clazz = clazz;
			this.memberMap = memberMap;
		}",method,
"		@Override
		@Nullable
		public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
			// exclude synthetic + bridged && static class initialization
			if (!isSyntheticOrBridged(access) && !STATIC_CLASS_INIT.equals(name)) {
				return new LocalVariableTableVisitor(clazz, memberMap, name, desc, isStatic(access));
			}
			return null;
		}",method,
"		private static boolean isSyntheticOrBridged(int access) {
			return (((access & Opcodes.ACC_SYNTHETIC) | (access & Opcodes.ACC_BRIDGE)) > 0);
		}",method,
"		private static boolean isStatic(int access) {
			return ((access & Opcodes.ACC_STATIC) > 0);
		}",method,
"		public LocalVariableTableVisitor(Class<?> clazz, Map<Member, String[]> map, String name, String desc, boolean isStatic) {
			super(SpringAsmInfo.ASM_VERSION);
			this.clazz = clazz;
			this.memberMap = map;
			this.name = name;
			this.args = Type.getArgumentTypes(desc);
			this.parameterNames = new String[this.args.length];
			this.isStatic = isStatic;
			this.lvtSlotIndex = computeLvtSlotIndices(isStatic, this.args);
		}",method,
"		@Override
		public void visitLocalVariable(String name, String description, String signature, Label start, Label end, int index) {
			this.hasLvtInfo = true;
			for (int i = 0; i < this.lvtSlotIndex.length; i++) {
				if (this.lvtSlotIndex[i] == index) {
					this.parameterNames[i] = name;
				}
			}
		}",method,
"			for (int i = 0; i < this.lvtSlotIndex.length; i++) {
				if (this.lvtSlotIndex[i] == index) {
					this.parameterNames[i] = name;
				}
			}",method,
"				if (this.lvtSlotIndex[i] == index) {
					this.parameterNames[i] = name;
				}",method,
"		@Override
		public void visitEnd() {
			if (this.hasLvtInfo || (this.isStatic && this.parameterNames.length == 0)) {
				// visitLocalVariable will never be called for static no args methods
				// which doesn't use any local variables.
				// This means that hasLvtInfo could be false for that kind of methods
				// even if the class has local variable info.
				this.memberMap.put(resolveMember(), this.parameterNames);
			}
		}",method,
"		private Member resolveMember() {
			ClassLoader loader = this.clazz.getClassLoader();
			Class<?>[] argTypes = new Class<?>[this.args.length];
			for (int i = 0; i < this.args.length; i++) {
				argTypes[i] = ClassUtils.resolveClassName(this.args[i].getClassName(), loader);
			}
			try {
				if (CONSTRUCTOR.equals(this.name)) {
					return this.clazz.getDeclaredConstructor(argTypes);
				}
				return this.clazz.getDeclaredMethod(this.name, argTypes);
			}
			catch (NoSuchMethodException ex) {
				throw new IllegalStateException(""Method ["" + this.name +
						""] was discovered in the .class file but cannot be resolved in the class object"", ex);
			}
		}",method,
"			for (int i = 0; i < this.args.length; i++) {
				argTypes[i] = ClassUtils.resolveClassName(this.args[i].getClassName(), loader);
			}",method,
"			catch (NoSuchMethodException ex) {
				throw new IllegalStateException(""Method ["" + this.name +
						""] was discovered in the .class file but cannot be resolved in the class object"", ex);
			}",method,
"		private static int[] computeLvtSlotIndices(boolean isStatic, Type[] paramTypes) {
			int[] lvtIndex = new int[paramTypes.length];
			int nextIndex = (isStatic ? 0 : 1);
			for (int i = 0; i < paramTypes.length; i++) {
				lvtIndex[i] = nextIndex;
				if (isWideType(paramTypes[i])) {
					nextIndex += 2;
				}
				else {
					nextIndex++;
				}
			}
			return lvtIndex;
		}",method,
"			for (int i = 0; i < paramTypes.length; i++) {
				lvtIndex[i] = nextIndex;
				if (isWideType(paramTypes[i])) {
					nextIndex += 2;
				}
				else {
					nextIndex++;
				}
			}",method,
"		private static boolean isWideType(Type aType) {
			// float is not a wide type
			return (aType == Type.LONG_TYPE || aType == Type.DOUBLE_TYPE);
		}",method,
"public final class ResponseCollectorService extends AbstractComponent implements ClusterStateListener {
    private static final double ALPHA = 0.3;
    private final ConcurrentMap<String, NodeStatistics> nodeIdToStats = ConcurrentCollections.newConcurrentMap();
    public ResponseCollectorService(Settings settings, ClusterService clusterService) {
        super(settings);
        clusterService.addListener(this);
    }
    @Override
    public void clusterChanged(ClusterChangedEvent event) {
        if (event.nodesRemoved()) {
            for (DiscoveryNode removedNode : event.nodesDelta().removedNodes()) {
                removeNode(removedNode.getId());
            }
        }
    }
    void removeNode(String nodeId) {
        nodeIdToStats.remove(nodeId);
    }
    public void addNodeStatistics(String nodeId, int queueSize, long responseTimeNanos, long avgServiceTimeNanos) {
        nodeIdToStats.compute(nodeId, (id, ns) -> {
            if (ns == null) {
                ExponentiallyWeightedMovingAverage queueEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, queueSize);
                ExponentiallyWeightedMovingAverage responseEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, responseTimeNanos);
                return new NodeStatistics(nodeId, queueEWMA, responseEWMA, avgServiceTimeNanos);
            } else {
                ns.queueSize.addValue((double) queueSize);
                ns.responseTime.addValue((double) responseTimeNanos);
                ns.serviceTime = avgServiceTimeNanos;
                return ns;
            }
        });
    }
    public Map<String, ComputedNodeStats> getAllNodeStatistics() {
        final int clientNum = nodeIdToStats.size();
        // Transform the mutable object internally used for accounting into the computed version
        Map<String, ComputedNodeStats> nodeStats = new HashMap<>(nodeIdToStats.size());
        nodeIdToStats.forEach((k, v) -> {
            nodeStats.put(k, new ComputedNodeStats(clientNum, v));
        });
        return nodeStats;
    }
    public Optional<ComputedNodeStats> getNodeStatistics(final String nodeId) {
        final int clientNum = nodeIdToStats.size();
        return Optional.ofNullable(nodeIdToStats.get(nodeId)).map(ns -> new ComputedNodeStats(clientNum, ns));
    }
    public static class ComputedNodeStats {
        // We store timestamps with nanosecond precision, however, the
        // formula specifies milliseconds, therefore we need to convert
        // the values so the times don't unduely weight the formula
        private final double FACTOR = 1000000.0;
        private final int clientNum;
        private double cachedRank = 0;
        public final String nodeId;
        public final int queueSize;
        public final double responseTime;
        public final double serviceTime;
        ComputedNodeStats(int clientNum, NodeStatistics nodeStats) {
            this.clientNum = clientNum;
            this.nodeId = nodeStats.nodeId;
            this.queueSize = (int) nodeStats.queueSize.getAverage();
            this.responseTime = nodeStats.responseTime.getAverage();
            this.serviceTime = nodeStats.serviceTime;
        }
        private double innerRank(long outstandingRequests) {
            // this is a placeholder value, the concurrency compensation is
            // defined as the number of outstanding requests from the client
            // to the node times the number of clients in the system
            double concurrencyCompensation = outstandingRequests * clientNum;
            // Cubic queue adjustment factor. The paper chose 3 though we could
            // potentially make this configurable if desired.
            int queueAdjustmentFactor = 3;
            // EWMA of queue size
            double qBar = queueSize;
            double qHatS = 1 + concurrencyCompensation + qBar;
            // EWMA of response time
            double rS = responseTime / FACTOR;
            // EWMA of service time
            double muBarS = serviceTime / FACTOR;
            // The final formula
            double rank = rS - (1.0 / muBarS) + (Math.pow(qHatS, queueAdjustmentFactor) / muBarS);
            return rank;
        }
        public double rank(long outstandingRequests) {
            if (cachedRank == 0) {
                cachedRank = innerRank(outstandingRequests);
            }
            return cachedRank;
        }
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder(""ComputedNodeStats["");
            sb.append(nodeId).append(""]("");
            sb.append(""nodes: "").append(clientNum);
            sb.append("", queue: "").append(queueSize);
            sb.append("", response time: "").append(String.format(Locale.ROOT, ""%.1f"", responseTime));
            sb.append("", service time: "").append(String.format(Locale.ROOT, ""%.1f"", serviceTime));
            sb.append("", rank: "").append(String.format(Locale.ROOT, ""%.1f"", rank(1)));
            sb.append("")"");
            return sb.toString();
        }
    }
    private static class NodeStatistics {
        final String nodeId;
        final ExponentiallyWeightedMovingAverage queueSize;
        final ExponentiallyWeightedMovingAverage responseTime;
        double serviceTime;
        NodeStatistics(String nodeId,
                       ExponentiallyWeightedMovingAverage queueSizeEWMA,
                       ExponentiallyWeightedMovingAverage responseTimeEWMA,
                       double serviceTimeEWMA) {
            this.nodeId = nodeId;
            this.queueSize = queueSizeEWMA;
            this.responseTime = responseTimeEWMA;
            this.serviceTime = serviceTimeEWMA;
        }
    }
}",class,
"    public static class ComputedNodeStats {
        // We store timestamps with nanosecond precision, however, the
        // formula specifies milliseconds, therefore we need to convert
        // the values so the times don't unduely weight the formula
        private final double FACTOR = 1000000.0;
        private final int clientNum;
        private double cachedRank = 0;
        public final String nodeId;
        public final int queueSize;
        public final double responseTime;
        public final double serviceTime;
        ComputedNodeStats(int clientNum, NodeStatistics nodeStats) {
            this.clientNum = clientNum;
            this.nodeId = nodeStats.nodeId;
            this.queueSize = (int) nodeStats.queueSize.getAverage();
            this.responseTime = nodeStats.responseTime.getAverage();
            this.serviceTime = nodeStats.serviceTime;
        }
        private double innerRank(long outstandingRequests) {
            // this is a placeholder value, the concurrency compensation is
            // defined as the number of outstanding requests from the client
            // to the node times the number of clients in the system
            double concurrencyCompensation = outstandingRequests * clientNum;
            // Cubic queue adjustment factor. The paper chose 3 though we could
            // potentially make this configurable if desired.
            int queueAdjustmentFactor = 3;
            // EWMA of queue size
            double qBar = queueSize;
            double qHatS = 1 + concurrencyCompensation + qBar;
            // EWMA of response time
            double rS = responseTime / FACTOR;
            // EWMA of service time
            double muBarS = serviceTime / FACTOR;
            // The final formula
            double rank = rS - (1.0 / muBarS) + (Math.pow(qHatS, queueAdjustmentFactor) / muBarS);
            return rank;
        }
        public double rank(long outstandingRequests) {
            if (cachedRank == 0) {
                cachedRank = innerRank(outstandingRequests);
            }
            return cachedRank;
        }
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder(""ComputedNodeStats["");
            sb.append(nodeId).append(""]("");
            sb.append(""nodes: "").append(clientNum);
            sb.append("", queue: "").append(queueSize);
            sb.append("", response time: "").append(String.format(Locale.ROOT, ""%.1f"", responseTime));
            sb.append("", service time: "").append(String.format(Locale.ROOT, ""%.1f"", serviceTime));
            sb.append("", rank: "").append(String.format(Locale.ROOT, ""%.1f"", rank(1)));
            sb.append("")"");
            return sb.toString();
        }
    }",class,
"    private static class NodeStatistics {
        final String nodeId;
        final ExponentiallyWeightedMovingAverage queueSize;
        final ExponentiallyWeightedMovingAverage responseTime;
        double serviceTime;
        NodeStatistics(String nodeId,
                       ExponentiallyWeightedMovingAverage queueSizeEWMA,
                       ExponentiallyWeightedMovingAverage responseTimeEWMA,
                       double serviceTimeEWMA) {
            this.nodeId = nodeId;
            this.queueSize = queueSizeEWMA;
            this.responseTime = responseTimeEWMA;
            this.serviceTime = serviceTimeEWMA;
        }
    }",class,
"    public ResponseCollectorService(Settings settings, ClusterService clusterService) {
        super(settings);
        clusterService.addListener(this);
    }",method,
"    @Override
    public void clusterChanged(ClusterChangedEvent event) {
        if (event.nodesRemoved()) {
            for (DiscoveryNode removedNode : event.nodesDelta().removedNodes()) {
                removeNode(removedNode.getId());
            }
        }
    }",method,
"    void removeNode(String nodeId) {
        nodeIdToStats.remove(nodeId);
    }",method,
"    public void addNodeStatistics(String nodeId, int queueSize, long responseTimeNanos, long avgServiceTimeNanos) {
        nodeIdToStats.compute(nodeId, (id, ns) -> {
            if (ns == null) {
                ExponentiallyWeightedMovingAverage queueEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, queueSize);
                ExponentiallyWeightedMovingAverage responseEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, responseTimeNanos);
                return new NodeStatistics(nodeId, queueEWMA, responseEWMA, avgServiceTimeNanos);
            } else {
                ns.queueSize.addValue((double) queueSize);
                ns.responseTime.addValue((double) responseTimeNanos);
                ns.serviceTime = avgServiceTimeNanos;
                return ns;
            }
        });
    }",method,
"            if (ns == null) {
                ExponentiallyWeightedMovingAverage queueEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, queueSize);
                ExponentiallyWeightedMovingAverage responseEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, responseTimeNanos);
                return new NodeStatistics(nodeId, queueEWMA, responseEWMA, avgServiceTimeNanos);
            }",method,
"    public Map<String, ComputedNodeStats> getAllNodeStatistics() {
        final int clientNum = nodeIdToStats.size();
        // Transform the mutable object internally used for accounting into the computed version
        Map<String, ComputedNodeStats> nodeStats = new HashMap<>(nodeIdToStats.size());
        nodeIdToStats.forEach((k, v) -> {
            nodeStats.put(k, new ComputedNodeStats(clientNum, v));
        });
        return nodeStats;
    }",method,
"    public Optional<ComputedNodeStats> getNodeStatistics(final String nodeId) {
        final int clientNum = nodeIdToStats.size();
        return Optional.ofNullable(nodeIdToStats.get(nodeId)).map(ns -> new ComputedNodeStats(clientNum, ns));
    }",method,
"        ComputedNodeStats(int clientNum, NodeStatistics nodeStats) {
            this.clientNum = clientNum;
            this.nodeId = nodeStats.nodeId;
            this.queueSize = (int) nodeStats.queueSize.getAverage();
            this.responseTime = nodeStats.responseTime.getAverage();
            this.serviceTime = nodeStats.serviceTime;
        }",method,
"        private double innerRank(long outstandingRequests) {
            // this is a placeholder value, the concurrency compensation is
            // defined as the number of outstanding requests from the client
            // to the node times the number of clients in the system
            double concurrencyCompensation = outstandingRequests * clientNum;
            // Cubic queue adjustment factor. The paper chose 3 though we could
            // potentially make this configurable if desired.
            int queueAdjustmentFactor = 3;
            // EWMA of queue size
            double qBar = queueSize;
            double qHatS = 1 + concurrencyCompensation + qBar;
            // EWMA of response time
            double rS = responseTime / FACTOR;
            // EWMA of service time
            double muBarS = serviceTime / FACTOR;
            // The final formula
            double rank = rS - (1.0 / muBarS) + (Math.pow(qHatS, queueAdjustmentFactor) / muBarS);
            return rank;
        }",method,
"        public double rank(long outstandingRequests) {
            if (cachedRank == 0) {
                cachedRank = innerRank(outstandingRequests);
            }
            return cachedRank;
        }",method,
"            if (cachedRank == 0) {
                cachedRank = innerRank(outstandingRequests);
            }",method,
"        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder(""ComputedNodeStats["");
            sb.append(nodeId).append(""]("");
            sb.append(""nodes: "").append(clientNum);
            sb.append("", queue: "").append(queueSize);
            sb.append("", response time: "").append(String.format(Locale.ROOT, ""%.1f"", responseTime));
            sb.append("", service time: "").append(String.format(Locale.ROOT, ""%.1f"", serviceTime));
            sb.append("", rank: "").append(String.format(Locale.ROOT, ""%.1f"", rank(1)));
            sb.append("")"");
            return sb.toString();
        }",method,
"        NodeStatistics(String nodeId,
                       ExponentiallyWeightedMovingAverage queueSizeEWMA,
                       ExponentiallyWeightedMovingAverage responseTimeEWMA,
                       double serviceTimeEWMA) {
            this.nodeId = nodeId;
            this.queueSize = queueSizeEWMA;
            this.responseTime = responseTimeEWMA;
            this.serviceTime = serviceTimeEWMA;
        }",method,
"public class AtlasCrashManager {
    private static Thread.UncaughtExceptionHandler defaultUnCaughtExceptionHandler;
    public static void forceStopAppWhenCrashed(){
        defaultUnCaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(new CrashHandler());
    }
    public static class CrashHandler implements Thread.UncaughtExceptionHandler{
        @Override
        public void uncaughtException(Thread thread, Throwable ex) {
            //force stop pkg
            try {
                Log.e(""CrashManager"",""force stop"");
                Field mPMField = RuntimeVariables.androidApplication.getPackageManager().getClass().getDeclaredField(""mPM"");
                mPMField.setAccessible(true);
                Object mPM = mPMField.get(RuntimeVariables.androidApplication.getPackageManager());
                Method setPackageStoppedState = mPM.getClass().getDeclaredMethod(""setPackageStoppedState"",String.class,boolean.class,int.class);
                setPackageStoppedState.setAccessible(true);
                setPackageStoppedState.invoke(mPM,RuntimeVariables.androidApplication.getPackageName(),true,RuntimeVariables.androidApplication.getApplicationInfo().uid);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            if(defaultUnCaughtExceptionHandler!=null) {
                defaultUnCaughtExceptionHandler.uncaughtException(thread, ex);
            }
        }
    }
}",class,
"    public static class CrashHandler implements Thread.UncaughtExceptionHandler{
        @Override
        public void uncaughtException(Thread thread, Throwable ex) {
            //force stop pkg
            try {
                Log.e(""CrashManager"",""force stop"");
                Field mPMField = RuntimeVariables.androidApplication.getPackageManager().getClass().getDeclaredField(""mPM"");
                mPMField.setAccessible(true);
                Object mPM = mPMField.get(RuntimeVariables.androidApplication.getPackageManager());
                Method setPackageStoppedState = mPM.getClass().getDeclaredMethod(""setPackageStoppedState"",String.class,boolean.class,int.class);
                setPackageStoppedState.setAccessible(true);
                setPackageStoppedState.invoke(mPM,RuntimeVariables.androidApplication.getPackageName(),true,RuntimeVariables.androidApplication.getApplicationInfo().uid);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            if(defaultUnCaughtExceptionHandler!=null) {
                defaultUnCaughtExceptionHandler.uncaughtException(thread, ex);
            }
        }
    }",class,
"    public static void forceStopAppWhenCrashed(){
        defaultUnCaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(new CrashHandler());
    }",method,
"        @Override
        public void uncaughtException(Thread thread, Throwable ex) {
            //force stop pkg
            try {
                Log.e(""CrashManager"",""force stop"");
                Field mPMField = RuntimeVariables.androidApplication.getPackageManager().getClass().getDeclaredField(""mPM"");
                mPMField.setAccessible(true);
                Object mPM = mPMField.get(RuntimeVariables.androidApplication.getPackageManager());
                Method setPackageStoppedState = mPM.getClass().getDeclaredMethod(""setPackageStoppedState"",String.class,boolean.class,int.class);
                setPackageStoppedState.setAccessible(true);
                setPackageStoppedState.invoke(mPM,RuntimeVariables.androidApplication.getPackageName(),true,RuntimeVariables.androidApplication.getApplicationInfo().uid);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            if(defaultUnCaughtExceptionHandler!=null) {
                defaultUnCaughtExceptionHandler.uncaughtException(thread, ex);
            }
        }",method,
"            if(defaultUnCaughtExceptionHandler!=null) {
                defaultUnCaughtExceptionHandler.uncaughtException(thread, ex);
            }",method,
"public class MultimapAsMapTester<K, V> extends AbstractMultimapTester<K, V, Multimap<K, V>> {
  public void testAsMapGet() {
    for (K key : sampleKeys()) {
      List<V> expectedValues = new ArrayList<>();
      for (Entry<K, V> entry : getSampleElements()) {
        if (entry.getKey().equals(key)) {
          expectedValues.add(entry.getValue());
        }
      }
      Collection<V> collection = multimap().asMap().get(key);
      if (expectedValues.isEmpty()) {
        assertNull(collection);
      } else {
        assertEqualIgnoringOrder(expectedValues, collection);
      }
    }
  }
  @CollectionSize.Require(absent = ZERO)
  @MapFeature.Require(ALLOWS_NULL_KEYS)
  public void testAsMapGetNullKeyPresent() {
    initMultimapWithNullKey();
    assertContentsAnyOrder(multimap().asMap().get(null), getValueForNullKey());
  }
  @MapFeature.Require(ALLOWS_NULL_KEY_QUERIES)
  public void testAsMapGetNullKeyAbsent() {
    assertNull(multimap().asMap().get(null));
  }
  @MapFeature.Require(absent = ALLOWS_NULL_KEY_QUERIES)
  public void testAsMapGetNullKeyUnsupported() {
    try {
      multimap().asMap().get(null);
      fail(""Expected NullPointerException"");
    } catch (NullPointerException expected) {
    }
  }
  @CollectionSize.Require(absent = ZERO)
  @MapFeature.Require(SUPPORTS_REMOVE)
  public void testAsMapRemove() {
    assertContentsInOrder(multimap().asMap().remove(k0()), v0());
    assertGet(k0());
    assertEquals(getNumElements() - 1, multimap().size());
  }
  @CollectionSize.Require(SEVERAL)
  @MapFeature.Require(SUPPORTS_PUT)
  public void testAsMapEntrySetReflectsPutSameKey() {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));
    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    Collection<V> valueCollection = Iterables.getOnlyElement(asMapEntrySet).getValue();
    assertContentsAnyOrder(valueCollection, v0(), v3());
    assertTrue(multimap().put(k0(), v4()));
    assertContentsAnyOrder(valueCollection, v0(), v3(), v4());
  }
  @CollectionSize.Require(SEVERAL)
  @MapFeature.Require(SUPPORTS_PUT)
  public void testAsMapEntrySetReflectsPutDifferentKey() {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));
    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    assertTrue(multimap().put(k1(), v4()));
    assertEquals(2, asMapEntrySet.size());
  }
  @CollectionSize.Require(SEVERAL)
  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
  public void testAsMapEntrySetRemovePropagatesToMultimap() {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));
    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    Entry<K, Collection<V>> asMapEntry0 = Iterables.getOnlyElement(asMapEntrySet);
    assertTrue(multimap().put(k1(), v4()));
    assertTrue(asMapEntrySet.remove(asMapEntry0));
    assertEquals(1, multimap().size());
    assertContentsInOrder(multimap().keySet(), k1());
  }
  @CollectionSize.Require(SEVERAL)
  @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
  public void testAsMapEntrySetIteratorRemovePropagatesToMultimap() {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));
    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    Iterator<Entry<K, Collection<V>>> asMapEntryItr = asMapEntrySet.iterator();
    asMapEntryItr.next();
    asMapEntryItr.remove();
    assertTrue(multimap().isEmpty());
  }
}",class,
"  public void testAsMapGet() {
    for (K key : sampleKeys()) {
      List<V> expectedValues = new ArrayList<>();
      for (Entry<K, V> entry : getSampleElements()) {
        if (entry.getKey().equals(key)) {
          expectedValues.add(entry.getValue());
        }
      }
      Collection<V> collection = multimap().asMap().get(key);
      if (expectedValues.isEmpty()) {
        assertNull(collection);
      } else {
        assertEqualIgnoringOrder(expectedValues, collection);
      }
    }
  }",method,
"  @CollectionSize.Require(absent = ZERO)
  @MapFeature.Require(ALLOWS_NULL_KEYS)
  public void testAsMapGetNullKeyPresent() {
    initMultimapWithNullKey();
    assertContentsAnyOrder(multimap().asMap().get(null), getValueForNullKey());
  }",method,
"  @MapFeature.Require(ALLOWS_NULL_KEY_QUERIES)
  public void testAsMapGetNullKeyAbsent() {
    assertNull(multimap().asMap().get(null));
  }",method,
"  @MapFeature.Require(absent = ALLOWS_NULL_KEY_QUERIES)
  public void testAsMapGetNullKeyUnsupported() {
    try {
      multimap().asMap().get(null);
      fail(""Expected NullPointerException"");
    } catch (NullPointerException expected) {
    }
  }",method,
"  @CollectionSize.Require(absent = ZERO)
  @MapFeature.Require(SUPPORTS_REMOVE)
  public void testAsMapRemove() {
    assertContentsInOrder(multimap().asMap().remove(k0()), v0());
    assertGet(k0());
    assertEquals(getNumElements() - 1, multimap().size());
  }",method,

code_snippet,type,score
"  private void drawMarker(Editor editor, Graphics2D g2,
                          int x1, int x2, int y1, int y2,
                          boolean ignoredBackgroundColor) {
    if (x1 >= x2) return;
    Color color = myDiffType.getColor(editor);
    if (y2 - y1 > 2) {
      if (!myResolved) {
        g2.setColor(ignoredBackgroundColor ? myDiffType.getIgnoredColor(editor) : color);
        g2.fillRect(x1, y1, x2 - x1, y2 - y1);
      } else {
        DiffDrawUtil.drawChunkBorderLine(g2, x1, x2, y1, color, false, myResolved);
        DiffDrawUtil.drawChunkBorderLine(g2, x1, x2, y2 - 1, color, false, myResolved);
      }
    }
    else {
      // range is empty - insertion or deletion
      // Draw 2 pixel line in that case
      DiffDrawUtil.drawChunkBorderLine(g2, x1, x2, y1 - 1, color, true, myResolved);
    }
  }",method,
"    if (y2 - y1 > 2) {
      if (!myResolved) {
        g2.setColor(ignoredBackgroundColor ? myDiffType.getIgnoredColor(editor) : color);
        g2.fillRect(x1, y1, x2 - x1, y2 - y1);
      } else {
        DiffDrawUtil.drawChunkBorderLine(g2, x1, x2, y1, color, false, myResolved);
        DiffDrawUtil.drawChunkBorderLine(g2, x1, x2, y2 - 1, color, false, myResolved);
      }
    }",method,
"      if (!myResolved) {
        g2.setColor(ignoredBackgroundColor ? myDiffType.getIgnoredColor(editor) : color);
        g2.fillRect(x1, y1, x2 - x1, y2 - y1);
      }",method,
"  @NotNull
  @Override
  public Position getPosition() {
    return Position.CUSTOM;
  }",method,
"public abstract class MockMvcWebConnectionBuilderSupport<T extends MockMvcWebConnectionBuilderSupport<T>> {
	private final MockMvc mockMvc;
	private final List<WebRequestMatcher> requestMatchers = new ArrayList<>();
	private String contextPath = """";
	private boolean alwaysUseMockMvc;
	protected MockMvcWebConnectionBuilderSupport(MockMvc mockMvc) {
		Assert.notNull(mockMvc, ""MockMvc must not be null"");
		this.mockMvc = mockMvc;
		this.requestMatchers.add(new HostRequestMatcher(""localhost""));
	}
	protected MockMvcWebConnectionBuilderSupport(WebApplicationContext context) {
		this(MockMvcBuilders.webAppContextSetup(context).build());
	}
	protected MockMvcWebConnectionBuilderSupport(WebApplicationContext context, MockMvcConfigurer configurer) {
		this(MockMvcBuilders.webAppContextSetup(context).apply(configurer).build());
	}
	@SuppressWarnings(""unchecked"")
	public T contextPath(String contextPath) {
		this.contextPath = contextPath;
		return (T) this;
	}
	@SuppressWarnings(""unchecked"")
	public T alwaysUseMockMvc() {
		this.alwaysUseMockMvc = true;
		return (T) this;
	}
	@SuppressWarnings(""unchecked"")
	public T useMockMvc(WebRequestMatcher... matchers) {
		for (WebRequestMatcher matcher : matchers) {
			this.requestMatchers.add(matcher);
		}
		return (T) this;
	}
	@SuppressWarnings(""unchecked"")
	public T useMockMvcForHosts(String... hosts) {
		this.requestMatchers.add(new HostRequestMatcher(hosts));
		return (T) this;
	}
	protected final WebConnection createConnection(WebClient webClient) {
		Assert.notNull(webClient, ""WebClient must not be null"");
		return createConnection(webClient, webClient.getWebConnection());
	}
	private WebConnection createConnection(WebClient webClient, WebConnection defaultConnection) {
		WebConnection connection = new MockMvcWebConnection(this.mockMvc, webClient, this.contextPath);
		if (this.alwaysUseMockMvc) {
			return connection;
		}
		List<DelegateWebConnection> delegates = new ArrayList<>(this.requestMatchers.size());
		for (WebRequestMatcher matcher : this.requestMatchers) {
			delegates.add(new DelegateWebConnection(matcher, connection));
		}
		return new DelegatingWebConnection(defaultConnection, delegates);
	}
}",class,
"	protected MockMvcWebConnectionBuilderSupport(MockMvc mockMvc) {
		Assert.notNull(mockMvc, ""MockMvc must not be null"");
		this.mockMvc = mockMvc;
		this.requestMatchers.add(new HostRequestMatcher(""localhost""));
	}",method,
"	protected MockMvcWebConnectionBuilderSupport(WebApplicationContext context) {
		this(MockMvcBuilders.webAppContextSetup(context).build());
	}",method,
"	protected MockMvcWebConnectionBuilderSupport(WebApplicationContext context, MockMvcConfigurer configurer) {
		this(MockMvcBuilders.webAppContextSetup(context).apply(configurer).build());
	}",method,
"	@SuppressWarnings(""unchecked"")
	public T contextPath(String contextPath) {
		this.contextPath = contextPath;
		return (T) this;
	}",method,
"	@SuppressWarnings(""unchecked"")
	public T alwaysUseMockMvc() {
		this.alwaysUseMockMvc = true;
		return (T) this;
	}",method,
"	@SuppressWarnings(""unchecked"")
	public T useMockMvc(WebRequestMatcher... matchers) {
		for (WebRequestMatcher matcher : matchers) {
			this.requestMatchers.add(matcher);
		}
		return (T) this;
	}",method,
"		for (WebRequestMatcher matcher : matchers) {
			this.requestMatchers.add(matcher);
		}",method,
"	@SuppressWarnings(""unchecked"")
	public T useMockMvcForHosts(String... hosts) {
		this.requestMatchers.add(new HostRequestMatcher(hosts));
		return (T) this;
	}",method,
"	protected final WebConnection createConnection(WebClient webClient) {
		Assert.notNull(webClient, ""WebClient must not be null"");
		return createConnection(webClient, webClient.getWebConnection());
	}",method,
"	private WebConnection createConnection(WebClient webClient, WebConnection defaultConnection) {
		WebConnection connection = new MockMvcWebConnection(this.mockMvc, webClient, this.contextPath);
		if (this.alwaysUseMockMvc) {
			return connection;
		}
		List<DelegateWebConnection> delegates = new ArrayList<>(this.requestMatchers.size());
		for (WebRequestMatcher matcher : this.requestMatchers) {
			delegates.add(new DelegateWebConnection(matcher, connection));
		}
		return new DelegatingWebConnection(defaultConnection, delegates);
	}",method,
"		if (this.alwaysUseMockMvc) {
			return connection;
		}",method,
"		for (WebRequestMatcher matcher : this.requestMatchers) {
			delegates.add(new DelegateWebConnection(matcher, connection));
		}",method,
"public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
    implements BlockingDeque<E> {
  protected ForwardingBlockingDeque() {}
  @Override
  protected abstract BlockingDeque<E> delegate();
  @Override
  public int remainingCapacity() {
    return delegate().remainingCapacity();
  }
  @Override
  public void putFirst(E e) throws InterruptedException {
    delegate().putFirst(e);
  }
  @Override
  public void putLast(E e) throws InterruptedException {
    delegate().putLast(e);
  }
  @Override
  public boolean offerFirst(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offerFirst(e, timeout, unit);
  }
  @Override
  public boolean offerLast(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offerLast(e, timeout, unit);
  }
  @Override
  public E takeFirst() throws InterruptedException {
    return delegate().takeFirst();
  }
  @Override
  public E takeLast() throws InterruptedException {
    return delegate().takeLast();
  }
  @Override
  public E pollFirst(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().pollFirst(timeout, unit);
  }
  @Override
  public E pollLast(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().pollLast(timeout, unit);
  }
  @Override
  public void put(E e) throws InterruptedException {
    delegate().put(e);
  }
  @Override
  public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offer(e, timeout, unit);
  }
  @Override
  public E take() throws InterruptedException {
    return delegate().take();
  }
  @Override
  public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().poll(timeout, unit);
  }
  @Override
  public int drainTo(Collection<? super E> c) {
    return delegate().drainTo(c);
  }
  @Override
  public int drainTo(Collection<? super E> c, int maxElements) {
    return delegate().drainTo(c, maxElements);
  }
}",class,
  protected ForwardingBlockingDeque() {},method,
"  @Override
  public int remainingCapacity() {
    return delegate().remainingCapacity();
  }",method,
"  @Override
  public void putFirst(E e) throws InterruptedException {
    delegate().putFirst(e);
  }",method,
"  @Override
  public void putLast(E e) throws InterruptedException {
    delegate().putLast(e);
  }",method,
"  @Override
  public boolean offerFirst(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offerFirst(e, timeout, unit);
  }",method,
"  @Override
  public boolean offerLast(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offerLast(e, timeout, unit);
  }",method,
"  @Override
  public E takeFirst() throws InterruptedException {
    return delegate().takeFirst();
  }",method,
"  @Override
  public E takeLast() throws InterruptedException {
    return delegate().takeLast();
  }",method,
"  @Override
  public E pollFirst(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().pollFirst(timeout, unit);
  }",method,
"  @Override
  public E pollLast(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().pollLast(timeout, unit);
  }",method,
"  @Override
  public void put(E e) throws InterruptedException {
    delegate().put(e);
  }",method,
"  @Override
  public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offer(e, timeout, unit);
  }",method,
"  @Override
  public E take() throws InterruptedException {
    return delegate().take();
  }",method,
"  @Override
  public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().poll(timeout, unit);
  }",method,
"  @Override
  public int drainTo(Collection<? super E> c) {
    return delegate().drainTo(c);
  }",method,
"  @Override
  public int drainTo(Collection<? super E> c, int maxElements) {
    return delegate().drainTo(c, maxElements);
  }",method,
"public class ByteArrayMultipartFileEditorTests {
	private final ByteArrayMultipartFileEditor editor = new ByteArrayMultipartFileEditor();
	@Test
	public void setValueAsByteArray() throws Exception {
		String expectedValue = ""Shumwere, shumhow, a shuck ish washing you. - Drunken Far Side"";
		editor.setValue(expectedValue.getBytes());
		assertEquals(expectedValue, editor.getAsText());
	}
	@Test
	public void setValueAsString() throws Exception {
		String expectedValue = ""'Green Wing' - classic British comedy"";
		editor.setValue(expectedValue);
		assertEquals(expectedValue, editor.getAsText());
	}
	@Test
	public void setValueAsCustomObjectInvokesToString() throws Exception {
		final String expectedValue = ""'Green Wing' - classic British comedy"";
		Object object = new Object() {
			@Override
			public String toString() {
				return expectedValue;
			}
		};
		editor.setValue(object);
		assertEquals(expectedValue, editor.getAsText());
	}
	@Test
	public void setValueAsNullGetsBackEmptyString() throws Exception {
		editor.setValue(null);
		assertEquals("""", editor.getAsText());
	}
	@Test
	public void setValueAsMultipartFile() throws Exception {
		String expectedValue = ""That is comforting to know"";
		MultipartFile file = mock(MultipartFile.class);
		given(file.getBytes()).willReturn(expectedValue.getBytes());
		editor.setValue(file);
		assertEquals(expectedValue, editor.getAsText());
	}
	@Test(expected = IllegalArgumentException.class)
	public void setValueAsMultipartFileWithBadBytes() throws Exception {
		MultipartFile file = mock(MultipartFile.class);
		given(file.getBytes()).willThrow(new IOException());
		editor.setValue(file);
	}
}",class,
"	@Test
	public void setValueAsByteArray() throws Exception {
		String expectedValue = ""Shumwere, shumhow, a shuck ish washing you. - Drunken Far Side"";
		editor.setValue(expectedValue.getBytes());
		assertEquals(expectedValue, editor.getAsText());
	}",method,
"	@Test
	public void setValueAsString() throws Exception {
		String expectedValue = ""'Green Wing' - classic British comedy"";
		editor.setValue(expectedValue);
		assertEquals(expectedValue, editor.getAsText());
	}",method,
"	@Test
	public void setValueAsCustomObjectInvokesToString() throws Exception {
		final String expectedValue = ""'Green Wing' - classic British comedy"";
		Object object = new Object() {
			@Override
			public String toString() {
				return expectedValue;
			}
		};
		editor.setValue(object);
		assertEquals(expectedValue, editor.getAsText());
	}",method,
"			@Override
			public String toString() {
				return expectedValue;
			}",method,
"	@Test
	public void setValueAsNullGetsBackEmptyString() throws Exception {
		editor.setValue(null);
		assertEquals("""", editor.getAsText());
	}",method,
"	@Test
	public void setValueAsMultipartFile() throws Exception {
		String expectedValue = ""That is comforting to know"";
		MultipartFile file = mock(MultipartFile.class);
		given(file.getBytes()).willReturn(expectedValue.getBytes());
		editor.setValue(file);
		assertEquals(expectedValue, editor.getAsText());
	}",method,
"	@Test(expected = IllegalArgumentException.class)
	public void setValueAsMultipartFileWithBadBytes() throws Exception {
		MultipartFile file = mock(MultipartFile.class);
		given(file.getBytes()).willThrow(new IOException());
		editor.setValue(file);
	}",method,
"public class RncHighlighter extends SyntaxHighlighterBase {
  @Override
  @NotNull
  public Lexer getHighlightingLexer() {
    return new CompactSyntaxLexerAdapter();
  }
  private static final Map<IElementType, TextAttributesKey> ourMap1;
  static {
    ourMap1 = new HashMap<>();
    fillMap(ourMap1, RncTokenTypes.KEYWORDS, DefaultLanguageHighlighterColors.KEYWORD);
    fillMap(ourMap1, RncTokenTypes.OPERATORS, DefaultLanguageHighlighterColors.OPERATION_SIGN);
    fillMap(ourMap1, RncTokenTypes.STRINGS, DefaultLanguageHighlighterColors.STRING);
    ourMap1.put(RncTokenTypes.LBRACE, DefaultLanguageHighlighterColors.BRACES);
    ourMap1.put(RncTokenTypes.RBRACE, DefaultLanguageHighlighterColors.BRACES);
    ourMap1.put(RncTokenTypes.LBRACKET, DefaultLanguageHighlighterColors.BRACKETS);
    ourMap1.put(RncTokenTypes.RBRACKET, DefaultLanguageHighlighterColors.BRACKETS);
    ourMap1.put(RncTokenTypes.LPAREN, DefaultLanguageHighlighterColors.PARENTHESES);
    ourMap1.put(RncTokenTypes.RPAREN, DefaultLanguageHighlighterColors.PARENTHESES);
    ourMap1.put(RncTokenTypes.COMMA, DefaultLanguageHighlighterColors.COMMA);
    fillMap(ourMap1, RncTokenTypes.DOC_TOKENS, DefaultLanguageHighlighterColors.DOC_COMMENT);
    fillMap(ourMap1, RncTokenTypes.COMMENTS, DefaultLanguageHighlighterColors.LINE_COMMENT);
    fillMap(ourMap1, RncTokenTypes.IDENTIFIERS, DefaultLanguageHighlighterColors.LOCAL_VARIABLE);
    ourMap1.put(RncTokenTypes.ILLEGAL_CHAR, HighlighterColors.BAD_CHARACTER);
  }
  @Override
  @NotNull
  public TextAttributesKey[] getTokenHighlights(IElementType tokenType) {
    return pack(ourMap1.get(tokenType));
  }
}",class,
"  @Override
  @NotNull
  public Lexer getHighlightingLexer() {
    return new CompactSyntaxLexerAdapter();
  }",method,
"  @Override
  @NotNull
  public TextAttributesKey[] getTokenHighlights(IElementType tokenType) {
    return pack(ourMap1.get(tokenType));
  }",method,
"public abstract class DatagramSocketImpl implements SocketOptions {
    protected int localPort;
    protected FileDescriptor fd;
    protected abstract void create() throws SocketException;
    protected abstract void bind(int lport, InetAddress laddr) throws SocketException;
    protected abstract void send(DatagramPacket p) throws IOException;
    protected void connect(InetAddress address, int port) throws SocketException {}
    protected void disconnect() {}
    protected abstract int peek(InetAddress i) throws IOException;
    protected abstract int peekData(DatagramPacket p) throws IOException;
    protected abstract void receive(DatagramPacket p) throws IOException;
    @Deprecated
    protected abstract void setTTL(byte ttl) throws IOException;
    @Deprecated
    protected abstract byte getTTL() throws IOException;
    protected abstract void setTimeToLive(int ttl) throws IOException;
    protected abstract int getTimeToLive() throws IOException;
    protected abstract void join(InetAddress inetaddr) throws IOException;
    protected abstract void leave(InetAddress inetaddr) throws IOException;
    protected abstract void joinGroup(SocketAddress mcastaddr,
                                      NetworkInterface netIf)
        throws IOException;
    protected abstract void leaveGroup(SocketAddress mcastaddr,
                                       NetworkInterface netIf)
        throws IOException;
    protected abstract void close();
    protected int getLocalPort() {
        return localPort;
    }
    protected FileDescriptor getFileDescriptor() {
        return fd;
    }
}",class,
"    protected void connect(InetAddress address, int port) throws SocketException {}",method,
    protected void disconnect() {},method,
"    protected int getLocalPort() {
        return localPort;
    }",method,
"    protected FileDescriptor getFileDescriptor() {
        return fd;
    }",method,
"public class ClassSmartPointerNode extends BaseSmartPointerPsiNode<SmartPsiElementPointer>{
  public ClassSmartPointerNode(Project project, PsiClass value, ViewSettings viewSettings) {
    super(project, SmartPointerManager.getInstance(project).createSmartPsiElementPointer(value), viewSettings);
  }
  public ClassSmartPointerNode(Project project, Object value, ViewSettings viewSettings) {
    this(project, (PsiClass)value, viewSettings);
  }
  @Override
  @NotNull
  public Collection<AbstractTreeNode> getChildrenImpl() {
    PsiClass parent = getPsiClass();
    final ArrayList<AbstractTreeNode> treeNodes = new ArrayList<>();
    ArrayList<PsiElement> result = new ArrayList<>();
    if (getSettings().isShowMembers()) {
      PsiClassChildrenSource.DEFAULT_CHILDREN.addChildren(parent, result);
      for (PsiElement psiElement : result) {
        psiElement.accept(new JavaElementVisitor() {
          @Override public void visitClass(PsiClass aClass) {
            treeNodes.add(new ClassSmartPointerNode(getProject(), aClass, getSettings()));
          }
          @Override public void visitMethod(PsiMethod method) {
            treeNodes.add(new MethodSmartPointerNode(getProject(), method, getSettings()));
          }
          @Override public void visitField(PsiField field) {
            treeNodes.add(new FieldSmartPointerNode(getProject(), field, getSettings()));
          }
          @Override public void visitReferenceExpression(PsiReferenceExpression expression) {
            visitExpression(expression);
          }
        });
      }
    }
    return treeNodes;
  }
  @Override
  public boolean isAlwaysLeaf() {
    return !getSettings().isShowMembers();
  }
  @Override
  public void updateImpl(PresentationData data) {
    final PsiClass aClass = getPsiClass();
    if (aClass != null) {
      data.setPresentableText(aClass.getName());
    }
  }
  public boolean isTopLevel() {
    return getPsiElement() != null && getPsiElement().getParent() instanceof PsiFile;
  }
  @Override
  public boolean expandOnDoubleClick() {
    return false;
  }
  public PsiClass getPsiClass() {
    return (PsiClass)getPsiElement();
  }
  @Override
  public boolean isAlwaysExpand() {
    return getParentValue() instanceof PsiFile;
  }
}",class,
"  public ClassSmartPointerNode(Project project, PsiClass value, ViewSettings viewSettings) {
    super(project, SmartPointerManager.getInstance(project).createSmartPsiElementPointer(value), viewSettings);
  }",method,
"  public ClassSmartPointerNode(Project project, Object value, ViewSettings viewSettings) {
    this(project, (PsiClass)value, viewSettings);
  }",method,
"  @Override
  @NotNull
  public Collection<AbstractTreeNode> getChildrenImpl() {
    PsiClass parent = getPsiClass();
    final ArrayList<AbstractTreeNode> treeNodes = new ArrayList<>();
    ArrayList<PsiElement> result = new ArrayList<>();
    if (getSettings().isShowMembers()) {
      PsiClassChildrenSource.DEFAULT_CHILDREN.addChildren(parent, result);
      for (PsiElement psiElement : result) {
        psiElement.accept(new JavaElementVisitor() {
          @Override public void visitClass(PsiClass aClass) {
            treeNodes.add(new ClassSmartPointerNode(getProject(), aClass, getSettings()));
          }
          @Override public void visitMethod(PsiMethod method) {
            treeNodes.add(new MethodSmartPointerNode(getProject(), method, getSettings()));
          }
          @Override public void visitField(PsiField field) {
            treeNodes.add(new FieldSmartPointerNode(getProject(), field, getSettings()));
          }
          @Override public void visitReferenceExpression(PsiReferenceExpression expression) {
            visitExpression(expression);
          }
        });
      }
    }
    return treeNodes;
  }",method,
"      for (PsiElement psiElement : result) {
        psiElement.accept(new JavaElementVisitor() {
          @Override public void visitClass(PsiClass aClass) {
            treeNodes.add(new ClassSmartPointerNode(getProject(), aClass, getSettings()));
          }
          @Override public void visitMethod(PsiMethod method) {
            treeNodes.add(new MethodSmartPointerNode(getProject(), method, getSettings()));
          }
          @Override public void visitField(PsiField field) {
            treeNodes.add(new FieldSmartPointerNode(getProject(), field, getSettings()));
          }
          @Override public void visitReferenceExpression(PsiReferenceExpression expression) {
            visitExpression(expression);
          }
        });
      }",method,
"        psiElement.accept(new JavaElementVisitor() {
          @Override public void visitClass(PsiClass aClass) {
            treeNodes.add(new ClassSmartPointerNode(getProject(), aClass, getSettings()));
          }
          @Override public void visitMethod(PsiMethod method) {
            treeNodes.add(new MethodSmartPointerNode(getProject(), method, getSettings()));
          }
          @Override public void visitField(PsiField field) {
            treeNodes.add(new FieldSmartPointerNode(getProject(), field, getSettings()));
          }
          @Override public void visitReferenceExpression(PsiReferenceExpression expression) {
            visitExpression(expression);
          }
        }",method,
"  @Override
  public boolean isAlwaysLeaf() {
    return !getSettings().isShowMembers();
  }",method,
"  @Override
  public void updateImpl(PresentationData data) {
    final PsiClass aClass = getPsiClass();
    if (aClass != null) {
      data.setPresentableText(aClass.getName());
    }
  }",method,
"    if (aClass != null) {
      data.setPresentableText(aClass.getName());
    }",method,
"  public boolean isTopLevel() {
    return getPsiElement() != null && getPsiElement().getParent() instanceof PsiFile;
  }",method,
"  @Override
  public boolean expandOnDoubleClick() {
    return false;
  }",method,
"  public PsiClass getPsiClass() {
    return (PsiClass)getPsiElement();
  }",method,
"  @Override
  public boolean isAlwaysExpand() {
    return getParentValue() instanceof PsiFile;
  }",method,
"public abstract class Transformation {
  public boolean couldApply(@NotNull GrMethodCall methodCall, @NotNull Options options) {
    return couldApplyInternal(methodCall, options) && (!options.withoutAdditionalParentheses() || !needParentheses(methodCall, options));
  }
  protected abstract boolean couldApplyInternal(@NotNull GrMethodCall methodCall, @NotNull Options options);
  protected abstract boolean needParentheses(@NotNull GrMethodCall methodCall, @NotNull Options options);
  public abstract void apply(@NotNull GrMethodCall methodCall, @NotNull Options options);
  @Nullable
  public static GrExpression getBase(@NotNull GrMethodCall callExpression) {
    GrExpression expression = callExpression.getInvokedExpression();
    GrReferenceExpression invokedExpression = (GrReferenceExpression)expression;
    GrExpression qualifier = invokedExpression.getQualifierExpression();
    if (isSuperExpression(qualifier)) return null;
    return qualifier;
  }
  public boolean checkArgumentsCount(@NotNull GrMethodCall callExpression, int count) {
    if (callExpression.getNamedArguments().length != 0) return false;
    return callExpression.getExpressionArguments().length + callExpression.getClosureArguments().length ==  count;
  }
  @NotNull
  public GrExpression getArgument(@NotNull GrMethodCall callExpression, int index) {
    GrExpression[] expressionArguments = callExpression.getExpressionArguments();
    if (index < expressionArguments.length) {
      return expressionArguments[index];
    }
    return callExpression.getClosureArguments()[index - expressionArguments.length];
  }
}",class,
"  public boolean couldApply(@NotNull GrMethodCall methodCall, @NotNull Options options) {
    return couldApplyInternal(methodCall, options) && (!options.withoutAdditionalParentheses() || !needParentheses(methodCall, options));
  }",method,
"  @Nullable
  public static GrExpression getBase(@NotNull GrMethodCall callExpression) {
    GrExpression expression = callExpression.getInvokedExpression();
    GrReferenceExpression invokedExpression = (GrReferenceExpression)expression;
    GrExpression qualifier = invokedExpression.getQualifierExpression();
    if (isSuperExpression(qualifier)) return null;
    return qualifier;
  }",method,
"  public boolean checkArgumentsCount(@NotNull GrMethodCall callExpression, int count) {
    if (callExpression.getNamedArguments().length != 0) return false;
    return callExpression.getExpressionArguments().length + callExpression.getClosureArguments().length ==  count;
  }",method,
"  @NotNull
  public GrExpression getArgument(@NotNull GrMethodCall callExpression, int index) {
    GrExpression[] expressionArguments = callExpression.getExpressionArguments();
    if (index < expressionArguments.length) {
      return expressionArguments[index];
    }
    return callExpression.getClosureArguments()[index - expressionArguments.length];
  }",method,
"    if (index < expressionArguments.length) {
      return expressionArguments[index];
    }",method,
"public class MemberClassAccessFilter
implements   MemberVisitor
{
    private final Clazz         referencingClass;
    private final MemberVisitor memberVisitor;
    public MemberClassAccessFilter(Clazz         referencingClass,
                                   MemberVisitor memberVisitor)
    {
        this.referencingClass = referencingClass;
        this.memberVisitor    = memberVisitor;
    }
    // Implementations for MemberVisitor.
    public void visitProgramField(ProgramClass programClass, ProgramField programField)
    {
        if (accepted(programClass, programField.getAccessFlags()))
        {
            memberVisitor.visitProgramField(programClass, programField);
        }
    }
    public void visitProgramMethod(ProgramClass programClass, ProgramMethod programMethod)
    {
        if (accepted(programClass, programMethod.getAccessFlags()))
        {
            memberVisitor.visitProgramMethod(programClass, programMethod);
        }
    }
    public void visitLibraryField(LibraryClass libraryClass, LibraryField libraryField)
    {
        if (accepted(libraryClass, libraryField.getAccessFlags()))
        {
            memberVisitor.visitLibraryField(libraryClass, libraryField);
        }
    }
    public void visitLibraryMethod(LibraryClass libraryClass, LibraryMethod libraryMethod)
    {
        if (accepted(libraryClass, libraryMethod.getAccessFlags()))
        {
            memberVisitor.visitLibraryMethod(libraryClass, libraryMethod);
        }
    }
    // Small utility methods.
    private boolean accepted(Clazz clazz, int memberAccessFlags)
    {
        int accessLevel = AccessUtil.accessLevel(memberAccessFlags);
        return
            (accessLevel >= AccessUtil.PUBLIC                                                              ) ||
            (accessLevel >= AccessUtil.PRIVATE         && referencingClass.equals(clazz)                   ) ||
            (accessLevel >= AccessUtil.PACKAGE_VISIBLE && (ClassUtil.internalPackageName(referencingClass.getName()).equals(
                                                           ClassUtil.internalPackageName(clazz.getName())))) ||
            (accessLevel >= AccessUtil.PROTECTED       && (referencingClass.extends_(clazz)                  ||
                                                           referencingClass.extendsOrImplements(clazz))            );
    }
}",class,
"    public MemberClassAccessFilter(Clazz         referencingClass,
                                   MemberVisitor memberVisitor)
    {
        this.referencingClass = referencingClass;
        this.memberVisitor    = memberVisitor;
    }",method,
"    public void visitProgramField(ProgramClass programClass, ProgramField programField)
    {
        if (accepted(programClass, programField.getAccessFlags()))
        {
            memberVisitor.visitProgramField(programClass, programField);
        }
    }",method,
"    public void visitProgramMethod(ProgramClass programClass, ProgramMethod programMethod)
    {
        if (accepted(programClass, programMethod.getAccessFlags()))
        {
            memberVisitor.visitProgramMethod(programClass, programMethod);
        }
    }",method,
"    public void visitLibraryField(LibraryClass libraryClass, LibraryField libraryField)
    {
        if (accepted(libraryClass, libraryField.getAccessFlags()))
        {
            memberVisitor.visitLibraryField(libraryClass, libraryField);
        }
    }",method,
"    public void visitLibraryMethod(LibraryClass libraryClass, LibraryMethod libraryMethod)
    {
        if (accepted(libraryClass, libraryMethod.getAccessFlags()))
        {
            memberVisitor.visitLibraryMethod(libraryClass, libraryMethod);
        }
    }",method,
"    private boolean accepted(Clazz clazz, int memberAccessFlags)
    {
        int accessLevel = AccessUtil.accessLevel(memberAccessFlags);
        return
            (accessLevel >= AccessUtil.PUBLIC                                                              ) ||
            (accessLevel >= AccessUtil.PRIVATE         && referencingClass.equals(clazz)                   ) ||
            (accessLevel >= AccessUtil.PACKAGE_VISIBLE && (ClassUtil.internalPackageName(referencingClass.getName()).equals(
                                                           ClassUtil.internalPackageName(clazz.getName())))) ||
            (accessLevel >= AccessUtil.PROTECTED       && (referencingClass.extends_(clazz)                  ||
                                                           referencingClass.extendsOrImplements(clazz))            );
    }",method,
"  static BuckJavacTaskProxy getTask(
      PluginClassLoaderFactory loaderFactory,
      JavaCompiler compiler,
      Writer out,
      JavaFileManager fileManager,
      DiagnosticListener<? super JavaFileObject> diagnosticListener,
      Iterable<String> options,
      Iterable<String> classes,
      Iterable<? extends JavaFileObject> compilationUnits) {
    JavaCompiler.CompilationTask task =
        compiler.getTask(out, fileManager, diagnosticListener, options, classes, compilationUnits);
    PluginClassLoader loader = loaderFactory.getPluginClassLoader(task);
    Class<? extends BuckJavacTaskProxy> proxyImplClass =
        loader.loadClass(
            ""com.facebook.buck.jvm.java.plugin.adapter.BuckJavacTaskProxyImpl"",
            BuckJavacTaskProxy.class);
    try {
      return proxyImplClass.getConstructor(JavaCompiler.CompilationTask.class).newInstance(task);
    } catch (ReflectiveOperationException e) {
      throw new RuntimeException(e);
    }
  }",method,
"public class NWalign {
	private static final Logger logger = Logger.getLogger(NWalign.class.getName());
	public static void main(String[] args) {
	    logger.info( Commons.getJAlignerInfo() ); 
        if (args.length < 3) {
			logger.severe( ""Invalid number of arguments: "" + args.length );
			printUsage();
			System.exit(1);
        } else {
			try {
				String f1 = args[0];					// file name of sequence #1
				String f2 = args[1];					// file name of sequence #1
				String mode = args[2]; // S or N  (smith-waterman or needleman-wunsch)
				//String m = args[2];						// scoring matrix id or file name user-defined scoring matrix
				//float o = Float.parseFloat(args[3]);	// open gap penalty
				//float e = Float.parseFloat(args[4]);	// extend gap penalty
				Sequence s1 = SequenceParser.parse(new File(f1));
				Sequence s2 = SequenceParser.parse(new File(f2));
				int match_score = 4;
				int mismatch_penalty = -5;
				int open_penalty = 10;
				int extend_penalty = 1;
				Matrix matrix = MatrixGenerator.generate(match_score, mismatch_penalty);
				//Matrix matrix = MatrixLoader.load(m);
				Alignment alignment;
				if (mode.equals(""S"")) {
					alignment = SmithWatermanGotoh.align (s1, s2, matrix, open_penalty, extend_penalty);
				}
				else if (mode.equals(""N"")){
					alignment = NeedlemanWunschGotoh.align(s1, s2, matrix, open_penalty, extend_penalty);
				}
				else if (mode.equals(""NB"")) {
					int bandwidth = Integer.parseInt(args[3]);
					alignment = NeedlemanWunschGotohBanded.align(s1, s2, matrix, open_penalty, extend_penalty, bandwidth);
				}
				else {
					printUsage();
					throw new RuntimeException(""error"");
				}
				System.out.println (alignment.getSummary());
				System.out.println (new Pair().format(alignment));
				AlignmentStats stats = get_alignment_stats(alignment);
				int alignment_length = stats.alignment_length;
				int matches = stats.matches;
				int mismatches = stats.mismatches;
				int gaps = stats.gaps;
				float percent_A_in_alignment = (float) stats.get_count_of_bases_in_aligned_region(s1.getId()) / (s1.length()) * 100;
				float percent_B_in_alignment = (float) stats.get_count_of_bases_in_aligned_region(s2.getId()) / (s2.length()) * 100;
				float max_percent_aligned = Math.max(percent_A_in_alignment, percent_B_in_alignment);
				float percent_identity = (float)matches/(matches+mismatches) * 100;
				float percent_gapped = (float)gaps/alignment_length * 100;
				System.out.println(""Matches: "" + matches + "", Mismatches: "" + mismatches + "", gaps: "" + gaps + "", align_len: "" + alignment_length);
				System.out.println(""percent_identity: "" + percent_identity + "", percent_gapped: "" + percent_gapped);
				System.out.println(""max_percent_aligned: "" + max_percent_aligned + ""\n"");
			} catch (Exception e) {
				logger.log(Level.SEVERE, ""Failed processing the command line: "" + e.getMessage(), e); 
				System.exit(1);
			}
		} 
	}
	private static void printUsage( ) {
		StringBuffer buffer = new StringBuffer();
		buffer.append ( ""\n"" );
		buffer.append ( ""Usage:\n"" );
		buffer.append ( ""------\n"" );
		buffer.append ( ""java -jar jaligner.jar <s1> <s2> (S, N, or NB) [bandwidth=10]\n"" );
		buffer.append(""\tS: Smith-Waterman\n"");
		buffer.append(""\tN: Needleman-Wunsch\n"");
		buffer.append ( ""\n"" ) ;
		logger.info(buffer.toString());
	}
	// utility methods:
	public static Alignment run_SW_alignment(String name1, String s1, String name2, String s2, int match, int mismatch, int open, int extend) {
		Matrix matrix = MatrixGenerator.generate(match, mismatch);
		Sequence seq1 = new Sequence(name1, s1);
		Sequence seq2 = new Sequence(name2, s2);
		Alignment alignment = SmithWatermanGotoh.align(seq1, seq2, matrix, open, extend);
		return(alignment);
	}
	public static Alignment run_NW_alignment(String name1, String s1, String name2, String s2, 
				int match, int mismatch, int open, int extend) {
		Matrix matrix = MatrixGenerator.generate(match, mismatch);
		Sequence seq1 = new Sequence(name1, s1);
		Sequence seq2 = new Sequence(name2, s2);
		Alignment alignment = NeedlemanWunschGotoh.align(seq1, seq2, matrix, open, extend);
		return(alignment);
	}
	public static Alignment run_NW_banded_alignment(String name1, String s1, String name2, String s2, 
			int match, int mismatch, int open, int extend, int bandwidth) {
		Matrix matrix = MatrixGenerator.generate(match, mismatch);
		Sequence seq1 = new Sequence(name1, s1);
		Sequence seq2 = new Sequence(name2, s2);
		Alignment alignment = NeedlemanWunschGotohBanded.align(seq1, seq2, matrix, open, extend, bandwidth);
		return(alignment);
	}
	public static AlignmentStats get_alignment_stats(Alignment a) {
		AlignmentStats stats = new AlignmentStats(a);
		return(stats);
	}
}",class,
"	public static void main(String[] args) {
	    logger.info( Commons.getJAlignerInfo() ); 
        if (args.length < 3) {
			logger.severe( ""Invalid number of arguments: "" + args.length );
			printUsage();
			System.exit(1);
        } else {
			try {
				String f1 = args[0];					// file name of sequence #1
				String f2 = args[1];					// file name of sequence #1
				String mode = args[2]; // S or N  (smith-waterman or needleman-wunsch)
				//String m = args[2];						// scoring matrix id or file name user-defined scoring matrix
				//float o = Float.parseFloat(args[3]);	// open gap penalty
				//float e = Float.parseFloat(args[4]);	// extend gap penalty
				Sequence s1 = SequenceParser.parse(new File(f1));
				Sequence s2 = SequenceParser.parse(new File(f2));
				int match_score = 4;
				int mismatch_penalty = -5;
				int open_penalty = 10;
				int extend_penalty = 1;
				Matrix matrix = MatrixGenerator.generate(match_score, mismatch_penalty);
				//Matrix matrix = MatrixLoader.load(m);
				Alignment alignment;
				if (mode.equals(""S"")) {
					alignment = SmithWatermanGotoh.align (s1, s2, matrix, open_penalty, extend_penalty);
				}
				else if (mode.equals(""N"")){
					alignment = NeedlemanWunschGotoh.align(s1, s2, matrix, open_penalty, extend_penalty);
				}
				else if (mode.equals(""NB"")) {
					int bandwidth = Integer.parseInt(args[3]);
					alignment = NeedlemanWunschGotohBanded.align(s1, s2, matrix, open_penalty, extend_penalty, bandwidth);
				}
				else {
					printUsage();
					throw new RuntimeException(""error"");
				}
				System.out.println (alignment.getSummary());
				System.out.println (new Pair().format(alignment));
				AlignmentStats stats = get_alignment_stats(alignment);
				int alignment_length = stats.alignment_length;
				int matches = stats.matches;
				int mismatches = stats.mismatches;
				int gaps = stats.gaps;
				float percent_A_in_alignment = (float) stats.get_count_of_bases_in_aligned_region(s1.getId()) / (s1.length()) * 100;
				float percent_B_in_alignment = (float) stats.get_count_of_bases_in_aligned_region(s2.getId()) / (s2.length()) * 100;
				float max_percent_aligned = Math.max(percent_A_in_alignment, percent_B_in_alignment);
				float percent_identity = (float)matches/(matches+mismatches) * 100;
				float percent_gapped = (float)gaps/alignment_length * 100;
				System.out.println(""Matches: "" + matches + "", Mismatches: "" + mismatches + "", gaps: "" + gaps + "", align_len: "" + alignment_length);
				System.out.println(""percent_identity: "" + percent_identity + "", percent_gapped: "" + percent_gapped);
				System.out.println(""max_percent_aligned: "" + max_percent_aligned + ""\n"");
			} catch (Exception e) {
				logger.log(Level.SEVERE, ""Failed processing the command line: "" + e.getMessage(), e); 
				System.exit(1);
			}
		} 
	}",method,
"        if (args.length < 3) {
			logger.severe( ""Invalid number of arguments: "" + args.length );
			printUsage();
			System.exit(1);
        }",method,
"	private static void printUsage( ) {
		StringBuffer buffer = new StringBuffer();
		buffer.append ( ""\n"" );
		buffer.append ( ""Usage:\n"" );
		buffer.append ( ""------\n"" );
		buffer.append ( ""java -jar jaligner.jar <s1> <s2> (S, N, or NB) [bandwidth=10]\n"" );
		buffer.append(""\tS: Smith-Waterman\n"");
		buffer.append(""\tN: Needleman-Wunsch\n"");
		buffer.append ( ""\n"" ) ;
		logger.info(buffer.toString());
	}",method,
"	public static Alignment run_SW_alignment(String name1, String s1, String name2, String s2, int match, int mismatch, int open, int extend) {
		Matrix matrix = MatrixGenerator.generate(match, mismatch);
		Sequence seq1 = new Sequence(name1, s1);
		Sequence seq2 = new Sequence(name2, s2);
		Alignment alignment = SmithWatermanGotoh.align(seq1, seq2, matrix, open, extend);
		return(alignment);
	}",method,
"	public static Alignment run_NW_alignment(String name1, String s1, String name2, String s2, 
				int match, int mismatch, int open, int extend) {
		Matrix matrix = MatrixGenerator.generate(match, mismatch);
		Sequence seq1 = new Sequence(name1, s1);
		Sequence seq2 = new Sequence(name2, s2);
		Alignment alignment = NeedlemanWunschGotoh.align(seq1, seq2, matrix, open, extend);
		return(alignment);
	}",method,
"	public static Alignment run_NW_banded_alignment(String name1, String s1, String name2, String s2, 
			int match, int mismatch, int open, int extend, int bandwidth) {
		Matrix matrix = MatrixGenerator.generate(match, mismatch);
		Sequence seq1 = new Sequence(name1, s1);
		Sequence seq2 = new Sequence(name2, s2);
		Alignment alignment = NeedlemanWunschGotohBanded.align(seq1, seq2, matrix, open, extend, bandwidth);
		return(alignment);
	}",method,
"	public static AlignmentStats get_alignment_stats(Alignment a) {
		AlignmentStats stats = new AlignmentStats(a);
		return(stats);
	}",method,
"public final class ApfProgramEvent implements Parcelable {
    // Bitflag constants describing what an Apf program filters.
    // Bits are indexeds from LSB to MSB, starting at index 0.
    public static final int FLAG_MULTICAST_FILTER_ON = 0;
    public static final int FLAG_HAS_IPV4_ADDRESS    = 1;
    @IntDef(flag = true, value = {FLAG_MULTICAST_FILTER_ON, FLAG_HAS_IPV4_ADDRESS})
    @Retention(RetentionPolicy.SOURCE)
    public @interface Flags {}
    public long lifetime;       // Maximum computed lifetime of the program in seconds
    public long actualLifetime; // Effective program lifetime in seconds
    public int filteredRas;     // Number of RAs filtered by the APF program
    public int currentRas;      // Total number of current RAs at generation time
    public int programLength;   // Length of the APF program in bytes
    public int flags;           // Bitfield compound of FLAG_* constants
    public ApfProgramEvent() {
    }
    private ApfProgramEvent(Parcel in) {
        this.lifetime = in.readLong();
        this.actualLifetime = in.readLong();
        this.filteredRas = in.readInt();
        this.currentRas = in.readInt();
        this.programLength = in.readInt();
        this.flags = in.readInt();
    }
    @Override
    public void writeToParcel(Parcel out, int flags) {
        out.writeLong(lifetime);
        out.writeLong(actualLifetime);
        out.writeInt(filteredRas);
        out.writeInt(currentRas);
        out.writeInt(programLength);
        out.writeInt(flags);
    }
    @Override
    public int describeContents() {
        return 0;
    }
    @Override
    public String toString() {
        String lifetimeString = (lifetime < Long.MAX_VALUE) ? lifetime + ""s"" : ""forever"";
        return String.format(""ApfProgramEvent(%d/%d RAs %dB %ds/%s %s)"", filteredRas, currentRas,
                programLength, actualLifetime, lifetimeString, namesOf(flags));
    }
    public static final Parcelable.Creator<ApfProgramEvent> CREATOR
            = new Parcelable.Creator<ApfProgramEvent>() {
        public ApfProgramEvent createFromParcel(Parcel in) {
            return new ApfProgramEvent(in);
        }
        public ApfProgramEvent[] newArray(int size) {
            return new ApfProgramEvent[size];
        }
    };
    public static @Flags int flagsFor(boolean hasIPv4, boolean multicastFilterOn) {
        int bitfield = 0;
        if (hasIPv4) {
            bitfield |= (1 << FLAG_HAS_IPV4_ADDRESS);
        }
        if (multicastFilterOn) {
            bitfield |= (1 << FLAG_MULTICAST_FILTER_ON);
        }
        return bitfield;
    }
    private static String namesOf(@Flags int bitfield) {
        List<String> names = new ArrayList<>(Integer.bitCount(bitfield));
        BitSet set = BitSet.valueOf(new long[]{bitfield & Integer.MAX_VALUE});
        // Only iterate over flag bits which are set.
        for (int bit = set.nextSetBit(0); bit >= 0; bit = set.nextSetBit(bit+1)) {
            names.add(Decoder.constants.get(bit));
        }
        return TextUtils.join(""|"", names);
    }
    final static class Decoder {
        static final SparseArray<String> constants =
                MessageUtils.findMessageNames(
                       new Class[]{ApfProgramEvent.class}, new String[]{""FLAG_""});
    }
}",class,
"    final static class Decoder {
        static final SparseArray<String> constants =
                MessageUtils.findMessageNames(
                       new Class[]{ApfProgramEvent.class}, new String[]{""FLAG_""});
    }",class,
"    public ApfProgramEvent() {
    }",method,
"    private ApfProgramEvent(Parcel in) {
        this.lifetime = in.readLong();
        this.actualLifetime = in.readLong();
        this.filteredRas = in.readInt();
        this.currentRas = in.readInt();
        this.programLength = in.readInt();
        this.flags = in.readInt();
    }",method,
"    @Override
    public void writeToParcel(Parcel out, int flags) {
        out.writeLong(lifetime);
        out.writeLong(actualLifetime);
        out.writeInt(filteredRas);
        out.writeInt(currentRas);
        out.writeInt(programLength);
        out.writeInt(flags);
    }",method,
"    @Override
    public int describeContents() {
        return 0;
    }",method,
"    @Override
    public String toString() {
        String lifetimeString = (lifetime < Long.MAX_VALUE) ? lifetime + ""s"" : ""forever"";
        return String.format(""ApfProgramEvent(%d/%d RAs %dB %ds/%s %s)"", filteredRas, currentRas,
                programLength, actualLifetime, lifetimeString, namesOf(flags));
    }",method,
"        public ApfProgramEvent createFromParcel(Parcel in) {
            return new ApfProgramEvent(in);
        }",method,
"        public ApfProgramEvent[] newArray(int size) {
            return new ApfProgramEvent[size];
        }",method,
"        if (hasIPv4) {
            bitfield |= (1 << FLAG_HAS_IPV4_ADDRESS);
        }",method,
"        if (multicastFilterOn) {
            bitfield |= (1 << FLAG_MULTICAST_FILTER_ON);
        }",method,
"    private static String namesOf(@Flags int bitfield) {
        List<String> names = new ArrayList<>(Integer.bitCount(bitfield));
        BitSet set = BitSet.valueOf(new long[]{bitfield & Integer.MAX_VALUE});
        // Only iterate over flag bits which are set.
        for (int bit = set.nextSetBit(0); bit >= 0; bit = set.nextSetBit(bit+1)) {
            names.add(Decoder.constants.get(bit));
        }
        return TextUtils.join(""|"", names);
    }",method,
"public class TravelTele extends SimpleImplementation {
	@Override
	protected String getDomain() {
		return ""traveltele.net"";
	}
	@Override
	protected String getDefaultName() {
		return ""Travel Telekom"";
	}
	//Customization
	@Override
	public void fillLayout(final SipProfile account) {
		super.fillLayout(account);
		accountUsername.setTitle(R.string.w_common_phone_number);
		accountUsername.setDialogTitle(parent.getString(R.string.w_common_phone_number ) + "" (without +)"");
		accountUsername.getEditText().setInputType(InputType.TYPE_CLASS_PHONE);
	}
	@Override
	public String getDefaultFieldSummary(String fieldName) {
		if(fieldName.equals(USER_NAME)) {
			return parent.getString(R.string.w_common_phone_number_desc) + "" (without +)"";
		}
		return super.getDefaultFieldSummary(fieldName);
	}
	public SipProfile buildAccount(SipProfile account) {
		account = super.buildAccount(account);
		account.proxies = new String[] {""sip:sip.traveltele.net""};
		return account;
	}
}",class,
"	@Override
	protected String getDomain() {
		return ""traveltele.net"";
	}",method,
"	@Override
	protected String getDefaultName() {
		return ""Travel Telekom"";
	}",method,
"	@Override
	public void fillLayout(final SipProfile account) {
		super.fillLayout(account);
		accountUsername.setTitle(R.string.w_common_phone_number);
		accountUsername.setDialogTitle(parent.getString(R.string.w_common_phone_number ) + "" (without +)"");
		accountUsername.getEditText().setInputType(InputType.TYPE_CLASS_PHONE);
	}",method,

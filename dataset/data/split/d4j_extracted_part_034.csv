code_snippet,type,score
"  @Override
  public boolean equals(Object obj) {
    if (obj instanceof TypeHierarchyItem) {
      TypeHierarchyItem other = (TypeHierarchyItem) obj;
      return
        ObjectUtilities.equals(other.classElement, classElement) &&
        ObjectUtilities.equals(other.displayName, displayName) &&
        ObjectUtilities.equals(other.memberElement, memberElement) &&
        ObjectUtilities.equals(other.superclass, superclass) &&
        Arrays.equals(other.interfaces, interfaces) &&
        Arrays.equals(other.mixins, mixins) &&
        Arrays.equals(other.subclasses, subclasses);
    }
    return false;
  }",method,
"    if (obj instanceof TypeHierarchyItem) {
      TypeHierarchyItem other = (TypeHierarchyItem) obj;
      return
        ObjectUtilities.equals(other.classElement, classElement) &&
        ObjectUtilities.equals(other.displayName, displayName) &&
        ObjectUtilities.equals(other.memberElement, memberElement) &&
        ObjectUtilities.equals(other.superclass, superclass) &&
        Arrays.equals(other.interfaces, interfaces) &&
        Arrays.equals(other.mixins, mixins) &&
        Arrays.equals(other.subclasses, subclasses);
    }",method,
"  public static TypeHierarchyItem fromJson(JsonObject jsonObject) {
    Element classElement = Element.fromJson(jsonObject.get(""classElement"").getAsJsonObject());
    String displayName = jsonObject.get(""displayName"") == null ? null : jsonObject.get(""displayName"").getAsString();
    Element memberElement = jsonObject.get(""memberElement"") == null ? null : Element.fromJson(jsonObject.get(""memberElement"").getAsJsonObject());
    Integer superclass = jsonObject.get(""superclass"") == null ? null : jsonObject.get(""superclass"").getAsInt();
    int[] interfaces = JsonUtilities.decodeIntArray(jsonObject.get(""interfaces"").getAsJsonArray());
    int[] mixins = JsonUtilities.decodeIntArray(jsonObject.get(""mixins"").getAsJsonArray());
    int[] subclasses = JsonUtilities.decodeIntArray(jsonObject.get(""subclasses"").getAsJsonArray());
    return new TypeHierarchyItem(classElement, displayName, memberElement, superclass, interfaces, mixins, subclasses);
  }",method,
"  public static List<TypeHierarchyItem> fromJsonArray(JsonArray jsonArray) {
    if (jsonArray == null) {
      return EMPTY_LIST;
    }
    ArrayList<TypeHierarchyItem> list = new ArrayList<TypeHierarchyItem>(jsonArray.size());
    Iterator<JsonElement> iterator = jsonArray.iterator();
    while (iterator.hasNext()) {
      list.add(fromJson(iterator.next().getAsJsonObject()));
    }
    return list;
  }",method,
"    if (jsonArray == null) {
      return EMPTY_LIST;
    }",method,
"  public String getBestName() {
    if (displayName == null) {
      return classElement.getName();
    } else {
      return displayName;
    }
  }",method,
"    if (displayName == null) {
      return classElement.getName();
    }",method,
"  public Element getClassElement() {
    return classElement;
  }",method,
"  public String getDisplayName() {
    return displayName;
  }",method,
"  public int[] getInterfaces() {
    return interfaces;
  }",method,
"  public Element getMemberElement() {
    return memberElement;
  }",method,
"  public int[] getMixins() {
    return mixins;
  }",method,
"  public int[] getSubclasses() {
    return subclasses;
  }",method,
"  public Integer getSuperclass() {
    return superclass;
  }",method,
"  @Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    builder.append(classElement);
    builder.append(displayName);
    builder.append(memberElement);
    builder.append(superclass);
    builder.append(interfaces);
    builder.append(mixins);
    builder.append(subclasses);
    return builder.toHashCode();
  }",method,
"  public JsonObject toJson() {
    JsonObject jsonObject = new JsonObject();
    jsonObject.add(""classElement"", classElement.toJson());
    if (displayName != null) {
      jsonObject.addProperty(""displayName"", displayName);
    }
    if (memberElement != null) {
      jsonObject.add(""memberElement"", memberElement.toJson());
    }
    if (superclass != null) {
      jsonObject.addProperty(""superclass"", superclass);
    }
    JsonArray jsonArrayInterfaces = new JsonArray();
    for (int elt : interfaces) {
      jsonArrayInterfaces.add(new JsonPrimitive(elt));
    }
    jsonObject.add(""interfaces"", jsonArrayInterfaces);
    JsonArray jsonArrayMixins = new JsonArray();
    for (int elt : mixins) {
      jsonArrayMixins.add(new JsonPrimitive(elt));
    }
    jsonObject.add(""mixins"", jsonArrayMixins);
    JsonArray jsonArraySubclasses = new JsonArray();
    for (int elt : subclasses) {
      jsonArraySubclasses.add(new JsonPrimitive(elt));
    }
    jsonObject.add(""subclasses"", jsonArraySubclasses);
    return jsonObject;
  }",method,
"    if (displayName != null) {
      jsonObject.addProperty(""displayName"", displayName);
    }",method,
"    if (memberElement != null) {
      jsonObject.add(""memberElement"", memberElement.toJson());
    }",method,
"    if (superclass != null) {
      jsonObject.addProperty(""superclass"", superclass);
    }",method,
"    for (int elt : interfaces) {
      jsonArrayInterfaces.add(new JsonPrimitive(elt));
    }",method,
"    for (int elt : mixins) {
      jsonArrayMixins.add(new JsonPrimitive(elt));
    }",method,
"    for (int elt : subclasses) {
      jsonArraySubclasses.add(new JsonPrimitive(elt));
    }",method,
"  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(""["");
    builder.append(""classElement="");
    builder.append(classElement + "", "");
    builder.append(""displayName="");
    builder.append(displayName + "", "");
    builder.append(""memberElement="");
    builder.append(memberElement + "", "");
    builder.append(""superclass="");
    builder.append(superclass + "", "");
    builder.append(""interfaces="");
    builder.append(StringUtils.join(interfaces, "", "") + "", "");
    builder.append(""mixins="");
    builder.append(StringUtils.join(mixins, "", "") + "", "");
    builder.append(""subclasses="");
    builder.append(StringUtils.join(subclasses, "", ""));
    builder.append(""]"");
    return builder.toString();
  }",method,
"public class ArithmeticBinaryExpression
        extends Expression
{
    public enum Type
    {
        ADD(""+""),
        SUBTRACT(""-""),
        MULTIPLY(""*""),
        DIVIDE(""/""),
        MODULUS(""%"");
        private final String value;
        Type(String value)
        {
            this.value = value;
        }
        public String getValue()
        {
            return value;
        }
    }
    private final Type type;
    private final Expression left;
    private final Expression right;
    public ArithmeticBinaryExpression(Type type, Expression left, Expression right)
    {
        this(Optional.empty(), type, left, right);
    }
    public ArithmeticBinaryExpression(NodeLocation location, Type type, Expression left, Expression right)
    {
        this(Optional.of(location), type, left, right);
    }
    private ArithmeticBinaryExpression(Optional<NodeLocation> location, Type type, Expression left, Expression right)
    {
        super(location);
        this.type = type;
        this.left = left;
        this.right = right;
    }
    public Type getType()
    {
        return type;
    }
    public Expression getLeft()
    {
        return left;
    }
    public Expression getRight()
    {
        return right;
    }
    @Override
    public <R, C> R accept(AstVisitor<R, C> visitor, C context)
    {
        return visitor.visitArithmeticBinary(this, context);
    }
    @Override
    public List<Node> getChildren()
    {
        return ImmutableList.of(left, right);
    }
    @Override
    public boolean equals(Object o)
    {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ArithmeticBinaryExpression that = (ArithmeticBinaryExpression) o;
        return (type == that.type) &&
                Objects.equals(left, that.left) &&
                Objects.equals(right, that.right);
    }
    @Override
    public int hashCode()
    {
        return Objects.hash(type, left, right);
    }
}",class,
"        Type(String value)
        {
            this.value = value;
        }",method,
"        public String getValue()
        {
            return value;
        }",method,
"    public ArithmeticBinaryExpression(Type type, Expression left, Expression right)
    {
        this(Optional.empty(), type, left, right);
    }",method,
"    public ArithmeticBinaryExpression(NodeLocation location, Type type, Expression left, Expression right)
    {
        this(Optional.of(location), type, left, right);
    }",method,
"    private ArithmeticBinaryExpression(Optional<NodeLocation> location, Type type, Expression left, Expression right)
    {
        super(location);
        this.type = type;
        this.left = left;
        this.right = right;
    }",method,
"    public Type getType()
    {
        return type;
    }",method,
"    public Expression getLeft()
    {
        return left;
    }",method,
"    public Expression getRight()
    {
        return right;
    }",method,
"    @Override
    public <R, C> R accept(AstVisitor<R, C> visitor, C context)
    {
        return visitor.visitArithmeticBinary(this, context);
    }",method,
"    @Override
    public List<Node> getChildren()
    {
        return ImmutableList.of(left, right);
    }",method,
"    @Override
    public boolean equals(Object o)
    {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ArithmeticBinaryExpression that = (ArithmeticBinaryExpression) o;
        return (type == that.type) &&
                Objects.equals(left, that.left) &&
                Objects.equals(right, that.right);
    }",method,
"        if (this == o) {
            return true;
        }",method,
"    @Override
    public int hashCode()
    {
        return Objects.hash(type, left, right);
    }",method,
"public class ScrimInsetsScrollView extends ScrollView {
    private Drawable mInsetForeground;
    private Rect mInsets;
    private Rect mTempRect = new Rect();
    private OnInsetsCallback mOnInsetsCallback;
    public ScrimInsetsScrollView(Context context) {
        super(context);
        init(context, null, 0);
    }
    public ScrimInsetsScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context, attrs, 0);
    }
    public ScrimInsetsScrollView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init(context, attrs, defStyle);
    }
    private void init(Context context, AttributeSet attrs, int defStyle) {
        final TypedArray a = context.obtainStyledAttributes(attrs,
                R.styleable.ScrimInsetsView, defStyle, 0);
        if (a == null) {
            return;
        }
        mInsetForeground = a.getDrawable(R.styleable.ScrimInsetsView_insetForeground);
        a.recycle();
        setWillNotDraw(true);
    }
    @Override
    protected boolean fitSystemWindows(Rect insets) {
        mInsets = new Rect(insets);
        setWillNotDraw(mInsetForeground == null);
        ViewCompat.postInvalidateOnAnimation(this);
        if (mOnInsetsCallback != null) {
            mOnInsetsCallback.onInsetsChanged(insets);
        }
        return true; // consume insets
    }
    @Override
    public void draw(Canvas canvas) {
        super.draw(canvas);
        int width = getWidth();
        int height = getHeight();
        if (mInsets != null && mInsetForeground != null) {
            int sc = canvas.save();
            canvas.translate(getScrollX(), getScrollY());
            // Top
            mTempRect.set(0, 0, width, mInsets.top);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Bottom
            mTempRect.set(0, height - mInsets.bottom, width, height);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Left
            mTempRect.set(0, mInsets.top, mInsets.left, height - mInsets.bottom);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Right
            mTempRect.set(width - mInsets.right, mInsets.top, width, height - mInsets.bottom);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            canvas.restoreToCount(sc);
        }
    }
    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (mInsetForeground != null) {
            mInsetForeground.setCallback(this);
        }
    }
    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (mInsetForeground != null) {
            mInsetForeground.setCallback(null);
        }
    }
    public void setOnInsetsCallback(OnInsetsCallback onInsetsCallback) {
        mOnInsetsCallback = onInsetsCallback;
    }
    public static interface OnInsetsCallback {
        public void onInsetsChanged(Rect insets);
    }
}",class,
"    public ScrimInsetsScrollView(Context context) {
        super(context);
        init(context, null, 0);
    }",method,
"    public ScrimInsetsScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context, attrs, 0);
    }",method,
"    public ScrimInsetsScrollView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init(context, attrs, defStyle);
    }",method,
"    private void init(Context context, AttributeSet attrs, int defStyle) {
        final TypedArray a = context.obtainStyledAttributes(attrs,
                R.styleable.ScrimInsetsView, defStyle, 0);
        if (a == null) {
            return;
        }
        mInsetForeground = a.getDrawable(R.styleable.ScrimInsetsView_insetForeground);
        a.recycle();
        setWillNotDraw(true);
    }",method,
"        if (a == null) {
            return;
        }",method,
"    @Override
    protected boolean fitSystemWindows(Rect insets) {
        mInsets = new Rect(insets);
        setWillNotDraw(mInsetForeground == null);
        ViewCompat.postInvalidateOnAnimation(this);
        if (mOnInsetsCallback != null) {
            mOnInsetsCallback.onInsetsChanged(insets);
        }
        return true; // consume insets
    }",method,
"        if (mOnInsetsCallback != null) {
            mOnInsetsCallback.onInsetsChanged(insets);
        }",method,
"    @Override
    public void draw(Canvas canvas) {
        super.draw(canvas);
        int width = getWidth();
        int height = getHeight();
        if (mInsets != null && mInsetForeground != null) {
            int sc = canvas.save();
            canvas.translate(getScrollX(), getScrollY());
            // Top
            mTempRect.set(0, 0, width, mInsets.top);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Bottom
            mTempRect.set(0, height - mInsets.bottom, width, height);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Left
            mTempRect.set(0, mInsets.top, mInsets.left, height - mInsets.bottom);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Right
            mTempRect.set(width - mInsets.right, mInsets.top, width, height - mInsets.bottom);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            canvas.restoreToCount(sc);
        }
    }",method,
"        if (mInsets != null && mInsetForeground != null) {
            int sc = canvas.save();
            canvas.translate(getScrollX(), getScrollY());
            // Top
            mTempRect.set(0, 0, width, mInsets.top);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Bottom
            mTempRect.set(0, height - mInsets.bottom, width, height);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Left
            mTempRect.set(0, mInsets.top, mInsets.left, height - mInsets.bottom);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            // Right
            mTempRect.set(width - mInsets.right, mInsets.top, width, height - mInsets.bottom);
            mInsetForeground.setBounds(mTempRect);
            mInsetForeground.draw(canvas);
            canvas.restoreToCount(sc);
        }",method,
"    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (mInsetForeground != null) {
            mInsetForeground.setCallback(this);
        }
    }",method,
"        if (mInsetForeground != null) {
            mInsetForeground.setCallback(this);
        }",method,
"    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (mInsetForeground != null) {
            mInsetForeground.setCallback(null);
        }
    }",method,
"        if (mInsetForeground != null) {
            mInsetForeground.setCallback(null);
        }",method,
"    public void setOnInsetsCallback(OnInsetsCallback onInsetsCallback) {
        mOnInsetsCallback = onInsetsCallback;
    }",method,
"public class SimpleConditionImpl extends ValueStmtImpl implements SimpleCondition {
	protected ClassCondition classCondition;
	protected ConditionValueStmt condition;
	protected ConditionNameReference conditionNameReference;
	protected SimpleConditionContext ctx;
	protected RelationConditionValueStmt relationCondition;
	protected SimpleConditionType simpleConditionType;
	public SimpleConditionImpl(final ProgramUnit programUnit, final SimpleConditionContext ctx) {
		super(programUnit, ctx);
	}
	@Override
	public ClassCondition addClassCondition(final ClassConditionContext ctx) {
		ClassCondition result = (ClassCondition) getASGElement(ctx);
		if (result == null) {
			result = new ClassConditionImpl(programUnit, ctx);
			// identifier
			if (ctx.identifier() != null) {
				final Call identifierCall = createCall(ctx.identifier());
				result.setIdentifierCall(identifierCall);
			}
			// not
			final boolean not = ctx.NOT() != null;
			result.setNot(not);
			// type
			final ClassCondition.ClassConditionType type;
			if (ctx.NUMERIC() != null) {
				type = ClassCondition.ClassConditionType.NUMERIC;
			} else if (ctx.ALPHABETIC() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC;
			} else if (ctx.ALPHABETIC_LOWER() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC_LOWER;
			} else if (ctx.ALPHABETIC_UPPER() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC_UPPER;
			} else if (ctx.DBCS() != null) {
				type = ClassCondition.ClassConditionType.DBCS;
			} else if (ctx.KANJI() != null) {
				type = ClassCondition.ClassConditionType.KANJI;
			} else if (ctx.className() != null) {
				type = ClassCondition.ClassConditionType.CLASS_NAME;
			} else {
				type = null;
			}
			result.setClassConditionType(type);
			// class call
			final Call classCall = createCall(ctx.className());
			result.setClassCall(classCall);
			classCondition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}
	@Override
	public ConditionValueStmt addCondition(final ConditionContext ctx) {
		ConditionValueStmt result = (ConditionValueStmt) getASGElement(ctx);
		if (result == null) {
			result = createConditionValueStmt(ctx);
			condition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}
	@Override
	public ConditionNameReference addConditionNameReference(final ConditionNameReferenceContext ctx) {
		ConditionNameReference result = (ConditionNameReference) getASGElement(ctx);
		if (result == null) {
			result = new ConditionNameReferenceImpl(programUnit, ctx);
			// condition name
			final Call conditionCall = createCall(ctx.conditionName());
			result.setConditionCall(conditionCall);
			// in data
			for (final InDataContext inDataContext : ctx.inData()) {
				result.addInData(inDataContext);
			}
			// in file
			if (ctx.inFile() != null) {
				result.addInFile(ctx.inFile());
			}
			// subscript
			for (final ConditionNameSubscriptReferenceContext conditionNameSubscriptReferenceContext : ctx
					.conditionNameSubscriptReference()) {
				result.addSubscriptReference(conditionNameSubscriptReferenceContext);
			}
			// mnemonic
			for (final InMnemonicContext inMnemonicContext : ctx.inMnemonic()) {
				result.addInMnemonic(inMnemonicContext);
			}
			conditionNameReference = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}
	@Override
	public RelationConditionValueStmt addRelationCondition(final RelationConditionContext ctx) {
		RelationConditionValueStmt result = (RelationConditionValueStmt) getASGElement(ctx);
		if (result == null) {
			result = createRelationConditionValueStmt(ctx);
			relationCondition = result;
			subValueStmts.add(result);
		}
		return result;
	}
	@Override
	public ClassCondition getClassCondition() {
		return classCondition;
	}
	@Override
	public ConditionValueStmt getCondition() {
		return condition;
	}
	@Override
	public ConditionNameReference getConditionNameReference() {
		return conditionNameReference;
	}
	@Override
	public RelationConditionValueStmt getRelationCondition() {
		return relationCondition;
	}
	@Override
	public SimpleConditionType getSimpleConditionType() {
		return simpleConditionType;
	}
	@Override
	public Type getType() {
		final Type result;
		switch (simpleConditionType) {
		case CLASS_CONDITION:
			result = classCondition.getType();
			break;
		case CONDITION:
			result = condition.getType();
			break;
		case CONDITION_NAME_REFERENCE:
			result = conditionNameReference.getType();
			break;
		case RELATION_CONDITION:
			result = relationCondition.getType();
			break;
		default:
			result = null;
			break;
		}
		return result;
	}
	@Override
	public Object getValue() {
		return null;
	}
	@Override
	public void setSimpleConditionType(final SimpleConditionType simpleConditionType) {
		this.simpleConditionType = simpleConditionType;
	}
}",class,
"			// class call
			final Call classCall = createCall(ctx.className());
			result.setClassCall(classCall);
			classCondition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}
	@Override
	public ConditionValueStmt addCondition(final ConditionContext ctx) {
		ConditionValueStmt result = (ConditionValueStmt) getASGElement(ctx);
		if (result == null) {
			result = createConditionValueStmt(ctx);
			condition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}",class,
"	public SimpleConditionImpl(final ProgramUnit programUnit, final SimpleConditionContext ctx) {
		super(programUnit, ctx);
	}",method,
"	@Override
	public ClassCondition addClassCondition(final ClassConditionContext ctx) {
		ClassCondition result = (ClassCondition) getASGElement(ctx);
		if (result == null) {
			result = new ClassConditionImpl(programUnit, ctx);
			// identifier
			if (ctx.identifier() != null) {
				final Call identifierCall = createCall(ctx.identifier());
				result.setIdentifierCall(identifierCall);
			}
			// not
			final boolean not = ctx.NOT() != null;
			result.setNot(not);
			// type
			final ClassCondition.ClassConditionType type;
			if (ctx.NUMERIC() != null) {
				type = ClassCondition.ClassConditionType.NUMERIC;
			} else if (ctx.ALPHABETIC() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC;
			} else if (ctx.ALPHABETIC_LOWER() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC_LOWER;
			} else if (ctx.ALPHABETIC_UPPER() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC_UPPER;
			} else if (ctx.DBCS() != null) {
				type = ClassCondition.ClassConditionType.DBCS;
			} else if (ctx.KANJI() != null) {
				type = ClassCondition.ClassConditionType.KANJI;
			} else if (ctx.className() != null) {
				type = ClassCondition.ClassConditionType.CLASS_NAME;
			} else {
				type = null;
			}
			result.setClassConditionType(type);
			// class call
			final Call classCall = createCall(ctx.className());
			result.setClassCall(classCall);
			classCondition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}",method,
"		if (result == null) {
			result = new ClassConditionImpl(programUnit, ctx);
			// identifier
			if (ctx.identifier() != null) {
				final Call identifierCall = createCall(ctx.identifier());
				result.setIdentifierCall(identifierCall);
			}
			// not
			final boolean not = ctx.NOT() != null;
			result.setNot(not);
			// type
			final ClassCondition.ClassConditionType type;
			if (ctx.NUMERIC() != null) {
				type = ClassCondition.ClassConditionType.NUMERIC;
			} else if (ctx.ALPHABETIC() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC;
			} else if (ctx.ALPHABETIC_LOWER() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC_LOWER;
			} else if (ctx.ALPHABETIC_UPPER() != null) {
				type = ClassCondition.ClassConditionType.ALPHABETIC_UPPER;
			} else if (ctx.DBCS() != null) {
				type = ClassCondition.ClassConditionType.DBCS;
			} else if (ctx.KANJI() != null) {
				type = ClassCondition.ClassConditionType.KANJI;
			} else if (ctx.className() != null) {
				type = ClassCondition.ClassConditionType.CLASS_NAME;
			} else {
				type = null;
			}
			result.setClassConditionType(type);
			// class call
			final Call classCall = createCall(ctx.className());
			result.setClassCall(classCall);
			classCondition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}",method,
"	@Override
	public ConditionValueStmt addCondition(final ConditionContext ctx) {
		ConditionValueStmt result = (ConditionValueStmt) getASGElement(ctx);
		if (result == null) {
			result = createConditionValueStmt(ctx);
			condition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}",method,
"		if (result == null) {
			result = createConditionValueStmt(ctx);
			condition = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}",method,
"	@Override
	public ConditionNameReference addConditionNameReference(final ConditionNameReferenceContext ctx) {
		ConditionNameReference result = (ConditionNameReference) getASGElement(ctx);
		if (result == null) {
			result = new ConditionNameReferenceImpl(programUnit, ctx);
			// condition name
			final Call conditionCall = createCall(ctx.conditionName());
			result.setConditionCall(conditionCall);
			// in data
			for (final InDataContext inDataContext : ctx.inData()) {
				result.addInData(inDataContext);
			}
			// in file
			if (ctx.inFile() != null) {
				result.addInFile(ctx.inFile());
			}
			// subscript
			for (final ConditionNameSubscriptReferenceContext conditionNameSubscriptReferenceContext : ctx
					.conditionNameSubscriptReference()) {
				result.addSubscriptReference(conditionNameSubscriptReferenceContext);
			}
			// mnemonic
			for (final InMnemonicContext inMnemonicContext : ctx.inMnemonic()) {
				result.addInMnemonic(inMnemonicContext);
			}
			conditionNameReference = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}
		return result;
	}",method,
"		if (result == null) {
			result = new ConditionNameReferenceImpl(programUnit, ctx);
			// condition name
			final Call conditionCall = createCall(ctx.conditionName());
			result.setConditionCall(conditionCall);
			// in data
			for (final InDataContext inDataContext : ctx.inData()) {
				result.addInData(inDataContext);
			}
			// in file
			if (ctx.inFile() != null) {
				result.addInFile(ctx.inFile());
			}
			// subscript
			for (final ConditionNameSubscriptReferenceContext conditionNameSubscriptReferenceContext : ctx
					.conditionNameSubscriptReference()) {
				result.addSubscriptReference(conditionNameSubscriptReferenceContext);
			}
			// mnemonic
			for (final InMnemonicContext inMnemonicContext : ctx.inMnemonic()) {
				result.addInMnemonic(inMnemonicContext);
			}
			conditionNameReference = result;
			subValueStmts.add(result);
			registerASGElement(result);
		}",method,
"	@Override
	public RelationConditionValueStmt addRelationCondition(final RelationConditionContext ctx) {
		RelationConditionValueStmt result = (RelationConditionValueStmt) getASGElement(ctx);
		if (result == null) {
			result = createRelationConditionValueStmt(ctx);
			relationCondition = result;
			subValueStmts.add(result);
		}
		return result;
	}",method,
"		if (result == null) {
			result = createRelationConditionValueStmt(ctx);
			relationCondition = result;
			subValueStmts.add(result);
		}",method,
"	@Override
	public ClassCondition getClassCondition() {
		return classCondition;
	}",method,
"	@Override
	public ConditionValueStmt getCondition() {
		return condition;
	}",method,
"	@Override
	public ConditionNameReference getConditionNameReference() {
		return conditionNameReference;
	}",method,
"	@Override
	public RelationConditionValueStmt getRelationCondition() {
		return relationCondition;
	}",method,
"	@Override
	public SimpleConditionType getSimpleConditionType() {
		return simpleConditionType;
	}",method,
"	@Override
	public Type getType() {
		final Type result;
		switch (simpleConditionType) {
		case CLASS_CONDITION:
			result = classCondition.getType();
			break;
		case CONDITION:
			result = condition.getType();
			break;
		case CONDITION_NAME_REFERENCE:
			result = conditionNameReference.getType();
			break;
		case RELATION_CONDITION:
			result = relationCondition.getType();
			break;
		default:
			result = null;
			break;
		}
		return result;
	}",method,
"		switch (simpleConditionType) {
		case CLASS_CONDITION:
			result = classCondition.getType();
			break;
		case CONDITION:
			result = condition.getType();
			break;
		case CONDITION_NAME_REFERENCE:
			result = conditionNameReference.getType();
			break;
		case RELATION_CONDITION:
			result = relationCondition.getType();
			break;
		default:
			result = null;
			break;
		}",method,
"	@Override
	public Object getValue() {
		return null;
	}",method,
"	@Override
	public void setSimpleConditionType(final SimpleConditionType simpleConditionType) {
		this.simpleConditionType = simpleConditionType;
	}",method,
"public class SystemCallFilterTests extends ESTestCase {
    static final String EXECUTABLE = Constants.WINDOWS ? ""calc"" : ""ls"";
    @Override
    public void setUp() throws Exception {
        super.setUp();
        assumeTrue(""requires system call filter installation"", Natives.isSystemCallFilterInstalled());
        // otherwise security manager will block the execution, no fun
        assumeTrue(""cannot test with security manager enabled"", System.getSecurityManager() == null);
        // otherwise, since we don't have TSYNC support, rules are not applied to the test thread
        // (randomizedrunner class initialization happens in its own thread, after the test thread is created)
        // instead we just forcefully run it for the test thread here.
        if (!JNANatives.LOCAL_SYSTEM_CALL_FILTER_ALL) {
            try {
                SystemCallFilter.init(createTempDir());
            } catch (Exception e) {
                throw new RuntimeException(""unable to forcefully apply system call filter to test thread"", e);
            }
        }
    }
    public void testNoExecution() throws Exception {
        try {
            Runtime.getRuntime().exec(EXECUTABLE);
            fail(""should not have been able to execute!"");
        } catch (Exception expected) {
            // we can't guarantee how its converted, currently its an IOException, like this:
        }
    }
    // make sure thread inherits this too (its documented that way)
    public void testNoExecutionFromThread() throws Exception {
        Thread t = new Thread() {
            @Override
            public void run() {
                try {
                    Runtime.getRuntime().exec(EXECUTABLE);
                    fail(""should not have been able to execute!"");
                } catch (Exception expected) {
                    // ok
                }
            }
        };
        t.start();
        t.join();
    }
}",class,
"        // (randomizedrunner class initialization happens in its own thread, after the test thread is created)
        // instead we just forcefully run it for the test thread here.
        if (!JNANatives.LOCAL_SYSTEM_CALL_FILTER_ALL) {
            try {
                SystemCallFilter.init(createTempDir());
            } catch (Exception e) {
                throw new RuntimeException(""unable to forcefully apply system call filter to test thread"", e);
            }
        }",class,
"    @Override
    public void setUp() throws Exception {
        super.setUp();
        assumeTrue(""requires system call filter installation"", Natives.isSystemCallFilterInstalled());
        // otherwise security manager will block the execution, no fun
        assumeTrue(""cannot test with security manager enabled"", System.getSecurityManager() == null);
        // otherwise, since we don't have TSYNC support, rules are not applied to the test thread
        // (randomizedrunner class initialization happens in its own thread, after the test thread is created)
        // instead we just forcefully run it for the test thread here.
        if (!JNANatives.LOCAL_SYSTEM_CALL_FILTER_ALL) {
            try {
                SystemCallFilter.init(createTempDir());
            } catch (Exception e) {
                throw new RuntimeException(""unable to forcefully apply system call filter to test thread"", e);
            }
        }
    }",method,
"        if (!JNANatives.LOCAL_SYSTEM_CALL_FILTER_ALL) {
            try {
                SystemCallFilter.init(createTempDir());
            } catch (Exception e) {
                throw new RuntimeException(""unable to forcefully apply system call filter to test thread"", e);
            }
        }",method,
"    public void testNoExecution() throws Exception {
        try {
            Runtime.getRuntime().exec(EXECUTABLE);
            fail(""should not have been able to execute!"");
        } catch (Exception expected) {
            // we can't guarantee how its converted, currently its an IOException, like this:
        }
    }",method,
"    public void testNoExecutionFromThread() throws Exception {
        Thread t = new Thread() {
            @Override
            public void run() {
                try {
                    Runtime.getRuntime().exec(EXECUTABLE);
                    fail(""should not have been able to execute!"");
                } catch (Exception expected) {
                    // ok
                }
            }
        };
        t.start();
        t.join();
    }",method,
"            @Override
            public void run() {
                try {
                    Runtime.getRuntime().exec(EXECUTABLE);
                    fail(""should not have been able to execute!"");
                } catch (Exception expected) {
                    // ok
                }
            }",method,
"                if (match == null) {
                    wasNew = true;
                }",method,
"                if (wasNew) {
                    if (prevNetDb == null) {
                        if ((!getContext().banlist().isBanlistedForever(key)) &&
                            getContext().blocklist().isBlocklisted(key) &&
                            _log.shouldLog(Log.WARN))
                                _log.warn(""Blocklisting new peer "" + key + ' ' + ri);
                    } else {
                        Collection<RouterAddress> oldAddr = prevNetDb.getAddresses();
                        Collection<RouterAddress> newAddr = ri.getAddresses();
                        if ((!newAddr.equals(oldAddr)) &&
                            (!getContext().banlist().isBanlistedForever(key)) &&
                            getContext().blocklist().isBlocklisted(key) &&
                            _log.shouldLog(Log.WARN))
                                _log.warn(""New address received, Blocklisting old peer "" + key + ' ' + ri);
                    }
                }",method,
"                    if (prevNetDb == null) {
                        if ((!getContext().banlist().isBanlistedForever(key)) &&
                            getContext().blocklist().isBlocklisted(key) &&
                            _log.shouldLog(Log.WARN))
                                _log.warn(""Blocklisting new peer "" + key + ' ' + ri);
                    }",method,
"        if (_fromHash != null) {
            if (invalidMessage == null) {
                getContext().profileManager().dbStoreReceived(_fromHash, wasNew);
                getContext().statManager().addRateData(""netDb.storeHandled"", ackEnd-recvEnd, 0);
            } else {
                // Should we record in the profile?
                if (_log.shouldLog(Log.WARN))
                    _log.warn(""Peer "" + _fromHash.toBase64() + "" sent bad data: "" + invalidMessage);
            }
        }",method,
"            if (invalidMessage == null) {
                getContext().profileManager().dbStoreReceived(_fromHash, wasNew);
                getContext().statManager().addRateData(""netDb.storeHandled"", ackEnd-recvEnd, 0);
            }",method,
"            if (wasNew) {
                // DOS prevention
                // Note this does not throttle the ack above
                if (_facade.shouldThrottleFlood(key)) {
                    if (_log.shouldLog(Log.WARN))
                        _log.warn(""Too many recent stores, not flooding key: "" + key);
                    getContext().statManager().addRateData(""netDb.floodThrottled"", 1, 0);
                    return;
                }
                long floodBegin = System.currentTimeMillis();
                _facade.flood(_message.getEntry());
                // ERR: see comment in HandleDatabaseLookupMessageJob regarding hidden mode
                //else if (!_message.getRouterInfo().isHidden())
                long floodEnd = System.currentTimeMillis();
                getContext().statManager().addRateData(""netDb.storeFloodNew"", floodEnd-floodBegin, 0);
            }",method,
"    private void sendAck() {
        DeliveryStatusMessage msg = new DeliveryStatusMessage(getContext());
        msg.setMessageId(_message.getReplyToken());
        msg.setArrival(getContext().clock().now());
            TunnelInfo outTunnel = selectOutboundTunnel();
            if (outTunnel == null) {
                if (_log.shouldLog(Log.WARN))
                    _log.warn(""No outbound tunnel could be found"");
                return;
            } else {
                getContext().tunnelDispatcher().dispatchOutbound(msg, outTunnel.getSendTunnelId(0), _message.getReplyTunnel(), _message.getReplyGateway());
            }
        //}
    }",method,
"            if (outTunnel == null) {
                if (_log.shouldLog(Log.WARN))
                    _log.warn(""No outbound tunnel could be found"");
                return;
            }",method,
"    private TunnelInfo selectOutboundTunnel() {
        return getContext().tunnelManager().selectOutboundTunnel();
    }",method,
"    public String getName() { return ""Handle Database Store Message""; }",method,
"    @Override
    public void dropped() {
        getContext().messageHistory().messageProcessingError(_message.getUniqueId(), _message.getClass().getName(), ""Dropped due to overload"");
    }",method,
"public class TypeParameterBoundTargetInfo extends TargetInfo
{
    public int u1typeParameterIndex;
    public int u1boundIndex;
    public TypeParameterBoundTargetInfo()
    {
    }
    public TypeParameterBoundTargetInfo(byte u1targetType)
    {
        super(u1targetType);
    }
    public TypeParameterBoundTargetInfo(byte u1targetType,
                                        int  u1typeParameterIndex,
                                        int  u1boundIndex)
    {
        super(u1targetType);
        this.u1typeParameterIndex = u1typeParameterIndex;
        this.u1boundIndex         = u1boundIndex;
    }
    // Implementations for TargetInfo.
    public void accept(Clazz clazz, TypeAnnotation typeAnnotation, TargetInfoVisitor targetInfoVisitor)
    {
        targetInfoVisitor.visitTypeParameterBoundTargetInfo(clazz, typeAnnotation, this);
    }
    public void accept(Clazz clazz, Field field, TypeAnnotation typeAnnotation, TargetInfoVisitor targetInfoVisitor)
    {
        targetInfoVisitor.visitTypeParameterBoundTargetInfo(clazz, field, typeAnnotation, this);
    }
    public void accept(Clazz clazz, Method method, TypeAnnotation typeAnnotation, TargetInfoVisitor targetInfoVisitor)
    {
        targetInfoVisitor.visitTypeParameterBoundTargetInfo(clazz, method, typeAnnotation, this);
    }
}",class,
"    public TypeParameterBoundTargetInfo()
    {
    }",method,
"    public TypeParameterBoundTargetInfo(byte u1targetType)
    {
        super(u1targetType);
    }",method,
"    public TypeParameterBoundTargetInfo(byte u1targetType,
                                        int  u1typeParameterIndex,
                                        int  u1boundIndex)
    {
        super(u1targetType);
        this.u1typeParameterIndex = u1typeParameterIndex;
        this.u1boundIndex         = u1boundIndex;
    }",method,
"    public void accept(Clazz clazz, TypeAnnotation typeAnnotation, TargetInfoVisitor targetInfoVisitor)
    {
        targetInfoVisitor.visitTypeParameterBoundTargetInfo(clazz, typeAnnotation, this);
    }",method,
"    public void accept(Clazz clazz, Field field, TypeAnnotation typeAnnotation, TargetInfoVisitor targetInfoVisitor)
    {
        targetInfoVisitor.visitTypeParameterBoundTargetInfo(clazz, field, typeAnnotation, this);
    }",method,
"    public void accept(Clazz clazz, Method method, TypeAnnotation typeAnnotation, TargetInfoVisitor targetInfoVisitor)
    {
        targetInfoVisitor.visitTypeParameterBoundTargetInfo(clazz, method, typeAnnotation, this);
    }",method,
"public class TitleBox extends AbstractFullBox {
    public static final String TYPE = ""titl"";
    private String language;
    private String title;
    public TitleBox() {
        super(TYPE);
    }
    public String getLanguage() {
        return language;
    }
    public String getTitle() {
        return title;
    }
    public void setLanguage(String language) {
        this.language = language;
    }
    public void setTitle(String title) {
        this.title = title;
    }
    protected long getContentSize() {
        return 7 + Utf8.utf8StringLengthInBytes(title);
    }
    protected void getContent(ByteBuffer byteBuffer) {
        writeVersionAndFlags(byteBuffer);
        IsoTypeWriter.writeIso639(byteBuffer, language);
        byteBuffer.put(Utf8.convert(title));
        byteBuffer.put((byte) 0);
    }
    @Override
    public void _parseDetails(ByteBuffer content) {
        parseVersionAndFlags(content);
        language = IsoTypeReader.readIso639(content);
        title = IsoTypeReader.readString(content);
    }
    public String toString() {
        return ""TitleBox[language="" + getLanguage() + "";title="" + getTitle() + ""]"";
    }
}",class,
"    public TitleBox() {
        super(TYPE);
    }",method,
"    public String getLanguage() {
        return language;
    }",method,
"    public String getTitle() {
        return title;
    }",method,

code_snippet,type,score
"        if (mVerificationComplete) {
            return (mState == STATE_VERIFICATION_SUCCESS);
        }",method,
"    public int getUserId() {
        return mUserId;
    }",method,
"    public String getPackageName() {
        return mPackageName;
    }",method,
"    public String getHostsString() {
        StringBuilder sb = new StringBuilder();
        final int count = mHosts.size();
        for (int i=0; i<count; i++) {
            if (i > 0) {
                sb.append("" "");
            }
            String host = mHosts.valueAt(i);
            // ""*.example.tld"" is validated via https://example.tld
            if (host.startsWith(""*."")) {
                host = host.substring(2);
            }
            sb.append(host);
        }
        return sb.toString();
    }",method,
"        for (int i=0; i<count; i++) {
            if (i > 0) {
                sb.append("" "");
            }
            String host = mHosts.valueAt(i);
            // ""*.example.tld"" is validated via https://example.tld
            if (host.startsWith(""*."")) {
                host = host.substring(2);
            }
            sb.append(host);
        }",method,
"            if (i > 0) {
                sb.append("" "");
            }",method,
"    public boolean setVerifierResponse(int callerUid, int code) {
        if (mRequiredVerifierUid == callerUid) {
            int state = STATE_UNDEFINED;
            if (code == PackageManager.INTENT_FILTER_VERIFICATION_SUCCESS) {
                state = STATE_VERIFICATION_SUCCESS;
            } else if (code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                state = STATE_VERIFICATION_FAILURE;
            }
            mVerificationComplete = true;
            setState(state);
            return true;
        }
        Slog.d(TAG, ""Cannot set verifier response with callerUid:"" + callerUid + "" and code:"" +
                code + "" as required verifierUid is:"" + mRequiredVerifierUid);
        return false;
    }",method,
"        if (mRequiredVerifierUid == callerUid) {
            int state = STATE_UNDEFINED;
            if (code == PackageManager.INTENT_FILTER_VERIFICATION_SUCCESS) {
                state = STATE_VERIFICATION_SUCCESS;
            } else if (code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                state = STATE_VERIFICATION_FAILURE;
            }
            mVerificationComplete = true;
            setState(state);
            return true;
        }",method,
"            if (code == PackageManager.INTENT_FILTER_VERIFICATION_SUCCESS) {
                state = STATE_VERIFICATION_SUCCESS;
            }",method,
"    public void addFilter(PackageParser.ActivityIntentInfo filter) {
        mFilters.add(filter);
        mHosts.addAll(filter.getHostsList());
    }",method,
"public class RecordValue implements GSimpleExpr, RecordExpr {
  private final JExpr ref;
  private final GExpr address;
  private RecordLayout layout;
  public RecordValue(RecordLayout layout, JExpr ref) {
    this.layout = layout;
    this.ref = ref;
    this.address = null;
  }
  public RecordValue(RecordLayout layout, JExpr ref, GExpr address) {
    this.layout = layout;
    this.ref = ref;
    this.address = address;
  }
  public Type getJvmType() {
    return ref.getType();
  }
  public JExpr getRef() {
    return ref;
  }
  @Override
  public void store(MethodGenerator mv, GExpr rhs) {
    JExpr rhsRef;
    if(rhs instanceof RecordValue) {
      rhsRef = ((RecordValue) rhs).unwrap();
    } else if(rhs instanceof ProvidedPtrExpr) {
      rhsRef = ((ProvidedPtrExpr) rhs).unwrap();
    } else if(rhs instanceof FatPtrPair) {
      FatPtrPair fatPtrExpr = (FatPtrPair) rhs;
      rhsRef =  Expressions.cast(elementAt(fatPtrExpr.getArray(), fatPtrExpr.getOffset()), getJvmType());
    } else {
      throw new InternalCompilerException(""Cannot assign "" + rhs + "" to "" + this);
    }
    ref.load(mv);
    Expressions.cast(rhsRef, ref.getType()).load(mv);
    mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, ref.getType()), false);
  }
  @Override
  public GExpr addressOf() {
    if (address == null) {
      throw new UnsupportedOperationException(""Not addressable"");
    }
    return address;
  }
  @Override
  public FunPtr toFunPtr() throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public FatArrayExpr toArrayExpr() throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public PrimitiveValue toPrimitiveExpr(GimplePrimitiveType targetType) throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public VoidPtrExpr toVoidPtrExpr() throws UnsupportedCastException {
    throw new UnsupportedCastException();
  }
  @Override
  public RecordArrayExpr toRecordArrayExpr() throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public VPtrExpr toVPtrExpr() throws UnsupportedCastException {
    throw new UnsupportedCastException();
  }
  @Override
  public ProvidedPtrExpr toProvidedPtrExpr(Type jvmType) {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public FatPtr toFatPtrExpr(ValueFunction valueFunction) {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public VPtrRecordExpr toVPtrRecord(GimpleRecordType recordType) {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public VArrayExpr toVArray(GimpleArrayType arrayType) {
    throw new UnsupportedOperationException(""TODO"");
  }
  @Override
  public JExpr unwrap() {
    return ref;
  }
  @Override
  public GExpr memberOf(MethodGenerator mv, int fieldOffsetBits, int size, GimpleType type) {
    return layout.memberOf(mv, this, fieldOffsetBits, size, type);
  }
  public RecordValue doClone(MethodGenerator mv) {
    LocalVarAllocator.LocalVar clone = mv.getLocalVarAllocator().reserve(getJvmType());
    ref.load(mv);
    mv.invokevirtual(layout.getType(), ""clone"", Type.getMethodDescriptor(layout.getType()), false);
    clone.store(mv);
    return new RecordValue(layout, clone);
  }
}",class,
"  public RecordValue(RecordLayout layout, JExpr ref) {
    this.layout = layout;
    this.ref = ref;
    this.address = null;
  }",method,
"  public RecordValue(RecordLayout layout, JExpr ref, GExpr address) {
    this.layout = layout;
    this.ref = ref;
    this.address = address;
  }",method,
"  public Type getJvmType() {
    return ref.getType();
  }",method,
"  public JExpr getRef() {
    return ref;
  }",method,
"  @Override
  public void store(MethodGenerator mv, GExpr rhs) {
    JExpr rhsRef;
    if(rhs instanceof RecordValue) {
      rhsRef = ((RecordValue) rhs).unwrap();
    } else if(rhs instanceof ProvidedPtrExpr) {
      rhsRef = ((ProvidedPtrExpr) rhs).unwrap();
    } else if(rhs instanceof FatPtrPair) {
      FatPtrPair fatPtrExpr = (FatPtrPair) rhs;
      rhsRef =  Expressions.cast(elementAt(fatPtrExpr.getArray(), fatPtrExpr.getOffset()), getJvmType());
    } else {
      throw new InternalCompilerException(""Cannot assign "" + rhs + "" to "" + this);
    }
    ref.load(mv);
    Expressions.cast(rhsRef, ref.getType()).load(mv);
    mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, ref.getType()), false);
  }",method,
"    if(rhs instanceof RecordValue) {
      rhsRef = ((RecordValue) rhs).unwrap();
    }",method,
"  @Override
  public GExpr addressOf() {
    if (address == null) {
      throw new UnsupportedOperationException(""Not addressable"");
    }
    return address;
  }",method,
"    if (address == null) {
      throw new UnsupportedOperationException(""Not addressable"");
    }",method,
"  @Override
  public FunPtr toFunPtr() throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public FatArrayExpr toArrayExpr() throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public PrimitiveValue toPrimitiveExpr(GimplePrimitiveType targetType) throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public VoidPtrExpr toVoidPtrExpr() throws UnsupportedCastException {
    throw new UnsupportedCastException();
  }",method,
"  @Override
  public RecordArrayExpr toRecordArrayExpr() throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public VPtrExpr toVPtrExpr() throws UnsupportedCastException {
    throw new UnsupportedCastException();
  }",method,
"  @Override
  public ProvidedPtrExpr toProvidedPtrExpr(Type jvmType) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public FatPtr toFatPtrExpr(ValueFunction valueFunction) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public VPtrRecordExpr toVPtrRecord(GimpleRecordType recordType) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public VArrayExpr toVArray(GimpleArrayType arrayType) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public JExpr unwrap() {
    return ref;
  }",method,
"  @Override
  public GExpr memberOf(MethodGenerator mv, int fieldOffsetBits, int size, GimpleType type) {
    return layout.memberOf(mv, this, fieldOffsetBits, size, type);
  }",method,
"  public RecordValue doClone(MethodGenerator mv) {
    LocalVarAllocator.LocalVar clone = mv.getLocalVarAllocator().reserve(getJvmType());
    ref.load(mv);
    mv.invokevirtual(layout.getType(), ""clone"", Type.getMethodDescriptor(layout.getType()), false);
    clone.store(mv);
    return new RecordValue(layout, clone);
  }",method,
"public class War extends Jar {
  private static final long serialVersionUID = 1L;
  @NotNull
  private final String myWebAppDirName;
  @NotNull
  private final File myWebAppDir;
  @Nullable
  private File myWebXml;
  @NotNull
  private List<WebResource> myWebResources;
  @NotNull
  private Set<File> myClasspath;
  public War(@NotNull String name, @NotNull String webAppDirName, @NotNull File webAppDir) {
    super(name);
    myWebAppDirName = webAppDirName;
    myWebAppDir = webAppDir;
    myWebResources = Collections.emptyList();
    myClasspath = Collections.emptySet();
  }
  @NotNull
  public String getWebAppDirName() {
    return myWebAppDirName;
  }
  @NotNull
  public File getWebAppDir() {
    return myWebAppDir;
  }
  public void setWebXml(@Nullable File webXml) {
    myWebXml = webXml;
  }
  @Nullable
  public File getWebXml() {
    return myWebXml;
  }
  public void setWebResources(@Nullable List<WebResource> webResources) {
    myWebResources = webResources == null ? Collections.emptyList() : webResources;
  }
  @NotNull
  public List<WebResource> getWebResources() {
    return myWebResources;
  }
  public void setClasspath(@Nullable Set<File> classpath) {
    myClasspath = classpath == null ? Collections.emptySet() : classpath;
  }
  @NotNull
  public Set<File> getClasspath() {
    return myClasspath;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof War)) return false;
    if (!super.equals(o)) return false;
    War war = (War)o;
    if (!myWebAppDirName.equals(war.myWebAppDirName)) return false;
    if (!myWebResources.equals(war.myWebResources)) return false;
    if (!myClasspath.equals(war.myClasspath)) return false;
    return true;
  }
  @Override
  public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + myWebAppDirName.hashCode();
    result = 31 * result + myWebResources.hashCode();
    return result;
  }
  @Override
  public String toString() {
    return ""War{"" +
           ""name='"" + getName() + '\'' +
           "", webAppDirName='"" + myWebAppDirName + '\'' +
           "", webAppDir="" + myWebAppDir +
           "", webXml="" + myWebXml +
           "", webResources="" + myWebResources +
           '}';
  }
}",class,
"  public War(@NotNull String name, @NotNull String webAppDirName, @NotNull File webAppDir) {
    super(name);
    myWebAppDirName = webAppDirName;
    myWebAppDir = webAppDir;
    myWebResources = Collections.emptyList();
    myClasspath = Collections.emptySet();
  }",method,
"  @NotNull
  public String getWebAppDirName() {
    return myWebAppDirName;
  }",method,
"  @NotNull
  public File getWebAppDir() {
    return myWebAppDir;
  }",method,
"  public void setWebXml(@Nullable File webXml) {
    myWebXml = webXml;
  }",method,
"  @Nullable
  public File getWebXml() {
    return myWebXml;
  }",method,
"  public void setWebResources(@Nullable List<WebResource> webResources) {
    myWebResources = webResources == null ? Collections.emptyList() : webResources;
  }",method,
"  @NotNull
  public List<WebResource> getWebResources() {
    return myWebResources;
  }",method,
"  public void setClasspath(@Nullable Set<File> classpath) {
    myClasspath = classpath == null ? Collections.emptySet() : classpath;
  }",method,
"  @NotNull
  public Set<File> getClasspath() {
    return myClasspath;
  }",method,
"  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof War)) return false;
    if (!super.equals(o)) return false;
    War war = (War)o;
    if (!myWebAppDirName.equals(war.myWebAppDirName)) return false;
    if (!myWebResources.equals(war.myWebResources)) return false;
    if (!myClasspath.equals(war.myClasspath)) return false;
    return true;
  }",method,
"  @Override
  public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + myWebAppDirName.hashCode();
    result = 31 * result + myWebResources.hashCode();
    return result;
  }",method,
"  @Override
  public String toString() {
    return ""War{"" +
           ""name='"" + getName() + '\'' +
           "", webAppDirName='"" + myWebAppDirName + '\'' +
           "", webAppDir="" + myWebAppDir +
           "", webXml="" + myWebXml +
           "", webResources="" + myWebResources +
           '}';
  }",method,
"public class BeanCreationException extends FatalBeanException {
	@Nullable
	private String beanName;
	@Nullable
	private String resourceDescription;
	@Nullable
	private List<Throwable> relatedCauses;
	public BeanCreationException(String msg) {
		super(msg);
	}
	public BeanCreationException(String msg, Throwable cause) {
		super(msg, cause);
	}
	public BeanCreationException(String beanName, String msg) {
		super(""Error creating bean with name '"" + beanName + ""': "" + msg);
		this.beanName = beanName;
	}
	public BeanCreationException(String beanName, String msg, Throwable cause) {
		this(beanName, msg);
		initCause(cause);
	}
	public BeanCreationException(@Nullable String resourceDescription, @Nullable String beanName, String msg) {
		super(""Error creating bean with name '"" + beanName + ""'"" +
				(resourceDescription != null ? "" defined in "" + resourceDescription : """") + "": "" + msg);
		this.resourceDescription = resourceDescription;
		this.beanName = beanName;
	}
	public BeanCreationException(@Nullable String resourceDescription, String beanName, String msg, Throwable cause) {
		this(resourceDescription, beanName, msg);
		initCause(cause);
	}
	@Nullable
	public String getResourceDescription() {
		return this.resourceDescription;
	}
	@Nullable
	public String getBeanName() {
		return this.beanName;
	}
	public void addRelatedCause(Throwable ex) {
		if (this.relatedCauses == null) {
			this.relatedCauses = new LinkedList<>();
		}
		this.relatedCauses.add(ex);
	}
	@Nullable
	public Throwable[] getRelatedCauses() {
		if (this.relatedCauses == null) {
			return null;
		}
		return this.relatedCauses.toArray(new Throwable[this.relatedCauses.size()]);
	}
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder(super.toString());
		if (this.relatedCauses != null) {
			for (Throwable relatedCause : this.relatedCauses) {
				sb.append(""\nRelated cause: "");
				sb.append(relatedCause);
			}
		}
		return sb.toString();
	}
	@Override
	public void printStackTrace(PrintStream ps) {
		synchronized (ps) {
			super.printStackTrace(ps);
			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					ps.println(""Related cause:"");
					relatedCause.printStackTrace(ps);
				}
			}
		}
	}
	@Override
	public void printStackTrace(PrintWriter pw) {
		synchronized (pw) {
			super.printStackTrace(pw);
			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					pw.println(""Related cause:"");
					relatedCause.printStackTrace(pw);
				}
			}
		}
	}
	@Override
	public boolean contains(@Nullable Class<?> exClass) {
		if (super.contains(exClass)) {
			return true;
		}
		if (this.relatedCauses != null) {
			for (Throwable relatedCause : this.relatedCauses) {
				if (relatedCause instanceof NestedRuntimeException &&
						((NestedRuntimeException) relatedCause).contains(exClass)) {
					return true;
				}
			}
		}
		return false;
	}
}",class,
"public class BeanCreationNotAllowedException extends BeanCreationException {
	public BeanCreationNotAllowedException(String beanName, String msg) {
		super(beanName, msg);
	}
}",class,
"public class BeanCurrentlyInCreationException extends BeanCreationException {
	public BeanCurrentlyInCreationException(String beanName) {
		super(beanName,
				""Requested bean is currently in creation: Is there an unresolvable circular reference?"");
	}
	public BeanCurrentlyInCreationException(String beanName, String msg) {
		super(beanName, msg);
	}
}",class,
"	public BeanCreationException(String msg) {
		super(msg);
	}",method,
"	public BeanCreationException(String msg, Throwable cause) {
		super(msg, cause);
	}",method,
"	public BeanCreationException(String beanName, String msg) {
		super(""Error creating bean with name '"" + beanName + ""': "" + msg);
		this.beanName = beanName;
	}",method,
"	public BeanCreationException(String beanName, String msg, Throwable cause) {
		this(beanName, msg);
		initCause(cause);
	}",method,
"	public BeanCreationException(@Nullable String resourceDescription, @Nullable String beanName, String msg) {
		super(""Error creating bean with name '"" + beanName + ""'"" +
				(resourceDescription != null ? "" defined in "" + resourceDescription : """") + "": "" + msg);
		this.resourceDescription = resourceDescription;
		this.beanName = beanName;
	}",method,
"	public BeanCreationException(@Nullable String resourceDescription, String beanName, String msg, Throwable cause) {
		this(resourceDescription, beanName, msg);
		initCause(cause);
	}",method,
"	@Nullable
	public String getResourceDescription() {
		return this.resourceDescription;
	}",method,
"	@Nullable
	public String getBeanName() {
		return this.beanName;
	}",method,
"	public void addRelatedCause(Throwable ex) {
		if (this.relatedCauses == null) {
			this.relatedCauses = new LinkedList<>();
		}
		this.relatedCauses.add(ex);
	}",method,
"		if (this.relatedCauses == null) {
			this.relatedCauses = new LinkedList<>();
		}",method,
"	@Nullable
	public Throwable[] getRelatedCauses() {
		if (this.relatedCauses == null) {
			return null;
		}
		return this.relatedCauses.toArray(new Throwable[this.relatedCauses.size()]);
	}",method,
"		if (this.relatedCauses == null) {
			return null;
		}",method,
"	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder(super.toString());
		if (this.relatedCauses != null) {
			for (Throwable relatedCause : this.relatedCauses) {
				sb.append(""\nRelated cause: "");
				sb.append(relatedCause);
			}
		}
		return sb.toString();
	}",method,
"		if (this.relatedCauses != null) {
			for (Throwable relatedCause : this.relatedCauses) {
				sb.append(""\nRelated cause: "");
				sb.append(relatedCause);
			}
		}",method,
"			for (Throwable relatedCause : this.relatedCauses) {
				sb.append(""\nRelated cause: "");
				sb.append(relatedCause);
			}",method,
"	@Override
	public void printStackTrace(PrintStream ps) {
		synchronized (ps) {
			super.printStackTrace(ps);
			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					ps.println(""Related cause:"");
					relatedCause.printStackTrace(ps);
				}
			}
		}
	}",method,
"		synchronized (ps) {
			super.printStackTrace(ps);
			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					ps.println(""Related cause:"");
					relatedCause.printStackTrace(ps);
				}
			}
		}",method,
"			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					ps.println(""Related cause:"");
					relatedCause.printStackTrace(ps);
				}
			}",method,
"				for (Throwable relatedCause : this.relatedCauses) {
					ps.println(""Related cause:"");
					relatedCause.printStackTrace(ps);
				}",method,
"	@Override
	public void printStackTrace(PrintWriter pw) {
		synchronized (pw) {
			super.printStackTrace(pw);
			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					pw.println(""Related cause:"");
					relatedCause.printStackTrace(pw);
				}
			}
		}
	}",method,
"		synchronized (pw) {
			super.printStackTrace(pw);
			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					pw.println(""Related cause:"");
					relatedCause.printStackTrace(pw);
				}
			}
		}",method,
"			if (this.relatedCauses != null) {
				for (Throwable relatedCause : this.relatedCauses) {
					pw.println(""Related cause:"");
					relatedCause.printStackTrace(pw);
				}
			}",method,
"				for (Throwable relatedCause : this.relatedCauses) {
					pw.println(""Related cause:"");
					relatedCause.printStackTrace(pw);
				}",method,
"	@Override
	public boolean contains(@Nullable Class<?> exClass) {
		if (super.contains(exClass)) {
			return true;
		}
		if (this.relatedCauses != null) {
			for (Throwable relatedCause : this.relatedCauses) {
				if (relatedCause instanceof NestedRuntimeException &&
						((NestedRuntimeException) relatedCause).contains(exClass)) {
					return true;
				}
			}
		}
		return false;
	}",method,
"		if (this.relatedCauses != null) {
			for (Throwable relatedCause : this.relatedCauses) {
				if (relatedCause instanceof NestedRuntimeException &&
						((NestedRuntimeException) relatedCause).contains(exClass)) {
					return true;
				}
			}
		}",method,
"			for (Throwable relatedCause : this.relatedCauses) {
				if (relatedCause instanceof NestedRuntimeException &&
						((NestedRuntimeException) relatedCause).contains(exClass)) {
					return true;
				}
			}",method,
"	public BeanCreationNotAllowedException(String beanName, String msg) {
		super(beanName, msg);
	}",method,
"	public BeanCurrentlyInCreationException(String beanName) {
		super(beanName,
				""Requested bean is currently in creation: Is there an unresolvable circular reference?"");
	}",method,
"	public BeanCurrentlyInCreationException(String beanName, String msg) {
		super(beanName, msg);
	}",method,
"public class DisconnectableInputStream extends BulkReadInputStream {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private final byte[] buffer;
    private int readPos;
    private int writePos;
    private boolean closed;
    private boolean inputFinished;
    static class ThreadExecuter implements Action<Runnable> {
        public void execute(Runnable runnable) {
            Thread thread = new Thread(runnable);
            thread.setName(""DisconnectableInputStream source reader"");
            thread.setDaemon(true);
            thread.start();
        }
    }
    public DisconnectableInputStream(InputStream source) {
        this(source, 1024);
    }
    public DisconnectableInputStream(final InputStream source, int bufferLength) {
        this(source, new ThreadExecuter(), bufferLength);
    }
    DisconnectableInputStream(InputStream source, Action<Runnable> executer) {
        this(source, executer, 1024);
    }
    DisconnectableInputStream(final InputStream source, Action<Runnable> executer, int bufferLength) {
        buffer = new byte[bufferLength];
        Runnable consume = new Runnable() {
            public void run() {
                try {
                    while (true) {
                        int pos;
                        lock.lock();
                        try {
                            while (!closed && writePos == buffer.length && writePos != readPos) {
                                // buffer is full, wait until it has been read
                                condition.await();
                            }
                            assert writePos >= readPos;
                            if (closed) {
                                // stream has been closed, don't bother reading anything else
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                            if (readPos == writePos) {
                                // buffer has been fully read, start at the beginning
                                readPos = 0;
                                writePos = 0;
                            }
                            pos = writePos;
                        } finally {
                            lock.unlock();
                        }
                        int nread = source.read(buffer, pos, buffer.length - pos);
                        lock.lock();
                        try {
                            if (nread > 0) {
                                // Have read some data - let readers know
                                assert writePos >= readPos;
                                writePos += nread;
                                assert buffer.length >= writePos;
                                condition.signalAll();
                            }
                            if (nread < 0) {
                                // End of the stream
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                } catch (Throwable throwable) {
                    lock.lock();
                    try {
                        inputFinished = true;
                        condition.signalAll();
                    } finally {
                        lock.unlock();
                    }
                    throw UncheckedException.throwAsUncheckedException(throwable);
                }
            }
        };
        executer.execute(consume);
    }
    @Override
    public int read(byte[] bytes, int pos, int count) throws IOException {
        lock.lock();
        try {
            while (!inputFinished && !closed && readPos == writePos) {
                condition.await();
            }
            if (closed) {
                return -1;
            }
            // Drain the buffer before returning end-of-stream
            if (writePos > readPos) {
                int nread = Math.min(count, writePos - readPos);
                System.arraycopy(buffer, readPos, bytes, pos, nread);
                readPos += nread;
                assert writePos >= readPos;
                condition.signalAll();
                return nread;
            }
            assert inputFinished;
            return -1;
        } catch (InterruptedException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        } finally {
            lock.unlock();
        }
    }
    @Override
    public void close() throws IOException {
        lock.lock();
        try {
            closed = true;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}",class,
"    static class ThreadExecuter implements Action<Runnable> {
        public void execute(Runnable runnable) {
            Thread thread = new Thread(runnable);
            thread.setName(""DisconnectableInputStream source reader"");
            thread.setDaemon(true);
            thread.start();
        }
    }",class,
"        public void execute(Runnable runnable) {
            Thread thread = new Thread(runnable);
            thread.setName(""DisconnectableInputStream source reader"");
            thread.setDaemon(true);
            thread.start();
        }",method,
"    public DisconnectableInputStream(InputStream source) {
        this(source, 1024);
    }",method,
"    public DisconnectableInputStream(final InputStream source, int bufferLength) {
        this(source, new ThreadExecuter(), bufferLength);
    }",method,
"    DisconnectableInputStream(InputStream source, Action<Runnable> executer) {
        this(source, executer, 1024);
    }",method,
"    DisconnectableInputStream(final InputStream source, Action<Runnable> executer, int bufferLength) {
        buffer = new byte[bufferLength];
        Runnable consume = new Runnable() {
            public void run() {
                try {
                    while (true) {
                        int pos;
                        lock.lock();
                        try {
                            while (!closed && writePos == buffer.length && writePos != readPos) {
                                // buffer is full, wait until it has been read
                                condition.await();
                            }
                            assert writePos >= readPos;
                            if (closed) {
                                // stream has been closed, don't bother reading anything else
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                            if (readPos == writePos) {
                                // buffer has been fully read, start at the beginning
                                readPos = 0;
                                writePos = 0;
                            }
                            pos = writePos;
                        } finally {
                            lock.unlock();
                        }
                        int nread = source.read(buffer, pos, buffer.length - pos);
                        lock.lock();
                        try {
                            if (nread > 0) {
                                // Have read some data - let readers know
                                assert writePos >= readPos;
                                writePos += nread;
                                assert buffer.length >= writePos;
                                condition.signalAll();
                            }
                            if (nread < 0) {
                                // End of the stream
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                } catch (Throwable throwable) {
                    lock.lock();
                    try {
                        inputFinished = true;
                        condition.signalAll();
                    } finally {
                        lock.unlock();
                    }
                    throw UncheckedException.throwAsUncheckedException(throwable);
                }
            }
        };
        executer.execute(consume);
    }",method,
"            public void run() {
                try {
                    while (true) {
                        int pos;
                        lock.lock();
                        try {
                            while (!closed && writePos == buffer.length && writePos != readPos) {
                                // buffer is full, wait until it has been read
                                condition.await();
                            }
                            assert writePos >= readPos;
                            if (closed) {
                                // stream has been closed, don't bother reading anything else
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                            if (readPos == writePos) {
                                // buffer has been fully read, start at the beginning
                                readPos = 0;
                                writePos = 0;
                            }
                            pos = writePos;
                        } finally {
                            lock.unlock();
                        }
                        int nread = source.read(buffer, pos, buffer.length - pos);
                        lock.lock();
                        try {
                            if (nread > 0) {
                                // Have read some data - let readers know
                                assert writePos >= readPos;
                                writePos += nread;
                                assert buffer.length >= writePos;
                                condition.signalAll();
                            }
                            if (nread < 0) {
                                // End of the stream
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                } catch (Throwable throwable) {
                    lock.lock();
                    try {
                        inputFinished = true;
                        condition.signalAll();
                    } finally {
                        lock.unlock();
                    }
                    throw UncheckedException.throwAsUncheckedException(throwable);
                }
            }",method,
"                    while (true) {
                        int pos;
                        lock.lock();
                        try {
                            while (!closed && writePos == buffer.length && writePos != readPos) {
                                // buffer is full, wait until it has been read
                                condition.await();
                            }
                            assert writePos >= readPos;
                            if (closed) {
                                // stream has been closed, don't bother reading anything else
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                            if (readPos == writePos) {
                                // buffer has been fully read, start at the beginning
                                readPos = 0;
                                writePos = 0;
                            }
                            pos = writePos;
                        } finally {
                            lock.unlock();
                        }
                        int nread = source.read(buffer, pos, buffer.length - pos);
                        lock.lock();
                        try {
                            if (nread > 0) {
                                // Have read some data - let readers know
                                assert writePos >= readPos;
                                writePos += nread;
                                assert buffer.length >= writePos;
                                condition.signalAll();
                            }
                            if (nread < 0) {
                                // End of the stream
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }
                        } finally {
                            lock.unlock();
                        }
                    }",method,
"                            while (!closed && writePos == buffer.length && writePos != readPos) {
                                // buffer is full, wait until it has been read
                                condition.await();
                            }",method,
"                            if (closed) {
                                // stream has been closed, don't bother reading anything else
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }",method,
"                            if (readPos == writePos) {
                                // buffer has been fully read, start at the beginning
                                readPos = 0;
                                writePos = 0;
                            }",method,
"                            if (nread > 0) {
                                // Have read some data - let readers know
                                assert writePos >= readPos;
                                writePos += nread;
                                assert buffer.length >= writePos;
                                condition.signalAll();
                            }",method,
"                            if (nread < 0) {
                                // End of the stream
                                inputFinished = true;
                                condition.signalAll();
                                return;
                            }",method,
"    @Override
    public int read(byte[] bytes, int pos, int count) throws IOException {
        lock.lock();
        try {
            while (!inputFinished && !closed && readPos == writePos) {
                condition.await();
            }
            if (closed) {
                return -1;
            }
            // Drain the buffer before returning end-of-stream
            if (writePos > readPos) {
                int nread = Math.min(count, writePos - readPos);
                System.arraycopy(buffer, readPos, bytes, pos, nread);
                readPos += nread;
                assert writePos >= readPos;
                condition.signalAll();
                return nread;
            }
            assert inputFinished;
            return -1;
        } catch (InterruptedException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        } finally {
            lock.unlock();
        }
    }",method,
"            while (!inputFinished && !closed && readPos == writePos) {
                condition.await();
            }",method,
"            if (closed) {
                return -1;
            }",method,
"            if (writePos > readPos) {
                int nread = Math.min(count, writePos - readPos);
                System.arraycopy(buffer, readPos, bytes, pos, nread);
                readPos += nread;
                assert writePos >= readPos;
                condition.signalAll();
                return nread;
            }",method,
"    @Override
    public void close() throws IOException {
        lock.lock();
        try {
            closed = true;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }",method,
"public class HPRecommendationPlugin extends ServiceRecommendationPlugin {
    private static final String PDL__PCL = ""application/vnd.hp-PCL"";
    private static final String PDL__PCLM = ""application/PCLm"";
    private static final String PDL__PDF = ""application/pdf"";
    private static final String PDL__PWG_RASTER = ""image/pwg-raster"";
    private static final String TAG_DESIGNJET = ""DESIGNJET"";
    private static final String TAG_PAGEWIDE = ""PAGEWIDE"";
    private static final String TAG_LATEX = ""LATEX"";
    private static final String TAG_SCITEX = ""SCITEX"";
    private static final String TAG_XL = ""XL"";
    private static final String ATTRIBUTE_VALUE__TRUE = ""T"";
    private static final String MDNS_ATTRIBUTE__HPLFMOBILEPRINTER = ""hplfpmobileprinter"";
    private static final String MDNS_ATTRIBUTE__TY = ""ty"";
    private static String[] mSupportedDesignJet = new String[]{
        ""HP DESIGNJET T120"",
        ""HP DESIGNJET T520"",
        ""HP DESIGNJET T930"",
        ""HP DESIGNJET T1530"",
        ""HP DESIGNJET T2530"",
        ""HP DESIGNJET T730"",
        ""HP DESIGNJET T830"",
    };
    private boolean isPrintSupported(String printerModel) {
        boolean isSupported;
        if (!TextUtils.isEmpty(printerModel)) {
            String modelToUpper = printerModel.toUpperCase(Locale.US);
            if (modelToUpper.contains(TAG_DESIGNJET)) {
                isSupported = isSupportedDesignjet(printerModel);
            } else
                isSupported = !(modelToUpper.contains(TAG_LATEX) || modelToUpper.contains(TAG_SCITEX)) && !(modelToUpper.contains(TAG_PAGEWIDE) && modelToUpper.contains(TAG_XL));
        } else {
            isSupported = false;
        }
        return isSupported;
    }
    private static boolean isSupportedDesignjet(String printerModel) {
        boolean isSupported = false;
        if (!TextUtils.isEmpty(printerModel)) {
            String modelToUpper = printerModel.toUpperCase(Locale.US);
            for (String supportedPrinter : mSupportedDesignJet) {
                if (modelToUpper.contains(supportedPrinter)) {
                    isSupported = true;
                }
            }
        }
        return isSupported;
    }
    public HPRecommendationPlugin(Context context) {
        super(context, R.string.plugin_vendor_hp, new VendorInfo(context.getResources(), R.array.known_print_vendor_info_for_hp), new String[]{""_pdl-datastream._tcp"",""_ipp._tcp"", ""_ipps._tcp""});
    }
    @Override
    public boolean matchesCriteria(String vendor, NsdServiceInfo nsdServiceInfo) {
        if (!TextUtils.equals(vendor, mVendorInfo.mVendorID)) return false;
        String pdls = MDnsUtils.getString(nsdServiceInfo.getAttributes().get(PDL_ATTRIBUTE));
        boolean hasMobileSupport = TextUtils.equals(ATTRIBUTE_VALUE__TRUE, MDnsUtils.getString(nsdServiceInfo.getAttributes().get(MDNS_ATTRIBUTE__HPLFMOBILEPRINTER)));
        return (((hasMobileSupport || isPrintSupported(MDnsUtils.getString(nsdServiceInfo.getAttributes().get(MDNS_ATTRIBUTE__TY))))
                    &&!TextUtils.isEmpty(pdls))
                && (pdls.contains(PDL__PCL)
                || pdls.contains(PDL__PDF)
                || pdls.contains(PDL__PCLM)
                || pdls.contains(PDL__PWG_RASTER)));
    }
}",class,
"    private boolean isPrintSupported(String printerModel) {
        boolean isSupported;
        if (!TextUtils.isEmpty(printerModel)) {
            String modelToUpper = printerModel.toUpperCase(Locale.US);
            if (modelToUpper.contains(TAG_DESIGNJET)) {
                isSupported = isSupportedDesignjet(printerModel);
            } else
                isSupported = !(modelToUpper.contains(TAG_LATEX) || modelToUpper.contains(TAG_SCITEX)) && !(modelToUpper.contains(TAG_PAGEWIDE) && modelToUpper.contains(TAG_XL));
        } else {
            isSupported = false;
        }
        return isSupported;
    }",method,
"    private static boolean isSupportedDesignjet(String printerModel) {
        boolean isSupported = false;
        if (!TextUtils.isEmpty(printerModel)) {
            String modelToUpper = printerModel.toUpperCase(Locale.US);
            for (String supportedPrinter : mSupportedDesignJet) {
                if (modelToUpper.contains(supportedPrinter)) {
                    isSupported = true;
                }
            }
        }
        return isSupported;
    }",method,
"            for (String supportedPrinter : mSupportedDesignJet) {
                if (modelToUpper.contains(supportedPrinter)) {
                    isSupported = true;
                }
            }",method,
"    public HPRecommendationPlugin(Context context) {
        super(context, R.string.plugin_vendor_hp, new VendorInfo(context.getResources(), R.array.known_print_vendor_info_for_hp), new String[]{""_pdl-datastream._tcp"",""_ipp._tcp"", ""_ipps._tcp""});
    }",method,

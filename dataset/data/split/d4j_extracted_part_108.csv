code_snippet,type,score
"    public void deliveryComplete(IMqttDeliveryToken token) {
    }",method,
"import java.util.*;
class ActivitySelection {
	static void activitySelection(List<Activity> activities, int n) {
		Collections.sort(activities, new ActivityComparator());
		System.out.println(""Following activities are selected"");
		int i= 0, j;
		System.out.println(activities.get(i));
		for (j = 1; j < n; j++){
			if (activities.get(j).start >= activities.get(i).finish){
				System.out.println(activities.get(j));
				i = j;
			}
		}
	}
	public static void main(String args[]) {
		List<Activity> activities = new ArrayList<Activity>();
		activities.add(new Activity(5, 9));
		activities.add(new Activity(1, 2));
		activities.add(new Activity(3, 4));
		activities.add(new Activity(0, 6));
		activities.add(new Activity(5, 7));
		activities.add(new Activity(8, 9));
		activitySelection(activities, 6);
	}
}",class,
"}
class Activity {
	int start;
	int finish;
	Activity(int start, int finish) {
		this.start = start;
		this.finish = finish;
	}
	@Override
    public String toString() {
        return String.format(""{start=%d, finish=%d}"", start, finish);
    }
}",class,
"}
class ActivityComparator implements Comparator<Activity> {
    @Override
    public int compare(Activity a, Activity b) {
        return a.finish < b.finish ? -1 : a.finish == b.finish ? 0 : 1;
    }
}",class,
"public class Dijkstra {
  // Dijkstra's algorithm to find shortest path from s to all other nodes
  public static int [] dijkstra (WeightedGraph G, int s) {
    final int [] dist = new int [G.size()];  // shortest known distance from ""s""
    final int [] pred = new int [G.size()];  // preceeding node in path
    final boolean [] visited = new boolean [G.size()]; // all false initially
    for (int i=0; i<dist.length; i++) {
      dist[i] = Integer.MAX_VALUE;
    }
    dist[s] = 0;
    for (int i=0; i<dist.length; i++) {
      final int next = minVertex (dist, visited);
      visited[next] = true;
      // The shortest path to next is dist[next] and via pred[next].
      final int [] n = G.neighbors (next);
      for (int j=0; j<n.length; j++) {
        final int v = n[j];
        final int d = dist[next] + G.getWeight(next,v);
        if (dist[v] > d) {
          dist[v] = d;
          pred[v] = next;
        }
      }
    }
    return pred;  // (ignore pred[s]==0!)
  }
  private static int minVertex (int [] dist, boolean [] v) {
    int x = Integer.MAX_VALUE;
    int y = -1;   // graph not connected, or no unvisited vertices
    for (int i=0; i<dist.length; i++) {
      if (!v[i] && dist[i]<x) {y=i; x=dist[i];}
    }
    return y;
  }
  public static void printPath (WeightedGraph G, int [] pred, int s, int e) {
    final java.util.ArrayList path = new java.util.ArrayList();
    int x = e;
    while (x!=s) {
      path.add (0, G.getLabel(x));
      x = pred[x];
    }
    path.add (0, G.getLabel(s));
    System.out.println (path);
  }
}",class,
"	static void activitySelection(List<Activity> activities, int n) {
		Collections.sort(activities, new ActivityComparator());
		System.out.println(""Following activities are selected"");
		int i= 0, j;
		System.out.println(activities.get(i));
		for (j = 1; j < n; j++){
			if (activities.get(j).start >= activities.get(i).finish){
				System.out.println(activities.get(j));
				i = j;
			}
		}
	}",method,
"		for (j = 1; j < n; j++){
			if (activities.get(j).start >= activities.get(i).finish){
				System.out.println(activities.get(j));
				i = j;
			}
		}",method,
"	public static void main(String args[]) {
		List<Activity> activities = new ArrayList<Activity>();
		activities.add(new Activity(5, 9));
		activities.add(new Activity(1, 2));
		activities.add(new Activity(3, 4));
		activities.add(new Activity(0, 6));
		activities.add(new Activity(5, 7));
		activities.add(new Activity(8, 9));
		activitySelection(activities, 6);
	}",method,
"	Activity(int start, int finish) {
		this.start = start;
		this.finish = finish;
	}",method,
"	@Override
    public String toString() {
        return String.format(""{start=%d, finish=%d}"", start, finish);
    }",method,
"    @Override
    public int compare(Activity a, Activity b) {
        return a.finish < b.finish ? -1 : a.finish == b.finish ? 0 : 1;
    }",method,
"  public static int [] dijkstra (WeightedGraph G, int s) {
    final int [] dist = new int [G.size()];  // shortest known distance from ""s""
    final int [] pred = new int [G.size()];  // preceeding node in path
    final boolean [] visited = new boolean [G.size()]; // all false initially
    for (int i=0; i<dist.length; i++) {
      dist[i] = Integer.MAX_VALUE;
    }
    dist[s] = 0;
    for (int i=0; i<dist.length; i++) {
      final int next = minVertex (dist, visited);
      visited[next] = true;
      // The shortest path to next is dist[next] and via pred[next].
      final int [] n = G.neighbors (next);
      for (int j=0; j<n.length; j++) {
        final int v = n[j];
        final int d = dist[next] + G.getWeight(next,v);
        if (dist[v] > d) {
          dist[v] = d;
          pred[v] = next;
        }
      }
    }
    return pred;  // (ignore pred[s]==0!)
  }",method,
"    for (int i=0; i<dist.length; i++) {
      dist[i] = Integer.MAX_VALUE;
    }",method,
"    for (int i=0; i<dist.length; i++) {
      final int next = minVertex (dist, visited);
      visited[next] = true;
      // The shortest path to next is dist[next] and via pred[next].
      final int [] n = G.neighbors (next);
      for (int j=0; j<n.length; j++) {
        final int v = n[j];
        final int d = dist[next] + G.getWeight(next,v);
        if (dist[v] > d) {
          dist[v] = d;
          pred[v] = next;
        }
      }
    }",method,
"      for (int j=0; j<n.length; j++) {
        final int v = n[j];
        final int d = dist[next] + G.getWeight(next,v);
        if (dist[v] > d) {
          dist[v] = d;
          pred[v] = next;
        }
      }",method,
"        if (dist[v] > d) {
          dist[v] = d;
          pred[v] = next;
        }",method,
"  private static int minVertex (int [] dist, boolean [] v) {
    int x = Integer.MAX_VALUE;
    int y = -1;   // graph not connected, or no unvisited vertices
    for (int i=0; i<dist.length; i++) {
      if (!v[i] && dist[i]<x) {y=i; x=dist[i];}
    }
    return y;
  }",method,
"    for (int i=0; i<dist.length; i++) {
      if (!v[i] && dist[i]<x) {y=i; x=dist[i];}
    }",method,
      if (!v[i] && dist[i]<x) {y=i; x=dist[i];},method,
"  public static void printPath (WeightedGraph G, int [] pred, int s, int e) {
    final java.util.ArrayList path = new java.util.ArrayList();
    int x = e;
    while (x!=s) {
      path.add (0, G.getLabel(x));
      x = pred[x];
    }
    path.add (0, G.getLabel(s));
    System.out.println (path);
  }",method,
"    while (x!=s) {
      path.add (0, G.getLabel(x));
      x = pred[x];
    }",method,
"public class RestExplainAction extends BaseRestHandler {
    public RestExplainAction(Settings settings, RestController controller) {
        super(settings);
        controller.registerHandler(GET, ""/{index}/{type}/{id}/_explain"", this);
        controller.registerHandler(POST, ""/{index}/{type}/{id}/_explain"", this);
    }
    @Override
    public String getName() {
        return ""explain_action"";
    }
    @Override
    public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {
        final ExplainRequest explainRequest = new ExplainRequest(request.param(""index""), request.param(""type""), request.param(""id""));
        explainRequest.parent(request.param(""parent""));
        explainRequest.routing(request.param(""routing""));
        explainRequest.preference(request.param(""preference""));
        String queryString = request.param(""q"");
        request.withContentOrSourceParamParserOrNull(parser -> {
            if (parser != null) {
                explainRequest.query(RestActions.getQueryContent(parser));
            } else if (queryString != null) {
                QueryBuilder query = RestActions.urlParamsToQueryBuilder(request);
                explainRequest.query(query);
            }
        });
        if (request.param(""fields"") != null) {
            throw new IllegalArgumentException(""The parameter [fields] is no longer supported, "" +
                ""please use [stored_fields] to retrieve stored fields"");
        }
        String sField = request.param(""stored_fields"");
        if (sField != null) {
            String[] sFields = Strings.splitStringByCommaToArray(sField);
            if (sFields != null) {
                explainRequest.storedFields(sFields);
            }
        }
        explainRequest.fetchSourceContext(FetchSourceContext.parseFromRestRequest(request));
        return channel -> client.explain(explainRequest, new RestBuilderListener<ExplainResponse>(channel) {
            @Override
            public RestResponse buildResponse(ExplainResponse response, XContentBuilder builder) throws Exception {
                builder.startObject();
                builder.field(Fields._INDEX, response.getIndex())
                        .field(Fields._TYPE, response.getType())
                        .field(Fields._ID, response.getId())
                        .field(Fields.MATCHED, response.isMatch());
                if (response.hasExplanation()) {
                    builder.startObject(Fields.EXPLANATION);
                    buildExplanation(builder, response.getExplanation());
                    builder.endObject();
                }
                GetResult getResult = response.getGetResult();
                if (getResult != null) {
                    builder.startObject(Fields.GET);
                    response.getGetResult().toXContentEmbedded(builder, request);
                    builder.endObject();
                }
                builder.endObject();
                return new BytesRestResponse(response.isExists() ? OK : NOT_FOUND, builder);
            }
            private void buildExplanation(XContentBuilder builder, Explanation explanation) throws IOException {
                builder.field(Fields.VALUE, explanation.getValue());
                builder.field(Fields.DESCRIPTION, explanation.getDescription());
                Explanation[] innerExps = explanation.getDetails();
                if (innerExps != null) {
                    builder.startArray(Fields.DETAILS);
                    for (Explanation exp : innerExps) {
                        builder.startObject();
                        buildExplanation(builder, exp);
                        builder.endObject();
                    }
                    builder.endArray();
                }
            }
        });
    }
    static class Fields {
        static final String _INDEX = ""_index"";
        static final String _TYPE = ""_type"";
        static final String _ID = ""_id"";
        static final String MATCHED = ""matched"";
        static final String EXPLANATION = ""explanation"";
        static final String VALUE = ""value"";
        static final String DESCRIPTION = ""description"";
        static final String DETAILS = ""details"";
        static final String GET = ""get"";
    }
}",class,
"    static class Fields {
        static final String _INDEX = ""_index"";
        static final String _TYPE = ""_type"";
        static final String _ID = ""_id"";
        static final String MATCHED = ""matched"";
        static final String EXPLANATION = ""explanation"";
        static final String VALUE = ""value"";
        static final String DESCRIPTION = ""description"";
        static final String DETAILS = ""details"";
        static final String GET = ""get"";
    }",class,
"    public RestExplainAction(Settings settings, RestController controller) {
        super(settings);
        controller.registerHandler(GET, ""/{index}/{type}/{id}/_explain"", this);
        controller.registerHandler(POST, ""/{index}/{type}/{id}/_explain"", this);
    }",method,
"    @Override
    public String getName() {
        return ""explain_action"";
    }",method,
"    @Override
    public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {
        final ExplainRequest explainRequest = new ExplainRequest(request.param(""index""), request.param(""type""), request.param(""id""));
        explainRequest.parent(request.param(""parent""));
        explainRequest.routing(request.param(""routing""));
        explainRequest.preference(request.param(""preference""));
        String queryString = request.param(""q"");
        request.withContentOrSourceParamParserOrNull(parser -> {
            if (parser != null) {
                explainRequest.query(RestActions.getQueryContent(parser));
            } else if (queryString != null) {
                QueryBuilder query = RestActions.urlParamsToQueryBuilder(request);
                explainRequest.query(query);
            }
        });
        if (request.param(""fields"") != null) {
            throw new IllegalArgumentException(""The parameter [fields] is no longer supported, "" +
                ""please use [stored_fields] to retrieve stored fields"");
        }
        String sField = request.param(""stored_fields"");
        if (sField != null) {
            String[] sFields = Strings.splitStringByCommaToArray(sField);
            if (sFields != null) {
                explainRequest.storedFields(sFields);
            }
        }
        explainRequest.fetchSourceContext(FetchSourceContext.parseFromRestRequest(request));
        return channel -> client.explain(explainRequest, new RestBuilderListener<ExplainResponse>(channel) {
            @Override
            public RestResponse buildResponse(ExplainResponse response, XContentBuilder builder) throws Exception {
                builder.startObject();
                builder.field(Fields._INDEX, response.getIndex())
                        .field(Fields._TYPE, response.getType())
                        .field(Fields._ID, response.getId())
                        .field(Fields.MATCHED, response.isMatch());
                if (response.hasExplanation()) {
                    builder.startObject(Fields.EXPLANATION);
                    buildExplanation(builder, response.getExplanation());
                    builder.endObject();
                }
                GetResult getResult = response.getGetResult();
                if (getResult != null) {
                    builder.startObject(Fields.GET);
                    response.getGetResult().toXContentEmbedded(builder, request);
                    builder.endObject();
                }
                builder.endObject();
                return new BytesRestResponse(response.isExists() ? OK : NOT_FOUND, builder);
            }
            private void buildExplanation(XContentBuilder builder, Explanation explanation) throws IOException {
                builder.field(Fields.VALUE, explanation.getValue());
                builder.field(Fields.DESCRIPTION, explanation.getDescription());
                Explanation[] innerExps = explanation.getDetails();
                if (innerExps != null) {
                    builder.startArray(Fields.DETAILS);
                    for (Explanation exp : innerExps) {
                        builder.startObject();
                        buildExplanation(builder, exp);
                        builder.endObject();
                    }
                    builder.endArray();
                }
            }
        });
    }",method,
"        request.withContentOrSourceParamParserOrNull(parser -> {
            if (parser != null) {
                explainRequest.query(RestActions.getQueryContent(parser));
            }",method,
"        if (sField != null) {
            String[] sFields = Strings.splitStringByCommaToArray(sField);
            if (sFields != null) {
                explainRequest.storedFields(sFields);
            }
        }",method,
"            if (sFields != null) {
                explainRequest.storedFields(sFields);
            }",method,
"            @Override
            public RestResponse buildResponse(ExplainResponse response, XContentBuilder builder) throws Exception {
                builder.startObject();
                builder.field(Fields._INDEX, response.getIndex())
                        .field(Fields._TYPE, response.getType())
                        .field(Fields._ID, response.getId())
                        .field(Fields.MATCHED, response.isMatch());
                if (response.hasExplanation()) {
                    builder.startObject(Fields.EXPLANATION);
                    buildExplanation(builder, response.getExplanation());
                    builder.endObject();
                }
                GetResult getResult = response.getGetResult();
                if (getResult != null) {
                    builder.startObject(Fields.GET);
                    response.getGetResult().toXContentEmbedded(builder, request);
                    builder.endObject();
                }
                builder.endObject();
                return new BytesRestResponse(response.isExists() ? OK : NOT_FOUND, builder);
            }",method,
"                if (getResult != null) {
                    builder.startObject(Fields.GET);
                    response.getGetResult().toXContentEmbedded(builder, request);
                    builder.endObject();
                }",method,
"            private void buildExplanation(XContentBuilder builder, Explanation explanation) throws IOException {
                builder.field(Fields.VALUE, explanation.getValue());
                builder.field(Fields.DESCRIPTION, explanation.getDescription());
                Explanation[] innerExps = explanation.getDetails();
                if (innerExps != null) {
                    builder.startArray(Fields.DETAILS);
                    for (Explanation exp : innerExps) {
                        builder.startObject();
                        buildExplanation(builder, exp);
                        builder.endObject();
                    }
                    builder.endArray();
                }
            }",method,
"                if (innerExps != null) {
                    builder.startArray(Fields.DETAILS);
                    for (Explanation exp : innerExps) {
                        builder.startObject();
                        buildExplanation(builder, exp);
                        builder.endObject();
                    }
                    builder.endArray();
                }",method,
"                    for (Explanation exp : innerExps) {
                        builder.startObject();
                        buildExplanation(builder, exp);
                        builder.endObject();
                    }",method,
"            if (parser != null) {
                explainRequest.query(RestActions.getQueryContent(parser));
            }",method,
"public class AsciiDependencyReportRenderer extends TextReportRenderer implements DependencyReportRenderer {
    private LegendRenderer legendRenderer;
    private boolean hasConfigs;
    DependencyGraphRenderer dependencyGraphRenderer;
    @Override
    public void startProject(Project project) {
        super.startProject(project);
        hasConfigs = false;
        legendRenderer = new LegendRenderer(getTextOutput());
    }
    @Override
    public void completeProject(Project project) {
        if (!hasConfigs) {
            getTextOutput().withStyle(Info).println(""No configurations"");
        }
        super.completeProject(project);
    }
    @Override
    public void startConfiguration(final Configuration configuration) {
        if (hasConfigs) {
            getTextOutput().println();
        }
        hasConfigs = true;
        GraphRenderer renderer = new GraphRenderer(getTextOutput());
        renderer.visit(new Action<StyledTextOutput>() {
            public void execute(StyledTextOutput styledTextOutput) {
                getTextOutput().withStyle(Identifier).text(configuration.getName());
                getTextOutput().withStyle(Description).text(getDescription(configuration));
                if (!configuration.isCanBeResolved()) {
                    getTextOutput().withStyle(Info).text("" (n)"");
                }
            }
        }, true);
        NodeRenderer nodeRenderer = new SimpleNodeRenderer();
        dependencyGraphRenderer = new DependencyGraphRenderer(renderer, nodeRenderer, legendRenderer);
    }
    private String getDescription(Configuration configuration) {
        return GUtil.isTrue(configuration.getDescription()) ? "" - "" + configuration.getDescription() : """";
    }
    @Override
    public void completeConfiguration(Configuration configuration) {}
    @Override
    public void render(Configuration configuration) throws IOException {
        if (configuration.isCanBeResolved()) {
            ResolutionResult result = configuration.getIncoming().getResolutionResult();
            RenderableDependency root = new RenderableModuleResult(result.getRoot());
            renderNow(root);
        } else {
            renderNow(new UnresolvableConfigurationResult(configuration));
        }
    }
    void renderNow(RenderableDependency root) {
        if (root.getChildren().isEmpty()) {
            getTextOutput().withStyle(Info).text(""No dependencies"");
            getTextOutput().println();
            return;
        }
        dependencyGraphRenderer.render(root);
    }
    @Override
    public void complete() {
        legendRenderer.printLegend();
        super.complete();
    }
}",class,
"    @Override
    public void startProject(Project project) {
        super.startProject(project);
        hasConfigs = false;
        legendRenderer = new LegendRenderer(getTextOutput());
    }",method,
"    @Override
    public void completeProject(Project project) {
        if (!hasConfigs) {
            getTextOutput().withStyle(Info).println(""No configurations"");
        }
        super.completeProject(project);
    }",method,
"        if (!hasConfigs) {
            getTextOutput().withStyle(Info).println(""No configurations"");
        }",method,
"    @Override
    public void startConfiguration(final Configuration configuration) {
        if (hasConfigs) {
            getTextOutput().println();
        }
        hasConfigs = true;
        GraphRenderer renderer = new GraphRenderer(getTextOutput());
        renderer.visit(new Action<StyledTextOutput>() {
            public void execute(StyledTextOutput styledTextOutput) {
                getTextOutput().withStyle(Identifier).text(configuration.getName());
                getTextOutput().withStyle(Description).text(getDescription(configuration));
                if (!configuration.isCanBeResolved()) {
                    getTextOutput().withStyle(Info).text("" (n)"");
                }
            }
        }, true);
        NodeRenderer nodeRenderer = new SimpleNodeRenderer();
        dependencyGraphRenderer = new DependencyGraphRenderer(renderer, nodeRenderer, legendRenderer);
    }",method,
"        if (hasConfigs) {
            getTextOutput().println();
        }",method,
"        renderer.visit(new Action<StyledTextOutput>() {
            public void execute(StyledTextOutput styledTextOutput) {
                getTextOutput().withStyle(Identifier).text(configuration.getName());
                getTextOutput().withStyle(Description).text(getDescription(configuration));
                if (!configuration.isCanBeResolved()) {
                    getTextOutput().withStyle(Info).text("" (n)"");
                }
            }
        }",method,
"            public void execute(StyledTextOutput styledTextOutput) {
                getTextOutput().withStyle(Identifier).text(configuration.getName());
                getTextOutput().withStyle(Description).text(getDescription(configuration));
                if (!configuration.isCanBeResolved()) {
                    getTextOutput().withStyle(Info).text("" (n)"");
                }
            }",method,
"    private String getDescription(Configuration configuration) {
        return GUtil.isTrue(configuration.getDescription()) ? "" - "" + configuration.getDescription() : """";
    }",method,
"    @Override
    public void completeConfiguration(Configuration configuration) {}",method,
"    @Override
    public void render(Configuration configuration) throws IOException {
        if (configuration.isCanBeResolved()) {
            ResolutionResult result = configuration.getIncoming().getResolutionResult();
            RenderableDependency root = new RenderableModuleResult(result.getRoot());
            renderNow(root);
        } else {
            renderNow(new UnresolvableConfigurationResult(configuration));
        }
    }",method,
"    void renderNow(RenderableDependency root) {
        if (root.getChildren().isEmpty()) {
            getTextOutput().withStyle(Info).text(""No dependencies"");
            getTextOutput().println();
            return;
        }
        dependencyGraphRenderer.render(root);
    }",method,
"    @Override
    public void complete() {
        legendRenderer.printLegend();
        super.complete();
    }",method,
"public abstract class Http2ChannelDuplexHandler extends ChannelDuplexHandler {
    private volatile Http2FrameCodec frameCodec;
    @Override
    public final void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        frameCodec = requireHttp2FrameCodec(ctx);
        handlerAdded0(ctx);
    }
    protected void handlerAdded0(@SuppressWarnings(""unused"") ChannelHandlerContext ctx) throws Exception {
        // NOOP
    }
    @Override
    public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        try {
            handlerRemoved0(ctx);
        } finally {
            frameCodec = null;
        }
    }
    protected void handlerRemoved0(@SuppressWarnings(""unused"") ChannelHandlerContext ctx) throws Exception {
        // NOOP
    }
    public final Http2FrameStream newStream() {
        Http2FrameCodec codec = frameCodec;
        if (codec == null) {
            throw new IllegalStateException(StringUtil.simpleClassName(Http2FrameCodec.class) + "" not found."" +
                    "" Has the handler been added to a pipeline?"");
        }
        return codec.newStream();
    }
    protected final void forEachActiveStream(Http2FrameStreamVisitor streamVisitor) throws Http2Exception {
        frameCodec.forEachActiveStream(streamVisitor);
    }
    private static Http2FrameCodec requireHttp2FrameCodec(ChannelHandlerContext ctx) {
        ChannelHandlerContext frameCodecCtx = ctx.pipeline().context(Http2FrameCodec.class);
        if (frameCodecCtx == null) {
            throw new IllegalArgumentException(Http2FrameCodec.class.getSimpleName()
                                               + "" was not found in the channel pipeline."");
        }
        return (Http2FrameCodec) frameCodecCtx.handler();
    }
}",class,
"    @Override
    public final void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        frameCodec = requireHttp2FrameCodec(ctx);
        handlerAdded0(ctx);
    }",method,
"    @Override
    public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        try {
            handlerRemoved0(ctx);
        } finally {
            frameCodec = null;
        }
    }",method,
"    public final Http2FrameStream newStream() {
        Http2FrameCodec codec = frameCodec;
        if (codec == null) {
            throw new IllegalStateException(StringUtil.simpleClassName(Http2FrameCodec.class) + "" not found."" +
                    "" Has the handler been added to a pipeline?"");
        }
        return codec.newStream();
    }",method,
"        if (codec == null) {
            throw new IllegalStateException(StringUtil.simpleClassName(Http2FrameCodec.class) + "" not found."" +
                    "" Has the handler been added to a pipeline?"");
        }",method,
"    protected final void forEachActiveStream(Http2FrameStreamVisitor streamVisitor) throws Http2Exception {
        frameCodec.forEachActiveStream(streamVisitor);
    }",method,
"    private static Http2FrameCodec requireHttp2FrameCodec(ChannelHandlerContext ctx) {
        ChannelHandlerContext frameCodecCtx = ctx.pipeline().context(Http2FrameCodec.class);
        if (frameCodecCtx == null) {
            throw new IllegalArgumentException(Http2FrameCodec.class.getSimpleName()
                                               + "" was not found in the channel pipeline."");
        }
        return (Http2FrameCodec) frameCodecCtx.handler();
    }",method,
"        if (frameCodecCtx == null) {
            throw new IllegalArgumentException(Http2FrameCodec.class.getSimpleName()
                                               + "" was not found in the channel pipeline."");
        }",method,
"public class LoggerPrinterTest {
  private final Printer printer = new LoggerPrinter();
  @Mock LogAdapter adapter;
  @Before public void setup() {
    initMocks(this);
    when(adapter.isLoggable(any(Integer.class), any(String.class))).thenReturn(true);
    printer.addAdapter(adapter);
  }
  @Test public void logDebug() {
    printer.d(""message %s"", ""sent"");
    verify(adapter).log(DEBUG, null, ""message sent"");
  }
  @Test public void logError() {
    printer.e(""message %s"", ""sent"");
    verify(adapter).log(ERROR, null, ""message sent"");
  }
  @Test public void logErrorWithThrowable() {
    Throwable throwable = new Throwable(""exception"");
    printer.e(throwable, ""message %s"", ""sent"");
    verify(adapter).log(eq(ERROR), isNull(String.class), contains(""message sent : java.lang.Throwable: exception""));
  }
  @Test public void logWarning() {
    printer.w(""message %s"", ""sent"");
    verify(adapter).log(WARN, null, ""message sent"");
  }
  @Test public void logInfo() {
    printer.i(""message %s"", ""sent"");
    verify(adapter).log(INFO, null, ""message sent"");
  }
  @Test public void logWtf() {
    printer.wtf(""message %s"", ""sent"");
    verify(adapter).log(ASSERT, null, ""message sent"");
  }
  @Test public void logVerbose() {
    printer.v(""message %s"", ""sent"");
    verify(adapter).log(VERBOSE, null, ""message sent"");
  }
  @Test public void oneTimeTag() {
    printer.t(""tag"").d(""message"");
    verify(adapter).log(DEBUG, ""tag"", ""message"");
  }
  @Test public void logObject() {
    Object object = ""Test"";
    printer.d(object);
    verify(adapter).log(DEBUG, null, ""Test"");
  }
  @Test public void logArray() {
    Object object = new int[]{1, 6, 7, 30, 33};
    printer.d(object);
    verify(adapter).log(DEBUG, null, ""[1, 6, 7, 30, 33]"");
  }
  @Test public void logStringArray() {
    Object object = new String[]{""a"", ""b"", ""c""};
    printer.d(object);
    verify(adapter).log(DEBUG, null, ""[a, b, c]"");
  }
  @Test public void logMultiDimensionArray() {
    double[][] doubles = {
        {1, 6},
        {1.2, 33},
    };
    printer.d(doubles);
    verify(adapter).log(DEBUG, null, ""[[1.0, 6.0], [1.2, 33.0]]"");
  }
  @Test public void logList() {
    List<String> list = Arrays.asList(""foo"", ""bar"");
    printer.d(list);
    verify(adapter).log(DEBUG, null, list.toString());
  }
  @Test public void logMap() {
    Map<String, String> map = new HashMap<>();
    map.put(""key"", ""value"");
    map.put(""key2"", ""value2"");
    printer.d(map);
    verify(adapter).log(DEBUG, null, map.toString());
  }
  @Test public void logSet() {
    Set<String> set = new HashSet<>();
    set.add(""key"");
    set.add(""key1"");
    printer.d(set);
    verify(adapter).log(DEBUG, null, set.toString());
  }
  @Test public void logJsonObject() {
    printer.json(""  {\""key\"":3}"");
    verify(adapter).log(DEBUG, null, ""{\""key\"": 3}"");
  }
  @Test public void logJsonArray() {
    printer.json(""[{\""key\"":3}]"");
    verify(adapter).log(DEBUG, null, ""[{\""key\"": 3}]"");
  }
  @Test public void logInvalidJsonObject() {
    printer.json(""no json"");
    printer.json(""{ missing end"");
    verify(adapter, times(2)).log(ERROR, null, ""Invalid Json"");
  }
  @Test public void jsonLogEmptyOrNull() {
    printer.json(null);
    printer.json("""");
    verify(adapter, times(2)).log(DEBUG, null, ""Empty/Null json content"");
  }
  @Test public void xmlLog() {
    printer.xml(""<xml>Test</xml>"");
    verify(adapter).log(DEBUG, null,
        ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n<xml>Test</xml>\n"");
  }
  @Test public void invalidXmlLog() {
    printer.xml(""xml>Test</xml>"");
    verify(adapter).log(ERROR, null, ""Invalid xml"");
  }
  @Test public void xmlLogNullOrEmpty() {
    printer.xml(null);
    printer.xml("""");
    verify(adapter, times(2)).log(DEBUG, null, ""Empty/Null xml content"");
  }
  @Test public void clearLogAdapters() {
    printer.clearLogAdapters();
    printer.d("""");
    verifyZeroInteractions(adapter);
  }
  @Test public void addAdapter() {
    printer.clearLogAdapters();
    LogAdapter adapter1 = mock(LogAdapter.class);
    LogAdapter adapter2 = mock(LogAdapter.class);
    printer.addAdapter(adapter1);
    printer.addAdapter(adapter2);
    printer.d(""message"");
    verify(adapter1).isLoggable(DEBUG, null);
    verify(adapter2).isLoggable(DEBUG, null);
  }
  @Test public void doNotLogIfNotLoggable() {
    printer.clearLogAdapters();
    LogAdapter adapter1 = mock(LogAdapter.class);
    when(adapter1.isLoggable(DEBUG, null)).thenReturn(false);
    LogAdapter adapter2 = mock(LogAdapter.class);
    when(adapter2.isLoggable(DEBUG, null)).thenReturn(true);
    printer.addAdapter(adapter1);
    printer.addAdapter(adapter2);
    printer.d(""message"");
    verify(adapter1, never()).log(DEBUG, null, ""message"");
    verify(adapter2).log(DEBUG, null, ""message"");
  }
  @Test public void logWithoutMessageAndThrowable() {
    printer.log(DEBUG, null, null, null);
    verify(adapter).log(DEBUG, null, ""Empty/NULL log message"");
  }
  @Test public void logWithOnlyThrowableWithoutMessage() {
    Throwable throwable = new Throwable(""exception"");
    printer.log(DEBUG, null, null, throwable);
    verify(adapter).log(eq(DEBUG), isNull(String.class), contains(""java.lang.Throwable: exception""));
  }
}",class,
"public class RootDomParentStrategy implements DomParentStrategy {
  private final DomFileElementImpl myFileElement;
  public RootDomParentStrategy(final DomFileElementImpl fileElement) {
    myFileElement = fileElement;
  }
  @Override
  @NotNull
  public DomInvocationHandler getParentHandler() {
    throw new UnsupportedOperationException(""Method getParentHandler is not yet implemented in "" + getClass().getName());
  }
  @Override
  public XmlTag getXmlElement() {
    return myFileElement.getRootTag();
  }
  @Override
  @NotNull
  public DomParentStrategy refreshStrategy(final DomInvocationHandler handler) {
    return this;
  }
  @Override
  @NotNull
  public DomParentStrategy setXmlElement(@NotNull final XmlElement element) {
    return this;
  }
  @Override
  @NotNull
  public DomParentStrategy clearXmlElement() {
    return this;
  }
  @Override
  public String checkValidity() {
    return myFileElement.checkValidity();
  }
  @Override
  public XmlFile getContainingFile(DomInvocationHandler handler) {
    return myFileElement.getFile();
  }
  @Override
  public boolean isPhysical() {
    return true;
  }
  public boolean equals(final Object o) {
    if (this == o) return true;
    if (!(o instanceof RootDomParentStrategy)) return false;
    final RootDomParentStrategy that = (RootDomParentStrategy)o;
    if (!myFileElement.equals(that.myFileElement)) return false;
    return true;
  }
  public int hashCode() {
    return myFileElement.hashCode();
  }
}",class,
"  public RootDomParentStrategy(final DomFileElementImpl fileElement) {
    myFileElement = fileElement;
  }",method,
"  @Override
  @NotNull
  public DomInvocationHandler getParentHandler() {
    throw new UnsupportedOperationException(""Method getParentHandler is not yet implemented in "" + getClass().getName());
  }",method,
"  @Override
  public XmlTag getXmlElement() {
    return myFileElement.getRootTag();
  }",method,
"  @Override
  @NotNull
  public DomParentStrategy refreshStrategy(final DomInvocationHandler handler) {
    return this;
  }",method,
"  @Override
  @NotNull
  public DomParentStrategy setXmlElement(@NotNull final XmlElement element) {
    return this;
  }",method,
"  @Override
  @NotNull
  public DomParentStrategy clearXmlElement() {
    return this;
  }",method,
"  @Override
  public String checkValidity() {
    return myFileElement.checkValidity();
  }",method,
"  @Override
  public XmlFile getContainingFile(DomInvocationHandler handler) {
    return myFileElement.getFile();
  }",method,
"  @Override
  public boolean isPhysical() {
    return true;
  }",method,
"  public boolean equals(final Object o) {
    if (this == o) return true;
    if (!(o instanceof RootDomParentStrategy)) return false;
    final RootDomParentStrategy that = (RootDomParentStrategy)o;
    if (!myFileElement.equals(that.myFileElement)) return false;
    return true;
  }",method,
"  public int hashCode() {
    return myFileElement.hashCode();
  }",method,
"public abstract class BaseLoaderCallback implements LoaderCallbackInterface {
    public BaseLoaderCallback(Context AppContext) {
        mAppContext = AppContext;
    }
    public void onManagerConnected(int status)
    {
        switch (status)
        {
            case LoaderCallbackInterface.SUCCESS:
            {
            } break;
            case LoaderCallbackInterface.MARKET_ERROR:
            {
                Log.e(TAG, ""Package installation failed!"");
                AlertDialog MarketErrorMessage = new AlertDialog.Builder(mAppContext).create();
                MarketErrorMessage.setTitle(""OpenCV Manager"");
                MarketErrorMessage.setMessage(""Package installation failed!"");
                MarketErrorMessage.setCancelable(false); // This blocks the 'BACK' button
                MarketErrorMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                MarketErrorMessage.show();
            } break;
            case LoaderCallbackInterface.INSTALL_CANCELED:
            {
                Log.d(TAG, ""OpenCV library installation was canceled by user"");
                finish();
            } break;
            case LoaderCallbackInterface.INCOMPATIBLE_MANAGER_VERSION:
            {
                Log.d(TAG, ""OpenCV Manager Service is uncompatible with this app!"");
                AlertDialog IncomatibilityMessage = new AlertDialog.Builder(mAppContext).create();
                IncomatibilityMessage.setTitle(""OpenCV Manager"");
                IncomatibilityMessage.setMessage(""OpenCV Manager service is incompatible with this app. Try to update it via Google Play."");
                IncomatibilityMessage.setCancelable(false); // This blocks the 'BACK' button
                IncomatibilityMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                IncomatibilityMessage.show();
            } break;
            default:
            {
                Log.e(TAG, ""OpenCV loading failed!"");
                AlertDialog InitFailedDialog = new AlertDialog.Builder(mAppContext).create();
                InitFailedDialog.setTitle(""OpenCV error"");
                InitFailedDialog.setMessage(""OpenCV was not initialised correctly. Application will be shut down"");
                InitFailedDialog.setCancelable(false); // This blocks the 'BACK' button
                InitFailedDialog.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                InitFailedDialog.show();
            } break;
        }
    }
    public void onPackageInstall(final int operation, final InstallCallbackInterface callback)
    {
        switch (operation)
        {
            case InstallCallbackInterface.NEW_INSTALLATION:
            {
                AlertDialog InstallMessage = new AlertDialog.Builder(mAppContext).create();
                InstallMessage.setTitle(""Package not found"");
                InstallMessage.setMessage(callback.getPackageName() + "" package was not found! Try to install it?"");
                InstallMessage.setCancelable(false); // This blocks the 'BACK' button
                InstallMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Yes"", new OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.install();
                    }
                });
                InstallMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""No"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.cancel();
                    }
                });
                InstallMessage.show();
            } break;
            case InstallCallbackInterface.INSTALLATION_PROGRESS:
            {
                AlertDialog WaitMessage = new AlertDialog.Builder(mAppContext).create();
                WaitMessage.setTitle(""OpenCV is not ready"");
                WaitMessage.setMessage(""Installation is in progress. Wait or exit?"");
                WaitMessage.setCancelable(false); // This blocks the 'BACK' button
                WaitMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Wait"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.wait_install();
                    }
                });
                WaitMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""Exit"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.cancel();
                    }
                });
                WaitMessage.show();
            } break;
        }
    }
    void finish()
    {
        ((Activity) mAppContext).finish();
    }
    protected Context mAppContext;
    private final static String TAG = ""OpenCVLoader/BaseLoaderCallback"";
}",class,
"    public BaseLoaderCallback(Context AppContext) {
        mAppContext = AppContext;
    }",method,
"    public void onManagerConnected(int status)
    {
        switch (status)
        {
            case LoaderCallbackInterface.SUCCESS:
            {
            } break;
            case LoaderCallbackInterface.MARKET_ERROR:
            {
                Log.e(TAG, ""Package installation failed!"");
                AlertDialog MarketErrorMessage = new AlertDialog.Builder(mAppContext).create();
                MarketErrorMessage.setTitle(""OpenCV Manager"");
                MarketErrorMessage.setMessage(""Package installation failed!"");
                MarketErrorMessage.setCancelable(false); // This blocks the 'BACK' button
                MarketErrorMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                MarketErrorMessage.show();
            } break;
            case LoaderCallbackInterface.INSTALL_CANCELED:
            {
                Log.d(TAG, ""OpenCV library installation was canceled by user"");
                finish();
            } break;
            case LoaderCallbackInterface.INCOMPATIBLE_MANAGER_VERSION:
            {
                Log.d(TAG, ""OpenCV Manager Service is uncompatible with this app!"");
                AlertDialog IncomatibilityMessage = new AlertDialog.Builder(mAppContext).create();
                IncomatibilityMessage.setTitle(""OpenCV Manager"");
                IncomatibilityMessage.setMessage(""OpenCV Manager service is incompatible with this app. Try to update it via Google Play."");
                IncomatibilityMessage.setCancelable(false); // This blocks the 'BACK' button
                IncomatibilityMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                IncomatibilityMessage.show();
            } break;
            default:
            {
                Log.e(TAG, ""OpenCV loading failed!"");
                AlertDialog InitFailedDialog = new AlertDialog.Builder(mAppContext).create();
                InitFailedDialog.setTitle(""OpenCV error"");
                InitFailedDialog.setMessage(""OpenCV was not initialised correctly. Application will be shut down"");
                InitFailedDialog.setCancelable(false); // This blocks the 'BACK' button
                InitFailedDialog.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                InitFailedDialog.show();
            } break;
        }
    }",method,
"        switch (status)
        {
            case LoaderCallbackInterface.SUCCESS:
            {
            } break;
            case LoaderCallbackInterface.MARKET_ERROR:
            {
                Log.e(TAG, ""Package installation failed!"");
                AlertDialog MarketErrorMessage = new AlertDialog.Builder(mAppContext).create();
                MarketErrorMessage.setTitle(""OpenCV Manager"");
                MarketErrorMessage.setMessage(""Package installation failed!"");
                MarketErrorMessage.setCancelable(false); // This blocks the 'BACK' button
                MarketErrorMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                MarketErrorMessage.show();
            } break;
            case LoaderCallbackInterface.INSTALL_CANCELED:
            {
                Log.d(TAG, ""OpenCV library installation was canceled by user"");
                finish();
            } break;
            case LoaderCallbackInterface.INCOMPATIBLE_MANAGER_VERSION:
            {
                Log.d(TAG, ""OpenCV Manager Service is uncompatible with this app!"");
                AlertDialog IncomatibilityMessage = new AlertDialog.Builder(mAppContext).create();
                IncomatibilityMessage.setTitle(""OpenCV Manager"");
                IncomatibilityMessage.setMessage(""OpenCV Manager service is incompatible with this app. Try to update it via Google Play."");
                IncomatibilityMessage.setCancelable(false); // This blocks the 'BACK' button
                IncomatibilityMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                IncomatibilityMessage.show();
            } break;
            default:
            {
                Log.e(TAG, ""OpenCV loading failed!"");
                AlertDialog InitFailedDialog = new AlertDialog.Builder(mAppContext).create();
                InitFailedDialog.setTitle(""OpenCV error"");
                InitFailedDialog.setMessage(""OpenCV was not initialised correctly. Application will be shut down"");
                InitFailedDialog.setCancelable(false); // This blocks the 'BACK' button
                InitFailedDialog.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
                InitFailedDialog.show();
            } break;
        }",method,
"                MarketErrorMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                }",method,
"                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }",method,
"                IncomatibilityMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                }",method,
"                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }",method,
"                InitFailedDialog.setButton(AlertDialog.BUTTON_POSITIVE, ""OK"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                }",method,
"                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }",method,
"    public void onPackageInstall(final int operation, final InstallCallbackInterface callback)
    {
        switch (operation)
        {
            case InstallCallbackInterface.NEW_INSTALLATION:
            {
                AlertDialog InstallMessage = new AlertDialog.Builder(mAppContext).create();
                InstallMessage.setTitle(""Package not found"");
                InstallMessage.setMessage(callback.getPackageName() + "" package was not found! Try to install it?"");
                InstallMessage.setCancelable(false); // This blocks the 'BACK' button
                InstallMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Yes"", new OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.install();
                    }
                });
                InstallMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""No"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.cancel();
                    }
                });
                InstallMessage.show();
            } break;
            case InstallCallbackInterface.INSTALLATION_PROGRESS:
            {
                AlertDialog WaitMessage = new AlertDialog.Builder(mAppContext).create();
                WaitMessage.setTitle(""OpenCV is not ready"");
                WaitMessage.setMessage(""Installation is in progress. Wait or exit?"");
                WaitMessage.setCancelable(false); // This blocks the 'BACK' button
                WaitMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Wait"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.wait_install();
                    }
                });
                WaitMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""Exit"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.cancel();
                    }
                });
                WaitMessage.show();
            } break;
        }
    }",method,
"        switch (operation)
        {
            case InstallCallbackInterface.NEW_INSTALLATION:
            {
                AlertDialog InstallMessage = new AlertDialog.Builder(mAppContext).create();
                InstallMessage.setTitle(""Package not found"");
                InstallMessage.setMessage(callback.getPackageName() + "" package was not found! Try to install it?"");
                InstallMessage.setCancelable(false); // This blocks the 'BACK' button
                InstallMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Yes"", new OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.install();
                    }
                });
                InstallMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""No"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.cancel();
                    }
                });
                InstallMessage.show();
            } break;
            case InstallCallbackInterface.INSTALLATION_PROGRESS:
            {
                AlertDialog WaitMessage = new AlertDialog.Builder(mAppContext).create();
                WaitMessage.setTitle(""OpenCV is not ready"");
                WaitMessage.setMessage(""Installation is in progress. Wait or exit?"");
                WaitMessage.setCancelable(false); // This blocks the 'BACK' button
                WaitMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Wait"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.wait_install();
                    }
                });
                WaitMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""Exit"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.cancel();
                    }
                });
                WaitMessage.show();
            } break;
        }",method,
"                InstallMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Yes"", new OnClickListener()
                {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.install();
                    }
                }",method,
"                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.install();
                    }",method,
"                InstallMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""No"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.cancel();
                    }
                }",method,
"                    public void onClick(DialogInterface dialog, int which)
                    {
                        callback.cancel();
                    }",method,
"                WaitMessage.setButton(AlertDialog.BUTTON_POSITIVE, ""Wait"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.wait_install();
                    }
                }",method,
"                    public void onClick(DialogInterface dialog, int which) {
                        callback.wait_install();
                    }",method,
"                WaitMessage.setButton(AlertDialog.BUTTON_NEGATIVE, ""Exit"", new OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        callback.cancel();
                    }
                }",method,
"                    public void onClick(DialogInterface dialog, int which) {
                        callback.cancel();
                    }",method,
"    void finish()
    {
        ((Activity) mAppContext).finish();
    }",method,
"public class SocksCmdRequestDecoder extends ReplayingDecoder<State> {
    private SocksCmdType cmdType;
    private SocksAddressType addressType;
    public SocksCmdRequestDecoder() {
        super(State.CHECK_PROTOCOL_VERSION);
    }
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
        switch (state()) {
            case CHECK_PROTOCOL_VERSION: {
                if (byteBuf.readByte() != SocksProtocolVersion.SOCKS5.byteValue()) {
                    out.add(SocksCommonUtils.UNKNOWN_SOCKS_REQUEST);
                    break;
                }
                checkpoint(State.READ_CMD_HEADER);
            }
            case READ_CMD_HEADER: {
                cmdType = SocksCmdType.valueOf(byteBuf.readByte());
                byteBuf.skipBytes(1); // reserved
                addressType = SocksAddressType.valueOf(byteBuf.readByte());
                checkpoint(State.READ_CMD_ADDRESS);
            }
            case READ_CMD_ADDRESS: {
                switch (addressType) {
                    case IPv4: {
                        String host = NetUtil.intToIpAddress(byteBuf.readInt());
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case DOMAIN: {
                        int fieldLength = byteBuf.readByte();
                        String host = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case IPv6: {
                        byte[] bytes = new byte[16];
                        byteBuf.readBytes(bytes);
                        String host = SocksCommonUtils.ipv6toStr(bytes);
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case UNKNOWN: {
                        out.add(SocksCommonUtils.UNKNOWN_SOCKS_REQUEST);
                        break;
                    }
                    default: {
                        throw new Error();
                    }
                }
                break;
            }
            default: {
                throw new Error();
            }
        }
        ctx.pipeline().remove(this);
    }
    enum State {
        CHECK_PROTOCOL_VERSION,
        READ_CMD_HEADER,
        READ_CMD_ADDRESS
    }
}",class,
"    public SocksCmdRequestDecoder() {
        super(State.CHECK_PROTOCOL_VERSION);
    }",method,
"    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
        switch (state()) {
            case CHECK_PROTOCOL_VERSION: {
                if (byteBuf.readByte() != SocksProtocolVersion.SOCKS5.byteValue()) {
                    out.add(SocksCommonUtils.UNKNOWN_SOCKS_REQUEST);
                    break;
                }
                checkpoint(State.READ_CMD_HEADER);
            }
            case READ_CMD_HEADER: {
                cmdType = SocksCmdType.valueOf(byteBuf.readByte());
                byteBuf.skipBytes(1); // reserved
                addressType = SocksAddressType.valueOf(byteBuf.readByte());
                checkpoint(State.READ_CMD_ADDRESS);
            }
            case READ_CMD_ADDRESS: {
                switch (addressType) {
                    case IPv4: {
                        String host = NetUtil.intToIpAddress(byteBuf.readInt());
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case DOMAIN: {
                        int fieldLength = byteBuf.readByte();
                        String host = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case IPv6: {
                        byte[] bytes = new byte[16];
                        byteBuf.readBytes(bytes);
                        String host = SocksCommonUtils.ipv6toStr(bytes);
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case UNKNOWN: {
                        out.add(SocksCommonUtils.UNKNOWN_SOCKS_REQUEST);
                        break;
                    }
                    default: {
                        throw new Error();
                    }
                }
                break;
            }
            default: {
                throw new Error();
            }
        }
        ctx.pipeline().remove(this);
    }",method,
"                switch (addressType) {
                    case IPv4: {
                        String host = NetUtil.intToIpAddress(byteBuf.readInt());
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case DOMAIN: {
                        int fieldLength = byteBuf.readByte();
                        String host = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case IPv6: {
                        byte[] bytes = new byte[16];
                        byteBuf.readBytes(bytes);
                        String host = SocksCommonUtils.ipv6toStr(bytes);
                        int port = byteBuf.readUnsignedShort();
                        out.add(new SocksCmdRequest(cmdType, addressType, host, port));
                        break;
                    }
                    case UNKNOWN: {
                        out.add(SocksCommonUtils.UNKNOWN_SOCKS_REQUEST);
                        break;
                    }
                    default: {
                        throw new Error();
                    }
                }",method,
"public class FlexUnitTask extends Task implements DynamicElement
{
   private TaskConfiguration configuration;
   public FlexUnitTask()
   {
   }
   @Override
   public void setProject(Project project)
   {
      super.setProject(project);
      configuration = new TaskConfiguration(project);
   }
   public void setLocalTrusted(final boolean localTrusted)
   {
      configuration.setLocalTrusted(localTrusted);
   }
   public void setPort(final int serverPort)
   {
      configuration.setPort(serverPort);
   }
   public void setTimeout(final int timeout)
   {
      configuration.setSocketTimeout(timeout);
   }
   public void setBuffer(final int size)
   {
      configuration.setServerBufferSize(size);
   }
   public void setSWF(final String testSWF)
   {
      configuration.setSwf(testSWF);
   }
   public void setToDir(final String toDir)
   {
      configuration.setReportDir(toDir);
   }
   public void setHaltonfailure(final boolean fail)
   {
      configuration.setFailOnTestFailure(fail);
   }
   public void setFailureproperty(final String failprop)
   {
      configuration.setFailureProperty(failprop);
   }
   public void setVerbose(final boolean verbose)
   {
      configuration.setVerbose(verbose);
   }
   public void setPlayer(String player)
   {
      configuration.setPlayer(player);
   }
   public void setCommand(String executableFilePath)
   {
      configuration.setCommand(executableFilePath);
   }
   public void setHeadless(boolean headless)
   {
      configuration.setHeadless(headless);
   }
   public void setDisplay(int number)
   {
      configuration.setDisplay(number);
   }
   public void addSource(FileSet fileset)
   {
      configuration.addSource(fileset);
   }
   public void addTestSource(FileSet fileset)
   {
      configuration.addTestSource(fileset);
   }
   public void addLibrary(FileSet fileset)
   {
      configuration.addLibrary(fileset);
   }
   public void setWorkingDir(String workingDirPath)
   {
      configuration.setWorkingDir(workingDirPath);
   }
   public void execute() throws BuildException
   {
      //verify entire configuration
      configuration.verify();
      //compile tests if necessary
      if(configuration.shouldCompile())
      {
         Compilation compilation = new Compilation(getProject(), configuration.getCompilationConfiguration());
         configuration.setSwf(compilation.compile());
      }
      //executes tests
      TestRun testRun = new TestRun(getProject(), configuration.getTestRunConfiguration());
      testRun.run();
   }
   public void setDebug(boolean value)
   {
       configuration.setDebug(value);
   }
	public Object createDynamicElement(String arg0) throws BuildException 
	{
	  if(""load-config"".equals(arg0))
	  {
	      LoadConfig loadconfig = new LoadConfig();
	      configuration.setLoadConfig(loadconfig);
	      return loadconfig;
	  } 
	  else
	  {
	      throw new BuildException( ""The <flexUnit> type doesn't support the "" + arg0 + ""nested element"");
	  }
	}
}",class,
"   public FlexUnitTask()
   {
   }",method,
"   @Override
   public void setProject(Project project)
   {
      super.setProject(project);
      configuration = new TaskConfiguration(project);
   }",method,
"   public void setLocalTrusted(final boolean localTrusted)
   {
      configuration.setLocalTrusted(localTrusted);
   }",method,
"   public void setPort(final int serverPort)
   {
      configuration.setPort(serverPort);
   }",method,
"   public void setTimeout(final int timeout)
   {
      configuration.setSocketTimeout(timeout);
   }",method,
"   public void setBuffer(final int size)
   {
      configuration.setServerBufferSize(size);
   }",method,

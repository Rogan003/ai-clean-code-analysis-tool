code_snippet,type,score
"  @Override
  public PrimitiveValue toPrimitiveExpr(GimplePrimitiveType targetType) throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public VoidPtrExpr toVoidPtrExpr() throws UnsupportedCastException {
    return new VoidPtrExpr(ref);
  }",method,
"  @Override
  public RecordArrayExpr toRecordArrayExpr() throws UnsupportedCastException {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public VPtrExpr toVPtrExpr() {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public ProvidedPtrExpr toProvidedPtrExpr(Type jvmType) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public FatPtr toFatPtrExpr(ValueFunction valueFunction) {
    return this;
  }",method,
"  @Override
  public VPtrRecordExpr toVPtrRecord(GimpleRecordType recordType) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public VArrayExpr toVArray(GimpleArrayType arrayType) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public void jumpIfNull(MethodGenerator mv, Label label) {
    getArray().load(mv);
    mv.ifnull(label);
  }",method,
"  @Override
  public JExpr memoryCompare(MethodGenerator mv, PtrExpr otherPointer, JExpr n) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public void memorySet(MethodGenerator mv, JExpr byteValue, JExpr length) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public void memoryCopy(MethodGenerator mv, PtrExpr source, JExpr length, boolean buffer) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public PtrExpr realloc(MethodGenerator mv, JExpr newSizeInBytes) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public PtrExpr pointerPlus(MethodGenerator mv, JExpr offsetInBytes) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  @Override
  public GExpr valueOf(GimpleType expectedType) {
    return valueFunction.dereference(this);
  }",method,
"  @Override
  public ConditionGenerator comparePointer(MethodGenerator mv, GimpleOp op, GExpr otherPointer) {
    throw new UnsupportedOperationException(""TODO"");
  }",method,
"  public JLValue valueExpr() {
    return new JLValue() {
      @Nonnull
      @Override
      public Type getType() {
        return valueFunction.getValueType();
      }
      @Override
      public void load(@Nonnull MethodGenerator mv) {
        ref.load(mv);
        if(ref.getType().equals(Type.getType(ObjectPtr.class))) {
          mv.invokevirtual(ref.getType(), ""get"", Type.getMethodDescriptor(Type.getType(Object.class)), false);
          mv.checkcast(valueFunction.getValueType());
        } else {
          mv.invokevirtual(ref.getType(), ""get"", Type.getMethodDescriptor(valueFunction.getValueType()), false);
        }
      }
      @Override
      public void store(MethodGenerator mv, JExpr expr) {
        ref.load(mv);
        expr.load(mv);
        if(ref.getType().equals(Type.getType(ObjectPtr.class))) {
          mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(Object.class)), false);
        } else {
          mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, valueFunction.getValueType()), false);
        }
      }
    };
  }",method,
"    return new JLValue() {
      @Nonnull
      @Override
      public Type getType() {
        return valueFunction.getValueType();
      }
      @Override
      public void load(@Nonnull MethodGenerator mv) {
        ref.load(mv);
        if(ref.getType().equals(Type.getType(ObjectPtr.class))) {
          mv.invokevirtual(ref.getType(), ""get"", Type.getMethodDescriptor(Type.getType(Object.class)), false);
          mv.checkcast(valueFunction.getValueType());
        } else {
          mv.invokevirtual(ref.getType(), ""get"", Type.getMethodDescriptor(valueFunction.getValueType()), false);
        }
      }
      @Override
      public void store(MethodGenerator mv, JExpr expr) {
        ref.load(mv);
        expr.load(mv);
        if(ref.getType().equals(Type.getType(ObjectPtr.class))) {
          mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(Object.class)), false);
        } else {
          mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, valueFunction.getValueType()), false);
        }
      }
    }",method,
"      @Nonnull
      @Override
      public Type getType() {
        return valueFunction.getValueType();
      }",method,
"      @Override
      public void load(@Nonnull MethodGenerator mv) {
        ref.load(mv);
        if(ref.getType().equals(Type.getType(ObjectPtr.class))) {
          mv.invokevirtual(ref.getType(), ""get"", Type.getMethodDescriptor(Type.getType(Object.class)), false);
          mv.checkcast(valueFunction.getValueType());
        } else {
          mv.invokevirtual(ref.getType(), ""get"", Type.getMethodDescriptor(valueFunction.getValueType()), false);
        }
      }",method,
"      @Override
      public void store(MethodGenerator mv, JExpr expr) {
        ref.load(mv);
        expr.load(mv);
        if(ref.getType().equals(Type.getType(ObjectPtr.class))) {
          mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(Object.class)), false);
        } else {
          mv.invokevirtual(ref.getType(), ""set"", Type.getMethodDescriptor(Type.VOID_TYPE, valueFunction.getValueType()), false);
        }
      }",method,
"public class CloseAction extends AnAction implements DumbAware {
  private RunContentDescriptor myContentDescriptor;
  private final Project myProject;
  private Executor myExecutor;
  public CloseAction(Executor executor, RunContentDescriptor contentDescriptor, Project project) {
    myExecutor = executor;
    myContentDescriptor = contentDescriptor;
    myProject = project;
    copyFrom(ActionManager.getInstance().getAction(IdeActions.ACTION_CLOSE));
    final Presentation templatePresentation = getTemplatePresentation();
    templatePresentation.setIcon(AllIcons.Actions.Cancel);
    templatePresentation.setText(ExecutionBundle.message(""close.tab.action.name""));
    templatePresentation.setDescription(null);
  }
  @Override
  public void actionPerformed(AnActionEvent e) {
    final RunContentDescriptor contentDescriptor = getContentDescriptor();
    if (contentDescriptor == null) {
      return;
    }
    final boolean removedOk = ExecutionManager.getInstance(myProject).getContentManager().removeRunContent(getExecutor(), contentDescriptor);
    if (removedOk) {
      myContentDescriptor = null;
      myExecutor = null;
    }
  }
  public RunContentDescriptor getContentDescriptor() {
    return myContentDescriptor;
  }
  public Executor getExecutor() {
    return myExecutor;
  }
  @Override
  public void update(AnActionEvent e) {
    e.getPresentation().setEnabled(myContentDescriptor != null);
  }
}",class,
"  public CloseAction(Executor executor, RunContentDescriptor contentDescriptor, Project project) {
    myExecutor = executor;
    myContentDescriptor = contentDescriptor;
    myProject = project;
    copyFrom(ActionManager.getInstance().getAction(IdeActions.ACTION_CLOSE));
    final Presentation templatePresentation = getTemplatePresentation();
    templatePresentation.setIcon(AllIcons.Actions.Cancel);
    templatePresentation.setText(ExecutionBundle.message(""close.tab.action.name""));
    templatePresentation.setDescription(null);
  }",method,
"  @Override
  public void actionPerformed(AnActionEvent e) {
    final RunContentDescriptor contentDescriptor = getContentDescriptor();
    if (contentDescriptor == null) {
      return;
    }
    final boolean removedOk = ExecutionManager.getInstance(myProject).getContentManager().removeRunContent(getExecutor(), contentDescriptor);
    if (removedOk) {
      myContentDescriptor = null;
      myExecutor = null;
    }
  }",method,
"    if (contentDescriptor == null) {
      return;
    }",method,
"    if (removedOk) {
      myContentDescriptor = null;
      myExecutor = null;
    }",method,
"  public RunContentDescriptor getContentDescriptor() {
    return myContentDescriptor;
  }",method,
"  public Executor getExecutor() {
    return myExecutor;
  }",method,
"  @Override
  public void update(AnActionEvent e) {
    e.getPresentation().setEnabled(myContentDescriptor != null);
  }",method,
"public final class ConfigElementSorter implements Comparator<IConfigurationElement> {
    private static final Map<Bundle, Bundle[]> BUNDLE_REQUISITES
    	= new HashMap<Bundle,Bundle[]>();
    private static final Bundle[] EMPTY_BUNDLE_ARRAY = new Bundle[0];
	public int compare(
			final IConfigurationElement configEl1, 
			final IConfigurationElement configEl2) {
        String bundleId1 = configEl1.getDeclaringExtension().getContributor().getName();
        String bundleId2 = configEl2.getDeclaringExtension().getContributor().getName();
        // shortcut
        if ( bundleId1.equals( bundleId2 ) ) {
			return 0;
		}
    	// else must do bundle checks
        try {
            Bundle bundle1 = Platform.getBundle( bundleId1 );
        	Bundle bundle2 = Platform.getBundle( bundleId2 );
            if ( isDependent( bundle1, bundle2 ) ) {
                // plugin1 depends on plugin2 so must be higher in list
                return -1;
            }
            else if ( isDependent( bundle2, bundle1 ) ) {
                // plugin2 depends on plugin1 so must be higher in list
                return 1;
            }
        }
        catch ( BundleException be ) {
        	assert false;
        }
        return 0;
	}
    private Bundle[] getRequisiteBundles( final Bundle bundle )
            throws BundleException {
        if (bundle == null) {
			throw new IllegalArgumentException();
		}
        Bundle[] requisites = ConfigElementSorter.BUNDLE_REQUISITES.get( bundle );
        if ( requisites == null ) {
			// question : how do I parameterise this?
            String requires = (String)bundle.getHeaders().get( 
					Constants.REQUIRE_BUNDLE );
            if ( requires == null ) {
            	requisites = ConfigElementSorter.EMPTY_BUNDLE_ARRAY;
            }
            else {
                ManifestElement[] elements = ManifestElement.parseHeader(
                        Constants.REQUIRE_BUNDLE, requires);
                // use a set so do not get duplicates
                Set<Bundle> requiredBundles = new HashSet<Bundle>();
                for ( int i=0 ; i < elements.length; i++ ) {
                    Bundle required = Platform.getBundle( elements[i].getValue() );
                    requiredBundles.add( required );
                    // recursive call
                    Bundle[] requiredsRequired = getRequisiteBundles( required ) ;
                    for ( int j=0 ; j < requiredsRequired.length; j++ ) {
                    	requiredBundles.add( requiredsRequired[j] );
                    }
                }
                // convert to array and cache
				requisites = requiredBundles.toArray( ConfigElementSorter.EMPTY_BUNDLE_ARRAY );
            }
            ConfigElementSorter.BUNDLE_REQUISITES.put( bundle, requisites );
        }
        assert requisites != null;
        return requisites;
    }
    // is plugin 1 dependent on plugin 2?
    private boolean isDependent( final Bundle bundle1, 
                                 final Bundle bundle2 ) throws BundleException  {
    	List required = Arrays.asList( getRequisiteBundles( bundle1 ) );
        return required.contains( bundle2 );
    }
}",class,
"	public int compare(
			final IConfigurationElement configEl1, 
			final IConfigurationElement configEl2) {
        String bundleId1 = configEl1.getDeclaringExtension().getContributor().getName();
        String bundleId2 = configEl2.getDeclaringExtension().getContributor().getName();
        // shortcut
        if ( bundleId1.equals( bundleId2 ) ) {
			return 0;
		}
    	// else must do bundle checks
        try {
            Bundle bundle1 = Platform.getBundle( bundleId1 );
        	Bundle bundle2 = Platform.getBundle( bundleId2 );
            if ( isDependent( bundle1, bundle2 ) ) {
                // plugin1 depends on plugin2 so must be higher in list
                return -1;
            }
            else if ( isDependent( bundle2, bundle1 ) ) {
                // plugin2 depends on plugin1 so must be higher in list
                return 1;
            }
        }
        catch ( BundleException be ) {
        	assert false;
        }
        return 0;
	}",method,
"        catch ( BundleException be ) {
        	assert false;
        }",method,
"    private Bundle[] getRequisiteBundles( final Bundle bundle )
            throws BundleException {
        if (bundle == null) {
			throw new IllegalArgumentException();
		}
        Bundle[] requisites = ConfigElementSorter.BUNDLE_REQUISITES.get( bundle );
        if ( requisites == null ) {
			// question : how do I parameterise this?
            String requires = (String)bundle.getHeaders().get( 
					Constants.REQUIRE_BUNDLE );
            if ( requires == null ) {
            	requisites = ConfigElementSorter.EMPTY_BUNDLE_ARRAY;
            }
            else {
                ManifestElement[] elements = ManifestElement.parseHeader(
                        Constants.REQUIRE_BUNDLE, requires);
                // use a set so do not get duplicates
                Set<Bundle> requiredBundles = new HashSet<Bundle>();
                for ( int i=0 ; i < elements.length; i++ ) {
                    Bundle required = Platform.getBundle( elements[i].getValue() );
                    requiredBundles.add( required );
                    // recursive call
                    Bundle[] requiredsRequired = getRequisiteBundles( required ) ;
                    for ( int j=0 ; j < requiredsRequired.length; j++ ) {
                    	requiredBundles.add( requiredsRequired[j] );
                    }
                }
                // convert to array and cache
				requisites = requiredBundles.toArray( ConfigElementSorter.EMPTY_BUNDLE_ARRAY );
            }
            ConfigElementSorter.BUNDLE_REQUISITES.put( bundle, requisites );
        }
        assert requisites != null;
        return requisites;
    }",method,
"        if (bundle == null) {
			throw new IllegalArgumentException();
		}",method,
"        if ( requisites == null ) {
			// question : how do I parameterise this?
            String requires = (String)bundle.getHeaders().get( 
					Constants.REQUIRE_BUNDLE );
            if ( requires == null ) {
            	requisites = ConfigElementSorter.EMPTY_BUNDLE_ARRAY;
            }
            else {
                ManifestElement[] elements = ManifestElement.parseHeader(
                        Constants.REQUIRE_BUNDLE, requires);
                // use a set so do not get duplicates
                Set<Bundle> requiredBundles = new HashSet<Bundle>();
                for ( int i=0 ; i < elements.length; i++ ) {
                    Bundle required = Platform.getBundle( elements[i].getValue() );
                    requiredBundles.add( required );
                    // recursive call
                    Bundle[] requiredsRequired = getRequisiteBundles( required ) ;
                    for ( int j=0 ; j < requiredsRequired.length; j++ ) {
                    	requiredBundles.add( requiredsRequired[j] );
                    }
                }
                // convert to array and cache
				requisites = requiredBundles.toArray( ConfigElementSorter.EMPTY_BUNDLE_ARRAY );
            }
            ConfigElementSorter.BUNDLE_REQUISITES.put( bundle, requisites );
        }",method,
"            if ( requires == null ) {
            	requisites = ConfigElementSorter.EMPTY_BUNDLE_ARRAY;
            }",method,
"                for ( int i=0 ; i < elements.length; i++ ) {
                    Bundle required = Platform.getBundle( elements[i].getValue() );
                    requiredBundles.add( required );
                    // recursive call
                    Bundle[] requiredsRequired = getRequisiteBundles( required ) ;
                    for ( int j=0 ; j < requiredsRequired.length; j++ ) {
                    	requiredBundles.add( requiredsRequired[j] );
                    }
                }",method,
"                    for ( int j=0 ; j < requiredsRequired.length; j++ ) {
                    	requiredBundles.add( requiredsRequired[j] );
                    }",method,
"    private boolean isDependent( final Bundle bundle1, 
                                 final Bundle bundle2 ) throws BundleException  {
    	List required = Arrays.asList( getRequisiteBundles( bundle1 ) );
        return required.contains( bundle2 );
    }",method,
"public class HighlightPhase extends AbstractComponent implements FetchSubPhase {
    private final Map<String, Highlighter> highlighters;
    public HighlightPhase(Settings settings, Map<String, Highlighter> highlighters) {
        super(settings);
        this.highlighters = highlighters;
    }
    @Override
    public void hitExecute(SearchContext context, HitContext hitContext) {
        if (context.highlight() == null) {
            return;
        }
        Map<String, HighlightField> highlightFields = new HashMap<>();
        for (SearchContextHighlight.Field field : context.highlight().fields()) {
            Collection<String> fieldNamesToHighlight;
            if (Regex.isSimpleMatchPattern(field.field())) {
                DocumentMapper documentMapper = context.mapperService().documentMapper(hitContext.hit().getType());
                fieldNamesToHighlight = documentMapper.mappers().simpleMatchToFullName(field.field());
            } else {
                fieldNamesToHighlight = Collections.singletonList(field.field());
            }
            if (context.highlight().forceSource(field)) {
                SourceFieldMapper sourceFieldMapper = context.mapperService().documentMapper(hitContext.hit().getType()).sourceMapper();
                if (!sourceFieldMapper.enabled()) {
                    throw new IllegalArgumentException(""source is forced for fields "" +  fieldNamesToHighlight
                            + "" but type ["" + hitContext.hit().getType() + ""] has disabled _source"");
                }
            }
            boolean fieldNameContainsWildcards = field.field().contains(""*"");
            for (String fieldName : fieldNamesToHighlight) {
                FieldMapper fieldMapper = getMapperForField(fieldName, context, hitContext);
                if (fieldMapper == null) {
                    continue;
                }
                // We should prevent highlighting if a field is anything but a text or keyword field.
                // However, someone might implement a custom field type that has text and still want to
                // highlight on that. We cannot know in advance if the highlighter will be able to
                // highlight such a field and so we do the following:
                // If the field is only highlighted because the field matches a wildcard we assume
                // it was a mistake and do not process it.
                // If the field was explicitly given we assume that whoever issued the query knew
                // what they were doing and try to highlight anyway.
                if (fieldNameContainsWildcards) {
                    if (fieldMapper.fieldType().typeName().equals(TextFieldMapper.CONTENT_TYPE) == false &&
                        fieldMapper.fieldType().typeName().equals(KeywordFieldMapper.CONTENT_TYPE) == false) {
                        continue;
                    }
                }
                String highlighterType = field.fieldOptions().highlighterType();
                if (highlighterType == null) {
                    highlighterType = ""unified"";
                }
                Highlighter highlighter = highlighters.get(highlighterType);
                if (highlighter == null) {
                    throw new IllegalArgumentException(""unknown highlighter type ["" + highlighterType
                            + ""] for the field ["" + fieldName + ""]"");
                }
                Query highlightQuery = field.fieldOptions().highlightQuery();
                if (highlightQuery == null) {
                    highlightQuery = context.parsedQuery().query();
                }
                HighlighterContext highlighterContext = new HighlighterContext(fieldName, field, fieldMapper, context,
                        hitContext, highlightQuery);
                if ((highlighter.canHighlight(fieldMapper) == false) && fieldNameContainsWildcards) {
                    // if several fieldnames matched the wildcard then we want to skip those that we cannot highlight
                    continue;
                }
                HighlightField highlightField = highlighter.highlight(highlighterContext);
                if (highlightField != null) {
                    highlightFields.put(highlightField.name(), highlightField);
                }
            }
        }
        hitContext.hit().highlightFields(highlightFields);
    }
    private FieldMapper getMapperForField(String fieldName, SearchContext searchContext, HitContext hitContext) {
        DocumentMapper documentMapper = searchContext.mapperService().documentMapper(hitContext.hit().getType());
        // TODO: no need to lookup the doc mapper with unambiguous field names? just look at the mapper service
        return documentMapper.mappers().smartNameFieldMapper(fieldName);
    }
}",class,
"    public HighlightPhase(Settings settings, Map<String, Highlighter> highlighters) {
        super(settings);
        this.highlighters = highlighters;
    }",method,
"    @Override
    public void hitExecute(SearchContext context, HitContext hitContext) {
        if (context.highlight() == null) {
            return;
        }
        Map<String, HighlightField> highlightFields = new HashMap<>();
        for (SearchContextHighlight.Field field : context.highlight().fields()) {
            Collection<String> fieldNamesToHighlight;
            if (Regex.isSimpleMatchPattern(field.field())) {
                DocumentMapper documentMapper = context.mapperService().documentMapper(hitContext.hit().getType());
                fieldNamesToHighlight = documentMapper.mappers().simpleMatchToFullName(field.field());
            } else {
                fieldNamesToHighlight = Collections.singletonList(field.field());
            }
            if (context.highlight().forceSource(field)) {
                SourceFieldMapper sourceFieldMapper = context.mapperService().documentMapper(hitContext.hit().getType()).sourceMapper();
                if (!sourceFieldMapper.enabled()) {
                    throw new IllegalArgumentException(""source is forced for fields "" +  fieldNamesToHighlight
                            + "" but type ["" + hitContext.hit().getType() + ""] has disabled _source"");
                }
            }
            boolean fieldNameContainsWildcards = field.field().contains(""*"");
            for (String fieldName : fieldNamesToHighlight) {
                FieldMapper fieldMapper = getMapperForField(fieldName, context, hitContext);
                if (fieldMapper == null) {
                    continue;
                }
                // We should prevent highlighting if a field is anything but a text or keyword field.
                // However, someone might implement a custom field type that has text and still want to
                // highlight on that. We cannot know in advance if the highlighter will be able to
                // highlight such a field and so we do the following:
                // If the field is only highlighted because the field matches a wildcard we assume
                // it was a mistake and do not process it.
                // If the field was explicitly given we assume that whoever issued the query knew
                // what they were doing and try to highlight anyway.
                if (fieldNameContainsWildcards) {
                    if (fieldMapper.fieldType().typeName().equals(TextFieldMapper.CONTENT_TYPE) == false &&
                        fieldMapper.fieldType().typeName().equals(KeywordFieldMapper.CONTENT_TYPE) == false) {
                        continue;
                    }
                }
                String highlighterType = field.fieldOptions().highlighterType();
                if (highlighterType == null) {
                    highlighterType = ""unified"";
                }
                Highlighter highlighter = highlighters.get(highlighterType);
                if (highlighter == null) {
                    throw new IllegalArgumentException(""unknown highlighter type ["" + highlighterType
                            + ""] for the field ["" + fieldName + ""]"");
                }
                Query highlightQuery = field.fieldOptions().highlightQuery();
                if (highlightQuery == null) {
                    highlightQuery = context.parsedQuery().query();
                }
                HighlighterContext highlighterContext = new HighlighterContext(fieldName, field, fieldMapper, context,
                        hitContext, highlightQuery);
                if ((highlighter.canHighlight(fieldMapper) == false) && fieldNameContainsWildcards) {
                    // if several fieldnames matched the wildcard then we want to skip those that we cannot highlight
                    continue;
                }
                HighlightField highlightField = highlighter.highlight(highlighterContext);
                if (highlightField != null) {
                    highlightFields.put(highlightField.name(), highlightField);
                }
            }
        }
        hitContext.hit().highlightFields(highlightFields);
    }",method,
"            for (String fieldName : fieldNamesToHighlight) {
                FieldMapper fieldMapper = getMapperForField(fieldName, context, hitContext);
                if (fieldMapper == null) {
                    continue;
                }
                // We should prevent highlighting if a field is anything but a text or keyword field.
                // However, someone might implement a custom field type that has text and still want to
                // highlight on that. We cannot know in advance if the highlighter will be able to
                // highlight such a field and so we do the following:
                // If the field is only highlighted because the field matches a wildcard we assume
                // it was a mistake and do not process it.
                // If the field was explicitly given we assume that whoever issued the query knew
                // what they were doing and try to highlight anyway.
                if (fieldNameContainsWildcards) {
                    if (fieldMapper.fieldType().typeName().equals(TextFieldMapper.CONTENT_TYPE) == false &&
                        fieldMapper.fieldType().typeName().equals(KeywordFieldMapper.CONTENT_TYPE) == false) {
                        continue;
                    }
                }
                String highlighterType = field.fieldOptions().highlighterType();
                if (highlighterType == null) {
                    highlighterType = ""unified"";
                }
                Highlighter highlighter = highlighters.get(highlighterType);
                if (highlighter == null) {
                    throw new IllegalArgumentException(""unknown highlighter type ["" + highlighterType
                            + ""] for the field ["" + fieldName + ""]"");
                }
                Query highlightQuery = field.fieldOptions().highlightQuery();
                if (highlightQuery == null) {
                    highlightQuery = context.parsedQuery().query();
                }
                HighlighterContext highlighterContext = new HighlighterContext(fieldName, field, fieldMapper, context,
                        hitContext, highlightQuery);
                if ((highlighter.canHighlight(fieldMapper) == false) && fieldNameContainsWildcards) {
                    // if several fieldnames matched the wildcard then we want to skip those that we cannot highlight
                    continue;
                }
                HighlightField highlightField = highlighter.highlight(highlighterContext);
                if (highlightField != null) {
                    highlightFields.put(highlightField.name(), highlightField);
                }
            }",method,
"                if (fieldMapper == null) {
                    continue;
                }",method,
"                if (fieldNameContainsWildcards) {
                    if (fieldMapper.fieldType().typeName().equals(TextFieldMapper.CONTENT_TYPE) == false &&
                        fieldMapper.fieldType().typeName().equals(KeywordFieldMapper.CONTENT_TYPE) == false) {
                        continue;
                    }
                }",method,
"                if (highlighterType == null) {
                    highlighterType = ""unified"";
                }",method,
"                if (highlighter == null) {
                    throw new IllegalArgumentException(""unknown highlighter type ["" + highlighterType
                            + ""] for the field ["" + fieldName + ""]"");
                }",method,
"                if (highlightQuery == null) {
                    highlightQuery = context.parsedQuery().query();
                }",method,
"                if (highlightField != null) {
                    highlightFields.put(highlightField.name(), highlightField);
                }",method,
"    private FieldMapper getMapperForField(String fieldName, SearchContext searchContext, HitContext hitContext) {
        DocumentMapper documentMapper = searchContext.mapperService().documentMapper(hitContext.hit().getType());
        // TODO: no need to lookup the doc mapper with unambiguous field names? just look at the mapper service
        return documentMapper.mappers().smartNameFieldMapper(fieldName);
    }",method,
"public final class EphemeralIntentFilter implements Parcelable {
    private final InstantAppIntentFilter mInstantAppIntentFilter;
    public EphemeralIntentFilter(@Nullable String splitName, @NonNull List<IntentFilter> filters) {
        mInstantAppIntentFilter = new InstantAppIntentFilter(splitName, filters);
    }
    EphemeralIntentFilter(@NonNull InstantAppIntentFilter intentFilter) {
        mInstantAppIntentFilter = intentFilter;
    }
    EphemeralIntentFilter(Parcel in) {
        mInstantAppIntentFilter = in.readParcelable(null );
    }
    public String getSplitName() {
        return mInstantAppIntentFilter.getSplitName();
    }
    public List<IntentFilter> getFilters() {
        return mInstantAppIntentFilter.getFilters();
    }
    InstantAppIntentFilter getInstantAppIntentFilter() {
        return mInstantAppIntentFilter;
    }
    @Override
    public int describeContents() {
        return 0;
    }
    @Override
    public void writeToParcel(Parcel out, int flags) {
        out.writeParcelable(mInstantAppIntentFilter, flags);
    }
    public static final Parcelable.Creator<EphemeralIntentFilter> CREATOR
            = new Parcelable.Creator<EphemeralIntentFilter>() {
        @Override
        public EphemeralIntentFilter createFromParcel(Parcel in) {
            return new EphemeralIntentFilter(in);
        }
        @Override
        public EphemeralIntentFilter[] newArray(int size) {
            return new EphemeralIntentFilter[size];
        }
    };
}",class,
"    public EphemeralIntentFilter(@Nullable String splitName, @NonNull List<IntentFilter> filters) {
        mInstantAppIntentFilter = new InstantAppIntentFilter(splitName, filters);
    }",method,
"    EphemeralIntentFilter(@NonNull InstantAppIntentFilter intentFilter) {
        mInstantAppIntentFilter = intentFilter;
    }",method,
"    EphemeralIntentFilter(Parcel in) {
        mInstantAppIntentFilter = in.readParcelable(null );
    }",method,
"    public String getSplitName() {
        return mInstantAppIntentFilter.getSplitName();
    }",method,
"    public List<IntentFilter> getFilters() {
        return mInstantAppIntentFilter.getFilters();
    }",method,
"    InstantAppIntentFilter getInstantAppIntentFilter() {
        return mInstantAppIntentFilter;
    }",method,
"    @Override
    public int describeContents() {
        return 0;
    }",method,
"    @Override
    public void writeToParcel(Parcel out, int flags) {
        out.writeParcelable(mInstantAppIntentFilter, flags);
    }",method,
"        @Override
        public EphemeralIntentFilter createFromParcel(Parcel in) {
            return new EphemeralIntentFilter(in);
        }",method,
"        @Override
        public EphemeralIntentFilter[] newArray(int size) {
            return new EphemeralIntentFilter[size];
        }",method,
"public class ProblemPerformanceTest extends ComponentTestCase {
	@Test
	public void test() throws Exception {
		ProblemAnalyzer analyzer = (ProblemAnalyzer) lookup(MessageAnalyzer.class, ProblemAnalyzer.ID);
		MessageTree tree = buildMessage();
		long current = System.currentTimeMillis();
		long size = 10000000l;
		for (int i = 0; i < size; i++) {
			analyzer.process(tree);
		}
		System.out.println(""Cost "" + (System.currentTimeMillis() - current) / 1000);
		System.out.println(analyzer.getReport(""cat""));
		// cost 64
	}
	@Test
	public void test2() throws Exception {
		ProblemAnalyzer analyzer = (ProblemAnalyzer) lookup(MessageAnalyzer.class, ProblemAnalyzer.ID);
		MessageTree tree = buildMessage();
		long current = System.currentTimeMillis();
		long size = 10000000l;
		for (int i = 0; i < size; i++) {
			Event event = new DefaultEvent(""Exception"", ""name"" + i % 100);
			tree.setMessage(event);
			analyzer.process(tree);
			Event event2 = new DefaultEvent(""Error"", ""name"" + i % 100);
			tree.setMessage(event2);
			analyzer.process(tree);
			Event event3 = new DefaultEvent(""Call"", ""name"" + i % 100);
			tree.setMessage(event3);
			analyzer.process(tree);
		}
		System.out.println(analyzer.getReport(""cat""));
		System.out.println(""Cost "" + (System.currentTimeMillis() - current) / 1000);
		// cost 64
	}
	public MessageTree buildMessage() {
		Message message = new MockMessageBuilder() {
			@Override
			public MessageHolder define() {
				TransactionHolder t = t(""WEB CLUSTER"", ""GET"", 112819)
				      .at(1348374838231L)
				      .after(1300)
				      .child(t(""QUICKIE SERVICE"", ""gimme_stuff"", 1571))
				      .after(100)
				      .child(e(""SERVICE"", ""event1""))
				      .child(e(""Excetion"", ""NullPointException1""))
				      .after(100)
				      .child(h(""SERVICE"", ""heartbeat1""))
				      .after(100)
				      .child(
				            t(""WEB SERVER"", ""GET"", 109358)
				                  .after(1000)
				                  .child(t(""SOME SERVICE"", ""get"", 4345) //
				                        .after(4000).child(t(""MEMCACHED"", ""Get"", 279)))
				                  .mark()
				                  .after(200)
				                  .child(t(""MEMCACHED"", ""Inc"", 319))
				                  .reset()
				                  .after(500)
				                  .child(
				                        t(""BIG ASS SERVICE"", ""getThemDatar"", 97155).after(1000).mark()
				                              .child(t(""SERVICE"", ""getStuff"", 3760)).reset()
				                              .child(t(""DATAR"", ""findThings"", 94537)).after(200)
				                              .child(t(""THINGIE"", ""getMoar"", 1435)) //
				                  )
				                  .after(100)
				                  .mark()
				                  .child(
				                        t(""OTHER DATA SERVICE"", ""get"", 4394).after(1000).mark()
				                              .child(t(""MEMCACHED"", ""Get"", 378)).reset().child(t(""MEMCACHED"", ""Get"", 3496)) //
				                  )
				                  .reset()
				                  .child(
				                        t(""FINAL DATA SERVICE"", ""get"", 4394).after(1000).mark()
				                              .child(t(""MEMCACHED"", ""Get"", 386)).reset().child(t(""MEMCACHED"", ""Get"", 322))
				                              .reset().child(t(""MEMCACHED"", ""Get"", 322))
				                              .child(e(""Excetion"", ""NullPointException""))) //
				      );
				return t;
			}
		}.build();
		MessageTree tree = new DefaultMessageTree();
		tree.setDomain(""cat"");
		tree.setHostName(""test"");
		tree.setIpAddress(""test"");
		tree.setThreadGroupName(""test"");
		tree.setThreadId(""test"");
		tree.setThreadName(""test"");
		tree.setMessage(message);
		return tree;
	}
}",class,
"	@Test
	public void test() throws Exception {
		ProblemAnalyzer analyzer = (ProblemAnalyzer) lookup(MessageAnalyzer.class, ProblemAnalyzer.ID);
		MessageTree tree = buildMessage();
		long current = System.currentTimeMillis();
		long size = 10000000l;
		for (int i = 0; i < size; i++) {
			analyzer.process(tree);
		}
		System.out.println(""Cost "" + (System.currentTimeMillis() - current) / 1000);
		System.out.println(analyzer.getReport(""cat""));
		// cost 64
	}",method,
"		for (int i = 0; i < size; i++) {
			analyzer.process(tree);
		}",method,
"	@Test
	public void test2() throws Exception {
		ProblemAnalyzer analyzer = (ProblemAnalyzer) lookup(MessageAnalyzer.class, ProblemAnalyzer.ID);
		MessageTree tree = buildMessage();
		long current = System.currentTimeMillis();
		long size = 10000000l;
		for (int i = 0; i < size; i++) {
			Event event = new DefaultEvent(""Exception"", ""name"" + i % 100);
			tree.setMessage(event);
			analyzer.process(tree);
			Event event2 = new DefaultEvent(""Error"", ""name"" + i % 100);
			tree.setMessage(event2);
			analyzer.process(tree);
			Event event3 = new DefaultEvent(""Call"", ""name"" + i % 100);
			tree.setMessage(event3);
			analyzer.process(tree);
		}
		System.out.println(analyzer.getReport(""cat""));
		System.out.println(""Cost "" + (System.currentTimeMillis() - current) / 1000);
		// cost 64
	}",method,
"		for (int i = 0; i < size; i++) {
			Event event = new DefaultEvent(""Exception"", ""name"" + i % 100);
			tree.setMessage(event);
			analyzer.process(tree);
			Event event2 = new DefaultEvent(""Error"", ""name"" + i % 100);
			tree.setMessage(event2);
			analyzer.process(tree);
			Event event3 = new DefaultEvent(""Call"", ""name"" + i % 100);
			tree.setMessage(event3);
			analyzer.process(tree);
		}",method,
"	public MessageTree buildMessage() {
		Message message = new MockMessageBuilder() {
			@Override
			public MessageHolder define() {
				TransactionHolder t = t(""WEB CLUSTER"", ""GET"", 112819)
				      .at(1348374838231L)
				      .after(1300)
				      .child(t(""QUICKIE SERVICE"", ""gimme_stuff"", 1571))
				      .after(100)
				      .child(e(""SERVICE"", ""event1""))
				      .child(e(""Excetion"", ""NullPointException1""))
				      .after(100)
				      .child(h(""SERVICE"", ""heartbeat1""))
				      .after(100)
				      .child(
				            t(""WEB SERVER"", ""GET"", 109358)
				                  .after(1000)
				                  .child(t(""SOME SERVICE"", ""get"", 4345) //
				                        .after(4000).child(t(""MEMCACHED"", ""Get"", 279)))
				                  .mark()
				                  .after(200)
				                  .child(t(""MEMCACHED"", ""Inc"", 319))
				                  .reset()
				                  .after(500)
				                  .child(
				                        t(""BIG ASS SERVICE"", ""getThemDatar"", 97155).after(1000).mark()
				                              .child(t(""SERVICE"", ""getStuff"", 3760)).reset()
				                              .child(t(""DATAR"", ""findThings"", 94537)).after(200)
				                              .child(t(""THINGIE"", ""getMoar"", 1435)) //
				                  )
				                  .after(100)
				                  .mark()
				                  .child(
				                        t(""OTHER DATA SERVICE"", ""get"", 4394).after(1000).mark()
				                              .child(t(""MEMCACHED"", ""Get"", 378)).reset().child(t(""MEMCACHED"", ""Get"", 3496)) //
				                  )
				                  .reset()
				                  .child(
				                        t(""FINAL DATA SERVICE"", ""get"", 4394).after(1000).mark()
				                              .child(t(""MEMCACHED"", ""Get"", 386)).reset().child(t(""MEMCACHED"", ""Get"", 322))
				                              .reset().child(t(""MEMCACHED"", ""Get"", 322))
				                              .child(e(""Excetion"", ""NullPointException""))) //
				      );
				return t;
			}
		}.build();
		MessageTree tree = new DefaultMessageTree();
		tree.setDomain(""cat"");
		tree.setHostName(""test"");
		tree.setIpAddress(""test"");
		tree.setThreadGroupName(""test"");
		tree.setThreadId(""test"");
		tree.setThreadName(""test"");
		tree.setMessage(message);
		return tree;
	}",method,
"			@Override
			public MessageHolder define() {
				TransactionHolder t = t(""WEB CLUSTER"", ""GET"", 112819)
				      .at(1348374838231L)
				      .after(1300)
				      .child(t(""QUICKIE SERVICE"", ""gimme_stuff"", 1571))
				      .after(100)
				      .child(e(""SERVICE"", ""event1""))
				      .child(e(""Excetion"", ""NullPointException1""))
				      .after(100)
				      .child(h(""SERVICE"", ""heartbeat1""))
				      .after(100)
				      .child(
				            t(""WEB SERVER"", ""GET"", 109358)
				                  .after(1000)
				                  .child(t(""SOME SERVICE"", ""get"", 4345) //
				                        .after(4000).child(t(""MEMCACHED"", ""Get"", 279)))
				                  .mark()
				                  .after(200)
				                  .child(t(""MEMCACHED"", ""Inc"", 319))
				                  .reset()
				                  .after(500)
				                  .child(
				                        t(""BIG ASS SERVICE"", ""getThemDatar"", 97155).after(1000).mark()
				                              .child(t(""SERVICE"", ""getStuff"", 3760)).reset()
				                              .child(t(""DATAR"", ""findThings"", 94537)).after(200)
				                              .child(t(""THINGIE"", ""getMoar"", 1435)) //
				                  )
				                  .after(100)
				                  .mark()
				                  .child(
				                        t(""OTHER DATA SERVICE"", ""get"", 4394).after(1000).mark()
				                              .child(t(""MEMCACHED"", ""Get"", 378)).reset().child(t(""MEMCACHED"", ""Get"", 3496)) //
				                  )
				                  .reset()
				                  .child(
				                        t(""FINAL DATA SERVICE"", ""get"", 4394).after(1000).mark()
				                              .child(t(""MEMCACHED"", ""Get"", 386)).reset().child(t(""MEMCACHED"", ""Get"", 322))
				                              .reset().child(t(""MEMCACHED"", ""Get"", 322))
				                              .child(e(""Excetion"", ""NullPointException""))) //
				      );
				return t;
			}",method,
"public class MongoEventLogTest {
  private static final String TEST_DB = ""lotteryDBTest"";
  private static final String TEST_EVENTS_COLLECTION = ""testEvents"";
  private MongoEventLog mongoEventLog;
  @Before
  public void init() {
    MongoConnectionPropertiesLoader.load();
    MongoClient mongoClient = new MongoClient(System.getProperty(""mongo-host""),
        Integer.parseInt(System.getProperty(""mongo-port"")));
    mongoClient.dropDatabase(TEST_DB);
    mongoClient.close();
    mongoEventLog = new MongoEventLog(TEST_DB, TEST_EVENTS_COLLECTION);
  }
  @Test
  public void testSetup() {
    assertEquals(0, mongoEventLog.getEventsCollection().count());
  }
  @Test
  public void testFundTransfers() {
    PlayerDetails playerDetails = new PlayerDetails(""john@wayne.com"", ""000-000"", ""03432534543"");
    mongoEventLog.prizeError(playerDetails, 1000);
    assertEquals(1, mongoEventLog.getEventsCollection().count());
    mongoEventLog.prizeError(playerDetails, 1000);
    assertEquals(2, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketDidNotWin(playerDetails);
    assertEquals(3, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketDidNotWin(playerDetails);
    assertEquals(4, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitError(playerDetails);
    assertEquals(5, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitError(playerDetails);
    assertEquals(6, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitted(playerDetails);
    assertEquals(7, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitted(playerDetails);
    assertEquals(8, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketWon(playerDetails, 1000);
    assertEquals(9, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketWon(playerDetails, 1000);
    assertEquals(10, mongoEventLog.getEventsCollection().count());
  }
}",class,
"  @Before
  public void init() {
    MongoConnectionPropertiesLoader.load();
    MongoClient mongoClient = new MongoClient(System.getProperty(""mongo-host""),
        Integer.parseInt(System.getProperty(""mongo-port"")));
    mongoClient.dropDatabase(TEST_DB);
    mongoClient.close();
    mongoEventLog = new MongoEventLog(TEST_DB, TEST_EVENTS_COLLECTION);
  }",method,
"  @Test
  public void testSetup() {
    assertEquals(0, mongoEventLog.getEventsCollection().count());
  }",method,
"  @Test
  public void testFundTransfers() {
    PlayerDetails playerDetails = new PlayerDetails(""john@wayne.com"", ""000-000"", ""03432534543"");
    mongoEventLog.prizeError(playerDetails, 1000);
    assertEquals(1, mongoEventLog.getEventsCollection().count());
    mongoEventLog.prizeError(playerDetails, 1000);
    assertEquals(2, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketDidNotWin(playerDetails);
    assertEquals(3, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketDidNotWin(playerDetails);
    assertEquals(4, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitError(playerDetails);
    assertEquals(5, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitError(playerDetails);
    assertEquals(6, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitted(playerDetails);
    assertEquals(7, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketSubmitted(playerDetails);
    assertEquals(8, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketWon(playerDetails, 1000);
    assertEquals(9, mongoEventLog.getEventsCollection().count());
    mongoEventLog.ticketWon(playerDetails, 1000);
    assertEquals(10, mongoEventLog.getEventsCollection().count());
  }",method,
"public class PseudoAction<InfoType extends MessageLite> extends AbstractAction {
  private final UUID uuid;
  private final String mnemonic;
  private final GeneratedExtension<ExtraActionInfo, InfoType> infoExtension;
  private final InfoType info;
  public PseudoAction(UUID uuid, ActionOwner owner,
      NestedSet<Artifact> inputs, Collection<Artifact> outputs,
      String mnemonic,
      GeneratedExtension<ExtraActionInfo, InfoType> infoExtension, InfoType info) {
    super(owner, inputs, outputs);
    this.uuid = uuid;
    this.mnemonic = mnemonic;
    this.infoExtension = infoExtension;
    this.info = info;
  }
  @Override
  public ActionResult execute(ActionExecutionContext actionExecutionContext)
      throws ActionExecutionException {
    throw new ActionExecutionException(
        mnemonic + ""ExtraAction should not be executed."", this, false);
  }
  @Override
  public String getMnemonic() {
    return mnemonic;
  }
  @Override
  protected String computeKey() {
    return new Fingerprint().addUUID(uuid).addBytes(getInfo().toByteArray()).hexDigestAndReset();
  }
  protected InfoType getInfo() {
    return this.info;
  }
  @Override
  public ExtraActionInfo.Builder getExtraActionInfo() {
    try {
      return super.getExtraActionInfo().setExtension(infoExtension, getInfo());
    } catch (CommandLineExpansionException e) {
      throw new AssertionError(""PsedoAction command line expansion cannot fail"");
    }
  }
  public static Artifact getDummyOutput(RuleContext ruleContext) {
    return ruleContext.getPackageRelativeArtifact(
        ruleContext.getLabel().getName() + "".extra_action_dummy"",
        ruleContext.getConfiguration().getGenfilesDirectory(
            ruleContext.getRule().getRepository()));
  }
}",class,
"  public PseudoAction(UUID uuid, ActionOwner owner,
      NestedSet<Artifact> inputs, Collection<Artifact> outputs,
      String mnemonic,
      GeneratedExtension<ExtraActionInfo, InfoType> infoExtension, InfoType info) {
    super(owner, inputs, outputs);
    this.uuid = uuid;
    this.mnemonic = mnemonic;
    this.infoExtension = infoExtension;
    this.info = info;
  }",method,
"  @Override
  public ActionResult execute(ActionExecutionContext actionExecutionContext)
      throws ActionExecutionException {
    throw new ActionExecutionException(
        mnemonic + ""ExtraAction should not be executed."", this, false);
  }",method,
"  @Override
  public String getMnemonic() {
    return mnemonic;
  }",method,
"  @Override
  protected String computeKey() {
    return new Fingerprint().addUUID(uuid).addBytes(getInfo().toByteArray()).hexDigestAndReset();
  }",method,
"  protected InfoType getInfo() {
    return this.info;
  }",method,
"  @Override
  public ExtraActionInfo.Builder getExtraActionInfo() {
    try {
      return super.getExtraActionInfo().setExtension(infoExtension, getInfo());
    } catch (CommandLineExpansionException e) {
      throw new AssertionError(""PsedoAction command line expansion cannot fail"");
    }
  }",method,
"  public static Artifact getDummyOutput(RuleContext ruleContext) {
    return ruleContext.getPackageRelativeArtifact(
        ruleContext.getLabel().getName() + "".extra_action_dummy"",
        ruleContext.getConfiguration().getGenfilesDirectory(
            ruleContext.getRule().getRepository()));
  }",method,
"public abstract class HandlerMethodArgumentResolverSupport implements HandlerMethodArgumentResolver {
	private final ReactiveAdapterRegistry adapterRegistry;
	protected HandlerMethodArgumentResolverSupport(ReactiveAdapterRegistry adapterRegistry) {
		Assert.notNull(adapterRegistry, ""ReactiveAdapterRegistry is required"");
		this.adapterRegistry = adapterRegistry;
	}
	public ReactiveAdapterRegistry getAdapterRegistry() {
		return this.adapterRegistry;
	}
	protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate) {
		Class<?> type = parameter.getParameterType();
		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type);
		if (adapter != null) {
			assertHasValues(adapter, parameter);
			type = parameter.nested().getNestedParameterType();
		}
		return predicate.test(type);
	}
	private void assertHasValues(ReactiveAdapter adapter, MethodParameter param) {
		if (adapter.isNoValue()) {
			throw new IllegalArgumentException(
					""No value reactive types not supported: "" + param.getGenericParameterType());
		}
	}
	protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate) {
		Class<?> type = parameter.getParameterType();
		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type);
		if (adapter != null) {
			assertHasValues(adapter, parameter);
			type = parameter.nested().getNestedParameterType();
		}
		if (predicate.test(type)) {
			if (adapter == null) {
				return true;
			}
			throw buildReactiveWrapperException(parameter);
		}
		return false;
	}
	private IllegalStateException buildReactiveWrapperException(MethodParameter parameter) {
		return new IllegalStateException(getClass().getSimpleName() +
				"" doesn't support reactive type wrapper: "" + parameter.getGenericParameterType());
	}
	protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper(
			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate) {
		A annotation = parameter.getParameterAnnotation(annotationType);
		if (annotation == null) {
			return false;
		}
		parameter = parameter.nestedIfOptional();
		Class<?> type = parameter.getNestedParameterType();
		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type);
		if (adapter != null) {
			assertHasValues(adapter, parameter);
			parameter = parameter.nested();
			type = parameter.getNestedParameterType();
		}
		if (typePredicate.test(annotation, type)) {
			if (adapter == null) {
				return true;
			}
			throw buildReactiveWrapperException(parameter);
		}
		return false;
	}
}",class,
"	protected HandlerMethodArgumentResolverSupport(ReactiveAdapterRegistry adapterRegistry) {
		Assert.notNull(adapterRegistry, ""ReactiveAdapterRegistry is required"");
		this.adapterRegistry = adapterRegistry;
	}",method,
"	public ReactiveAdapterRegistry getAdapterRegistry() {
		return this.adapterRegistry;
	}",method,
"	protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate) {
		Class<?> type = parameter.getParameterType();
		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type);
		if (adapter != null) {
			assertHasValues(adapter, parameter);
			type = parameter.nested().getNestedParameterType();
		}
		return predicate.test(type);
	}",method,
"		if (adapter != null) {
			assertHasValues(adapter, parameter);
			type = parameter.nested().getNestedParameterType();
		}",method,
"	private void assertHasValues(ReactiveAdapter adapter, MethodParameter param) {
		if (adapter.isNoValue()) {
			throw new IllegalArgumentException(
					""No value reactive types not supported: "" + param.getGenericParameterType());
		}
	}",method,
"	protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate) {
		Class<?> type = parameter.getParameterType();
		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type);
		if (adapter != null) {
			assertHasValues(adapter, parameter);
			type = parameter.nested().getNestedParameterType();
		}
		if (predicate.test(type)) {
			if (adapter == null) {
				return true;
			}
			throw buildReactiveWrapperException(parameter);
		}
		return false;
	}",method,
"		if (adapter != null) {
			assertHasValues(adapter, parameter);
			type = parameter.nested().getNestedParameterType();
		}",method,
"			if (adapter == null) {
				return true;
			}",method,
"	private IllegalStateException buildReactiveWrapperException(MethodParameter parameter) {
		return new IllegalStateException(getClass().getSimpleName() +
				"" doesn't support reactive type wrapper: "" + parameter.getGenericParameterType());
	}",method,
"	protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper(
			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate) {
		A annotation = parameter.getParameterAnnotation(annotationType);
		if (annotation == null) {
			return false;
		}
		parameter = parameter.nestedIfOptional();
		Class<?> type = parameter.getNestedParameterType();
		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type);
		if (adapter != null) {
			assertHasValues(adapter, parameter);
			parameter = parameter.nested();
			type = parameter.getNestedParameterType();
		}
		if (typePredicate.test(annotation, type)) {
			if (adapter == null) {
				return true;
			}
			throw buildReactiveWrapperException(parameter);
		}
		return false;
	}",method,
"		if (annotation == null) {
			return false;
		}",method,
"		if (adapter != null) {
			assertHasValues(adapter, parameter);
			parameter = parameter.nested();
			type = parameter.getNestedParameterType();
		}",method,
"			if (adapter == null) {
				return true;
			}",method,
"public class WXStorageModuleTest {
  WXStorageModule module;
  JSCallback callback;
  @Before
  public void setUp() throws Exception {
    module = new WXStorageModule();
    module.mWXSDKInstance = WXSDKInstanceTest.createInstance();
    module.mStorageAdapter = new IWXStorageAdapter() {
      @Override
      public void setItem(String key, String value, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void getItem(String key, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void removeItem(String key, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void length(OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void getAllKeys(OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void setItemPersistent(String key, String value, OnResultReceivedListener listener) {
      }
      @Override
      public void close() {
      }
    };
    callback = Mockito.mock(JSCallback.class);
  }
  @Test
  public void testSetItem() throws Exception {
    module.setItem("""","""",callback);
    verify(callback,times(1)).invoke(any());
  }
  @Test
  public void testGetItem() throws Exception {
    module.getItem("""",callback);
    verify(callback,times(1)).invoke(any());
  }
  @Test
  public void testRemoveItem() throws Exception {
    module.removeItem("""",callback);
    verify(callback,times(1)).invoke(any());
  }
  @Test
  public void testLength() throws Exception {
    module.length(callback);
    verify(callback,times(1)).invoke(any());
  }
  @Test
  public void testGetAllKeys() throws Exception {
    module.getAllKeys(callback);
    verify(callback,times(1)).invoke(any());
  }
}",class,
"  @Before
  public void setUp() throws Exception {
    module = new WXStorageModule();
    module.mWXSDKInstance = WXSDKInstanceTest.createInstance();
    module.mStorageAdapter = new IWXStorageAdapter() {
      @Override
      public void setItem(String key, String value, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void getItem(String key, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void removeItem(String key, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void length(OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void getAllKeys(OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }
      @Override
      public void setItemPersistent(String key, String value, OnResultReceivedListener listener) {
      }
      @Override
      public void close() {
      }
    };
    callback = Mockito.mock(JSCallback.class);
  }",method,
"      @Override
      public void setItem(String key, String value, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }",method,
"      @Override
      public void getItem(String key, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }",method,
"      @Override
      public void removeItem(String key, OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }",method,
"      @Override
      public void length(OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }",method,
"      @Override
      public void getAllKeys(OnResultReceivedListener listener) {
        Map<String, Object> data = StorageResultHandler.setItemResult(true);
        listener.onReceived(data);
      }",method,

code_snippet,type,score
"      if (nestedMap == null) {
        nestedMap = new IncompleteChildrenMap<>(FileUtil.PATH_HASHING_STRATEGY);
        map.put(parentId, nestedMap);
      }",method,
"    IncompleteChildrenMap(TObjectHashingStrategy<K> strategy) {
      super(strategy);
    }",method,
"  @Override
  public boolean canProcessElement(PsiFile element) {
    return element.getFileType() == PythonFileType.INSTANCE;
  }",method,
"  @Override
  public void prepareMovedFile(PsiFile file, PsiDirectory moveDestination, Map<PsiElement, PsiElement> oldToNewMap) {
    if (file != null) {
      VirtualFile virtualFile = file.getVirtualFile();
      if (virtualFile != null) {
        PyUtil.deletePycFiles(virtualFile.getPath());
      }
      final Collection<VirtualFile> roots = PyUtil.getSourceRoots(file);
      PsiDirectory root = moveDestination;
      while (root != null && !roots.contains(root.getVirtualFile())) {
        root = root.getParentDirectory();
      }
      final boolean searchForReferences = RefactoringSettings.getInstance().MOVE_SEARCH_FOR_REFERENCES_FOR_FILE;
      if (moveDestination != root && root != null && searchForReferences && !probablyNamespacePackage(file, moveDestination, root)) {
        CreatePackageAction.createInitPyInHierarchy(moveDestination, root);
      }
    }
  }",method,
"    if (file != null) {
      VirtualFile virtualFile = file.getVirtualFile();
      if (virtualFile != null) {
        PyUtil.deletePycFiles(virtualFile.getPath());
      }
      final Collection<VirtualFile> roots = PyUtil.getSourceRoots(file);
      PsiDirectory root = moveDestination;
      while (root != null && !roots.contains(root.getVirtualFile())) {
        root = root.getParentDirectory();
      }
      final boolean searchForReferences = RefactoringSettings.getInstance().MOVE_SEARCH_FOR_REFERENCES_FOR_FILE;
      if (moveDestination != root && root != null && searchForReferences && !probablyNamespacePackage(file, moveDestination, root)) {
        CreatePackageAction.createInitPyInHierarchy(moveDestination, root);
      }
    }",method,
"      if (virtualFile != null) {
        PyUtil.deletePycFiles(virtualFile.getPath());
      }",method,
"  @Override
  public void updateMovedFile(PsiFile file) throws IncorrectOperationException {
    if (file instanceof PyFile) {
      updateRelativeImportsInModule((PyFile)file);
    }
  }",method,
"    if (file instanceof PyFile) {
      updateRelativeImportsInModule((PyFile)file);
    }",method,
"    if (originalLocation == null) {
      return;
    }",method,
"      if (sourceElement == null) {
        continue;
      }",method,
"public class ArithmeticExpressionTest extends CobolTestBase {
	@Test
	public void test() throws Exception {
		final File inputFile = new File(""src/test/resources/io/proleap/cobol/asg/valuestmt/ArithmeticExpression.cbl"");
		final Program program = new CobolParserRunnerImpl().analyzeFile(inputFile, CobolSourceFormatEnum.TANDEM);
		final CompilationUnit compilationUnit = program.getCompilationUnit(""ArithmeticExpression"");
		final ProgramUnit programUnit = compilationUnit.getProgramUnit();
		final ProcedureDivision procedureDivision = programUnit.getProcedureDivision();
		assertEquals(1, procedureDivision.getStatements().size());
		{
			final ComputeStatement computeStatement = (ComputeStatement) procedureDivision.getStatements().get(0);
			assertEquals(StatementTypeEnum.COMPUTE, computeStatement.getStatementType());
			{
				final Store store = computeStatement.getStores().get(0);
				assertNotNull(store.getStoreCall());
				assertEquals(Call.CallType.UNDEFINED_CALL, store.getStoreCall().getCallType());
			}
			{
				final ArithmeticValueStmt arithmeticExpression = computeStatement.getArithmeticExpression();
				assertEquals(1, arithmeticExpression.getSubValueStmts().size());
				{
					final MultDivs multDivsValueStmt = (MultDivs) arithmeticExpression.getSubValueStmts().get(0);
					assertEquals(2, multDivsValueStmt.getSubValueStmts().size());
					{
						final Powers powersValueStmt = (Powers) multDivsValueStmt.getSubValueStmts().get(0);
						assertEquals(1, powersValueStmt.getSubValueStmts().size());
						{
							final Basis basisValueStmt = (Basis) powersValueStmt.getSubValueStmts().get(0);
							assertNotNull(basisValueStmt.getBasisValueStmt());
							{
								final LiteralValueStmt literalValueStmt = (LiteralValueStmt) basisValueStmt
										.getBasisValueStmt();
								assertEquals(2, literalValueStmt.getValue());
							}
						}
					}
					{
						final MultDiv multDivValueStmt = (MultDiv) multDivsValueStmt.getSubValueStmts().get(1);
						assertEquals(MultDiv.MultDivType.MULT, multDivValueStmt.getMultDivType());
						assertEquals(1, multDivValueStmt.getSubValueStmts().size());
						{
							final Powers powersValueStmt = (Powers) multDivValueStmt.getSubValueStmts().get(0);
							{
								final Basis basisValueStmt = (Basis) powersValueStmt.getSubValueStmts().get(0);
								assertNotNull(basisValueStmt.getBasisValueStmt());
								{
									final LiteralValueStmt literalValueStmt = (LiteralValueStmt) basisValueStmt
											.getBasisValueStmt();
									assertEquals(2, literalValueStmt.getValue());
								}
							}
						}
					}
				}
			}
		}
	}
}",class,
"	@Test
	public void test() throws Exception {
		final File inputFile = new File(""src/test/resources/io/proleap/cobol/asg/valuestmt/ArithmeticExpression.cbl"");
		final Program program = new CobolParserRunnerImpl().analyzeFile(inputFile, CobolSourceFormatEnum.TANDEM);
		final CompilationUnit compilationUnit = program.getCompilationUnit(""ArithmeticExpression"");
		final ProgramUnit programUnit = compilationUnit.getProgramUnit();
		final ProcedureDivision procedureDivision = programUnit.getProcedureDivision();
		assertEquals(1, procedureDivision.getStatements().size());
		{
			final ComputeStatement computeStatement = (ComputeStatement) procedureDivision.getStatements().get(0);
			assertEquals(StatementTypeEnum.COMPUTE, computeStatement.getStatementType());
			{
				final Store store = computeStatement.getStores().get(0);
				assertNotNull(store.getStoreCall());
				assertEquals(Call.CallType.UNDEFINED_CALL, store.getStoreCall().getCallType());
			}
			{
				final ArithmeticValueStmt arithmeticExpression = computeStatement.getArithmeticExpression();
				assertEquals(1, arithmeticExpression.getSubValueStmts().size());
				{
					final MultDivs multDivsValueStmt = (MultDivs) arithmeticExpression.getSubValueStmts().get(0);
					assertEquals(2, multDivsValueStmt.getSubValueStmts().size());
					{
						final Powers powersValueStmt = (Powers) multDivsValueStmt.getSubValueStmts().get(0);
						assertEquals(1, powersValueStmt.getSubValueStmts().size());
						{
							final Basis basisValueStmt = (Basis) powersValueStmt.getSubValueStmts().get(0);
							assertNotNull(basisValueStmt.getBasisValueStmt());
							{
								final LiteralValueStmt literalValueStmt = (LiteralValueStmt) basisValueStmt
										.getBasisValueStmt();
								assertEquals(2, literalValueStmt.getValue());
							}
						}
					}
					{
						final MultDiv multDivValueStmt = (MultDiv) multDivsValueStmt.getSubValueStmts().get(1);
						assertEquals(MultDiv.MultDivType.MULT, multDivValueStmt.getMultDivType());
						assertEquals(1, multDivValueStmt.getSubValueStmts().size());
						{
							final Powers powersValueStmt = (Powers) multDivValueStmt.getSubValueStmts().get(0);
							{
								final Basis basisValueStmt = (Basis) powersValueStmt.getSubValueStmts().get(0);
								assertNotNull(basisValueStmt.getBasisValueStmt());
								{
									final LiteralValueStmt literalValueStmt = (LiteralValueStmt) basisValueStmt
											.getBasisValueStmt();
									assertEquals(2, literalValueStmt.getValue());
								}
							}
						}
					}
				}
			}
		}
	}",method,
"public class SvnPropertiesDiffRequest extends ContentDiffRequest {
  @NotNull private final List<DiffContent> myContents;
  @NotNull private final List<String> myContentTitles;
  @NotNull private final String myWindowTitle;
  public SvnPropertiesDiffRequest(@NotNull String windowTitle,
                                  @NotNull DiffContent content1,
                                  @NotNull DiffContent content2,
                                  @NotNull String title1,
                                  @NotNull String title2) {
    myWindowTitle = windowTitle;
    myContents = ContainerUtil.list(content1, content2);
    myContentTitles = ContainerUtil.list(title1, title2);
    assert content1 instanceof PropertyContent || content1 instanceof EmptyContent;
    assert content2 instanceof PropertyContent || content2 instanceof EmptyContent;
    assert content1 instanceof PropertyContent || content2 instanceof PropertyContent;
  }
  public SvnPropertiesDiffRequest(@Nullable List<PropertyData> before, @Nullable List<PropertyData> after,
                                  @Nullable String title1, @Nullable String title2) {
    assert before != null || after != null;
    myContents = ContainerUtil.list(createContent(before), createContent(after));
    myWindowTitle = ""Svn Properties Diff"";
    myContentTitles = ContainerUtil.list(title1, title2);
  }
  @NotNull
  public DiffContent createContent(@Nullable List<PropertyData> content) {
    if (content == null) return new EmptyContent();
    return new PropertyContent(content);
  }
  @NotNull
  @Override
  public String getTitle() {
    return myWindowTitle;
  }
  @NotNull
  @Override
  public List<String> getContentTitles() {
    return myContentTitles;
  }
  @NotNull
  @Override
  public List<DiffContent> getContents() {
    return myContents;
  }
  public static class PropertyContent extends DiffContentBase {
    @NotNull private final List<PropertyData> myProperties;
    public PropertyContent(@NotNull List<PropertyData> properties) {
      myProperties = properties;
    }
    @NotNull
    public List<PropertyData> getProperties() {
      return myProperties;
    }
    @Nullable
    @Override
    public FileType getContentType() {
      return null;
    }
  }
}",class,
"  public static class PropertyContent extends DiffContentBase {
    @NotNull private final List<PropertyData> myProperties;
    public PropertyContent(@NotNull List<PropertyData> properties) {
      myProperties = properties;
    }
    @NotNull
    public List<PropertyData> getProperties() {
      return myProperties;
    }
    @Nullable
    @Override
    public FileType getContentType() {
      return null;
    }
  }",class,
"  @NotNull private final List<DiffContent> myContents;
  @NotNull private final List<String> myContentTitles;
  @NotNull private final String myWindowTitle;
  public SvnPropertiesDiffRequest(@NotNull String windowTitle,
                                  @NotNull DiffContent content1,
                                  @NotNull DiffContent content2,
                                  @NotNull String title1,
                                  @NotNull String title2) {
    myWindowTitle = windowTitle;
    myContents = ContainerUtil.list(content1, content2);
    myContentTitles = ContainerUtil.list(title1, title2);
    assert content1 instanceof PropertyContent || content1 instanceof EmptyContent;
    assert content2 instanceof PropertyContent || content2 instanceof EmptyContent;
    assert content1 instanceof PropertyContent || content2 instanceof PropertyContent;
  }",method,
"  public SvnPropertiesDiffRequest(@Nullable List<PropertyData> before, @Nullable List<PropertyData> after,
                                  @Nullable String title1, @Nullable String title2) {
    assert before != null || after != null;
    myContents = ContainerUtil.list(createContent(before), createContent(after));
    myWindowTitle = ""Svn Properties Diff"";
    myContentTitles = ContainerUtil.list(title1, title2);
  }",method,
"  @NotNull
  public DiffContent createContent(@Nullable List<PropertyData> content) {
    if (content == null) return new EmptyContent();
    return new PropertyContent(content);
  }",method,
"  @NotNull
  @Override
  public String getTitle() {
    return myWindowTitle;
  }",method,
"  @NotNull
  @Override
  public List<String> getContentTitles() {
    return myContentTitles;
  }",method,
"  @NotNull
  @Override
  public List<DiffContent> getContents() {
    return myContents;
  }",method,
"    @NotNull private final List<PropertyData> myProperties;
    public PropertyContent(@NotNull List<PropertyData> properties) {
      myProperties = properties;
    }",method,
"    @NotNull
    public List<PropertyData> getProperties() {
      return myProperties;
    }",method,
"    @Nullable
    @Override
    public FileType getContentType() {
      return null;
    }",method,
"public class MagicAmaroFilter extends GPUImageFilter{
    private int[] inputTextureHandles = {-1,-1,-1};
    private int[] inputTextureUniformLocations = {-1,-1,-1};
    private int mGLStrengthLocation;
    public MagicAmaroFilter(){
        super(MagicFilterType.AMARO, R.raw.amaro);
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
        GLES20.glDeleteTextures(inputTextureHandles.length, inputTextureHandles, 0);
        for(int i = 0; i < inputTextureHandles.length; i++)
            inputTextureHandles[i] = -1;
    }
    @Override
    protected void onDrawArraysAfter(){
        for(int i = 0; i < inputTextureHandles.length && inputTextureHandles[i] != OpenGLUtils.NO_TEXTURE; i++){
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + (i+3));
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
        }
    }
    @Override
    protected void onDrawArraysPre(){
        for(int i = 0; i < inputTextureHandles.length && inputTextureHandles[i] != OpenGLUtils.NO_TEXTURE; i++){
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + (i+3));
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, inputTextureHandles[i]);
            GLES20.glUniform1i(inputTextureUniformLocations[i], (i+3));
        }
    }
    @Override
    protected void onInit(){
        super.onInit();
        for (int i = 0; i < inputTextureUniformLocations.length; i++) {
            inputTextureUniformLocations[i] = GLES20.glGetUniformLocation(getProgram(), ""inputImageTexture"" + (2 + i));
        }
        mGLStrengthLocation = GLES20.glGetUniformLocation(getProgram(), ""strength"");
    }
    @Override
    protected void onInitialized(){
        super.onInitialized();
        setFloat(mGLStrengthLocation, 1.0f);
        runOnDraw(new Runnable(){
            public void run(){
                inputTextureHandles[0] = OpenGLUtils.loadTexture(getContext(), ""filter/brannan_blowout.png"");
                inputTextureHandles[1] = OpenGLUtils.loadTexture(getContext(), ""filter/overlaymap.png"");
                inputTextureHandles[2] = OpenGLUtils.loadTexture(getContext(), ""filter/amaromap.png"");
            }
        });
    }
}",class,
"    public MagicAmaroFilter(){
        super(MagicFilterType.AMARO, R.raw.amaro);
    }",method,
"    @Override
    protected void onDestroy() {
        super.onDestroy();
        GLES20.glDeleteTextures(inputTextureHandles.length, inputTextureHandles, 0);
        for(int i = 0; i < inputTextureHandles.length; i++)
            inputTextureHandles[i] = -1;
    }",method,
"    @Override
    protected void onDrawArraysAfter(){
        for(int i = 0; i < inputTextureHandles.length && inputTextureHandles[i] != OpenGLUtils.NO_TEXTURE; i++){
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + (i+3));
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
        }
    }",method,
"        for(int i = 0; i < inputTextureHandles.length && inputTextureHandles[i] != OpenGLUtils.NO_TEXTURE; i++){
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + (i+3));
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
        }",method,
"    @Override
    protected void onDrawArraysPre(){
        for(int i = 0; i < inputTextureHandles.length && inputTextureHandles[i] != OpenGLUtils.NO_TEXTURE; i++){
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + (i+3));
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, inputTextureHandles[i]);
            GLES20.glUniform1i(inputTextureUniformLocations[i], (i+3));
        }
    }",method,
"        for(int i = 0; i < inputTextureHandles.length && inputTextureHandles[i] != OpenGLUtils.NO_TEXTURE; i++){
            GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + (i+3));
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, inputTextureHandles[i]);
            GLES20.glUniform1i(inputTextureUniformLocations[i], (i+3));
        }",method,
"    @Override
    protected void onInit(){
        super.onInit();
        for (int i = 0; i < inputTextureUniformLocations.length; i++) {
            inputTextureUniformLocations[i] = GLES20.glGetUniformLocation(getProgram(), ""inputImageTexture"" + (2 + i));
        }
        mGLStrengthLocation = GLES20.glGetUniformLocation(getProgram(), ""strength"");
    }",method,
"        for (int i = 0; i < inputTextureUniformLocations.length; i++) {
            inputTextureUniformLocations[i] = GLES20.glGetUniformLocation(getProgram(), ""inputImageTexture"" + (2 + i));
        }",method,
"    @Override
    protected void onInitialized(){
        super.onInitialized();
        setFloat(mGLStrengthLocation, 1.0f);
        runOnDraw(new Runnable(){
            public void run(){
                inputTextureHandles[0] = OpenGLUtils.loadTexture(getContext(), ""filter/brannan_blowout.png"");
                inputTextureHandles[1] = OpenGLUtils.loadTexture(getContext(), ""filter/overlaymap.png"");
                inputTextureHandles[2] = OpenGLUtils.loadTexture(getContext(), ""filter/amaromap.png"");
            }
        });
    }",method,
"        runOnDraw(new Runnable(){
            public void run(){
                inputTextureHandles[0] = OpenGLUtils.loadTexture(getContext(), ""filter/brannan_blowout.png"");
                inputTextureHandles[1] = OpenGLUtils.loadTexture(getContext(), ""filter/overlaymap.png"");
                inputTextureHandles[2] = OpenGLUtils.loadTexture(getContext(), ""filter/amaromap.png"");
            }
        }",method,
"            public void run(){
                inputTextureHandles[0] = OpenGLUtils.loadTexture(getContext(), ""filter/brannan_blowout.png"");
                inputTextureHandles[1] = OpenGLUtils.loadTexture(getContext(), ""filter/overlaymap.png"");
                inputTextureHandles[2] = OpenGLUtils.loadTexture(getContext(), ""filter/amaromap.png"");
            }",method,
"final class GenericTypeAwarePropertyDescriptor extends PropertyDescriptor {
	private final Class<?> beanClass;
	@Nullable
	private final Method readMethod;
	@Nullable
	private final Method writeMethod;
	@Nullable
	private volatile Set<Method> ambiguousWriteMethods;
	@Nullable
	private MethodParameter writeMethodParameter;
	@Nullable
	private Class<?> propertyType;
	private final Class<?> propertyEditorClass;
	public GenericTypeAwarePropertyDescriptor(Class<?> beanClass, String propertyName,
			@Nullable Method readMethod, @Nullable Method writeMethod, Class<?> propertyEditorClass)
			throws IntrospectionException {
		super(propertyName, null, null);
		this.beanClass = beanClass;
		Method readMethodToUse = (readMethod != null ? BridgeMethodResolver.findBridgedMethod(readMethod) : null);
		Method writeMethodToUse = (writeMethod != null ? BridgeMethodResolver.findBridgedMethod(writeMethod) : null);
		if (writeMethodToUse == null && readMethodToUse != null) {
			// Fallback: Original JavaBeans introspection might not have found matching setter
			// method due to lack of bridge method resolution, in case of the getter using a
			// covariant return type whereas the setter is defined for the concrete property type.
			Method candidate = ClassUtils.getMethodIfAvailable(
					this.beanClass, ""set"" + StringUtils.capitalize(getName()), (Class<?>[]) null);
			if (candidate != null && candidate.getParameterCount() == 1) {
				writeMethodToUse = candidate;
			}
		}
		this.readMethod = readMethodToUse;
		this.writeMethod = writeMethodToUse;
		if (this.writeMethod != null) {
			if (this.readMethod == null) {
				// Write method not matched against read method: potentially ambiguous through
				// several overloaded variants, in which case an arbitrary winner has been chosen
				// by the JDK's JavaBeans Introspector...
				Set<Method> ambiguousCandidates = new HashSet<>();
				for (Method method : beanClass.getMethods()) {
					if (method.getName().equals(writeMethodToUse.getName()) &&
							!method.equals(writeMethodToUse) && !method.isBridge() &&
							method.getParameterCount() == writeMethodToUse.getParameterCount()) {
						ambiguousCandidates.add(method);
					}
				}
				if (!ambiguousCandidates.isEmpty()) {
					this.ambiguousWriteMethods = ambiguousCandidates;
				}
			}
			this.writeMethodParameter = new MethodParameter(this.writeMethod, 0);
			GenericTypeResolver.resolveParameterType(this.writeMethodParameter, this.beanClass);
		}
		if (this.readMethod != null) {
			this.propertyType = GenericTypeResolver.resolveReturnType(this.readMethod, this.beanClass);
		}
		else if (this.writeMethodParameter != null) {
			this.propertyType = this.writeMethodParameter.getParameterType();
		}
		this.propertyEditorClass = propertyEditorClass;
	}
	public Class<?> getBeanClass() {
		return this.beanClass;
	}
	@Override
	@Nullable
	public Method getReadMethod() {
		return this.readMethod;
	}
	@Override
	@Nullable
	public Method getWriteMethod() {
		return this.writeMethod;
	}
	public Method getWriteMethodForActualAccess() {
		Assert.state(this.writeMethod != null, ""No write method available"");
		Set<Method> ambiguousCandidates = this.ambiguousWriteMethods;
		if (ambiguousCandidates != null) {
			this.ambiguousWriteMethods = null;
			LogFactory.getLog(GenericTypeAwarePropertyDescriptor.class).warn(""Invalid JavaBean property '"" +
					getName() + ""' being accessed! Ambiguous write methods found next to actually used ["" +
					this.writeMethod + ""]: "" + ambiguousCandidates);
		}
		return this.writeMethod;
	}
	public MethodParameter getWriteMethodParameter() {
		Assert.state(this.writeMethodParameter != null, ""No write method available"");
		return this.writeMethodParameter;
	}
	@Override
	@Nullable
	public Class<?> getPropertyType() {
		return this.propertyType;
	}
	@Override
	public Class<?> getPropertyEditorClass() {
		return this.propertyEditorClass;
	}
	@Override
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof GenericTypeAwarePropertyDescriptor)) {
			return false;
		}
		GenericTypeAwarePropertyDescriptor otherPd = (GenericTypeAwarePropertyDescriptor) other;
		return (getBeanClass().equals(otherPd.getBeanClass()) && PropertyDescriptorUtils.equals(this, otherPd));
	}
	@Override
	public int hashCode() {
		int hashCode = getBeanClass().hashCode();
		hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getReadMethod());
		hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getWriteMethod());
		return hashCode;
	}
}",class,
"	public GenericTypeAwarePropertyDescriptor(Class<?> beanClass, String propertyName,
			@Nullable Method readMethod, @Nullable Method writeMethod, Class<?> propertyEditorClass)
			throws IntrospectionException {
		super(propertyName, null, null);
		this.beanClass = beanClass;
		Method readMethodToUse = (readMethod != null ? BridgeMethodResolver.findBridgedMethod(readMethod) : null);
		Method writeMethodToUse = (writeMethod != null ? BridgeMethodResolver.findBridgedMethod(writeMethod) : null);
		if (writeMethodToUse == null && readMethodToUse != null) {
			// Fallback: Original JavaBeans introspection might not have found matching setter
			// method due to lack of bridge method resolution, in case of the getter using a
			// covariant return type whereas the setter is defined for the concrete property type.
			Method candidate = ClassUtils.getMethodIfAvailable(
					this.beanClass, ""set"" + StringUtils.capitalize(getName()), (Class<?>[]) null);
			if (candidate != null && candidate.getParameterCount() == 1) {
				writeMethodToUse = candidate;
			}
		}
		this.readMethod = readMethodToUse;
		this.writeMethod = writeMethodToUse;
		if (this.writeMethod != null) {
			if (this.readMethod == null) {
				// Write method not matched against read method: potentially ambiguous through
				// several overloaded variants, in which case an arbitrary winner has been chosen
				// by the JDK's JavaBeans Introspector...
				Set<Method> ambiguousCandidates = new HashSet<>();
				for (Method method : beanClass.getMethods()) {
					if (method.getName().equals(writeMethodToUse.getName()) &&
							!method.equals(writeMethodToUse) && !method.isBridge() &&
							method.getParameterCount() == writeMethodToUse.getParameterCount()) {
						ambiguousCandidates.add(method);
					}
				}
				if (!ambiguousCandidates.isEmpty()) {
					this.ambiguousWriteMethods = ambiguousCandidates;
				}
			}
			this.writeMethodParameter = new MethodParameter(this.writeMethod, 0);
			GenericTypeResolver.resolveParameterType(this.writeMethodParameter, this.beanClass);
		}
		if (this.readMethod != null) {
			this.propertyType = GenericTypeResolver.resolveReturnType(this.readMethod, this.beanClass);
		}
		else if (this.writeMethodParameter != null) {
			this.propertyType = this.writeMethodParameter.getParameterType();
		}
		this.propertyEditorClass = propertyEditorClass;
	}",method,
"		if (writeMethodToUse == null && readMethodToUse != null) {
			// Fallback: Original JavaBeans introspection might not have found matching setter
			// method due to lack of bridge method resolution, in case of the getter using a
			// covariant return type whereas the setter is defined for the concrete property type.
			Method candidate = ClassUtils.getMethodIfAvailable(
					this.beanClass, ""set"" + StringUtils.capitalize(getName()), (Class<?>[]) null);
			if (candidate != null && candidate.getParameterCount() == 1) {
				writeMethodToUse = candidate;
			}
		}",method,
"		if (this.writeMethod != null) {
			if (this.readMethod == null) {
				// Write method not matched against read method: potentially ambiguous through
				// several overloaded variants, in which case an arbitrary winner has been chosen
				// by the JDK's JavaBeans Introspector...
				Set<Method> ambiguousCandidates = new HashSet<>();
				for (Method method : beanClass.getMethods()) {
					if (method.getName().equals(writeMethodToUse.getName()) &&
							!method.equals(writeMethodToUse) && !method.isBridge() &&
							method.getParameterCount() == writeMethodToUse.getParameterCount()) {
						ambiguousCandidates.add(method);
					}
				}
				if (!ambiguousCandidates.isEmpty()) {
					this.ambiguousWriteMethods = ambiguousCandidates;
				}
			}
			this.writeMethodParameter = new MethodParameter(this.writeMethod, 0);
			GenericTypeResolver.resolveParameterType(this.writeMethodParameter, this.beanClass);
		}",method,
"			if (this.readMethod == null) {
				// Write method not matched against read method: potentially ambiguous through
				// several overloaded variants, in which case an arbitrary winner has been chosen
				// by the JDK's JavaBeans Introspector...
				Set<Method> ambiguousCandidates = new HashSet<>();
				for (Method method : beanClass.getMethods()) {
					if (method.getName().equals(writeMethodToUse.getName()) &&
							!method.equals(writeMethodToUse) && !method.isBridge() &&
							method.getParameterCount() == writeMethodToUse.getParameterCount()) {
						ambiguousCandidates.add(method);
					}
				}
				if (!ambiguousCandidates.isEmpty()) {
					this.ambiguousWriteMethods = ambiguousCandidates;
				}
			}",method,
"		if (this.readMethod != null) {
			this.propertyType = GenericTypeResolver.resolveReturnType(this.readMethod, this.beanClass);
		}",method,
"		else if (this.writeMethodParameter != null) {
			this.propertyType = this.writeMethodParameter.getParameterType();
		}",method,
"	public Class<?> getBeanClass() {
		return this.beanClass;
	}",method,
"	@Override
	@Nullable
	public Method getReadMethod() {
		return this.readMethod;
	}",method,
"	@Override
	@Nullable
	public Method getWriteMethod() {
		return this.writeMethod;
	}",method,
"	public Method getWriteMethodForActualAccess() {
		Assert.state(this.writeMethod != null, ""No write method available"");
		Set<Method> ambiguousCandidates = this.ambiguousWriteMethods;
		if (ambiguousCandidates != null) {
			this.ambiguousWriteMethods = null;
			LogFactory.getLog(GenericTypeAwarePropertyDescriptor.class).warn(""Invalid JavaBean property '"" +
					getName() + ""' being accessed! Ambiguous write methods found next to actually used ["" +
					this.writeMethod + ""]: "" + ambiguousCandidates);
		}
		return this.writeMethod;
	}",method,
"		if (ambiguousCandidates != null) {
			this.ambiguousWriteMethods = null;
			LogFactory.getLog(GenericTypeAwarePropertyDescriptor.class).warn(""Invalid JavaBean property '"" +
					getName() + ""' being accessed! Ambiguous write methods found next to actually used ["" +
					this.writeMethod + ""]: "" + ambiguousCandidates);
		}",method,
"	public MethodParameter getWriteMethodParameter() {
		Assert.state(this.writeMethodParameter != null, ""No write method available"");
		return this.writeMethodParameter;
	}",method,
"	@Override
	@Nullable
	public Class<?> getPropertyType() {
		return this.propertyType;
	}",method,
"	@Override
	public Class<?> getPropertyEditorClass() {
		return this.propertyEditorClass;
	}",method,
"	@Override
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof GenericTypeAwarePropertyDescriptor)) {
			return false;
		}
		GenericTypeAwarePropertyDescriptor otherPd = (GenericTypeAwarePropertyDescriptor) other;
		return (getBeanClass().equals(otherPd.getBeanClass()) && PropertyDescriptorUtils.equals(this, otherPd));
	}",method,
"		if (this == other) {
			return true;
		}",method,
"	@Override
	public int hashCode() {
		int hashCode = getBeanClass().hashCode();
		hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getReadMethod());
		hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getWriteMethod());
		return hashCode;
	}",method,
"public class ParallelPerf implements Function<Integer, Integer> {
    @Param({""10000""})
    public int count;
    @Param({""1"", ""10"", ""100"", ""1000"", ""10000""})
    public int compute;
    @Param({""1"", ""2"", ""3"", ""4""})
    public int parallelism;
    Flowable<Integer> flatMap;
    Flowable<Integer> groupBy;
    Flowable<Integer> parallel;
    @Override
    public Integer apply(Integer t) throws Exception {
        Blackhole.consumeCPU(compute);
        return t;
    }
    @Setup
    public void setup() {
        final int cpu = parallelism;
        Integer[] ints = new Integer[count];
        Arrays.fill(ints, 777);
        Flowable<Integer> source = Flowable.fromArray(ints);
        flatMap = source.flatMap(new Function<Integer, Publisher<Integer>>() {
            @Override
            public Publisher<Integer> apply(Integer v) throws Exception {
                return Flowable.just(v).subscribeOn(Schedulers.computation())
                        .map(ParallelPerf.this);
            }
        }, cpu);
        groupBy = source.groupBy(new Function<Integer, Integer>() {
            int i;
            @Override
            public Integer apply(Integer v) throws Exception {
                return (i++) % cpu;
            }
        })
        .flatMap(new Function<GroupedFlowable<Integer, Integer>, Publisher<Integer>>() {
            @Override
            public Publisher<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {
                return g.observeOn(Schedulers.computation()).map(ParallelPerf.this);
            }
        });
        parallel = source.parallel(cpu).runOn(Schedulers.computation()).map(this).sequential();
    }
    void subscribe(Flowable<Integer> f, Blackhole bh) {
        PerfAsyncConsumer consumer = new PerfAsyncConsumer(bh);
        f.subscribe(consumer);
        consumer.await(count);
    }
    @Benchmark
    public void flatMap(Blackhole bh) {
        subscribe(flatMap, bh);
    }
    @Benchmark
    public void groupBy(Blackhole bh) {
        subscribe(groupBy, bh);
    }
    @Benchmark
    public void parallel(Blackhole bh) {
        subscribe(parallel, bh);
    }
}",class,
"    @Override
    public Integer apply(Integer t) throws Exception {
        Blackhole.consumeCPU(compute);
        return t;
    }",method,
"    @Setup
    public void setup() {
        final int cpu = parallelism;
        Integer[] ints = new Integer[count];
        Arrays.fill(ints, 777);
        Flowable<Integer> source = Flowable.fromArray(ints);
        flatMap = source.flatMap(new Function<Integer, Publisher<Integer>>() {
            @Override
            public Publisher<Integer> apply(Integer v) throws Exception {
                return Flowable.just(v).subscribeOn(Schedulers.computation())
                        .map(ParallelPerf.this);
            }
        }, cpu);
        groupBy = source.groupBy(new Function<Integer, Integer>() {
            int i;
            @Override
            public Integer apply(Integer v) throws Exception {
                return (i++) % cpu;
            }
        })
        .flatMap(new Function<GroupedFlowable<Integer, Integer>, Publisher<Integer>>() {
            @Override
            public Publisher<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {
                return g.observeOn(Schedulers.computation()).map(ParallelPerf.this);
            }
        });
        parallel = source.parallel(cpu).runOn(Schedulers.computation()).map(this).sequential();
    }",method,
"            @Override
            public Publisher<Integer> apply(Integer v) throws Exception {
                return Flowable.just(v).subscribeOn(Schedulers.computation())
                        .map(ParallelPerf.this);
            }",method,
"            @Override
            public Integer apply(Integer v) throws Exception {
                return (i++) % cpu;
            }",method,
"        .flatMap(new Function<GroupedFlowable<Integer, Integer>, Publisher<Integer>>() {
            @Override
            public Publisher<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {
                return g.observeOn(Schedulers.computation()).map(ParallelPerf.this);
            }
        }",method,
"            @Override
            public Publisher<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {
                return g.observeOn(Schedulers.computation()).map(ParallelPerf.this);
            }",method,
"    void subscribe(Flowable<Integer> f, Blackhole bh) {
        PerfAsyncConsumer consumer = new PerfAsyncConsumer(bh);
        f.subscribe(consumer);
        consumer.await(count);
    }",method,
"    @Benchmark
    public void flatMap(Blackhole bh) {
        subscribe(flatMap, bh);
    }",method,
"    @Benchmark
    public void groupBy(Blackhole bh) {
        subscribe(groupBy, bh);
    }",method,
"    @Benchmark
    public void parallel(Blackhole bh) {
        subscribe(parallel, bh);
    }",method,
"public class MoreMatchersTest extends TestBase {
    @Mock private IMethods mock;
    @Test
    public void should_help_out_with_unnecessary_casting() {
        when(mock.objectArgMethod(any(String.class))).thenReturn(""string"");
        assertEquals(""string"", mock.objectArgMethod(""foo""));
    }
    @Test
    public void any_should_be_actual_alias_to_anyObject() {
        mock.simpleMethod((Object) null);
        verify(mock).simpleMethod(any());
        verify(mock).simpleMethod(anyObject());
    }
    @Test
    public void any_class_should_be_actual_alias_to_isA() {
        mock.simpleMethod(new ArrayList());
        verify(mock).simpleMethod(isA(List.class));
        verify(mock).simpleMethod(any(List.class));
        mock.simpleMethod((String) null);
        try {
            verify(mock).simpleMethod(isA(String.class));
            fail();
        } catch (AssertionError ignored) { }
        try {
            verify(mock).simpleMethod(any(String.class));
            fail();
        } catch (AssertionError ignored) { }
    }
    @Test
    public void should_help_out_with_unnecessary_casting_of_lists() {
        //Below yields compiler warning:
        //when(mock.listArgMethod(anyList())).thenReturn(""list"");
        when(mock.listArgMethod(anyListOf(String.class))).thenReturn(""list"");
        assertEquals(""list"", mock.listArgMethod(new LinkedList<String>()));
        assertEquals(""list"", mock.listArgMethod(Collections.<String>emptyList()));
    }
    @Test
    public void should_help_out_with_unnecessary_casting_of_sets() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.setArgMethod(anySetOf(String.class))).thenReturn(""set"");
        assertEquals(""set"", mock.setArgMethod(new HashSet<String>()));
        assertEquals(""set"", mock.setArgMethod(Collections.<String>emptySet()));
    }
    @Test
    public void should_help_out_with_unnecessary_casting_of_maps() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.forMap(anyMapOf(String.class, String.class))).thenReturn(""map"");
        assertEquals(""map"", mock.forMap(new HashMap<String, String>()));
        assertEquals(""map"", mock.forMap(Collections.<String, String>emptyMap()));
    }
    @Test
    public void should_help_out_with_unnecessary_casting_of_collections() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn(""collection"");
        assertEquals(""collection"", mock.collectionArgMethod(new ArrayList<String>()));
        assertEquals(""collection"", mock.collectionArgMethod(Collections.<String>emptyList()));
    }
    @Test
    public void should_help_out_with_unnecessary_casting_of_iterables() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.iterableArgMethod(anyIterableOf(String.class))).thenReturn(""iterable"");
        assertEquals(""iterable"", mock.iterableArgMethod(new ArrayList<String>()));
        assertEquals(""iterable"", mock.iterableArgMethod(Collections.<String>emptyList()));
    }
    @Test
    public void should_help_out_with_unnecessary_casting_of_nullity_checks() {
        when(mock.objectArgMethod(isNull(LinkedList.class))).thenReturn(""string"");
        when(mock.objectArgMethod(notNull(LinkedList.class))).thenReturn(""string"");
        when(mock.objectArgMethod(isNotNull(LinkedList.class))).thenReturn(""string"");
        assertEquals(""string"", mock.objectArgMethod(null));
        assertEquals(""string"", mock.objectArgMethod(""foo""));
        assertEquals(""string"", mock.objectArgMethod(""foo""));
    }
}",class,
"    @Mock private IMethods mock;
    @Test
    public void should_help_out_with_unnecessary_casting() {
        when(mock.objectArgMethod(any(String.class))).thenReturn(""string"");
        assertEquals(""string"", mock.objectArgMethod(""foo""));
    }",method,
"    @Test
    public void any_should_be_actual_alias_to_anyObject() {
        mock.simpleMethod((Object) null);
        verify(mock).simpleMethod(any());
        verify(mock).simpleMethod(anyObject());
    }",method,
"    @Test
    public void any_class_should_be_actual_alias_to_isA() {
        mock.simpleMethod(new ArrayList());
        verify(mock).simpleMethod(isA(List.class));
        verify(mock).simpleMethod(any(List.class));
        mock.simpleMethod((String) null);
        try {
            verify(mock).simpleMethod(isA(String.class));
            fail();
        } catch (AssertionError ignored) { }
        try {
            verify(mock).simpleMethod(any(String.class));
            fail();
        } catch (AssertionError ignored) { }
    }",method,
"    @Test
    public void should_help_out_with_unnecessary_casting_of_lists() {
        //Below yields compiler warning:
        //when(mock.listArgMethod(anyList())).thenReturn(""list"");
        when(mock.listArgMethod(anyListOf(String.class))).thenReturn(""list"");
        assertEquals(""list"", mock.listArgMethod(new LinkedList<String>()));
        assertEquals(""list"", mock.listArgMethod(Collections.<String>emptyList()));
    }",method,
"    @Test
    public void should_help_out_with_unnecessary_casting_of_sets() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.setArgMethod(anySetOf(String.class))).thenReturn(""set"");
        assertEquals(""set"", mock.setArgMethod(new HashSet<String>()));
        assertEquals(""set"", mock.setArgMethod(Collections.<String>emptySet()));
    }",method,
"    @Test
    public void should_help_out_with_unnecessary_casting_of_maps() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.forMap(anyMapOf(String.class, String.class))).thenReturn(""map"");
        assertEquals(""map"", mock.forMap(new HashMap<String, String>()));
        assertEquals(""map"", mock.forMap(Collections.<String, String>emptyMap()));
    }",method,
"    @Test
    public void should_help_out_with_unnecessary_casting_of_collections() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn(""collection"");
        assertEquals(""collection"", mock.collectionArgMethod(new ArrayList<String>()));
        assertEquals(""collection"", mock.collectionArgMethod(Collections.<String>emptyList()));
    }",method,
"    @Test
    public void should_help_out_with_unnecessary_casting_of_iterables() {
        //Below yields compiler warning:
        //when(mock.setArgMethod(anySet())).thenReturn(""set"");
        when(mock.iterableArgMethod(anyIterableOf(String.class))).thenReturn(""iterable"");
        assertEquals(""iterable"", mock.iterableArgMethod(new ArrayList<String>()));
        assertEquals(""iterable"", mock.iterableArgMethod(Collections.<String>emptyList()));
    }",method,
"    @Test
    public void should_help_out_with_unnecessary_casting_of_nullity_checks() {
        when(mock.objectArgMethod(isNull(LinkedList.class))).thenReturn(""string"");
        when(mock.objectArgMethod(notNull(LinkedList.class))).thenReturn(""string"");
        when(mock.objectArgMethod(isNotNull(LinkedList.class))).thenReturn(""string"");
        assertEquals(""string"", mock.objectArgMethod(null));
        assertEquals(""string"", mock.objectArgMethod(""foo""));
        assertEquals(""string"", mock.objectArgMethod(""foo""));
    }",method,
"public class FeedFragment extends Fragment implements FeedContract.View {
    private static final String TAG = makeLogTag(FeedFragment.class);
    private FeedContract.Presenter mPresenter;
    private RecyclerView mRecyclerView;
    private FeedAdapter mFeedAdapter;
    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
            @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.feed_fragment, container, false);
        mRecyclerView = (RecyclerView) view.findViewById(R.id.feed_recycler_view);
        mRecyclerView.setHasFixedSize(true);
        mFeedAdapter = new FeedAdapter(getContext());
        mRecyclerView.addItemDecoration(new DividerItemDecoration(getContext(), VERTICAL));
        mRecyclerView.setAdapter(mFeedAdapter);
        View header = view.findViewById(R.id.header_anim);
        if (header instanceof ImageView) {
            AnimatedVectorDrawable avd = (AnimatedVectorDrawable) ContextCompat.getDrawable(
                    getContext(), R.drawable.avd_header_feed);
            ((ImageView) header).setImageDrawable(avd);
            avd.start();
        }
        return view;
    }
    @Override
    public void setPresenter(FeedContract.Presenter presenter) {
        mPresenter = presenter;
    }
    @Override
    public void showErrorMessage() {
        Snackbar.make(mRecyclerView, R.string.feed_error, Snackbar.LENGTH_SHORT);
    }
    @Override
    public void addFeedMessage(FeedMessage feedMessage) {
        mFeedAdapter.addFeedMessage(feedMessage);
        mRecyclerView.getLayoutManager().smoothScrollToPosition(mRecyclerView, null, 0);
    }
    @Override
    public void updateFeedMessage(FeedMessage feedMessage) {
        mFeedAdapter.updateFeedMessage(feedMessage);
        mRecyclerView.getLayoutManager().smoothScrollToPosition(mRecyclerView, null, 0);
    }
    @Override
    public void removeFeedMessage(FeedMessage feedMessage) {
        mFeedAdapter.removeFeedMessage(feedMessage);
        mRecyclerView.getLayoutManager().smoothScrollToPosition(mRecyclerView, null, 0);
    }
}",class,
"    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
            @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.feed_fragment, container, false);
        mRecyclerView = (RecyclerView) view.findViewById(R.id.feed_recycler_view);
        mRecyclerView.setHasFixedSize(true);
        mFeedAdapter = new FeedAdapter(getContext());
        mRecyclerView.addItemDecoration(new DividerItemDecoration(getContext(), VERTICAL));
        mRecyclerView.setAdapter(mFeedAdapter);
        View header = view.findViewById(R.id.header_anim);
        if (header instanceof ImageView) {
            AnimatedVectorDrawable avd = (AnimatedVectorDrawable) ContextCompat.getDrawable(
                    getContext(), R.drawable.avd_header_feed);
            ((ImageView) header).setImageDrawable(avd);
            avd.start();
        }
        return view;
    }",method,
"        if (header instanceof ImageView) {
            AnimatedVectorDrawable avd = (AnimatedVectorDrawable) ContextCompat.getDrawable(
                    getContext(), R.drawable.avd_header_feed);
            ((ImageView) header).setImageDrawable(avd);
            avd.start();
        }",method,
"    @Override
    public void setPresenter(FeedContract.Presenter presenter) {
        mPresenter = presenter;
    }",method,
"    @Override
    public void showErrorMessage() {
        Snackbar.make(mRecyclerView, R.string.feed_error, Snackbar.LENGTH_SHORT);
    }",method,
"    @Override
    public void addFeedMessage(FeedMessage feedMessage) {
        mFeedAdapter.addFeedMessage(feedMessage);
        mRecyclerView.getLayoutManager().smoothScrollToPosition(mRecyclerView, null, 0);
    }",method,
"    @Override
    public void updateFeedMessage(FeedMessage feedMessage) {
        mFeedAdapter.updateFeedMessage(feedMessage);
        mRecyclerView.getLayoutManager().smoothScrollToPosition(mRecyclerView, null, 0);
    }",method,
"    @Override
    public void removeFeedMessage(FeedMessage feedMessage) {
        mFeedAdapter.removeFeedMessage(feedMessage);
        mRecyclerView.getLayoutManager().smoothScrollToPosition(mRecyclerView, null, 0);
    }",method,
"public class GroovyStaticMethodNamingConventionInspection extends ConventionInspection {
  private static final int DEFAULT_MIN_LENGTH = 4;
  private static final int DEFAULT_MAX_LENGTH = 32;
  @Override
  @NotNull
  public String getDisplayName() {
    return ""Static method naming convention"";
  }
  @Override
  protected GroovyFix buildFix(@NotNull PsiElement location) {
    return GroovyQuickFixFactory.getInstance().createRenameFix();
  }
  @Override
  protected boolean buildQuickFixesOnlyForOnTheFlyErrors() {
    return true;
  }
  @Override
  @NotNull
  public String buildErrorString(Object... args) {
    final String className = (String) args[0];
    if (className.length() < getMinLength()) {
      return ""Static method name '#ref' is too short"";
    } else if (className.length() > getMaxLength()) {
      return ""Static method name '#ref' is too long"";
    }
    return ""Static method name '#ref' doesn't match regex '"" + getRegex() + ""' #loc"";
  }
  @Override
  protected String getDefaultRegex() {
    return ""[a-z][A-Za-z\\d]*"";
  }
  @Override
  protected int getDefaultMinLength() {
    return DEFAULT_MIN_LENGTH;
  }
  @Override
  protected int getDefaultMaxLength() {
    return DEFAULT_MAX_LENGTH;
  }
  @NotNull
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new NamingConventionsVisitor();
  }
  private class NamingConventionsVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethod(@NotNull GrMethod grMethod) {
      super.visitMethod(grMethod);
      if (!grMethod.hasModifierProperty(PsiModifier.STATIC)) {
        return;
      }
      final String name = grMethod.getName();
      if (isValid(name)) {
        return;
      }
      registerMethodError(grMethod, name);
    }
  }
}",class,
"  private class NamingConventionsVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethod(@NotNull GrMethod grMethod) {
      super.visitMethod(grMethod);
      if (!grMethod.hasModifierProperty(PsiModifier.STATIC)) {
        return;
      }
      final String name = grMethod.getName();
      if (isValid(name)) {
        return;
      }
      registerMethodError(grMethod, name);
    }
  }",class,
"  @Override
  @NotNull
  public String getDisplayName() {
    return ""Static method naming convention"";
  }",method,
"  @Override
  protected GroovyFix buildFix(@NotNull PsiElement location) {
    return GroovyQuickFixFactory.getInstance().createRenameFix();
  }",method,
"  @Override
  protected boolean buildQuickFixesOnlyForOnTheFlyErrors() {
    return true;
  }",method,
"  @Override
  @NotNull
  public String buildErrorString(Object... args) {
    final String className = (String) args[0];
    if (className.length() < getMinLength()) {
      return ""Static method name '#ref' is too short"";
    } else if (className.length() > getMaxLength()) {
      return ""Static method name '#ref' is too long"";
    }
    return ""Static method name '#ref' doesn't match regex '"" + getRegex() + ""' #loc"";
  }",method,
"  @Override
  protected String getDefaultRegex() {
    return ""[a-z][A-Za-z\\d]*"";
  }",method,
"  @Override
  protected int getDefaultMinLength() {
    return DEFAULT_MIN_LENGTH;
  }",method,
"  @Override
  protected int getDefaultMaxLength() {
    return DEFAULT_MAX_LENGTH;
  }",method,
"  @NotNull
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new NamingConventionsVisitor();
  }",method,
"    @Override
    public void visitMethod(@NotNull GrMethod grMethod) {
      super.visitMethod(grMethod);
      if (!grMethod.hasModifierProperty(PsiModifier.STATIC)) {
        return;
      }
      final String name = grMethod.getName();
      if (isValid(name)) {
        return;
      }
      registerMethodError(grMethod, name);
    }",method,
"public class ESTestCaseTests extends ESTestCase {
    public void testExpectThrows() {
        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> {
            throw new IllegalArgumentException(""bad arg"");
        });
        assertEquals(""bad arg"", e.getMessage());
        try {
            expectThrows(IllegalArgumentException.class, () -> {
               throw new IllegalStateException(""bad state"");
            });
            fail(""expected assertion error"");
        } catch (AssertionFailedError assertFailed) {
            assertEquals(""Unexpected exception type, expected IllegalArgumentException but got java.lang.IllegalStateException: bad state"",
                    assertFailed.getMessage());
            assertNotNull(assertFailed.getCause());
            assertEquals(""bad state"", assertFailed.getCause().getMessage());
        }
        try {
            expectThrows(IllegalArgumentException.class, () -> {});
            fail(""expected assertion error"");
        } catch (AssertionFailedError assertFailed) {
            assertNull(assertFailed.getCause());
            assertEquals(""Expected exception IllegalArgumentException but no exception was thrown"",
                    assertFailed.getMessage());
        }
    }
    public void testShuffleMap() throws IOException {
        XContentType xContentType = randomFrom(XContentType.values());
        BytesReference source = RandomObjects.randomSource(random(), xContentType, 5);
        try (XContentParser parser = createParser(xContentType.xContent(), source)) {
            LinkedHashMap<String, Object> initialMap = (LinkedHashMap<String, Object>)parser.mapOrdered();
            Set<List<String>> distinctKeys = new HashSet<>();
            for (int i = 0; i < 10; i++) {
                LinkedHashMap<String, Object> shuffledMap = shuffleMap(initialMap, Collections.emptySet());
                assertEquals(""both maps should contain the same mappings"", initialMap, shuffledMap);
                List<String> shuffledKeys = new ArrayList<>(shuffledMap.keySet());
                distinctKeys.add(shuffledKeys);
            }
            //out of 10 shuffling runs we expect to have at least more than 1 distinct output.
            //This is to make sure that we actually do the shuffling
            assertThat(distinctKeys.size(), greaterThan(1));
        }
    }
    public void testShuffleXContentExcludeFields() throws IOException {
        XContentType xContentType = randomFrom(XContentType.values());
        try (XContentBuilder builder = XContentBuilder.builder(xContentType.xContent())) {
            builder.startObject();
            {
                builder.field(""field1"", ""value1"");
                builder.field(""field2"", ""value2"");
                {
                    builder.startObject(""object1"");
                    {
                        builder.field(""inner1"", ""value1"");
                        builder.field(""inner2"", ""value2"");
                        builder.field(""inner3"", ""value3"");
                    }
                    builder.endObject();
                }
                {
                    builder.startObject(""object2"");
                    {
                        builder.field(""inner4"", ""value4"");
                        builder.field(""inner5"", ""value5"");
                        builder.field(""inner6"", ""value6"");
                    }
                    builder.endObject();
                }
            }
            builder.endObject();
            BytesReference bytes = builder.bytes();
            final LinkedHashMap<String, Object> initialMap;
            try (XContentParser parser = createParser(xContentType.xContent(), bytes)) {
                initialMap = (LinkedHashMap<String, Object>)parser.mapOrdered();
            }
            List<String> expectedInnerKeys1 = Arrays.asList(""inner1"", ""inner2"", ""inner3"");
            Set<List<String>> distinctTopLevelKeys = new HashSet<>();
            Set<List<String>> distinctInnerKeys2 = new HashSet<>();
            for (int i = 0; i < 10; i++) {
                try (XContentParser parser = createParser(xContentType.xContent(), bytes)) {
                    try (XContentBuilder shuffledBuilder = shuffleXContent(parser, randomBoolean(), ""object1"")) {
                        try (XContentParser shuffledParser = createParser(shuffledBuilder)) {
                            Map<String, Object> shuffledMap = shuffledParser.mapOrdered();
                            assertEquals(""both maps should contain the same mappings"", initialMap, shuffledMap);
                            List<String> shuffledKeys = new ArrayList<>(shuffledMap.keySet());
                            distinctTopLevelKeys.add(shuffledKeys);
                            @SuppressWarnings(""unchecked"")
                            Map<String, Object> innerMap1 = (Map<String, Object>)shuffledMap.get(""object1"");
                            List<String> actualInnerKeys1 = new ArrayList<>(innerMap1.keySet());
                            assertEquals(""object1 should have been left untouched"", expectedInnerKeys1, actualInnerKeys1);
                            @SuppressWarnings(""unchecked"")
                            Map<String, Object> innerMap2 = (Map<String, Object>)shuffledMap.get(""object2"");
                            List<String> actualInnerKeys2 = new ArrayList<>(innerMap2.keySet());
                            distinctInnerKeys2.add(actualInnerKeys2);
                        }
                    }
                }
            }
            //out of 10 shuffling runs we expect to have at least more than 1 distinct output for both top level keys and inner object2
            assertThat(distinctTopLevelKeys.size(), greaterThan(1));
            assertThat(distinctInnerKeys2.size(), greaterThan(1));
        }
    }
    public void testRandomUniqueNotUnique() {
        assertThat(randomUnique(() -> 1, 10), hasSize(1));
    }
    public void testRandomUniqueTotallyUnique() {
        AtomicInteger i = new AtomicInteger();
        assertThat(randomUnique(i::incrementAndGet, 100), hasSize(100));
    }
    public void testRandomUniqueNormalUsageAlwayMoreThanOne() {
        assertThat(randomUnique(() -> randomAlphaOfLengthBetween(1, 20), 10), hasSize(greaterThan(0)));
    }
}",class,
"    public void testExpectThrows() {
        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> {
            throw new IllegalArgumentException(""bad arg"");
        });
        assertEquals(""bad arg"", e.getMessage());
        try {
            expectThrows(IllegalArgumentException.class, () -> {
               throw new IllegalStateException(""bad state"");
            });
            fail(""expected assertion error"");
        } catch (AssertionFailedError assertFailed) {
            assertEquals(""Unexpected exception type, expected IllegalArgumentException but got java.lang.IllegalStateException: bad state"",
                    assertFailed.getMessage());
            assertNotNull(assertFailed.getCause());
            assertEquals(""bad state"", assertFailed.getCause().getMessage());
        }
        try {
            expectThrows(IllegalArgumentException.class, () -> {});
            fail(""expected assertion error"");
        } catch (AssertionFailedError assertFailed) {
            assertNull(assertFailed.getCause());
            assertEquals(""Expected exception IllegalArgumentException but no exception was thrown"",
                    assertFailed.getMessage());
        }
    }",method,
"    public void testShuffleMap() throws IOException {
        XContentType xContentType = randomFrom(XContentType.values());
        BytesReference source = RandomObjects.randomSource(random(), xContentType, 5);
        try (XContentParser parser = createParser(xContentType.xContent(), source)) {
            LinkedHashMap<String, Object> initialMap = (LinkedHashMap<String, Object>)parser.mapOrdered();
            Set<List<String>> distinctKeys = new HashSet<>();
            for (int i = 0; i < 10; i++) {
                LinkedHashMap<String, Object> shuffledMap = shuffleMap(initialMap, Collections.emptySet());
                assertEquals(""both maps should contain the same mappings"", initialMap, shuffledMap);
                List<String> shuffledKeys = new ArrayList<>(shuffledMap.keySet());
                distinctKeys.add(shuffledKeys);
            }
            //out of 10 shuffling runs we expect to have at least more than 1 distinct output.
            //This is to make sure that we actually do the shuffling
            assertThat(distinctKeys.size(), greaterThan(1));
        }
    }",method,
"            for (int i = 0; i < 10; i++) {
                LinkedHashMap<String, Object> shuffledMap = shuffleMap(initialMap, Collections.emptySet());
                assertEquals(""both maps should contain the same mappings"", initialMap, shuffledMap);
                List<String> shuffledKeys = new ArrayList<>(shuffledMap.keySet());
                distinctKeys.add(shuffledKeys);
            }",method,
"    public void testShuffleXContentExcludeFields() throws IOException {
        XContentType xContentType = randomFrom(XContentType.values());
        try (XContentBuilder builder = XContentBuilder.builder(xContentType.xContent())) {
            builder.startObject();
            {
                builder.field(""field1"", ""value1"");
                builder.field(""field2"", ""value2"");
                {
                    builder.startObject(""object1"");
                    {
                        builder.field(""inner1"", ""value1"");
                        builder.field(""inner2"", ""value2"");
                        builder.field(""inner3"", ""value3"");
                    }
                    builder.endObject();
                }
                {
                    builder.startObject(""object2"");
                    {
                        builder.field(""inner4"", ""value4"");
                        builder.field(""inner5"", ""value5"");
                        builder.field(""inner6"", ""value6"");
                    }
                    builder.endObject();
                }
            }
            builder.endObject();
            BytesReference bytes = builder.bytes();
            final LinkedHashMap<String, Object> initialMap;
            try (XContentParser parser = createParser(xContentType.xContent(), bytes)) {
                initialMap = (LinkedHashMap<String, Object>)parser.mapOrdered();
            }
            List<String> expectedInnerKeys1 = Arrays.asList(""inner1"", ""inner2"", ""inner3"");
            Set<List<String>> distinctTopLevelKeys = new HashSet<>();
            Set<List<String>> distinctInnerKeys2 = new HashSet<>();
            for (int i = 0; i < 10; i++) {
                try (XContentParser parser = createParser(xContentType.xContent(), bytes)) {
                    try (XContentBuilder shuffledBuilder = shuffleXContent(parser, randomBoolean(), ""object1"")) {
                        try (XContentParser shuffledParser = createParser(shuffledBuilder)) {
                            Map<String, Object> shuffledMap = shuffledParser.mapOrdered();
                            assertEquals(""both maps should contain the same mappings"", initialMap, shuffledMap);
                            List<String> shuffledKeys = new ArrayList<>(shuffledMap.keySet());
                            distinctTopLevelKeys.add(shuffledKeys);
                            @SuppressWarnings(""unchecked"")
                            Map<String, Object> innerMap1 = (Map<String, Object>)shuffledMap.get(""object1"");
                            List<String> actualInnerKeys1 = new ArrayList<>(innerMap1.keySet());
                            assertEquals(""object1 should have been left untouched"", expectedInnerKeys1, actualInnerKeys1);
                            @SuppressWarnings(""unchecked"")
                            Map<String, Object> innerMap2 = (Map<String, Object>)shuffledMap.get(""object2"");
                            List<String> actualInnerKeys2 = new ArrayList<>(innerMap2.keySet());
                            distinctInnerKeys2.add(actualInnerKeys2);
                        }
                    }
                }
            }
            //out of 10 shuffling runs we expect to have at least more than 1 distinct output for both top level keys and inner object2
            assertThat(distinctTopLevelKeys.size(), greaterThan(1));
            assertThat(distinctInnerKeys2.size(), greaterThan(1));
        }
    }",method,
"            for (int i = 0; i < 10; i++) {
                try (XContentParser parser = createParser(xContentType.xContent(), bytes)) {
                    try (XContentBuilder shuffledBuilder = shuffleXContent(parser, randomBoolean(), ""object1"")) {
                        try (XContentParser shuffledParser = createParser(shuffledBuilder)) {
                            Map<String, Object> shuffledMap = shuffledParser.mapOrdered();
                            assertEquals(""both maps should contain the same mappings"", initialMap, shuffledMap);
                            List<String> shuffledKeys = new ArrayList<>(shuffledMap.keySet());
                            distinctTopLevelKeys.add(shuffledKeys);
                            @SuppressWarnings(""unchecked"")
                            Map<String, Object> innerMap1 = (Map<String, Object>)shuffledMap.get(""object1"");
                            List<String> actualInnerKeys1 = new ArrayList<>(innerMap1.keySet());
                            assertEquals(""object1 should have been left untouched"", expectedInnerKeys1, actualInnerKeys1);
                            @SuppressWarnings(""unchecked"")
                            Map<String, Object> innerMap2 = (Map<String, Object>)shuffledMap.get(""object2"");
                            List<String> actualInnerKeys2 = new ArrayList<>(innerMap2.keySet());
                            distinctInnerKeys2.add(actualInnerKeys2);
                        }
                    }
                }
            }",method,
"    public void testRandomUniqueNotUnique() {
        assertThat(randomUnique(() -> 1, 10), hasSize(1));
    }",method,
"    public void testRandomUniqueTotallyUnique() {
        AtomicInteger i = new AtomicInteger();
        assertThat(randomUnique(i::incrementAndGet, 100), hasSize(100));
    }",method,

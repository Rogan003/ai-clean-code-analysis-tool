code_snippet,type,score
"    @Override
    public Peer join(URL url, ChannelHandler handler) throws RemotingException {
        Peer peer = super.join(url, handler);
        send(JOIN + "" "" + url.toFullString());
        return peer;
    }",method,
"    @Override
    public void leave(URL url) throws RemotingException {
        super.leave(url);
        send(LEAVE + "" "" + url.toFullString());
    }",method,
"public class SizeAreaComparator implements Comparator<Camera.Size> {
    @Override
    public int compare(Camera.Size size, Camera.Size size2) {
        checkNotNull(size, ""size must not be null"");
        checkNotNull(size2, ""size2 must not be null"");
        if (size.equals(size2)) {
            return 0;
        }
        long width = size.width;
        long width2 = size2.width;
        long area = width * size.height;
        long area2 = width2 * size2.height;
        if (area == area2) {
            return (width > width2) ? 1 : -1;
        }
        return (area > area2) ? 1 : -1;
    }
    public static Camera.Size findLargestByArea(List<Camera.Size> sizes) {
        checkNotNull(sizes, ""sizes must not be null"");
        return Collections.max(sizes, new SizeAreaComparator());
    }
}",class,
"    @Override
    public int compare(Camera.Size size, Camera.Size size2) {
        checkNotNull(size, ""size must not be null"");
        checkNotNull(size2, ""size2 must not be null"");
        if (size.equals(size2)) {
            return 0;
        }
        long width = size.width;
        long width2 = size2.width;
        long area = width * size.height;
        long area2 = width2 * size2.height;
        if (area == area2) {
            return (width > width2) ? 1 : -1;
        }
        return (area > area2) ? 1 : -1;
    }",method,
"        if (area == area2) {
            return (width > width2) ? 1 : -1;
        }",method,
"    public static Camera.Size findLargestByArea(List<Camera.Size> sizes) {
        checkNotNull(sizes, ""sizes must not be null"");
        return Collections.max(sizes, new SizeAreaComparator());
    }",method,
"public class SimpleChangesBrowser extends ChangesBrowserBase {
  private final List<Change> myChanges = new ArrayList<>();
  @Nullable private ChangeNodeDecorator myChangeNodeDecorator;
  public SimpleChangesBrowser(@NotNull Project project,
                              @NotNull Collection<? extends Change> changes) {
    this(project, false, false);
    setChangesToDisplay(changes);
  }
  public SimpleChangesBrowser(@NotNull Project project,
                              boolean showCheckboxes,
                              boolean highlightProblems) {
    super(project, showCheckboxes, highlightProblems);
    init();
  }
  @NotNull
  @Override
  protected DefaultTreeModel buildTreeModel(boolean showFlatten) {
    return TreeModelBuilder.buildFromChanges(myProject, showFlatten, myChanges, myChangeNodeDecorator);
  }
  public void setChangesToDisplay(@NotNull Collection<? extends Change> changes) {
    myChanges.clear();
    myChanges.addAll(changes);
    myViewer.rebuildTree();
  }
  public void setChangeNodeDecorator(@Nullable ChangeNodeDecorator value) {
    myChangeNodeDecorator = value;
    myViewer.rebuildTree();
  }
  public void setIncludedChanges(@NotNull Collection<? extends Change> changes) {
    myViewer.setIncludedChanges(changes);
  }
  @NotNull
  public List<Change> getAllChanges() {
    return VcsTreeModelData.all(myViewer).userObjects(Change.class);
  }
  @NotNull
  public List<Change> getSelectedChanges() {
    return VcsTreeModelData.selected(myViewer).userObjects(Change.class);
  }
  @NotNull
  public List<Change> getIncludedChanges() {
    return VcsTreeModelData.included(myViewer).userObjects(Change.class);
  }
}",class,
"  @Nullable private ChangeNodeDecorator myChangeNodeDecorator;
  public SimpleChangesBrowser(@NotNull Project project,
                              @NotNull Collection<? extends Change> changes) {
    this(project, false, false);
    setChangesToDisplay(changes);
  }",method,
"  public SimpleChangesBrowser(@NotNull Project project,
                              boolean showCheckboxes,
                              boolean highlightProblems) {
    super(project, showCheckboxes, highlightProblems);
    init();
  }",method,
"  @NotNull
  @Override
  protected DefaultTreeModel buildTreeModel(boolean showFlatten) {
    return TreeModelBuilder.buildFromChanges(myProject, showFlatten, myChanges, myChangeNodeDecorator);
  }",method,
"  public void setChangesToDisplay(@NotNull Collection<? extends Change> changes) {
    myChanges.clear();
    myChanges.addAll(changes);
    myViewer.rebuildTree();
  }",method,
"  public void setChangeNodeDecorator(@Nullable ChangeNodeDecorator value) {
    myChangeNodeDecorator = value;
    myViewer.rebuildTree();
  }",method,
"  public void setIncludedChanges(@NotNull Collection<? extends Change> changes) {
    myViewer.setIncludedChanges(changes);
  }",method,
"  @NotNull
  public List<Change> getAllChanges() {
    return VcsTreeModelData.all(myViewer).userObjects(Change.class);
  }",method,
"  @NotNull
  public List<Change> getSelectedChanges() {
    return VcsTreeModelData.selected(myViewer).userObjects(Change.class);
  }",method,
"  @NotNull
  public List<Change> getIncludedChanges() {
    return VcsTreeModelData.included(myViewer).userObjects(Change.class);
  }",method,
"public class ErrorLoggerTest {
  static class LoggedErrors {
    @Nullable String userVisible = null;
    @Nullable String userVisibleInternal = null;
    @Nullable Throwable verbose = null;
  }
  @Test
  public void testRuntimeException() {
    LoggedErrors errors = logException(new RuntimeException(""message""));
    assertNull(errors.userVisible);
    assertEquals(""message"", errors.userVisibleInternal);
  }
  @Test
  public void testHumanReadableException() {
    LoggedErrors errors = logException(new HumanReadableException(""message""));
    assertNull(errors.userVisibleInternal);
    assertEquals(""message"", errors.userVisible);
  }
  @Test
  public void testWrappedException() {
    LoggedErrors errors =
        logException(new BuckExecutionException(new HumanReadableException(""message"")));
    assertNull(errors.userVisibleInternal);
    assertEquals(""message"", errors.userVisible);
  }
  @Test
  public void testWrappedExceptionWithContext() {
    LoggedErrors errors =
        logException(new BuckExecutionException(new HumanReadableException(""message""), ""context""));
    assertNull(errors.userVisibleInternal);
    assertEquals(""message\n"" + ""    context"", errors.userVisible);
  }
  LoggedErrors logException(Exception e) {
    LoggedErrors result = new LoggedErrors();
    new ErrorLogger(
            new ErrorLogger.LogImpl() {
              @Override
              public void logUserVisible(String message) {
                assertNull(result.userVisible);
                result.userVisible = message;
              }
              @Override
              public void logUserVisibleInternalError(String message) {
                assertNull(result.userVisibleInternal);
                result.userVisibleInternal = message;
              }
              @Override
              public void logVerbose(Throwable e) {
                assertNull(result.verbose);
                result.verbose = e;
              }
            })
        .logException(e);
    assertTrue(result.userVisibleInternal == null ^ result.userVisible == null);
    assertNotNull(result.verbose);
    assertEquals(e, result.verbose);
    return result;
  }
}",class,
"  static class LoggedErrors {
    @Nullable String userVisible = null;
    @Nullable String userVisibleInternal = null;
    @Nullable Throwable verbose = null;
  }",class,
"  @Test
  public void testRuntimeException() {
    LoggedErrors errors = logException(new RuntimeException(""message""));
    assertNull(errors.userVisible);
    assertEquals(""message"", errors.userVisibleInternal);
  }",method,
"  @Test
  public void testHumanReadableException() {
    LoggedErrors errors = logException(new HumanReadableException(""message""));
    assertNull(errors.userVisibleInternal);
    assertEquals(""message"", errors.userVisible);
  }",method,
"  @Test
  public void testWrappedException() {
    LoggedErrors errors =
        logException(new BuckExecutionException(new HumanReadableException(""message"")));
    assertNull(errors.userVisibleInternal);
    assertEquals(""message"", errors.userVisible);
  }",method,
"  @Test
  public void testWrappedExceptionWithContext() {
    LoggedErrors errors =
        logException(new BuckExecutionException(new HumanReadableException(""message""), ""context""));
    assertNull(errors.userVisibleInternal);
    assertEquals(""message\n"" + ""    context"", errors.userVisible);
  }",method,
"  LoggedErrors logException(Exception e) {
    LoggedErrors result = new LoggedErrors();
    new ErrorLogger(
            new ErrorLogger.LogImpl() {
              @Override
              public void logUserVisible(String message) {
                assertNull(result.userVisible);
                result.userVisible = message;
              }
              @Override
              public void logUserVisibleInternalError(String message) {
                assertNull(result.userVisibleInternal);
                result.userVisibleInternal = message;
              }
              @Override
              public void logVerbose(Throwable e) {
                assertNull(result.verbose);
                result.verbose = e;
              }
            })
        .logException(e);
    assertTrue(result.userVisibleInternal == null ^ result.userVisible == null);
    assertNotNull(result.verbose);
    assertEquals(e, result.verbose);
    return result;
  }",method,
"    new ErrorLogger(
            new ErrorLogger.LogImpl() {
              @Override
              public void logUserVisible(String message) {
                assertNull(result.userVisible);
                result.userVisible = message;
              }
              @Override
              public void logUserVisibleInternalError(String message) {
                assertNull(result.userVisibleInternal);
                result.userVisibleInternal = message;
              }
              @Override
              public void logVerbose(Throwable e) {
                assertNull(result.verbose);
                result.verbose = e;
              }
            }",method,
"              @Override
              public void logUserVisible(String message) {
                assertNull(result.userVisible);
                result.userVisible = message;
              }",method,
"              @Override
              public void logUserVisibleInternalError(String message) {
                assertNull(result.userVisibleInternal);
                result.userVisibleInternal = message;
              }",method,
"              @Override
              public void logVerbose(Throwable e) {
                assertNull(result.verbose);
                result.verbose = e;
              }",method,
"import java.net.SocketException;
class TdsTlsSocket extends Socket {
    private final Socket delegate;
    private final InputStream istm;
    private final OutputStream ostm;
    TdsTlsSocket(Socket delegate) throws IOException {
        this.delegate = delegate;
        istm = new TdsTlsInputStream(delegate.getInputStream());
        ostm = new TdsTlsOutputStream(delegate.getOutputStream());
    }
    public synchronized void close() throws IOException {
        // Do nothing. Underlying socket closed elsewhere
    }
    public InputStream getInputStream() throws IOException {
        return istm;
    }
    public OutputStream getOutputStream() throws IOException {
        return ostm;
    }
    public boolean isConnected() {
        return true;
    }
    public synchronized void setSoTimeout(int timeout) throws SocketException {
        delegate.setSoTimeout(timeout);
    }
    public synchronized void setKeepAlive(boolean keepAlive) throws SocketException {
        delegate.setKeepAlive(keepAlive);
    }
    public void setTcpNoDelay(boolean on) throws SocketException {
        delegate.setTcpNoDelay(on);
    }
}",class,
"    TdsTlsSocket(Socket delegate) throws IOException {
        this.delegate = delegate;
        istm = new TdsTlsInputStream(delegate.getInputStream());
        ostm = new TdsTlsOutputStream(delegate.getOutputStream());
    }",method,
"    public synchronized void close() throws IOException {
        // Do nothing. Underlying socket closed elsewhere
    }",method,
"    public InputStream getInputStream() throws IOException {
        return istm;
    }",method,
"    public OutputStream getOutputStream() throws IOException {
        return ostm;
    }",method,
"    public boolean isConnected() {
        return true;
    }",method,
"    public synchronized void setSoTimeout(int timeout) throws SocketException {
        delegate.setSoTimeout(timeout);
    }",method,
"    public synchronized void setKeepAlive(boolean keepAlive) throws SocketException {
        delegate.setKeepAlive(keepAlive);
    }",method,
"    public void setTcpNoDelay(boolean on) throws SocketException {
        delegate.setTcpNoDelay(on);
    }",method,
"import org.jetbrains.annotations.NotNull;
class CodeFoldingPass extends EditorBoundHighlightingPass implements PossiblyDumbAware {
  private static final Key<Boolean> THE_FIRST_TIME = Key.create(""FirstFoldingPass"");
  private volatile Runnable myRunnable;
  CodeFoldingPass(@NotNull Editor editor, @NotNull PsiFile file) {
    super(editor, file, false);
  }
  @Override
  public void doCollectInformation(@NotNull ProgressIndicator progress) {
    final boolean firstTime = isFirstTime(myFile, myEditor, THE_FIRST_TIME);
    myRunnable = CodeFoldingManager.getInstance(myProject).updateFoldRegionsAsync(myEditor, firstTime);
  }
  static boolean isFirstTime(PsiFile file, Editor editor, Key<Boolean> key) {
    return file.getUserData(key) == null || editor.getUserData(key) == null;
  }
  static void clearFirstTimeFlag(PsiFile file, Editor editor, Key<Boolean> key) {
    file.putUserData(key, Boolean.FALSE);
    editor.putUserData(key, Boolean.FALSE);
  }
  @Override
  public void doApplyInformationToEditor() {
    Runnable runnable = myRunnable;
    if (runnable != null){
      try {
        runnable.run();
      }
      catch (IndexNotReadyException ignored) {
      }
    }
    if (InjectedLanguageManager.getInstance(myFile.getProject()).getTopLevelFile(myFile) == myFile) {
      clearFirstTimeFlag(myFile, myEditor, THE_FIRST_TIME);
    }
  }
  @Override
  public boolean isDumbAware() {
    return FoldingUpdate.supportsDumbModeFolding(myEditor);
  }
}",class,
"  CodeFoldingPass(@NotNull Editor editor, @NotNull PsiFile file) {
    super(editor, file, false);
  }",method,
"  @Override
  public void doCollectInformation(@NotNull ProgressIndicator progress) {
    final boolean firstTime = isFirstTime(myFile, myEditor, THE_FIRST_TIME);
    myRunnable = CodeFoldingManager.getInstance(myProject).updateFoldRegionsAsync(myEditor, firstTime);
  }",method,
"  static boolean isFirstTime(PsiFile file, Editor editor, Key<Boolean> key) {
    return file.getUserData(key) == null || editor.getUserData(key) == null;
  }",method,
"  static void clearFirstTimeFlag(PsiFile file, Editor editor, Key<Boolean> key) {
    file.putUserData(key, Boolean.FALSE);
    editor.putUserData(key, Boolean.FALSE);
  }",method,
"  @Override
  public void doApplyInformationToEditor() {
    Runnable runnable = myRunnable;
    if (runnable != null){
      try {
        runnable.run();
      }
      catch (IndexNotReadyException ignored) {
      }
    }
    if (InjectedLanguageManager.getInstance(myFile.getProject()).getTopLevelFile(myFile) == myFile) {
      clearFirstTimeFlag(myFile, myEditor, THE_FIRST_TIME);
    }
  }",method,
"    if (runnable != null){
      try {
        runnable.run();
      }
      catch (IndexNotReadyException ignored) {
      }
    }",method,
"      catch (IndexNotReadyException ignored) {
      }",method,
"  @Override
  public boolean isDumbAware() {
    return FoldingUpdate.supportsDumbModeFolding(myEditor);
  }",method,
"public class BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspectionBase extends BaseInspection {
  private static final String[] STATIC_CONFIGS = new String[] {
    ""org.junit.BeforeClass"",
    ""org.junit.AfterClass"",
    ""org.junit.jupiter.api.BeforeAll"",
    ""org.junit.jupiter.api.AfterAll""
  };
  protected static boolean isJunit4Annotation(String annotation) {
    return annotation.endsWith(""Class"");
  }
  @Override
  @NotNull
  public String getID() {
    return ""BeforeOrAfterWithIncorrectSignature"";
  }
  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""before.class.or.after.class.is.public.static.void.no.arg.display.name"");
  }
  @Override
  @NotNull
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(
      ""before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor"", infos[1]);
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new BeforeClassOrAfterClassIsPublicStaticVoidNoArgVisitor();
  }
  private static class BeforeClassOrAfterClassIsPublicStaticVoidNoArgVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      //note: no call to super;
      String annotation = Arrays.stream(STATIC_CONFIGS)
        .filter(anno -> AnnotationUtil.isAnnotated(method, anno, true))
        .findFirst().orElse(null);
      if (annotation == null) {
        return;
      }
      final PsiType returnType = method.getReturnType();
      if (returnType == null) {
        return;
      }
      final PsiClass targetClass = method.getContainingClass();
      if (targetClass == null) {
        return;
      }
      final PsiParameterList parameterList = method.getParameterList();
      boolean junit4Annotation = isJunit4Annotation(annotation);
      if (junit4Annotation && (parameterList.getParametersCount() != 0 || !method.hasModifierProperty(PsiModifier.PUBLIC)) ||
          !returnType.equals(PsiType.VOID) || 
          !method.hasModifierProperty(PsiModifier.STATIC) && (junit4Annotation || !TestUtils.testInstancePerClass(targetClass))) {
        registerMethodError(method, method, annotation);
      }
    }
  }
}",class,
"  private static class BeforeClassOrAfterClassIsPublicStaticVoidNoArgVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      //note: no call to super;
      String annotation = Arrays.stream(STATIC_CONFIGS)
        .filter(anno -> AnnotationUtil.isAnnotated(method, anno, true))
        .findFirst().orElse(null);
      if (annotation == null) {
        return;
      }
      final PsiType returnType = method.getReturnType();
      if (returnType == null) {
        return;
      }
      final PsiClass targetClass = method.getContainingClass();
      if (targetClass == null) {
        return;
      }
      final PsiParameterList parameterList = method.getParameterList();
      boolean junit4Annotation = isJunit4Annotation(annotation);
      if (junit4Annotation && (parameterList.getParametersCount() != 0 || !method.hasModifierProperty(PsiModifier.PUBLIC)) ||
          !returnType.equals(PsiType.VOID) || 
          !method.hasModifierProperty(PsiModifier.STATIC) && (junit4Annotation || !TestUtils.testInstancePerClass(targetClass))) {
        registerMethodError(method, method, annotation);
      }
    }
  }",class,
"  protected static boolean isJunit4Annotation(String annotation) {
    return annotation.endsWith(""Class"");
  }",method,
"  @Override
  @NotNull
  public String getID() {
    return ""BeforeOrAfterWithIncorrectSignature"";
  }",method,
"  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""before.class.or.after.class.is.public.static.void.no.arg.display.name"");
  }",method,
"  @Override
  @NotNull
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(
      ""before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor"", infos[1]);
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new BeforeClassOrAfterClassIsPublicStaticVoidNoArgVisitor();
  }",method,
"    @Override
    public void visitMethod(@NotNull PsiMethod method) {
      //note: no call to super;
      String annotation = Arrays.stream(STATIC_CONFIGS)
        .filter(anno -> AnnotationUtil.isAnnotated(method, anno, true))
        .findFirst().orElse(null);
      if (annotation == null) {
        return;
      }
      final PsiType returnType = method.getReturnType();
      if (returnType == null) {
        return;
      }
      final PsiClass targetClass = method.getContainingClass();
      if (targetClass == null) {
        return;
      }
      final PsiParameterList parameterList = method.getParameterList();
      boolean junit4Annotation = isJunit4Annotation(annotation);
      if (junit4Annotation && (parameterList.getParametersCount() != 0 || !method.hasModifierProperty(PsiModifier.PUBLIC)) ||
          !returnType.equals(PsiType.VOID) || 
          !method.hasModifierProperty(PsiModifier.STATIC) && (junit4Annotation || !TestUtils.testInstancePerClass(targetClass))) {
        registerMethodError(method, method, annotation);
      }
    }",method,
"      if (annotation == null) {
        return;
      }",method,
"      if (returnType == null) {
        return;
      }",method,
"      if (targetClass == null) {
        return;
      }",method,
"public class ThreadLocalRandom extends Random {
    // same constants as Random, but must be redeclared because private
    private static final long multiplier = 0x5DEECE66DL;
    private static final long addend = 0xBL;
    private static final long mask = (1L << 48) - 1;
    private long rnd;
    boolean initialized;
    // Padding to help avoid memory contention among seed updates in
    // different TLRs in the common case that they are located near
    // each other.
    private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;
    private static final ThreadLocal<ThreadLocalRandom> localRandom =
        new ThreadLocal<ThreadLocalRandom>() {
            protected ThreadLocalRandom initialValue() {
                return new ThreadLocalRandom();
            }
    };
    ThreadLocalRandom() {
        super();
        initialized = true;
    }
    public static ThreadLocalRandom current() {
        return localRandom.get();
    }
    public void setSeed(long seed) {
        if (initialized)
            throw new UnsupportedOperationException();
        rnd = (seed ^ multiplier) & mask;
    }
    protected int next(int bits) {
        rnd = (rnd * multiplier + addend) & mask;
        return (int) (rnd >>> (48-bits));
    }
    public int nextInt(int least, int bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextInt(bound - least) + least;
    }
    public long nextLong(long n) {
        if (n <= 0)
            throw new IllegalArgumentException(""n must be positive"");
        // Divide n by two until small enough for nextInt. On each
        // iteration (at most 31 of them but usually much less),
        // randomly choose both whether to include high bit in result
        // (offset) and whether to continue with the lower vs upper
        // half (which makes a difference only if odd).
        long offset = 0;
        while (n >= Integer.MAX_VALUE) {
            int bits = next(2);
            long half = n >>> 1;
            long nextn = ((bits & 2) == 0) ? half : n - half;
            if ((bits & 1) == 0)
                offset += n - nextn;
            n = nextn;
        }
        return offset + nextInt((int) n);
    }
    public long nextLong(long least, long bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextLong(bound - least) + least;
    }
    public double nextDouble(double n) {
        if (n <= 0)
            throw new IllegalArgumentException(""n must be positive"");
        return nextDouble() * n;
    }
    public double nextDouble(double least, double bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextDouble() * (bound - least) + least;
    }
    private static final long serialVersionUID = -5851777807851030925L;
}",class,
"            protected ThreadLocalRandom initialValue() {
                return new ThreadLocalRandom();
            }",method,
"    ThreadLocalRandom() {
        super();
        initialized = true;
    }",method,
"    public static ThreadLocalRandom current() {
        return localRandom.get();
    }",method,
"    public void setSeed(long seed) {
        if (initialized)
            throw new UnsupportedOperationException();
        rnd = (seed ^ multiplier) & mask;
    }",method,
"    protected int next(int bits) {
        rnd = (rnd * multiplier + addend) & mask;
        return (int) (rnd >>> (48-bits));
    }",method,
"    public int nextInt(int least, int bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextInt(bound - least) + least;
    }",method,
"    public long nextLong(long n) {
        if (n <= 0)
            throw new IllegalArgumentException(""n must be positive"");
        // Divide n by two until small enough for nextInt. On each
        // iteration (at most 31 of them but usually much less),
        // randomly choose both whether to include high bit in result
        // (offset) and whether to continue with the lower vs upper
        // half (which makes a difference only if odd).
        long offset = 0;
        while (n >= Integer.MAX_VALUE) {
            int bits = next(2);
            long half = n >>> 1;
            long nextn = ((bits & 2) == 0) ? half : n - half;
            if ((bits & 1) == 0)
                offset += n - nextn;
            n = nextn;
        }
        return offset + nextInt((int) n);
    }",method,
"        while (n >= Integer.MAX_VALUE) {
            int bits = next(2);
            long half = n >>> 1;
            long nextn = ((bits & 2) == 0) ? half : n - half;
            if ((bits & 1) == 0)
                offset += n - nextn;
            n = nextn;
        }",method,
"    public long nextLong(long least, long bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextLong(bound - least) + least;
    }",method,
"    public double nextDouble(double n) {
        if (n <= 0)
            throw new IllegalArgumentException(""n must be positive"");
        return nextDouble() * n;
    }",method,
"    public double nextDouble(double least, double bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextDouble() * (bound - least) + least;
    }",method,
"        private ClassData(com.google.protobuf.GeneratedMessageLite.Builder builder) {
          super(builder);
        }",method,
        private ClassData(boolean noInit) {},method,
"        public static ClassData getDefaultInstance() {
          return defaultInstance;
        }",method,
"        public ClassData getDefaultInstanceForType() {
          return defaultInstance;
        }",method,
"public final class EnvironmentBackedRecursivePackageProvider implements RecursivePackageProvider {
  private final Environment env;
  public EnvironmentBackedRecursivePackageProvider(Environment env) {
    this.env = env;
  }
  @Override
  public Package getPackage(ExtendedEventHandler eventHandler, PackageIdentifier packageName)
      throws NoSuchPackageException, MissingDepException, InterruptedException {
    SkyKey pkgKey = PackageValue.key(packageName);
    PackageValue pkgValue =
        (PackageValue) env.getValueOrThrow(pkgKey, NoSuchPackageException.class);
    if (pkgValue == null) {
      throw new MissingDepException();
    }
    Package pkg = pkgValue.getPackage();
    if (pkg.containsErrors()) {
      // If this is a nokeep_going build, we must shut the build down by throwing an exception. To
      // do that, we request a node that will throw an exception, and then try to catch it and
      // continue. This gives the framework notification to shut down the build if it should.
      try {
        env.getValueOrThrow(
            PackageErrorFunction.key(packageName), BuildFileContainsErrorsException.class);
        Preconditions.checkState(env.valuesMissing(), ""Should have thrown for %s"", packageName);
        throw new MissingDepException();
      } catch (BuildFileContainsErrorsException e) {
        // Expected.
      }
    }
    return pkgValue.getPackage();
  }
  @Override
  public Map<PackageIdentifier, Package> bulkGetPackages(Iterable<PackageIdentifier> pkgIds)
      throws NoSuchPackageException, InterruptedException {
    ImmutableMap.Builder<PackageIdentifier, Package> builder = ImmutableMap.builder();
    for (PackageIdentifier pkgId : pkgIds) {
      builder.put(pkgId, getPackage(env.getListener(), pkgId));
    }
    return builder.build();
  }
  @Override
  public boolean isPackage(ExtendedEventHandler eventHandler, PackageIdentifier packageId)
      throws MissingDepException, InterruptedException {
    SkyKey packageLookupKey = PackageLookupValue.key(packageId);
    try {
      PackageLookupValue packageLookupValue =
          (PackageLookupValue) env.getValueOrThrow(packageLookupKey, NoSuchPackageException.class,
              InconsistentFilesystemException.class);
      if (packageLookupValue == null) {
        throw new MissingDepException();
      }
      return packageLookupValue.packageExists();
    } catch (NoSuchPackageException | InconsistentFilesystemException e) {
      env.getListener().handle(Event.error(e.getMessage()));
      return false;
    }
  }
  @Override
  public Iterable<PathFragment> getPackagesUnderDirectory(
      ExtendedEventHandler eventHandler,
      RepositoryName repository,
      PathFragment directory,
      ImmutableSet<PathFragment> blacklistedSubdirectories,
      ImmutableSet<PathFragment> excludedSubdirectories)
      throws MissingDepException, InterruptedException {
    PathPackageLocator packageLocator = PrecomputedValue.PATH_PACKAGE_LOCATOR.get(env);
    if (packageLocator == null) {
      throw new MissingDepException();
    }
    List<Path> roots = new ArrayList<>();
    if (repository.isMain()) {
      roots.addAll(packageLocator.getPathEntries());
    } else {
      RepositoryDirectoryValue repositoryValue =
          (RepositoryDirectoryValue) env.getValue(RepositoryDirectoryValue.key(repository));
      if (repositoryValue == null) {
        throw new MissingDepException();
      }
      if (!repositoryValue.repositoryExists()) {
        // This shouldn't be possible; we're given a repository, so we assume that the caller has
        // already checked for its existence.
        throw new IllegalStateException(String.format(""No such repository '%s'"", repository));
      }
      roots.add(repositoryValue.getPath());
    }
    LinkedHashSet<PathFragment> packageNames = new LinkedHashSet<>();
    for (Path root : roots) {
      PathFragment.checkAllPathsAreUnder(blacklistedSubdirectories, directory);
      RecursivePkgValue lookup = (RecursivePkgValue) env.getValue(RecursivePkgValue.key(
          repository, RootedPath.toRootedPath(root, directory), blacklistedSubdirectories));
      if (lookup == null) {
        // Typically a null value from Environment.getValue(k) means that either the key k is
        // missing a dependency or an exception was thrown during evaluation of k. Here, if this
        // getValue call returns null in a keep_going build, it can only mean a missing dependency
        // because RecursivePkgFunction#compute never throws.
        // In a nokeep_going build, a lower-level exception that RecursivePkgFunction ignored may
        // bubble up to here, but we ignore it and depend on the top-level caller to be flexible in
        // the exception types it can accept.
        throw new MissingDepException();
      }
      for (String packageName : lookup.getPackages()) {
        // TODO(bazel-team): Make RecursivePkgValue return NestedSet<PathFragment> so this transform
        // is unnecessary.
        PathFragment packageNamePathFragment = PathFragment.create(packageName);
        if (!Iterables.any(
            excludedSubdirectories,
            excludedSubdirectory -> packageNamePathFragment.startsWith(excludedSubdirectory))) {
          packageNames.add(packageNamePathFragment);
        }
      }
    }
    return packageNames;
  }
  @Override
  public Target getTarget(ExtendedEventHandler eventHandler, Label label)
      throws NoSuchPackageException, NoSuchTargetException, MissingDepException,
          InterruptedException {
    return getPackage(eventHandler, label.getPackageIdentifier()).getTarget(label.getName());
  }
  static class MissingDepException extends RuntimeException {
  }
}",class,
"  static class MissingDepException extends RuntimeException {
  }",class,
"  public EnvironmentBackedRecursivePackageProvider(Environment env) {
    this.env = env;
  }",method,
"  @Override
  public Package getPackage(ExtendedEventHandler eventHandler, PackageIdentifier packageName)
      throws NoSuchPackageException, MissingDepException, InterruptedException {
    SkyKey pkgKey = PackageValue.key(packageName);
    PackageValue pkgValue =
        (PackageValue) env.getValueOrThrow(pkgKey, NoSuchPackageException.class);
    if (pkgValue == null) {
      throw new MissingDepException();
    }
    Package pkg = pkgValue.getPackage();
    if (pkg.containsErrors()) {
      // If this is a nokeep_going build, we must shut the build down by throwing an exception. To
      // do that, we request a node that will throw an exception, and then try to catch it and
      // continue. This gives the framework notification to shut down the build if it should.
      try {
        env.getValueOrThrow(
            PackageErrorFunction.key(packageName), BuildFileContainsErrorsException.class);
        Preconditions.checkState(env.valuesMissing(), ""Should have thrown for %s"", packageName);
        throw new MissingDepException();
      } catch (BuildFileContainsErrorsException e) {
        // Expected.
      }
    }
    return pkgValue.getPackage();
  }",method,
"    if (pkgValue == null) {
      throw new MissingDepException();
    }",method,
"  @Override
  public Map<PackageIdentifier, Package> bulkGetPackages(Iterable<PackageIdentifier> pkgIds)
      throws NoSuchPackageException, InterruptedException {
    ImmutableMap.Builder<PackageIdentifier, Package> builder = ImmutableMap.builder();
    for (PackageIdentifier pkgId : pkgIds) {
      builder.put(pkgId, getPackage(env.getListener(), pkgId));
    }
    return builder.build();
  }",method,
"    for (PackageIdentifier pkgId : pkgIds) {
      builder.put(pkgId, getPackage(env.getListener(), pkgId));
    }",method,
"  @Override
  public boolean isPackage(ExtendedEventHandler eventHandler, PackageIdentifier packageId)
      throws MissingDepException, InterruptedException {
    SkyKey packageLookupKey = PackageLookupValue.key(packageId);
    try {
      PackageLookupValue packageLookupValue =
          (PackageLookupValue) env.getValueOrThrow(packageLookupKey, NoSuchPackageException.class,
              InconsistentFilesystemException.class);
      if (packageLookupValue == null) {
        throw new MissingDepException();
      }
      return packageLookupValue.packageExists();
    } catch (NoSuchPackageException | InconsistentFilesystemException e) {
      env.getListener().handle(Event.error(e.getMessage()));
      return false;
    }
  }",method,
"      if (packageLookupValue == null) {
        throw new MissingDepException();
      }",method,
"  @Override
  public Iterable<PathFragment> getPackagesUnderDirectory(
      ExtendedEventHandler eventHandler,
      RepositoryName repository,
      PathFragment directory,
      ImmutableSet<PathFragment> blacklistedSubdirectories,
      ImmutableSet<PathFragment> excludedSubdirectories)
      throws MissingDepException, InterruptedException {
    PathPackageLocator packageLocator = PrecomputedValue.PATH_PACKAGE_LOCATOR.get(env);
    if (packageLocator == null) {
      throw new MissingDepException();
    }
    List<Path> roots = new ArrayList<>();
    if (repository.isMain()) {
      roots.addAll(packageLocator.getPathEntries());
    } else {
      RepositoryDirectoryValue repositoryValue =
          (RepositoryDirectoryValue) env.getValue(RepositoryDirectoryValue.key(repository));
      if (repositoryValue == null) {
        throw new MissingDepException();
      }
      if (!repositoryValue.repositoryExists()) {
        // This shouldn't be possible; we're given a repository, so we assume that the caller has
        // already checked for its existence.
        throw new IllegalStateException(String.format(""No such repository '%s'"", repository));
      }
      roots.add(repositoryValue.getPath());
    }
    LinkedHashSet<PathFragment> packageNames = new LinkedHashSet<>();
    for (Path root : roots) {
      PathFragment.checkAllPathsAreUnder(blacklistedSubdirectories, directory);
      RecursivePkgValue lookup = (RecursivePkgValue) env.getValue(RecursivePkgValue.key(
          repository, RootedPath.toRootedPath(root, directory), blacklistedSubdirectories));
      if (lookup == null) {
        // Typically a null value from Environment.getValue(k) means that either the key k is
        // missing a dependency or an exception was thrown during evaluation of k. Here, if this
        // getValue call returns null in a keep_going build, it can only mean a missing dependency
        // because RecursivePkgFunction#compute never throws.
        // In a nokeep_going build, a lower-level exception that RecursivePkgFunction ignored may
        // bubble up to here, but we ignore it and depend on the top-level caller to be flexible in
        // the exception types it can accept.
        throw new MissingDepException();
      }
      for (String packageName : lookup.getPackages()) {
        // TODO(bazel-team): Make RecursivePkgValue return NestedSet<PathFragment> so this transform
        // is unnecessary.
        PathFragment packageNamePathFragment = PathFragment.create(packageName);
        if (!Iterables.any(
            excludedSubdirectories,
            excludedSubdirectory -> packageNamePathFragment.startsWith(excludedSubdirectory))) {
          packageNames.add(packageNamePathFragment);
        }
      }
    }
    return packageNames;
  }",method,
"    if (packageLocator == null) {
      throw new MissingDepException();
    }",method,
"      if (repositoryValue == null) {
        throw new MissingDepException();
      }",method,
"    for (Path root : roots) {
      PathFragment.checkAllPathsAreUnder(blacklistedSubdirectories, directory);
      RecursivePkgValue lookup = (RecursivePkgValue) env.getValue(RecursivePkgValue.key(
          repository, RootedPath.toRootedPath(root, directory), blacklistedSubdirectories));
      if (lookup == null) {
        // Typically a null value from Environment.getValue(k) means that either the key k is
        // missing a dependency or an exception was thrown during evaluation of k. Here, if this
        // getValue call returns null in a keep_going build, it can only mean a missing dependency
        // because RecursivePkgFunction#compute never throws.
        // In a nokeep_going build, a lower-level exception that RecursivePkgFunction ignored may
        // bubble up to here, but we ignore it and depend on the top-level caller to be flexible in
        // the exception types it can accept.
        throw new MissingDepException();
      }
      for (String packageName : lookup.getPackages()) {
        // TODO(bazel-team): Make RecursivePkgValue return NestedSet<PathFragment> so this transform
        // is unnecessary.
        PathFragment packageNamePathFragment = PathFragment.create(packageName);
        if (!Iterables.any(
            excludedSubdirectories,
            excludedSubdirectory -> packageNamePathFragment.startsWith(excludedSubdirectory))) {
          packageNames.add(packageNamePathFragment);
        }
      }
    }",method,
"      if (lookup == null) {
        // Typically a null value from Environment.getValue(k) means that either the key k is
        // missing a dependency or an exception was thrown during evaluation of k. Here, if this
        // getValue call returns null in a keep_going build, it can only mean a missing dependency
        // because RecursivePkgFunction#compute never throws.
        // In a nokeep_going build, a lower-level exception that RecursivePkgFunction ignored may
        // bubble up to here, but we ignore it and depend on the top-level caller to be flexible in
        // the exception types it can accept.
        throw new MissingDepException();
      }",method,
"  @Override
  public Target getTarget(ExtendedEventHandler eventHandler, Label label)
      throws NoSuchPackageException, NoSuchTargetException, MissingDepException,
          InterruptedException {
    return getPackage(eventHandler, label.getPackageIdentifier()).getTarget(label.getName());
  }",method,
"public class YourkitFilter implements Filter{
  private static final Logger LOG = Logger.getInstance(""#com.intellij.execution.filters.YourkitFilter"");
  private final Project myProject;
  private static final Pattern PATTERN = Pattern.compile(""\\s*(\\w*)\\(\\):(-?\\d*), (\\w*\\.java)\\n"");
  public YourkitFilter(@NotNull final Project project) {
    myProject = project;
  }
  public Result applyFilter(final String line, final int entireLength) {
    if (!line.endsWith("".java\n"")) {
      return null;
    }
    try {
      final Matcher matcher = PATTERN.matcher(line);
      if (matcher.matches()) {
        final String method = matcher.group(1);
        final int lineNumber = Integer.parseInt(matcher.group(2));
        final String fileName = matcher.group(3);
        final int textStartOffset = entireLength - line.length();
        final PsiShortNamesCache cache = PsiShortNamesCache.getInstance(myProject);
        final PsiFile[] psiFiles = cache.getFilesByName(fileName);
        if (psiFiles.length == 0) return null;
        final HyperlinkInfo info = psiFiles.length == 1 ?
                                   new OpenFileHyperlinkInfo(myProject, psiFiles[0].getVirtualFile(), lineNumber - 1) :
                                   new MyHyperlinkInfo(psiFiles);
        return new Result(textStartOffset + matcher.start(2), textStartOffset + matcher.end(3), info);
      }
    }
    catch (NumberFormatException e) {
      LOG.debug(e);
    }
    return null;
  }
  private static class MyHyperlinkInfo implements HyperlinkInfo {
    private final PsiFile[] myPsiFiles;
    public MyHyperlinkInfo(final PsiFile[] psiFiles) {
      myPsiFiles = psiFiles;
    }
    public void navigate(final Project project) {
      DefaultPsiElementListCellRenderer renderer = new DefaultPsiElementListCellRenderer();
      final JList list = new JBList(myPsiFiles);
      list.setCellRenderer(renderer);
      final PopupChooserBuilder builder = new PopupChooserBuilder(list);
      renderer.installSpeedSearch(builder);
      final Runnable runnable = () -> {
        int[] ids = list.getSelectedIndices();
        if (ids == null || ids.length == 0) return;
        Object[] selectedElements = list.getSelectedValues();
        for (Object element : selectedElements) {
          Navigatable descriptor = EditSourceUtil.getDescriptor((PsiElement)element);
          if (descriptor != null && descriptor.canNavigate()) {
            descriptor.navigate(true);
          }
        }
      };
      final Editor editor = CommonDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());
      builder.
        setTitle(""Choose file"").
        setItemChoosenCallback(runnable).
        createPopup().showInBestPositionFor(editor);
    }
  }
  private static class DefaultPsiElementListCellRenderer extends PsiElementListCellRenderer {
    public String getElementText(final PsiElement element) {
      return element.getContainingFile().getName();
    }
    @Nullable
    protected String getContainerText(final PsiElement element, final String name) {
      final PsiDirectory parent = ((PsiFile)element).getParent();
      if (parent == null) return null;
      final PsiPackage psiPackage = JavaDirectoryService.getInstance().getPackage(parent);
      if (psiPackage == null) return null;
      return ""("" + psiPackage.getQualifiedName() + "")"";
    }
    protected int getIconFlags() {
      return 0;
    }
  }
}",class,
"  private static class MyHyperlinkInfo implements HyperlinkInfo {
    private final PsiFile[] myPsiFiles;
    public MyHyperlinkInfo(final PsiFile[] psiFiles) {
      myPsiFiles = psiFiles;
    }
    public void navigate(final Project project) {
      DefaultPsiElementListCellRenderer renderer = new DefaultPsiElementListCellRenderer();
      final JList list = new JBList(myPsiFiles);
      list.setCellRenderer(renderer);
      final PopupChooserBuilder builder = new PopupChooserBuilder(list);
      renderer.installSpeedSearch(builder);
      final Runnable runnable = () -> {
        int[] ids = list.getSelectedIndices();
        if (ids == null || ids.length == 0) return;
        Object[] selectedElements = list.getSelectedValues();
        for (Object element : selectedElements) {
          Navigatable descriptor = EditSourceUtil.getDescriptor((PsiElement)element);
          if (descriptor != null && descriptor.canNavigate()) {
            descriptor.navigate(true);
          }
        }
      };
      final Editor editor = CommonDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());
      builder.
        setTitle(""Choose file"").
        setItemChoosenCallback(runnable).
        createPopup().showInBestPositionFor(editor);
    }
  }",class,
"  private static class DefaultPsiElementListCellRenderer extends PsiElementListCellRenderer {
    public String getElementText(final PsiElement element) {
      return element.getContainingFile().getName();
    }
    @Nullable
    protected String getContainerText(final PsiElement element, final String name) {
      final PsiDirectory parent = ((PsiFile)element).getParent();
      if (parent == null) return null;
      final PsiPackage psiPackage = JavaDirectoryService.getInstance().getPackage(parent);
      if (psiPackage == null) return null;
      return ""("" + psiPackage.getQualifiedName() + "")"";
    }
    protected int getIconFlags() {
      return 0;
    }
  }",class,
"  public YourkitFilter(@NotNull final Project project) {
    myProject = project;
  }",method,
"  public Result applyFilter(final String line, final int entireLength) {
    if (!line.endsWith("".java\n"")) {
      return null;
    }
    try {
      final Matcher matcher = PATTERN.matcher(line);
      if (matcher.matches()) {
        final String method = matcher.group(1);
        final int lineNumber = Integer.parseInt(matcher.group(2));
        final String fileName = matcher.group(3);
        final int textStartOffset = entireLength - line.length();
        final PsiShortNamesCache cache = PsiShortNamesCache.getInstance(myProject);
        final PsiFile[] psiFiles = cache.getFilesByName(fileName);
        if (psiFiles.length == 0) return null;
        final HyperlinkInfo info = psiFiles.length == 1 ?
                                   new OpenFileHyperlinkInfo(myProject, psiFiles[0].getVirtualFile(), lineNumber - 1) :
                                   new MyHyperlinkInfo(psiFiles);
        return new Result(textStartOffset + matcher.start(2), textStartOffset + matcher.end(3), info);
      }
    }
    catch (NumberFormatException e) {
      LOG.debug(e);
    }
    return null;
  }",method,
"    catch (NumberFormatException e) {
      LOG.debug(e);
    }",method,
"    public MyHyperlinkInfo(final PsiFile[] psiFiles) {
      myPsiFiles = psiFiles;
    }",method,
"    public void navigate(final Project project) {
      DefaultPsiElementListCellRenderer renderer = new DefaultPsiElementListCellRenderer();
      final JList list = new JBList(myPsiFiles);
      list.setCellRenderer(renderer);
      final PopupChooserBuilder builder = new PopupChooserBuilder(list);
      renderer.installSpeedSearch(builder);
      final Runnable runnable = () -> {
        int[] ids = list.getSelectedIndices();
        if (ids == null || ids.length == 0) return;
        Object[] selectedElements = list.getSelectedValues();
        for (Object element : selectedElements) {
          Navigatable descriptor = EditSourceUtil.getDescriptor((PsiElement)element);
          if (descriptor != null && descriptor.canNavigate()) {
            descriptor.navigate(true);
          }
        }
      };
      final Editor editor = CommonDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());
      builder.
        setTitle(""Choose file"").
        setItemChoosenCallback(runnable).
        createPopup().showInBestPositionFor(editor);
    }",method,
"        for (Object element : selectedElements) {
          Navigatable descriptor = EditSourceUtil.getDescriptor((PsiElement)element);
          if (descriptor != null && descriptor.canNavigate()) {
            descriptor.navigate(true);
          }
        }",method,
"    public String getElementText(final PsiElement element) {
      return element.getContainingFile().getName();
    }",method,
"    @Nullable
    protected String getContainerText(final PsiElement element, final String name) {
      final PsiDirectory parent = ((PsiFile)element).getParent();
      if (parent == null) return null;
      final PsiPackage psiPackage = JavaDirectoryService.getInstance().getPackage(parent);
      if (psiPackage == null) return null;
      return ""("" + psiPackage.getQualifiedName() + "")"";
    }",method,
"    protected int getIconFlags() {
      return 0;
    }",method,
"public class PrimitiveManager {
    private final Map<String, String> lazyPrimitiveClasses = new ConcurrentHashMap<>();
    private final Map<String, PrimitiveNodeConstructor> primitives = new ConcurrentHashMap<>();
    private final PrimitiveNodeConstructor undefinedPrimitive;
    public PrimitiveManager() {
        final NodeFactory<? extends RubyNode> nodeFactory = UndefinedPrimitiveNodeFactory.getInstance();
        final Primitive annotation = nodeFactory.getNodeClass().getAnnotation(Primitive.class);
        undefinedPrimitive = new PrimitiveNodeConstructor(annotation, nodeFactory);
    }
    public PrimitiveNodeConstructor getPrimitive(String name) {
        final PrimitiveNodeConstructor constructor = primitives.get(name);
        if (constructor != null) {
            return constructor;
        }
        if (!TruffleOptions.AOT) {
            final String lazyPrimitive = lazyPrimitiveClasses.get(name);
            if (lazyPrimitive != null) {
                return loadLazyPrimitive(lazyPrimitive);
            }
        }
        return undefinedPrimitive;
    }
    public void addLazyPrimitive(String primitive, String nodeFactoryClass) {
        lazyPrimitiveClasses.put(primitive, nodeFactoryClass);
    }
    private PrimitiveNodeConstructor loadLazyPrimitive(String lazyPrimitive) {
        final NodeFactory<? extends RubyNode> nodeFactory = CoreMethodNodeManager.loadNodeFactory(lazyPrimitive);
        final Primitive annotation = nodeFactory.getNodeClass().getAnnotation(Primitive.class);
        return addPrimitive(nodeFactory, annotation);
    }
    public PrimitiveNodeConstructor addPrimitive(NodeFactory<? extends RubyNode> nodeFactory, Primitive annotation) {
        return ConcurrentOperations.getOrCompute(primitives, annotation.name(),
                k -> new PrimitiveNodeConstructor(annotation, nodeFactory));
    }
}",class,
"    public PrimitiveManager() {
        final NodeFactory<? extends RubyNode> nodeFactory = UndefinedPrimitiveNodeFactory.getInstance();
        final Primitive annotation = nodeFactory.getNodeClass().getAnnotation(Primitive.class);
        undefinedPrimitive = new PrimitiveNodeConstructor(annotation, nodeFactory);
    }",method,

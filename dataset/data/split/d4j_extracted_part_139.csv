code_snippet,type,score
"    private ParsedModuleStringNotation splitModuleFromExtension(String notation) {
        int idx = notation.lastIndexOf('@');
        if (idx == -1 || ClientModule.class.isAssignableFrom(wantedType)) {
            return new ParsedModuleStringNotation(notation, null);
        }
        int versionIndx = notation.lastIndexOf(':');
        if (versionIndx<idx) {
            return new ParsedModuleStringNotation(notation.substring(0, idx), notation.substring(idx + 1));
        }
        return new ParsedModuleStringNotation(notation, null);
    }",method,
"        if (versionIndx<idx) {
            return new ParsedModuleStringNotation(notation.substring(0, idx), notation.substring(idx + 1));
        }",method,
"public final class SerializedLambda implements Serializable {
    public SerializedLambda(Class<?> capturingClass,
                            String functionalInterfaceClass,
                            String functionalInterfaceMethodName,
                            String functionalInterfaceMethodSignature,
                            int implMethodKind,
                            String implClass,
                            String implMethodName,
                            String implMethodSignature,
                            String instantiatedMethodType,
                            Object[] capturedArgs) { }
    public String getCapturingClass() { return null; }
    public String getFunctionalInterfaceClass() {
        return null;
    }
    public String getFunctionalInterfaceMethodName() {
        return null;
    }
    public String getFunctionalInterfaceMethodSignature() { return null; }
    public String getImplClass() {
        return null;
    }
    public String getImplMethodName() {
        return null;
    }
    public String getImplMethodSignature() {
        return null;
    }
    public int getImplMethodKind() {
        return 0;
    }
    public final String getInstantiatedMethodType() {
        return null;
    }
    public int getCapturedArgCount() {
        return 0;
    }
    public Object getCapturedArg(int i) {
        return null;
    }
}",class,
"    public SerializedLambda(Class<?> capturingClass,
                            String functionalInterfaceClass,
                            String functionalInterfaceMethodName,
                            String functionalInterfaceMethodSignature,
                            int implMethodKind,
                            String implClass,
                            String implMethodName,
                            String implMethodSignature,
                            String instantiatedMethodType,
                            Object[] capturedArgs) { }",method,
    public String getCapturingClass() { return null; },method,
"    public String getFunctionalInterfaceClass() {
        return null;
    }",method,
"    public String getFunctionalInterfaceMethodName() {
        return null;
    }",method,
    public String getFunctionalInterfaceMethodSignature() { return null; },method,
"    public String getImplClass() {
        return null;
    }",method,
"    public String getImplMethodName() {
        return null;
    }",method,
"    public String getImplMethodSignature() {
        return null;
    }",method,
"    public int getImplMethodKind() {
        return 0;
    }",method,
"    public final String getInstantiatedMethodType() {
        return null;
    }",method,
"    public int getCapturedArgCount() {
        return 0;
    }",method,
"    public Object getCapturedArg(int i) {
        return null;
    }",method,
"public class ScalaMethod {
    private final String description;
    private final Method method;
    private final Object instance;
    public ScalaMethod(ScalaObject scalaObject, String methodName, Class<?>... typeParameters) {
        description = scalaObject.getClassName() + ""."" + methodName + ""()"";
        instance = scalaObject.getInstance();
        method = getMethod(scalaObject.getType(), methodName, typeParameters);
    }
    public ScalaMethod(ClassLoader classLoader, String className, String methodName, Class<?>... typeParameters) {
        this(new ScalaObject(classLoader, className), methodName, typeParameters);
    }
    private Method getMethod(Class<?> type, String methodName, Class<?>[] typeParameters) {
        try {
            return type.getMethod(methodName, typeParameters);
        } catch (NoSuchMethodException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
    public Object invoke(Object... args) {
        try {
            return method.invoke(instance, args);
        } catch (InvocationTargetException e) {
            throw UncheckedException.throwAsUncheckedException(e.getCause());
        } catch (Exception e) {
            throw new GradleException(String.format(""Could not invoke Scala method %s."", description), e);
        }
    }
}",class,
"    public ScalaMethod(ScalaObject scalaObject, String methodName, Class<?>... typeParameters) {
        description = scalaObject.getClassName() + ""."" + methodName + ""()"";
        instance = scalaObject.getInstance();
        method = getMethod(scalaObject.getType(), methodName, typeParameters);
    }",method,
"    public ScalaMethod(ClassLoader classLoader, String className, String methodName, Class<?>... typeParameters) {
        this(new ScalaObject(classLoader, className), methodName, typeParameters);
    }",method,
"    private Method getMethod(Class<?> type, String methodName, Class<?>[] typeParameters) {
        try {
            return type.getMethod(methodName, typeParameters);
        } catch (NoSuchMethodException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }",method,
"    public Object invoke(Object... args) {
        try {
            return method.invoke(instance, args);
        } catch (InvocationTargetException e) {
            throw UncheckedException.throwAsUncheckedException(e.getCause());
        } catch (Exception e) {
            throw new GradleException(String.format(""Could not invoke Scala method %s."", description), e);
        }
    }",method,
"public class Scene {
  private final int width;
  private final int height;
  private final int depth;
  private final HeatData heatData;
  private final FluidField fluidField;
  private float[] buffer;
  private boolean[] wallBlocks;
  private final Vector<Integer> origin;
  public Scene(int size) {
    this(size, new Vector<>(0, 0, 0));
  }
  public Scene(int size, Vector<Integer> origin) {
    this(size, size, size, origin);
  }
  public Scene(int width, int height, int depth, Vector<Integer> origin) {
    this.buffer = new float[width * height * depth];
    this.wallBlocks = new boolean[width * height * depth];
    this.heatData = new HeatData(width, height, depth);
    this.fluidField = new FluidField();
    this.origin = origin;
    this.width = width;
    this.height = height;
    this.depth = depth;
  }
  public float[] buffer() {
    return this.buffer;
  }
  public HeatData heatData() {
    return this.heatData;
  }
  public FluidField fluidField() {
    return this.fluidField;
  }
  public int width() {
    return this.width;
  }
  public int volume() {
    return this.width * this.height * this.depth;
  }
  public class FluidField {
    public float[] velocitiesX = new float[0];
    public float[] velocitiesY = new float[0];
    public float[] velocitiesZ = new float[0];
    public float[] positionsX = new float[0];
    public float[] positionsY = new float[0];
    public float[] positionsZ = new float[0];
  }
  public class HeatData {
    float[] heatPoints;
    float[] heatCoeffs;
    public HeatData(int width, int height, int depth) {
      this.heatPoints = new float[width * height * depth];
      this.heatCoeffs = new float[width * height * depth];
    }
    public float[] heatPoints() {
      return this.heatPoints;
    }
    public float heat(int x, int y, int z) {
      return this.heatPoints[width * height * x + height * y + z];
    }
    public void setHeat(int x, int y, int z, float heat) {
      this.heatPoints[width * height * x + height * y + z] = heat;
    }
    public float[] heatCoeffs() {
      return this.heatCoeffs;
    }
  }
}",class,
"  public class FluidField {
    public float[] velocitiesX = new float[0];
    public float[] velocitiesY = new float[0];
    public float[] velocitiesZ = new float[0];
    public float[] positionsX = new float[0];
    public float[] positionsY = new float[0];
    public float[] positionsZ = new float[0];
  }",class,
"  public class HeatData {
    float[] heatPoints;
    float[] heatCoeffs;
    public HeatData(int width, int height, int depth) {
      this.heatPoints = new float[width * height * depth];
      this.heatCoeffs = new float[width * height * depth];
    }
    public float[] heatPoints() {
      return this.heatPoints;
    }
    public float heat(int x, int y, int z) {
      return this.heatPoints[width * height * x + height * y + z];
    }
    public void setHeat(int x, int y, int z, float heat) {
      this.heatPoints[width * height * x + height * y + z] = heat;
    }
    public float[] heatCoeffs() {
      return this.heatCoeffs;
    }
  }",class,
"public class Vector<T> {
  public final T x;
  public final T y;
  public final T z;
  public Vector(T x, T y, T z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
}",class,
"public class Voxel {
  private Vector vector;
  private final Material material;
  private final double temperature;
  public Voxel(Material material, int temperature) {
    this(material, temperature, new Vector(0, 0, 0));
  }
  public Voxel(Material material, int temperature, Vector vector) {
    this.vector = vector;
    this.material = material;
    this.temperature = temperature;
  }
  public void setPoint(int x, int y, int z) {
    this.vector = new Vector(x, y, z);
  }
  public Vector point() {
    return this.vector;
  }
  public Material material() {
    return this.material;
  }
  public double temperature() {
    return this.temperature;
  }
}",class,
"  public Scene(int size) {
    this(size, new Vector<>(0, 0, 0));
  }",method,
"  public Scene(int size, Vector<Integer> origin) {
    this(size, size, size, origin);
  }",method,
"  public Scene(int width, int height, int depth, Vector<Integer> origin) {
    this.buffer = new float[width * height * depth];
    this.wallBlocks = new boolean[width * height * depth];
    this.heatData = new HeatData(width, height, depth);
    this.fluidField = new FluidField();
    this.origin = origin;
    this.width = width;
    this.height = height;
    this.depth = depth;
  }",method,
"  public float[] buffer() {
    return this.buffer;
  }",method,
"  public HeatData heatData() {
    return this.heatData;
  }",method,
"  public FluidField fluidField() {
    return this.fluidField;
  }",method,
"  public int width() {
    return this.width;
  }",method,
"  public int volume() {
    return this.width * this.height * this.depth;
  }",method,
"    public HeatData(int width, int height, int depth) {
      this.heatPoints = new float[width * height * depth];
      this.heatCoeffs = new float[width * height * depth];
    }",method,
"    public float[] heatPoints() {
      return this.heatPoints;
    }",method,
"    public float heat(int x, int y, int z) {
      return this.heatPoints[width * height * x + height * y + z];
    }",method,
"    public void setHeat(int x, int y, int z, float heat) {
      this.heatPoints[width * height * x + height * y + z] = heat;
    }",method,
"    public float[] heatCoeffs() {
      return this.heatCoeffs;
    }",method,
"  public Vector(T x, T y, T z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }",method,
"  public Voxel(Material material, int temperature) {
    this(material, temperature, new Vector(0, 0, 0));
  }",method,
"  public Voxel(Material material, int temperature, Vector vector) {
    this.vector = vector;
    this.material = material;
    this.temperature = temperature;
  }",method,
"  public void setPoint(int x, int y, int z) {
    this.vector = new Vector(x, y, z);
  }",method,
"  public Vector point() {
    return this.vector;
  }",method,
"  public Material material() {
    return this.material;
  }",method,
"  public double temperature() {
    return this.temperature;
  }",method,
"public class RestClient 
{
	private String																	endpoint;
	private MultivaluedMap<String, String>					parameters;
	private MediaType															httpContentType;
	private MediaType															httpAcceptType;
	private Client																	client;
	private WebResource													service;
	private Object																	requestBody;
	private ClientResponse													clientResponse;
	private String																	responseBody;
	public RestClient(
			String endpoint,
			MediaType httpContentType,
			MediaType httpAcceptType) 
	{
		this.endpoint = endpoint;
		this.httpContentType = httpContentType;
		this.httpAcceptType = httpAcceptType;
		this.parameters = new StringKeyIgnoreCaseMultivaluedMap<String>();
	}
	public void addRequestBody(Object requestBody)
	{
		this.requestBody = requestBody;
	}
	public void addParameter(String key, String value)
	{
		if (key != null && key != """" && value != null && value != """")
			parameters.add(key, value);
	}
	public void clearParameters()
	{
		parameters.clear();
	}
	public String printResponse()
	{
		StringBuffer tmp = new StringBuffer();
		tmp.append(""HTTP "" + clientResponse.getStatus() + "" "" + clientResponse.getClientResponseStatus().toString() + ""\n"");
		MultivaluedMap<String, String> headers = clientResponse.getHeaders();
		Set<String> keys = headers.keySet();
		for (String key : keys)
			tmp.append(key + "": "" + headers.get(key).get(0) + ""\n"");
		tmp.append(responseBody);
		return tmp.toString();
	}
	public int getHttpResponseCode()
	{
		return clientResponse.getStatus();
	}
	public String getResponseContent()
	{
		return responseBody;
	}
	public ClientResponse getClientResponseObject()
	{
		return clientResponse;
	}
	public void updateEndpoint(String endpoint)
	{
		this.endpoint = endpoint;
	}
	public void updateContentType(MediaType contentType)
	{
		httpContentType = contentType;
	}
	//Implements the POST method
	public String	invoke(HttpMethod method, boolean includeParameters)
	{	
		if (includeParameters && parameters.isEmpty())
		{
			try 
			{
				throw new Exception();
			} catch (Exception e) 
			{
				return ""Exception: Parameters map is empty, please execute addParameter() method before calling post()"";
			}
		}
		//Create a service object
		ClientConfig configuration = new DefaultClientConfig();
		configuration.getProperties().put(ClientConfig.PROPERTY_FOLLOW_REDIRECTS, true);
		//configuration.getProperties().put(ClientConfig.PROPERTY_CHUNKED_ENCODING_SIZE,0);
		client = Client.create(configuration);
		client.setFollowRedirects(true);
		service = client.resource(endpoint);
		switch (method)
		{
		case POST:
			if (!httpContentType.getType().equalsIgnoreCase(""multipart"")) {
				clientResponse = service.queryParams(parameters).type(httpContentType).accept(httpAcceptType).post(ClientResponse.class, requestBody);
			 }
			else
			{
				if (!httpContentType.getSubtype().equalsIgnoreCase(""form-data"")) {
					clientResponse = service.queryParams(parameters).header(""Content-Type"", ""multipart/mixed; type=\""application/json\""; start=\""<startpart>\""; boundary=\""foo\"""").accept(httpAcceptType).post(ClientResponse.class, requestBody);
				}
				else {
					clientResponse = service.queryParams(parameters).header(""Content-Type"", ""multipart/form-encoded; type=\""application/x-www-form-urlencoded\""; start=\""<startpart>\""; boundary=\""foo\"""").accept(httpAcceptType).post(ClientResponse.class, requestBody);
				}
			}
			break;
		case GET:
			clientResponse = service.queryParams(parameters).accept(httpAcceptType).get(ClientResponse.class);
			break;
		case PUT:
			break;
		case DELETE:
			break;
		case OPTIONS:
			break;
		}
		//System.out.println(""request is:   "" + client.getHeadHandler().toString());
		responseBody = clientResponse.getEntity(String.class);
		return responseBody;
	}
}",class,
"	public RestClient(
			String endpoint,
			MediaType httpContentType,
			MediaType httpAcceptType) 
	{
		this.endpoint = endpoint;
		this.httpContentType = httpContentType;
		this.httpAcceptType = httpAcceptType;
		this.parameters = new StringKeyIgnoreCaseMultivaluedMap<String>();
	}",method,
"	public void addRequestBody(Object requestBody)
	{
		this.requestBody = requestBody;
	}",method,
"	public void addParameter(String key, String value)
	{
		if (key != null && key != """" && value != null && value != """")
			parameters.add(key, value);
	}",method,
"	public void clearParameters()
	{
		parameters.clear();
	}",method,
"	public String printResponse()
	{
		StringBuffer tmp = new StringBuffer();
		tmp.append(""HTTP "" + clientResponse.getStatus() + "" "" + clientResponse.getClientResponseStatus().toString() + ""\n"");
		MultivaluedMap<String, String> headers = clientResponse.getHeaders();
		Set<String> keys = headers.keySet();
		for (String key : keys)
			tmp.append(key + "": "" + headers.get(key).get(0) + ""\n"");
		tmp.append(responseBody);
		return tmp.toString();
	}",method,
"	public int getHttpResponseCode()
	{
		return clientResponse.getStatus();
	}",method,
"	public String getResponseContent()
	{
		return responseBody;
	}",method,
"	public ClientResponse getClientResponseObject()
	{
		return clientResponse;
	}",method,
"	public void updateEndpoint(String endpoint)
	{
		this.endpoint = endpoint;
	}",method,
"	public void updateContentType(MediaType contentType)
	{
		httpContentType = contentType;
	}",method,
"	public String	invoke(HttpMethod method, boolean includeParameters)
	{	
		if (includeParameters && parameters.isEmpty())
		{
			try 
			{
				throw new Exception();
			} catch (Exception e) 
			{
				return ""Exception: Parameters map is empty, please execute addParameter() method before calling post()"";
			}
		}
		//Create a service object
		ClientConfig configuration = new DefaultClientConfig();
		configuration.getProperties().put(ClientConfig.PROPERTY_FOLLOW_REDIRECTS, true);
		//configuration.getProperties().put(ClientConfig.PROPERTY_CHUNKED_ENCODING_SIZE,0);
		client = Client.create(configuration);
		client.setFollowRedirects(true);
		service = client.resource(endpoint);
		switch (method)
		{
		case POST:
			if (!httpContentType.getType().equalsIgnoreCase(""multipart"")) {
				clientResponse = service.queryParams(parameters).type(httpContentType).accept(httpAcceptType).post(ClientResponse.class, requestBody);
			 }
			else
			{
				if (!httpContentType.getSubtype().equalsIgnoreCase(""form-data"")) {
					clientResponse = service.queryParams(parameters).header(""Content-Type"", ""multipart/mixed; type=\""application/json\""; start=\""<startpart>\""; boundary=\""foo\"""").accept(httpAcceptType).post(ClientResponse.class, requestBody);
				}
				else {
					clientResponse = service.queryParams(parameters).header(""Content-Type"", ""multipart/form-encoded; type=\""application/x-www-form-urlencoded\""; start=\""<startpart>\""; boundary=\""foo\"""").accept(httpAcceptType).post(ClientResponse.class, requestBody);
				}
			}
			break;
		case GET:
			clientResponse = service.queryParams(parameters).accept(httpAcceptType).get(ClientResponse.class);
			break;
		case PUT:
			break;
		case DELETE:
			break;
		case OPTIONS:
			break;
		}
		//System.out.println(""request is:   "" + client.getHeadHandler().toString());
		responseBody = clientResponse.getEntity(String.class);
		return responseBody;
	}",method,
"		switch (method)
		{
		case POST:
			if (!httpContentType.getType().equalsIgnoreCase(""multipart"")) {
				clientResponse = service.queryParams(parameters).type(httpContentType).accept(httpAcceptType).post(ClientResponse.class, requestBody);
			 }
			else
			{
				if (!httpContentType.getSubtype().equalsIgnoreCase(""form-data"")) {
					clientResponse = service.queryParams(parameters).header(""Content-Type"", ""multipart/mixed; type=\""application/json\""; start=\""<startpart>\""; boundary=\""foo\"""").accept(httpAcceptType).post(ClientResponse.class, requestBody);
				}
				else {
					clientResponse = service.queryParams(parameters).header(""Content-Type"", ""multipart/form-encoded; type=\""application/x-www-form-urlencoded\""; start=\""<startpart>\""; boundary=\""foo\"""").accept(httpAcceptType).post(ClientResponse.class, requestBody);
				}
			}
			break;
		case GET:
			clientResponse = service.queryParams(parameters).accept(httpAcceptType).get(ClientResponse.class);
			break;
		case PUT:
			break;
		case DELETE:
			break;
		case OPTIONS:
			break;
		}",method,
"public class GetFieldMappingsRequest extends ActionRequest implements IndicesRequest.Replaceable {
    protected boolean local = false;
    private String[] fields = Strings.EMPTY_ARRAY;
    private boolean includeDefaults = false;
    private String[] indices = Strings.EMPTY_ARRAY;
    private String[] types = Strings.EMPTY_ARRAY;
    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();
    public GetFieldMappingsRequest() {
    }
    public GetFieldMappingsRequest local(boolean local) {
        this.local = local;
        return this;
    }
    public boolean local() {
        return local;
    }
    @Override
    public GetFieldMappingsRequest indices(String... indices) {
        this.indices = indices;
        return this;
    }
    public GetFieldMappingsRequest types(String... types) {
        this.types = types;
        return this;
    }
    public GetFieldMappingsRequest indicesOptions(IndicesOptions indicesOptions) {
        this.indicesOptions = indicesOptions;
        return this;
    }
    @Override
    public String[] indices() {
        return indices;
    }
    public String[] types() {
        return types;
    }
    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
    }
    public GetFieldMappingsRequest fields(String... fields) {
        this.fields = fields;
        return this;
    }
    public String[] fields() {
        return fields;
    }
    public boolean includeDefaults() {
        return includeDefaults;
    }
    public GetFieldMappingsRequest includeDefaults(boolean includeDefaults) {
        this.includeDefaults = includeDefaults;
        return this;
    }
    @Override
    public ActionRequestValidationException validate() {
        return null;
    }
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeStringArray(indices);
        out.writeStringArray(types);
        indicesOptions.writeIndicesOptions(out);
        out.writeBoolean(local);
        out.writeStringArray(fields);
        out.writeBoolean(includeDefaults);
    }
    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        indices = in.readStringArray();
        types = in.readStringArray();
        indicesOptions = IndicesOptions.readIndicesOptions(in);
        local = in.readBoolean();
        fields = in.readStringArray();
        includeDefaults = in.readBoolean();
    }
}",class,
"    public GetFieldMappingsRequest() {
    }",method,
"    public GetFieldMappingsRequest local(boolean local) {
        this.local = local;
        return this;
    }",method,
"    public boolean local() {
        return local;
    }",method,
"    @Override
    public GetFieldMappingsRequest indices(String... indices) {
        this.indices = indices;
        return this;
    }",method,
"    public GetFieldMappingsRequest types(String... types) {
        this.types = types;
        return this;
    }",method,
"    public GetFieldMappingsRequest indicesOptions(IndicesOptions indicesOptions) {
        this.indicesOptions = indicesOptions;
        return this;
    }",method,
"    @Override
    public String[] indices() {
        return indices;
    }",method,
"    public String[] types() {
        return types;
    }",method,
"    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
    }",method,
"    public GetFieldMappingsRequest fields(String... fields) {
        this.fields = fields;
        return this;
    }",method,
"    public String[] fields() {
        return fields;
    }",method,
"    public boolean includeDefaults() {
        return includeDefaults;
    }",method,
"    public GetFieldMappingsRequest includeDefaults(boolean includeDefaults) {
        this.includeDefaults = includeDefaults;
        return this;
    }",method,
"    @Override
    public ActionRequestValidationException validate() {
        return null;
    }",method,
"    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeStringArray(indices);
        out.writeStringArray(types);
        indicesOptions.writeIndicesOptions(out);
        out.writeBoolean(local);
        out.writeStringArray(fields);
        out.writeBoolean(includeDefaults);
    }",method,
"    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        indices = in.readStringArray();
        types = in.readStringArray();
        indicesOptions = IndicesOptions.readIndicesOptions(in);
        local = in.readBoolean();
        fields = in.readStringArray();
        includeDefaults = in.readBoolean();
    }",method,
"public class LibraryDownloadSettings {
  private final FrameworkLibraryVersion myVersion;
  private final DownloadableLibraryType myLibraryType;
  private String myLibrariesPath;
  private final String myLibraryName;
  private final boolean myDownloadSources;
  private final boolean myDownloadJavaDocs;
  private final LibrariesContainer.LibraryLevel myLibraryLevel;
  private final List<? extends DownloadableLibraryFileDescription> mySelectedDownloads;
  public LibraryDownloadSettings(@NotNull FrameworkLibraryVersion libraryVersion,
                                 @Nullable DownloadableLibraryType libraryType,
                                 final LibrariesContainer.LibraryLevel libraryLevel, final String downloadedLibrariesPath) {
    this(libraryVersion, libraryType, downloadedLibrariesPath, libraryVersion.getDefaultLibraryName(), libraryLevel,
         getRequiredFiles(libraryVersion.getFiles()), true, true);
  }
  public LibraryDownloadSettings(@NotNull FrameworkLibraryVersion libraryVersion, @Nullable DownloadableLibraryType libraryType,
                                 @NotNull String librariesPath, @NotNull String libraryName,
                                 @NotNull LibrariesContainer.LibraryLevel libraryLevel,
                                 @NotNull List<? extends DownloadableLibraryFileDescription> selectedDownloads,
                                 boolean downloadSources, boolean downloadJavaDocs) {
    myVersion = libraryVersion;
    myLibraryType = libraryType;
    myLibrariesPath = librariesPath;
    myLibraryName = libraryName;
    myDownloadSources = downloadSources;
    myDownloadJavaDocs = downloadJavaDocs;
    myLibraryLevel = libraryLevel;
    mySelectedDownloads = selectedDownloads;
  }
  private static List<? extends DownloadableLibraryFileDescription> getRequiredFiles(List<? extends DownloadableLibraryFileDescription> files) {
    return ContainerUtil.filter(files, (Condition<DownloadableLibraryFileDescription>)description -> !description.isOptional());
  }
  @NotNull
  public FrameworkLibraryVersion getVersion() {
    return myVersion;
  }
  public boolean isDownloadJavaDocs() {
    return myDownloadJavaDocs;
  }
  public boolean isDownloadSources() {
    return myDownloadSources;
  }
  public String getLibraryName() {
    return myLibraryName;
  }
  public String getDirectoryForDownloadedLibrariesPath() {
    return myLibrariesPath;
  }
  public List<? extends DownloadableLibraryFileDescription> getSelectedDownloads() {
    return mySelectedDownloads;
  }
  @NotNull
  public LibrariesContainer.LibraryLevel getLibraryLevel() {
    return myLibraryLevel;
  }
  public DownloadableLibraryType getLibraryType() {
    return myLibraryType;
  }
  @Nullable
  public NewLibraryEditor download(JComponent parent, @Nullable String rootPath) {
    final List<DownloadableFileDescription> toDownload = new ArrayList<>(mySelectedDownloads);
    Map<DownloadableFileDescription, OrderRootType> rootTypes = new HashMap<>();
    for (DownloadableLibraryFileDescription description : mySelectedDownloads) {
      final DownloadableFileDescription sources = description.getSourcesDescription();
      if (myDownloadSources && sources != null) {
        toDownload.add(sources);
        rootTypes.put(sources, OrderRootType.SOURCES);
      }
      final DownloadableFileDescription docs = description.getDocumentationDescription();
      if (myDownloadJavaDocs && docs != null) {
        toDownload.add(docs);
        rootTypes.put(docs, JavadocOrderRootType.getInstance());
      }
    }
    String path = rootPath != null && !FileUtil.isAbsolute(myLibrariesPath) ? new File(rootPath, myLibrariesPath).getPath() : myLibrariesPath;
    List<Pair<VirtualFile,DownloadableFileDescription>> downloaded =
      DownloadableFileService.getInstance()
        .createDownloader(toDownload, myLibraryName + "" Library"")
        .downloadWithProgress(path, null, parent);
    if (downloaded == null) {
      return null;
    }
    final NewLibraryEditor libraryEditor;
    if (myLibraryType != null) {
      libraryEditor = new NewLibraryEditor(myLibraryType, new LibraryVersionProperties(myVersion.getVersionString()));
    }
    else {
      libraryEditor = new NewLibraryEditor();
    }
    libraryEditor.setName(myLibraryName);
    for (Pair<VirtualFile, DownloadableFileDescription> pair : downloaded) {
      final OrderRootType rootType = rootTypes.containsKey(pair.getSecond()) ? rootTypes.get(pair.getSecond()) : OrderRootType.CLASSES;
      libraryEditor.addRoot(pair.getFirst(), rootType);
    }
    return libraryEditor;
  }
}",class,
"  public LibraryDownloadSettings(@NotNull FrameworkLibraryVersion libraryVersion,
                                 @Nullable DownloadableLibraryType libraryType,
                                 final LibrariesContainer.LibraryLevel libraryLevel, final String downloadedLibrariesPath) {
    this(libraryVersion, libraryType, downloadedLibrariesPath, libraryVersion.getDefaultLibraryName(), libraryLevel,
         getRequiredFiles(libraryVersion.getFiles()), true, true);
  }",method,
"  public LibraryDownloadSettings(@NotNull FrameworkLibraryVersion libraryVersion, @Nullable DownloadableLibraryType libraryType,
                                 @NotNull String librariesPath, @NotNull String libraryName,
                                 @NotNull LibrariesContainer.LibraryLevel libraryLevel,
                                 @NotNull List<? extends DownloadableLibraryFileDescription> selectedDownloads,
                                 boolean downloadSources, boolean downloadJavaDocs) {
    myVersion = libraryVersion;
    myLibraryType = libraryType;
    myLibrariesPath = librariesPath;
    myLibraryName = libraryName;
    myDownloadSources = downloadSources;
    myDownloadJavaDocs = downloadJavaDocs;
    myLibraryLevel = libraryLevel;
    mySelectedDownloads = selectedDownloads;
  }",method,
"  private static List<? extends DownloadableLibraryFileDescription> getRequiredFiles(List<? extends DownloadableLibraryFileDescription> files) {
    return ContainerUtil.filter(files, (Condition<DownloadableLibraryFileDescription>)description -> !description.isOptional());
  }",method,
"  @NotNull
  public FrameworkLibraryVersion getVersion() {
    return myVersion;
  }",method,
"  public boolean isDownloadJavaDocs() {
    return myDownloadJavaDocs;
  }",method,
"  public boolean isDownloadSources() {
    return myDownloadSources;
  }",method,
"  public String getLibraryName() {
    return myLibraryName;
  }",method,
"  public String getDirectoryForDownloadedLibrariesPath() {
    return myLibrariesPath;
  }",method,
"  public List<? extends DownloadableLibraryFileDescription> getSelectedDownloads() {
    return mySelectedDownloads;
  }",method,
"  @NotNull
  public LibrariesContainer.LibraryLevel getLibraryLevel() {
    return myLibraryLevel;
  }",method,
"  public DownloadableLibraryType getLibraryType() {
    return myLibraryType;
  }",method,
"  @Nullable
  public NewLibraryEditor download(JComponent parent, @Nullable String rootPath) {
    final List<DownloadableFileDescription> toDownload = new ArrayList<>(mySelectedDownloads);
    Map<DownloadableFileDescription, OrderRootType> rootTypes = new HashMap<>();
    for (DownloadableLibraryFileDescription description : mySelectedDownloads) {
      final DownloadableFileDescription sources = description.getSourcesDescription();
      if (myDownloadSources && sources != null) {
        toDownload.add(sources);
        rootTypes.put(sources, OrderRootType.SOURCES);
      }
      final DownloadableFileDescription docs = description.getDocumentationDescription();
      if (myDownloadJavaDocs && docs != null) {
        toDownload.add(docs);
        rootTypes.put(docs, JavadocOrderRootType.getInstance());
      }
    }
    String path = rootPath != null && !FileUtil.isAbsolute(myLibrariesPath) ? new File(rootPath, myLibrariesPath).getPath() : myLibrariesPath;
    List<Pair<VirtualFile,DownloadableFileDescription>> downloaded =
      DownloadableFileService.getInstance()
        .createDownloader(toDownload, myLibraryName + "" Library"")
        .downloadWithProgress(path, null, parent);
    if (downloaded == null) {
      return null;
    }
    final NewLibraryEditor libraryEditor;
    if (myLibraryType != null) {
      libraryEditor = new NewLibraryEditor(myLibraryType, new LibraryVersionProperties(myVersion.getVersionString()));
    }
    else {
      libraryEditor = new NewLibraryEditor();
    }
    libraryEditor.setName(myLibraryName);
    for (Pair<VirtualFile, DownloadableFileDescription> pair : downloaded) {
      final OrderRootType rootType = rootTypes.containsKey(pair.getSecond()) ? rootTypes.get(pair.getSecond()) : OrderRootType.CLASSES;
      libraryEditor.addRoot(pair.getFirst(), rootType);
    }
    return libraryEditor;
  }",method,
"    for (DownloadableLibraryFileDescription description : mySelectedDownloads) {
      final DownloadableFileDescription sources = description.getSourcesDescription();
      if (myDownloadSources && sources != null) {
        toDownload.add(sources);
        rootTypes.put(sources, OrderRootType.SOURCES);
      }
      final DownloadableFileDescription docs = description.getDocumentationDescription();
      if (myDownloadJavaDocs && docs != null) {
        toDownload.add(docs);
        rootTypes.put(docs, JavadocOrderRootType.getInstance());
      }
    }",method,
"      if (myDownloadSources && sources != null) {
        toDownload.add(sources);
        rootTypes.put(sources, OrderRootType.SOURCES);
      }",method,
"      if (myDownloadJavaDocs && docs != null) {
        toDownload.add(docs);
        rootTypes.put(docs, JavadocOrderRootType.getInstance());
      }",method,
"    if (downloaded == null) {
      return null;
    }",method,
"    if (myLibraryType != null) {
      libraryEditor = new NewLibraryEditor(myLibraryType, new LibraryVersionProperties(myVersion.getVersionString()));
    }",method,
"    for (Pair<VirtualFile, DownloadableFileDescription> pair : downloaded) {
      final OrderRootType rootType = rootTypes.containsKey(pair.getSecond()) ? rootTypes.get(pair.getSecond()) : OrderRootType.CLASSES;
      libraryEditor.addRoot(pair.getFirst(), rootType);
    }",method,
"    public String getScopeName(VcsContext dataContext, final ActionInfo actionInfo) {
      return VcsBundle.message(""update.project.scope.name"");
    }",method,
"    public boolean filterExistsInVcs() {
      return true;
    }",method,
"    public FilePath[] getRoots(VcsContext context, final ActionInfo actionInfo) {
      ArrayList<FilePath> result = new ArrayList<>();
      Project project = context.getProject();
      final ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(project);
      final AbstractVcs[] vcses = vcsManager.getAllActiveVcss();
      for(AbstractVcs vcs: vcses) {
        if (actionInfo.getEnvironment(vcs) != null) {
          final VirtualFile[] files = vcsManager.getRootsUnderVcs(vcs);
          for(VirtualFile file: files) {
            result.add(VcsUtil.getFilePath(file));
          }
        }
      }
      return result.toArray(new FilePath[result.size()]);
    }",method,
"      for(AbstractVcs vcs: vcses) {
        if (actionInfo.getEnvironment(vcs) != null) {
          final VirtualFile[] files = vcsManager.getRootsUnderVcs(vcs);
          for(VirtualFile file: files) {
            result.add(VcsUtil.getFilePath(file));
          }
        }
      }",method,
"          for(VirtualFile file: files) {
            result.add(VcsUtil.getFilePath(file));
          }",method,
"    public String getScopeName(VcsContext dataContext, final ActionInfo actionInfo) {
      FilePath[] roots = getRoots(dataContext, actionInfo);
      if (roots == null || roots.length == 0) {
        return VcsBundle.message(""update.files.scope.name"");
      }
      boolean directory = roots[0].isDirectory();
      if (roots.length == 1) {
        if (directory) {
          return VcsBundle.message(""update.directory.scope.name"");
        }
        else {
          return VcsBundle.message(""update.file.scope.name"");
        }
      }
      else {
        if (directory) {
          return VcsBundle.message(""update.directories.scope.name"");
        }
        else {
          return VcsBundle.message(""update.files.scope.name"");
        }
      }
    }",method,
"      if (roots == null || roots.length == 0) {
        return VcsBundle.message(""update.files.scope.name"");
      }",method,

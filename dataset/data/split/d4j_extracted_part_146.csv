code_snippet,type,score
"    @Override
    public void startActivity(Intent intent, boolean dismissShade, Callback callback) {
        if (mActualStarter == null) return;
        mActualStarter.startActivity(intent, dismissShade, callback);
    }",method,
"    @Override
    public void postStartActivityDismissingKeyguard(Intent intent, int delay) {
        if (mActualStarter == null) return;
        mActualStarter.postStartActivityDismissingKeyguard(intent, delay);
    }",method,
"    @Override
    public void postStartActivityDismissingKeyguard(PendingIntent intent) {
        if (mActualStarter == null) return;
        mActualStarter.postStartActivityDismissingKeyguard(intent);
    }",method,
"    @Override
    public void postQSRunnableDismissingKeyguard(Runnable runnable) {
        if (mActualStarter == null) return;
        mActualStarter.postQSRunnableDismissingKeyguard(runnable);
    }",method,
"    public void setActivityStarterImpl(ActivityStarter starter) {
        mActualStarter = starter;
    }",method,
"public class KeyboardModifierListener implements Disposable {
  private boolean myShiftPressed;
  private boolean myCtrlPressed;
  private boolean myAltPressed;
  @Nullable private Window myWindow;
  private final WindowFocusListener myWindowFocusListener = new WindowFocusListener() {
    @Override
    public void windowGainedFocus(WindowEvent e) {
      resetState();
    }
    @Override
    public void windowLostFocus(WindowEvent e) {
      resetState();
    }
  };
  public void init(@NotNull JComponent component, @NotNull Disposable disposable) {
    assert myWindow == null;
    Disposer.register(disposable, this);
    // we can use KeyListener on Editors, but Ctrl+Click will not work with focus in other place.
    // ex: commit dialog with focus in commit message
    IdeEventQueue.getInstance().addPostprocessor(e -> {
      if (e instanceof KeyEvent) {
        onKeyEvent((KeyEvent)e);
      }
      return false;
    }, disposable);
    myWindow = UIUtil.getWindow(component);
    if (myWindow != null) {
      myWindow.addWindowFocusListener(myWindowFocusListener);
    }
  }
  @Override
  public void dispose() {
    if (myWindow != null) {
      myWindow.removeWindowFocusListener(myWindowFocusListener);
      myWindow = null;
    }
  }
  private void onKeyEvent(KeyEvent e) {
    final int keyCode = e.getKeyCode();
    if (keyCode == KeyEvent.VK_SHIFT) {
      myShiftPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }
    if (keyCode == KeyEvent.VK_CONTROL) {
      myCtrlPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }
    if (keyCode == KeyEvent.VK_ALT) {
      myAltPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }
  }
  private void resetState() {
    myShiftPressed = false;
    myAltPressed = false;
    myCtrlPressed = false;
    onModifiersChanged();
  }
  public boolean isShiftPressed() {
    return myShiftPressed;
  }
  public boolean isCtrlPressed() {
    return myCtrlPressed;
  }
  public boolean isAltPressed() {
    return myAltPressed;
  }
  public void onModifiersChanged() {
  }
}",class,
"    @Override
    public void windowGainedFocus(WindowEvent e) {
      resetState();
    }",method,
"    @Override
    public void windowLostFocus(WindowEvent e) {
      resetState();
    }",method,
"  public void init(@NotNull JComponent component, @NotNull Disposable disposable) {
    assert myWindow == null;
    Disposer.register(disposable, this);
    // we can use KeyListener on Editors, but Ctrl+Click will not work with focus in other place.
    // ex: commit dialog with focus in commit message
    IdeEventQueue.getInstance().addPostprocessor(e -> {
      if (e instanceof KeyEvent) {
        onKeyEvent((KeyEvent)e);
      }
      return false;
    }, disposable);
    myWindow = UIUtil.getWindow(component);
    if (myWindow != null) {
      myWindow.addWindowFocusListener(myWindowFocusListener);
    }
  }",method,
"      if (e instanceof KeyEvent) {
        onKeyEvent((KeyEvent)e);
      }",method,
"    if (myWindow != null) {
      myWindow.addWindowFocusListener(myWindowFocusListener);
    }",method,
"  @Override
  public void dispose() {
    if (myWindow != null) {
      myWindow.removeWindowFocusListener(myWindowFocusListener);
      myWindow = null;
    }
  }",method,
"    if (myWindow != null) {
      myWindow.removeWindowFocusListener(myWindowFocusListener);
      myWindow = null;
    }",method,
"  private void onKeyEvent(KeyEvent e) {
    final int keyCode = e.getKeyCode();
    if (keyCode == KeyEvent.VK_SHIFT) {
      myShiftPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }
    if (keyCode == KeyEvent.VK_CONTROL) {
      myCtrlPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }
    if (keyCode == KeyEvent.VK_ALT) {
      myAltPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }
  }",method,
"    if (keyCode == KeyEvent.VK_SHIFT) {
      myShiftPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }",method,
"    if (keyCode == KeyEvent.VK_CONTROL) {
      myCtrlPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }",method,
"    if (keyCode == KeyEvent.VK_ALT) {
      myAltPressed = e.getID() == KeyEvent.KEY_PRESSED;
      onModifiersChanged();
    }",method,
"  private void resetState() {
    myShiftPressed = false;
    myAltPressed = false;
    myCtrlPressed = false;
    onModifiersChanged();
  }",method,
"  public boolean isShiftPressed() {
    return myShiftPressed;
  }",method,
"  public boolean isCtrlPressed() {
    return myCtrlPressed;
  }",method,
"  public boolean isAltPressed() {
    return myAltPressed;
  }",method,
"  public void onModifiersChanged() {
  }",method,
"public class MongoColumnHandle
        implements ColumnHandle
{
    public static final String SAMPLE_WEIGHT_COLUMN_NAME = ""presto_sample_weight"";
    private final String name;
    private final Type type;
    private final boolean hidden;
    @JsonCreator
    public MongoColumnHandle(
            @JsonProperty(""name"") String name,
            @JsonProperty(""columnType"") Type type,
            @JsonProperty(""hidden"") boolean hidden)
    {
        this.name = requireNonNull(name, ""name is null"");
        this.type = requireNonNull(type, ""columnType is null"");
        this.hidden = hidden;
    }
    @JsonProperty
    public String getName()
    {
        return name;
    }
    @JsonProperty(""columnType"")
    public Type getType()
    {
        return type;
    }
    @JsonProperty
    public boolean isHidden()
    {
        return hidden;
    }
    public ColumnMetadata toColumnMetadata()
    {
        return new ColumnMetadata(name, type, null, hidden);
    }
    public Document getDocument()
    {
        return new Document().append(""name"", name)
                .append(""type"", type.getTypeSignature().toString())
                .append(""hidden"", hidden);
    }
    @Override
    public int hashCode()
    {
        return Objects.hash(name, type, hidden);
    }
    @Override
    public boolean equals(Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        MongoColumnHandle other = (MongoColumnHandle) obj;
        return Objects.equals(name, other.name) &&
                Objects.equals(type, other.type) &&
                Objects.equals(hidden, other.hidden);
    }
    @Override
    public String toString()
    {
        return toStringHelper(this)
                .add(""name"", name)
                .add(""type"", type)
                .add(""hidden"", hidden)
                .toString();
    }
}",class,
"    @JsonProperty
    public String getName()
    {
        return name;
    }",method,
"    @JsonProperty(""columnType"")
    public Type getType()
    {
        return type;
    }",method,
"    @JsonProperty
    public boolean isHidden()
    {
        return hidden;
    }",method,
"    public ColumnMetadata toColumnMetadata()
    {
        return new ColumnMetadata(name, type, null, hidden);
    }",method,
"    public Document getDocument()
    {
        return new Document().append(""name"", name)
                .append(""type"", type.getTypeSignature().toString())
                .append(""hidden"", hidden);
    }",method,
"    @Override
    public int hashCode()
    {
        return Objects.hash(name, type, hidden);
    }",method,
"    @Override
    public boolean equals(Object obj)
    {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        MongoColumnHandle other = (MongoColumnHandle) obj;
        return Objects.equals(name, other.name) &&
                Objects.equals(type, other.type) &&
                Objects.equals(hidden, other.hidden);
    }",method,
"        if (this == obj) {
            return true;
        }",method,
"    @Override
    public String toString()
    {
        return toStringHelper(this)
                .add(""name"", name)
                .add(""type"", type)
                .add(""hidden"", hidden)
                .toString();
    }",method,
"import net.i2p.util.SimpleTimer;
class ParticipatingThrottler {
    private final RouterContext context;
    private final ObjectCounter<Hash> counter;
    private static final int LIFETIME_PORTION = 3;
    private static final int MIN_LIMIT = 18 / LIFETIME_PORTION;
    private static final int MAX_LIMIT = 66 / LIFETIME_PORTION;
    private static final int PERCENT_LIMIT = 12 / LIFETIME_PORTION;
    private static final long CLEAN_TIME = 11*60*1000 / LIFETIME_PORTION;
    ParticipatingThrottler(RouterContext ctx) {
        this.context = ctx;
        this.counter = new ObjectCounter<Hash>();
        ctx.simpleScheduler().addPeriodicEvent(new Cleaner(), CLEAN_TIME);
    }
    boolean shouldThrottle(Hash h) {
        int numTunnels = this.context.tunnelManager().getParticipatingCount();
        int limit = Math.max(MIN_LIMIT, Math.min(MAX_LIMIT, numTunnels * PERCENT_LIMIT / 100));
        return this.counter.increment(h) > limit;
    }
    private class Cleaner implements SimpleTimer.TimedEvent {
        public void timeReached() {
            ParticipatingThrottler.this.counter.clear();
        }
    }
}",class,
"    private class Cleaner implements SimpleTimer.TimedEvent {
        public void timeReached() {
            ParticipatingThrottler.this.counter.clear();
        }
    }",class,
"    ParticipatingThrottler(RouterContext ctx) {
        this.context = ctx;
        this.counter = new ObjectCounter<Hash>();
        ctx.simpleScheduler().addPeriodicEvent(new Cleaner(), CLEAN_TIME);
    }",method,
"    boolean shouldThrottle(Hash h) {
        int numTunnels = this.context.tunnelManager().getParticipatingCount();
        int limit = Math.max(MIN_LIMIT, Math.min(MAX_LIMIT, numTunnels * PERCENT_LIMIT / 100));
        return this.counter.increment(h) > limit;
    }",method,
"        public void timeReached() {
            ParticipatingThrottler.this.counter.clear();
        }",method,
"public final class DOM3SerializerImpl implements DOM3Serializer {
    // The DOMErrorHandler
    private DOMErrorHandler fErrorHandler;
    // A LSSerializerFilter
    private LSSerializerFilter fSerializerFilter;
    // A LSSerializerFilter
    private String fNewLine;
    // A SerializationHandler ex. an instance of ToXMLStream
    private SerializationHandler fSerializationHandler;
    public DOM3SerializerImpl(SerializationHandler handler) {
        fSerializationHandler = handler;
    }
    // Public memebers
    public DOMErrorHandler getErrorHandler() {
        return fErrorHandler;
    }
    public LSSerializerFilter getNodeFilter() {
        return fSerializerFilter;
    }
    public char[] getNewLine() {
        return (fNewLine != null) ? fNewLine.toCharArray() : null;
    }
    public void serializeDOM3(Node node) throws IOException {
        try {
            DOM3TreeWalker walker = new DOM3TreeWalker(fSerializationHandler,
                    fErrorHandler, fSerializerFilter, fNewLine);
            walker.traverse(node);
        } catch (org.xml.sax.SAXException se) {
            throw new WrappedRuntimeException(se);
        }
    }
    public void setErrorHandler(DOMErrorHandler handler) {
        fErrorHandler = handler;
    }
    public void setNodeFilter(LSSerializerFilter filter) {
        fSerializerFilter = filter;
    }
    public void setSerializationHandler(SerializationHandler handler) {
        fSerializationHandler = handler;
    }
    public void setNewLine(char[] newLine) {
        fNewLine = (newLine != null) ? new String(newLine) : null;
    }
}",class,
"    public DOM3SerializerImpl(SerializationHandler handler) {
        fSerializationHandler = handler;
    }",method,
"    public DOMErrorHandler getErrorHandler() {
        return fErrorHandler;
    }",method,
"    public LSSerializerFilter getNodeFilter() {
        return fSerializerFilter;
    }",method,
"    public char[] getNewLine() {
        return (fNewLine != null) ? fNewLine.toCharArray() : null;
    }",method,
"    public void serializeDOM3(Node node) throws IOException {
        try {
            DOM3TreeWalker walker = new DOM3TreeWalker(fSerializationHandler,
                    fErrorHandler, fSerializerFilter, fNewLine);
            walker.traverse(node);
        } catch (org.xml.sax.SAXException se) {
            throw new WrappedRuntimeException(se);
        }
    }",method,
"    public void setErrorHandler(DOMErrorHandler handler) {
        fErrorHandler = handler;
    }",method,
"    public void setNodeFilter(LSSerializerFilter filter) {
        fSerializerFilter = filter;
    }",method,
"    public void setSerializationHandler(SerializationHandler handler) {
        fSerializationHandler = handler;
    }",method,
"    public void setNewLine(char[] newLine) {
        fNewLine = (newLine != null) ? new String(newLine) : null;
    }",method,
"public final class UiThread extends ServiceThread {
    private static final long SLOW_DISPATCH_THRESHOLD_MS = 100;
    private static UiThread sInstance;
    private static Handler sHandler;
    private UiThread() {
        super(""android.ui"", Process.THREAD_PRIORITY_FOREGROUND, false );
    }
    @Override
    public void run() {
        // Make sure UiThread is in the fg stune boost group
        Process.setThreadGroup(Process.myTid(), Process.THREAD_GROUP_TOP_APP);
        super.run();
    }
    private static void ensureThreadLocked() {
        if (sInstance == null) {
            sInstance = new UiThread();
            sInstance.start();
            final Looper looper = sInstance.getLooper();
            looper.setTraceTag(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            looper.setSlowDispatchThresholdMs(SLOW_DISPATCH_THRESHOLD_MS);
            sHandler = new Handler(sInstance.getLooper());
        }
    }
    public static UiThread get() {
        synchronized (UiThread.class) {
            ensureThreadLocked();
            return sInstance;
        }
    }
    public static Handler getHandler() {
        synchronized (UiThread.class) {
            ensureThreadLocked();
            return sHandler;
        }
    }
}",class,
"    private UiThread() {
        super(""android.ui"", Process.THREAD_PRIORITY_FOREGROUND, false );
    }",method,
"    @Override
    public void run() {
        // Make sure UiThread is in the fg stune boost group
        Process.setThreadGroup(Process.myTid(), Process.THREAD_GROUP_TOP_APP);
        super.run();
    }",method,
"    private static void ensureThreadLocked() {
        if (sInstance == null) {
            sInstance = new UiThread();
            sInstance.start();
            final Looper looper = sInstance.getLooper();
            looper.setTraceTag(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            looper.setSlowDispatchThresholdMs(SLOW_DISPATCH_THRESHOLD_MS);
            sHandler = new Handler(sInstance.getLooper());
        }
    }",method,
"        if (sInstance == null) {
            sInstance = new UiThread();
            sInstance.start();
            final Looper looper = sInstance.getLooper();
            looper.setTraceTag(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            looper.setSlowDispatchThresholdMs(SLOW_DISPATCH_THRESHOLD_MS);
            sHandler = new Handler(sInstance.getLooper());
        }",method,
"    public static UiThread get() {
        synchronized (UiThread.class) {
            ensureThreadLocked();
            return sInstance;
        }
    }",method,
"        synchronized (UiThread.class) {
            ensureThreadLocked();
            return sInstance;
        }",method,
"    public static Handler getHandler() {
        synchronized (UiThread.class) {
            ensureThreadLocked();
            return sHandler;
        }
    }",method,
"        synchronized (UiThread.class) {
            ensureThreadLocked();
            return sHandler;
        }",method,
"public class TestPagesIndex
{
    @Test
    public void testEstimatedSize()
    {
        List<Type> types = ImmutableList.of(BIGINT, VARCHAR);
        PagesIndex pagesIndex = newPagesIndex(types, 30);
        long initialEstimatedSize = pagesIndex.getEstimatedSize().toBytes();
        assertTrue(initialEstimatedSize > 0, format(""Initial estimated size must be positive, got %s"", initialEstimatedSize));
        pagesIndex.addPage(somePage(types));
        long estimatedSizeWithOnePage = pagesIndex.getEstimatedSize().toBytes();
        assertTrue(estimatedSizeWithOnePage > initialEstimatedSize, ""Estimated size should grow after adding a page"");
        pagesIndex.addPage(somePage(types));
        long estimatedSizeWithTwoPages = pagesIndex.getEstimatedSize().toBytes();
        assertEquals(
                estimatedSizeWithTwoPages,
                initialEstimatedSize + (estimatedSizeWithOnePage - initialEstimatedSize) * 2,
                ""Estimated size should grow linearly as long as we don't pass expectedPositions"");
        pagesIndex.compact();
        long estimatedSizeAfterCompact = pagesIndex.getEstimatedSize().toBytes();
        // We can expect compact to reduce size because VARCHAR sequence pages are compactable.
        assertTrue(estimatedSizeAfterCompact < estimatedSizeWithTwoPages, format(
                ""Compact should reduce (or retain) size, but changed from %s to %s"",
                estimatedSizeWithTwoPages,
                estimatedSizeAfterCompact));
    }
    private static PagesIndex newPagesIndex(List<Type> types, int expectedPositions)
    {
        return new PagesIndex.TestingFactory().newPagesIndex(types, expectedPositions);
    }
    private static Page somePage(List<Type> types)
    {
        int[] initialValues = new int[types.size()];
        Arrays.setAll(initialValues, i -> 100 * i);
        return createSequencePage(types, 7, initialValues);
    }
}",class,
"    @Test
    public void testEstimatedSize()
    {
        List<Type> types = ImmutableList.of(BIGINT, VARCHAR);
        PagesIndex pagesIndex = newPagesIndex(types, 30);
        long initialEstimatedSize = pagesIndex.getEstimatedSize().toBytes();
        assertTrue(initialEstimatedSize > 0, format(""Initial estimated size must be positive, got %s"", initialEstimatedSize));
        pagesIndex.addPage(somePage(types));
        long estimatedSizeWithOnePage = pagesIndex.getEstimatedSize().toBytes();
        assertTrue(estimatedSizeWithOnePage > initialEstimatedSize, ""Estimated size should grow after adding a page"");
        pagesIndex.addPage(somePage(types));
        long estimatedSizeWithTwoPages = pagesIndex.getEstimatedSize().toBytes();
        assertEquals(
                estimatedSizeWithTwoPages,
                initialEstimatedSize + (estimatedSizeWithOnePage - initialEstimatedSize) * 2,
                ""Estimated size should grow linearly as long as we don't pass expectedPositions"");
        pagesIndex.compact();
        long estimatedSizeAfterCompact = pagesIndex.getEstimatedSize().toBytes();
        // We can expect compact to reduce size because VARCHAR sequence pages are compactable.
        assertTrue(estimatedSizeAfterCompact < estimatedSizeWithTwoPages, format(
                ""Compact should reduce (or retain) size, but changed from %s to %s"",
                estimatedSizeWithTwoPages,
                estimatedSizeAfterCompact));
    }",method,
"    private static PagesIndex newPagesIndex(List<Type> types, int expectedPositions)
    {
        return new PagesIndex.TestingFactory().newPagesIndex(types, expectedPositions);
    }",method,
"    private static Page somePage(List<Type> types)
    {
        int[] initialValues = new int[types.size()];
        Arrays.setAll(initialValues, i -> 100 * i);
        return createSequencePage(types, 7, initialValues);
    }",method,
"public class WideningConversionNode extends Node {
    protected Tree tree;
    protected Node operand;
    public WideningConversionNode(Tree tree, Node operand, TypeMirror type) {
        super(type);
        assert TypesUtils.isPrimitive(type) : ""non-primitive type in widening conversion"";
        this.tree = tree;
        this.operand = operand;
    }
    public Node getOperand() {
        return operand;
    }
    @Override
    public TypeMirror getType() {
        return type;
    }
    @Override
    public Tree getTree() {
        return tree;
    }
    @Override
    public <R, P> R accept(NodeVisitor<R, P> visitor, P p) {
        return visitor.visitWideningConversion(this, p);
    }
    @Override
    public String toString() {
        return ""WideningConversion("" + getOperand() + "", "" + type + "")"";
    }
    @Override
    public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof WideningConversionNode)) {
            return false;
        }
        WideningConversionNode other = (WideningConversionNode) obj;
        return getOperand().equals(other.getOperand())
                && TypesUtils.areSamePrimitiveTypes(getType(), other.getType());
    }
    @Override
    public int hashCode() {
        return HashCodeUtils.hash(getOperand());
    }
    @Override
    public Collection<Node> getOperands() {
        return Collections.singletonList(getOperand());
    }
}",class,
"    public WideningConversionNode(Tree tree, Node operand, TypeMirror type) {
        super(type);
        assert TypesUtils.isPrimitive(type) : ""non-primitive type in widening conversion"";
        this.tree = tree;
        this.operand = operand;
    }",method,
"    public Node getOperand() {
        return operand;
    }",method,
"    @Override
    public TypeMirror getType() {
        return type;
    }",method,
"    @Override
    public Tree getTree() {
        return tree;
    }",method,
"    @Override
    public <R, P> R accept(NodeVisitor<R, P> visitor, P p) {
        return visitor.visitWideningConversion(this, p);
    }",method,
"    @Override
    public String toString() {
        return ""WideningConversion("" + getOperand() + "", "" + type + "")"";
    }",method,
"    @Override
    public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof WideningConversionNode)) {
            return false;
        }
        WideningConversionNode other = (WideningConversionNode) obj;
        return getOperand().equals(other.getOperand())
                && TypesUtils.areSamePrimitiveTypes(getType(), other.getType());
    }",method,
"    @Override
    public int hashCode() {
        return HashCodeUtils.hash(getOperand());
    }",method,
"    @Override
    public Collection<Node> getOperands() {
        return Collections.singletonList(getOperand());
    }",method,
"public class TypefaceSpan extends MetricAffectingSpan implements ParcelableSpan {
    private final String mFamily;
    public TypefaceSpan(String family) {
        mFamily = family;
    }
    public TypefaceSpan(Parcel src) {
        mFamily = src.readString();
    }
    public int getSpanTypeId() {
        return getSpanTypeIdInternal();
    }
    public int getSpanTypeIdInternal() {
        return TextUtils.TYPEFACE_SPAN;
    }
    public int describeContents() {
        return 0;
    }
    public void writeToParcel(Parcel dest, int flags) {
        writeToParcelInternal(dest, flags);
    }
    public void writeToParcelInternal(Parcel dest, int flags) {
        dest.writeString(mFamily);
    }
    public String getFamily() {
        return mFamily;
    }
    @Override
    public void updateDrawState(TextPaint ds) {
        apply(ds, mFamily);
    }
    @Override
    public void updateMeasureState(TextPaint paint) {
        apply(paint, mFamily);
    }
    private static void apply(Paint paint, String family) {
        int oldStyle;
        Typeface old = paint.getTypeface();
        if (old == null) {
            oldStyle = 0;
        } else {
            oldStyle = old.getStyle();
        }
        Typeface tf = Typeface.create(family, oldStyle);
        int fake = oldStyle & ~tf.getStyle();
        if ((fake & Typeface.BOLD) != 0) {
            paint.setFakeBoldText(true);
        }
        if ((fake & Typeface.ITALIC) != 0) {
            paint.setTextSkewX(-0.25f);
        }
        paint.setTypeface(tf);
    }
}",class,
"    public TypefaceSpan(String family) {
        mFamily = family;
    }",method,
"    public TypefaceSpan(Parcel src) {
        mFamily = src.readString();
    }",method,
"    public int getSpanTypeId() {
        return getSpanTypeIdInternal();
    }",method,
"    public int getSpanTypeIdInternal() {
        return TextUtils.TYPEFACE_SPAN;
    }",method,
"    public int describeContents() {
        return 0;
    }",method,
"    public void writeToParcel(Parcel dest, int flags) {
        writeToParcelInternal(dest, flags);
    }",method,
"    public void writeToParcelInternal(Parcel dest, int flags) {
        dest.writeString(mFamily);
    }",method,
"    public String getFamily() {
        return mFamily;
    }",method,
"    @Override
    public void updateDrawState(TextPaint ds) {
        apply(ds, mFamily);
    }",method,
"    @Override
    public void updateMeasureState(TextPaint paint) {
        apply(paint, mFamily);
    }",method,
"    private static void apply(Paint paint, String family) {
        int oldStyle;
        Typeface old = paint.getTypeface();
        if (old == null) {
            oldStyle = 0;
        } else {
            oldStyle = old.getStyle();
        }
        Typeface tf = Typeface.create(family, oldStyle);
        int fake = oldStyle & ~tf.getStyle();
        if ((fake & Typeface.BOLD) != 0) {
            paint.setFakeBoldText(true);
        }
        if ((fake & Typeface.ITALIC) != 0) {
            paint.setTextSkewX(-0.25f);
        }
        paint.setTypeface(tf);
    }",method,
"        if (old == null) {
            oldStyle = 0;
        }",method,
"public class Sprite extends BaseSprite {
	// ===========================================================
	// Constants
	// ===========================================================
	// ===========================================================
	// Fields
	// ===========================================================
	// ===========================================================
	// Constructors
	// ===========================================================
	public Sprite(final float pX, final float pY, final TextureRegion pTextureRegion) {
		super(pX, pY, pTextureRegion.getWidth(), pTextureRegion.getHeight(), pTextureRegion);
	}
	public Sprite(final float pX, final float pY, final float pWidth, final float pHeight, final TextureRegion pTextureRegion) {
		super(pX, pY, pWidth, pHeight, pTextureRegion);
	}
	public Sprite(final float pX, final float pY, final TextureRegion pTextureRegion, final RectangleVertexBuffer pRectangleVertexBuffer) {
		super(pX, pY, pTextureRegion.getWidth(), pTextureRegion.getHeight(), pTextureRegion, pRectangleVertexBuffer);
	}
	public Sprite(final float pX, final float pY, final float pWidth, final float pHeight, final TextureRegion pTextureRegion, final RectangleVertexBuffer pRectangleVertexBuffer) {
		super(pX, pY, pWidth, pHeight, pTextureRegion, pRectangleVertexBuffer);
	}
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	@Override
	public TextureRegion getTextureRegion() {
		return (TextureRegion)this.mTextureRegion;
	}
	// ===========================================================
	// Methods
	// ===========================================================
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	public Sprite(final float pX, final float pY, final TextureRegion pTextureRegion) {
		super(pX, pY, pTextureRegion.getWidth(), pTextureRegion.getHeight(), pTextureRegion);
	}",method,
"	public Sprite(final float pX, final float pY, final float pWidth, final float pHeight, final TextureRegion pTextureRegion) {
		super(pX, pY, pWidth, pHeight, pTextureRegion);
	}",method,
"	public Sprite(final float pX, final float pY, final TextureRegion pTextureRegion, final RectangleVertexBuffer pRectangleVertexBuffer) {
		super(pX, pY, pTextureRegion.getWidth(), pTextureRegion.getHeight(), pTextureRegion, pRectangleVertexBuffer);
	}",method,
"	public Sprite(final float pX, final float pY, final float pWidth, final float pHeight, final TextureRegion pTextureRegion, final RectangleVertexBuffer pRectangleVertexBuffer) {
		super(pX, pY, pWidth, pHeight, pTextureRegion, pRectangleVertexBuffer);
	}",method,
"	@Override
	public TextureRegion getTextureRegion() {
		return (TextureRegion)this.mTextureRegion;
	}",method,
"public class CollectionContainsTester<E> extends AbstractCollectionTester<E> {
  @CollectionSize.Require(absent = ZERO)
  public void testContains_yes() {
    assertTrue(""contains(present) should return true"", collection.contains(e0()));
  }
  public void testContains_no() {
    assertFalse(""contains(notPresent) should return false"", collection.contains(e3()));
  }
  @CollectionFeature.Require(ALLOWS_NULL_QUERIES)
  public void testContains_nullNotContainedButQueriesSupported() {
    assertFalse(""contains(null) should return false"", collection.contains(null));
  }
  @CollectionFeature.Require(absent = ALLOWS_NULL_QUERIES)
  public void testContains_nullNotContainedAndUnsupported() {
    expectNullMissingWhenNullUnsupported(""contains(null) should return false or throw"");
  }
  @CollectionFeature.Require(ALLOWS_NULL_VALUES)
  @CollectionSize.Require(absent = ZERO)
  public void testContains_nonNullWhenNullContained() {
    initCollectionWithNullElement();
    assertFalse(""contains(notPresent) should return false"", collection.contains(e3()));
  }
  @CollectionFeature.Require(ALLOWS_NULL_VALUES)
  @CollectionSize.Require(absent = ZERO)
  public void testContains_nullContained() {
    initCollectionWithNullElement();
    assertTrue(""contains(null) should return true"", collection.contains(null));
  }
  public void testContains_wrongType() {
    try {
      assertFalse(
          ""contains(wrongType) should return false or throw"", collection.contains(WrongType.VALUE));
    } catch (ClassCastException tolerated) {
    }
  }
}",class,
"  @CollectionSize.Require(absent = ZERO)
  public void testContains_yes() {
    assertTrue(""contains(present) should return true"", collection.contains(e0()));
  }",method,
"  public void testContains_no() {
    assertFalse(""contains(notPresent) should return false"", collection.contains(e3()));
  }",method,
"  @CollectionFeature.Require(ALLOWS_NULL_QUERIES)
  public void testContains_nullNotContainedButQueriesSupported() {
    assertFalse(""contains(null) should return false"", collection.contains(null));
  }",method,
"  @CollectionFeature.Require(absent = ALLOWS_NULL_QUERIES)
  public void testContains_nullNotContainedAndUnsupported() {
    expectNullMissingWhenNullUnsupported(""contains(null) should return false or throw"");
  }",method,
"  @CollectionFeature.Require(ALLOWS_NULL_VALUES)
  @CollectionSize.Require(absent = ZERO)
  public void testContains_nonNullWhenNullContained() {
    initCollectionWithNullElement();
    assertFalse(""contains(notPresent) should return false"", collection.contains(e3()));
  }",method,
"  @CollectionFeature.Require(ALLOWS_NULL_VALUES)
  @CollectionSize.Require(absent = ZERO)
  public void testContains_nullContained() {
    initCollectionWithNullElement();
    assertTrue(""contains(null) should return true"", collection.contains(null));
  }",method,
"  public void testContains_wrongType() {
    try {
      assertFalse(
          ""contains(wrongType) should return false or throw"", collection.contains(WrongType.VALUE));
    } catch (ClassCastException tolerated) {
    }
  }",method,
"public class NewExceptionWithoutArgumentsInspection extends BaseInspection {
  @Deprecated
  @SuppressWarnings(""PublicField"")
  public boolean ignoreWithoutParameters;
  @Nls
  @NotNull
  @Override
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""new.exception.without.arguments.display.name"");
  }
  @NotNull
  @Override
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""new.exception.without.arguments.problem.descriptor"");
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new NewExceptionWithoutArgumentsVisitor();
  }
  private class NewExceptionWithoutArgumentsVisitor extends BaseInspectionVisitor {
    @Override
    public void visitNewExpression(PsiNewExpression expression) {
      super.visitNewExpression(expression);
      final PsiExpressionList argumentList = expression.getArgumentList();
      if (argumentList == null) {
        return;
      }
      final PsiExpression[] expressions = argumentList.getExpressions();
      if (expressions.length != 0) {
        return;
      }
      final PsiJavaCodeReferenceElement classReference = expression.getClassReference();
      if (classReference == null) {
        return;
      }
      final PsiElement target = classReference.resolve();
      if (!(target instanceof PsiClass)) {
        return;
      }
      final PsiClass aClass = (PsiClass)target;
      if (!InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_EXCEPTION)) {
        return;
      }
      if (hasAccessibleConstructorWithParameters(aClass, expression)) {
        registerNewExpressionError(expression);
      }
    }
    private boolean hasAccessibleConstructorWithParameters(PsiClass aClass, PsiElement context) {
      final PsiMethod[] constructors = aClass.getConstructors();
      for (PsiMethod constructor : constructors) {
        final PsiParameterList parameterList = constructor.getParameterList();
        final int count = parameterList.getParametersCount();
        if (count <= 0) {
          continue;
        }
        final PsiResolveHelper resolveHelper = JavaPsiFacade.getInstance(context.getProject()).getResolveHelper();
        if (resolveHelper.isAccessible(constructor, context, aClass)) {
          return true;
        }
      }
      return false;
    }
  }
}",class,
"  private class NewExceptionWithoutArgumentsVisitor extends BaseInspectionVisitor {
    @Override
    public void visitNewExpression(PsiNewExpression expression) {
      super.visitNewExpression(expression);
      final PsiExpressionList argumentList = expression.getArgumentList();
      if (argumentList == null) {
        return;
      }
      final PsiExpression[] expressions = argumentList.getExpressions();
      if (expressions.length != 0) {
        return;
      }
      final PsiJavaCodeReferenceElement classReference = expression.getClassReference();
      if (classReference == null) {
        return;
      }
      final PsiElement target = classReference.resolve();
      if (!(target instanceof PsiClass)) {
        return;
      }
      final PsiClass aClass = (PsiClass)target;
      if (!InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_EXCEPTION)) {
        return;
      }
      if (hasAccessibleConstructorWithParameters(aClass, expression)) {
        registerNewExpressionError(expression);
      }
    }
    private boolean hasAccessibleConstructorWithParameters(PsiClass aClass, PsiElement context) {
      final PsiMethod[] constructors = aClass.getConstructors();
      for (PsiMethod constructor : constructors) {
        final PsiParameterList parameterList = constructor.getParameterList();
        final int count = parameterList.getParametersCount();
        if (count <= 0) {
          continue;
        }
        final PsiResolveHelper resolveHelper = JavaPsiFacade.getInstance(context.getProject()).getResolveHelper();
        if (resolveHelper.isAccessible(constructor, context, aClass)) {
          return true;
        }
      }
      return false;
    }
  }",class,
"  @Nls
  @NotNull
  @Override
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""new.exception.without.arguments.display.name"");
  }",method,
"  @NotNull
  @Override
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""new.exception.without.arguments.problem.descriptor"");
  }",method,

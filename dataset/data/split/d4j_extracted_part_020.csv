code_snippet,type,score
"    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return next().scheduleAtFixedRate(command, initialDelay, period, unit);
    }",method,
"    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return next().scheduleWithFixedDelay(command, initialDelay, delay, unit);
    }",method,
"    @Override
    public Future<?> shutdownGracefully() {
        return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);
    }",method,
"    @Override
    @Deprecated
    public List<Runnable> shutdownNow() {
        shutdown();
        return Collections.emptyList();
    }",method,
"    @Override
    public <T> List<java.util.concurrent.Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
            throws InterruptedException {
        return next().invokeAll(tasks);
    }",method,
"    @Override
    public <T> List<java.util.concurrent.Future<T>> invokeAll(
            Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return next().invokeAll(tasks, timeout, unit);
    }",method,
"    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return next().invokeAny(tasks);
    }",method,
"    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
        return next().invokeAny(tasks, timeout, unit);
    }",method,
"    @Override
    public void execute(Runnable command) {
        next().execute(command);
    }",method,
"public class BindableElement extends SVGGraphicsElement {
    protected String namespaceURI;
    protected String localName;
    protected XBLOMShadowTreeElement xblShadowTree;
    protected BindableElement() {
    }
    public BindableElement(String prefix,
                           AbstractDocument owner,
                           String ns,
                           String ln) {
        super(prefix, owner);
        namespaceURI = ns;
        localName = ln;
    }
    public String getNamespaceURI() {
        return namespaceURI;
    }
    public String getLocalName() {
        return localName;
    }
    protected AttributeInitializer getAttributeInitializer() {
        return null;
    }
    protected Node newNode() {
        return new BindableElement(null, null, namespaceURI, localName);
    }
    public void setShadowTree(XBLOMShadowTreeElement s) {
        xblShadowTree = s;
    }
    public XBLOMShadowTreeElement getShadowTree() {
        return xblShadowTree;
    }
    // CSSNavigableNode ///////////////////////////////////////////////
    public Node getCSSFirstChild() {
        if (xblShadowTree != null) {
            return xblShadowTree.getFirstChild();
        }
        return null;
    }
    public Node getCSSLastChild() {
        return getCSSFirstChild();
    }
}",class,
"    protected BindableElement() {
    }",method,
"    public BindableElement(String prefix,
                           AbstractDocument owner,
                           String ns,
                           String ln) {
        super(prefix, owner);
        namespaceURI = ns;
        localName = ln;
    }",method,
"    public String getNamespaceURI() {
        return namespaceURI;
    }",method,
"    public String getLocalName() {
        return localName;
    }",method,
"    protected AttributeInitializer getAttributeInitializer() {
        return null;
    }",method,
"    protected Node newNode() {
        return new BindableElement(null, null, namespaceURI, localName);
    }",method,
"    public void setShadowTree(XBLOMShadowTreeElement s) {
        xblShadowTree = s;
    }",method,
"    public XBLOMShadowTreeElement getShadowTree() {
        return xblShadowTree;
    }",method,
"    public Node getCSSFirstChild() {
        if (xblShadowTree != null) {
            return xblShadowTree.getFirstChild();
        }
        return null;
    }",method,
"        if (xblShadowTree != null) {
            return xblShadowTree.getFirstChild();
        }",method,
"    public Node getCSSLastChild() {
        return getCSSFirstChild();
    }",method,
"public class TestHiveTypeTranslator
{
    private final TypeTranslator typeTranslator;
    private final Map<String, HiveType> typeTranslationMap;
    public TestHiveTypeTranslator()
    {
        this(new HiveTypeTranslator(), ImmutableMap.of());
    }
    protected TestHiveTypeTranslator(TypeTranslator typeTranslator, Map<String, HiveType> overwriteTranslation)
    {
        this.typeTranslator = requireNonNull(typeTranslator, ""typeTranslator is null"");
        ImmutableMap<String, HiveType> hiveTypeTranslationMap = ImmutableMap.<String, HiveType>builder()
                .put(""bigint"", HiveType.HIVE_LONG)
                .put(""integer"", HiveType.HIVE_INT)
                .put(""smallint"", HiveType.HIVE_SHORT)
                .put(""tinyint"", HiveType.HIVE_BYTE)
                .put(""double"", HiveType.HIVE_DOUBLE)
                .put(""varchar(3)"", HiveType.valueOf(""varchar(3)""))
                .put(""varchar"", HiveType.HIVE_STRING)
                .put(""date"", HiveType.HIVE_DATE)
                .put(""timestamp"", HiveType.HIVE_TIMESTAMP)
                .put(""decimal(5,3)"", HiveType.valueOf(""decimal(5,3)""))
                .put(""varbinary"", HiveType.HIVE_BINARY)
                .put(""array(timestamp)"", HiveType.valueOf(""array<timestamp>""))
                .put(""map(boolean,varbinary)"", HiveType.valueOf(""map<boolean,binary>""))
                .put(""row(col0 integer,col1 varbinary)"", HiveType.valueOf(""struct<col0:int,col1:binary>""))
                .build();
        typeTranslationMap = new HashMap<>();
        typeTranslationMap.putAll(hiveTypeTranslationMap);
        typeTranslationMap.putAll(overwriteTranslation);
    }
    @Test
    public void testTypeTranslator()
    {
        for (Map.Entry<String, HiveType> entry : typeTranslationMap.entrySet()) {
            assertTypeTranslation(entry.getKey(), entry.getValue());
        }
    }
    private void assertTypeTranslation(String typeName, HiveType hiveType)
    {
        Type type = TYPE_MANAGER.getType(parseTypeSignature(typeName));
        assertEquals(HiveType.toHiveType(typeTranslator, type), hiveType);
    }
}",class,
"    public TestHiveTypeTranslator()
    {
        this(new HiveTypeTranslator(), ImmutableMap.of());
    }",method,
"    protected TestHiveTypeTranslator(TypeTranslator typeTranslator, Map<String, HiveType> overwriteTranslation)
    {
        this.typeTranslator = requireNonNull(typeTranslator, ""typeTranslator is null"");
        ImmutableMap<String, HiveType> hiveTypeTranslationMap = ImmutableMap.<String, HiveType>builder()
                .put(""bigint"", HiveType.HIVE_LONG)
                .put(""integer"", HiveType.HIVE_INT)
                .put(""smallint"", HiveType.HIVE_SHORT)
                .put(""tinyint"", HiveType.HIVE_BYTE)
                .put(""double"", HiveType.HIVE_DOUBLE)
                .put(""varchar(3)"", HiveType.valueOf(""varchar(3)""))
                .put(""varchar"", HiveType.HIVE_STRING)
                .put(""date"", HiveType.HIVE_DATE)
                .put(""timestamp"", HiveType.HIVE_TIMESTAMP)
                .put(""decimal(5,3)"", HiveType.valueOf(""decimal(5,3)""))
                .put(""varbinary"", HiveType.HIVE_BINARY)
                .put(""array(timestamp)"", HiveType.valueOf(""array<timestamp>""))
                .put(""map(boolean,varbinary)"", HiveType.valueOf(""map<boolean,binary>""))
                .put(""row(col0 integer,col1 varbinary)"", HiveType.valueOf(""struct<col0:int,col1:binary>""))
                .build();
        typeTranslationMap = new HashMap<>();
        typeTranslationMap.putAll(hiveTypeTranslationMap);
        typeTranslationMap.putAll(overwriteTranslation);
    }",method,
"    @Test
    public void testTypeTranslator()
    {
        for (Map.Entry<String, HiveType> entry : typeTranslationMap.entrySet()) {
            assertTypeTranslation(entry.getKey(), entry.getValue());
        }
    }",method,
"    private void assertTypeTranslation(String typeName, HiveType hiveType)
    {
        Type type = TYPE_MANAGER.getType(parseTypeSignature(typeName));
        assertEquals(HiveType.toHiveType(typeTranslator, type), hiveType);
    }",method,
"public class ScreenListenerService extends Service {
  private BroadcastReceiver mScreenStateBroadcastReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
      Intent discoveryIntent = new Intent(context, UrlDeviceDiscoveryService.class);
      if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
        context.startService(discoveryIntent);
      } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
        context.stopService(discoveryIntent);
      }
    }
  };
  @Override
  public void onCreate() {
    super.onCreate();
    IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(Intent.ACTION_SCREEN_ON);
    intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mScreenStateBroadcastReceiver, intentFilter);
  }
  @Override
  public void onDestroy() {
    unregisterReceiver(mScreenStateBroadcastReceiver);
    super.onDestroy();
  }
  @Override
  public IBinder onBind(Intent intent) {
    // Nothing should bind to this service
    return null;
  }
}",class,
"    @Override
    public void onReceive(Context context, Intent intent) {
      Intent discoveryIntent = new Intent(context, UrlDeviceDiscoveryService.class);
      if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
        context.startService(discoveryIntent);
      } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
        context.stopService(discoveryIntent);
      }
    }",method,
"  @Override
  public void onCreate() {
    super.onCreate();
    IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(Intent.ACTION_SCREEN_ON);
    intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mScreenStateBroadcastReceiver, intentFilter);
  }",method,
"  @Override
  public void onDestroy() {
    unregisterReceiver(mScreenStateBroadcastReceiver);
    super.onDestroy();
  }",method,
"  @Override
  public IBinder onBind(Intent intent) {
    // Nothing should bind to this service
    return null;
  }",method,
"    @Before
    public void setupTestIndex() throws IOException {
        StringBuilder bulk = new StringBuilder();
        for (int i = 0; i < count; i++) {
            bulk.append(""{\""index\"":{}}\n"");
            bulk.append(""{\""test\"":\""test\""}\n"");
        }
        client().performRequest(""POST"", ""/test/test/_bulk"", singletonMap(""refresh"", ""true""),
                new StringEntity(bulk.toString(), ContentType.APPLICATION_JSON));
    }",method,
"        for (int i = 0; i < count; i++) {
            bulk.append(""{\""index\"":{}}\n"");
            bulk.append(""{\""test\"":\""test\""}\n"");
        }",method,
"    public void testReindex() throws IOException {
        Map<String, Object> response = toMap(client().performRequest(""POST"", ""/_reindex"", emptyMap(), new StringEntity(
                ""{\""source\"":{\""index\"":\""test\""}, \""dest\"":{\""index\"":\""des\""}}"",
                ContentType.APPLICATION_JSON)));
        assertThat(response, hasEntry(""total"", count));
        assertThat(response, hasEntry(""created"", count));
    }",method,
"    public void testReindexFromRemote() throws IOException {
        Map<?, ?> nodesInfo = toMap(client().performRequest(""GET"", ""/_nodes/http""));
        nodesInfo = (Map<?, ?>) nodesInfo.get(""nodes"");
        Map<?, ?> nodeInfo = (Map<?, ?>) nodesInfo.values().iterator().next();
        Map<?, ?> http = (Map<?, ?>) nodeInfo.get(""http"");
        String remote = ""http://""+ http.get(""publish_address"");
        Map<String, Object> response = toMap(client().performRequest(""POST"", ""/_reindex"", emptyMap(), new StringEntity(
                ""{\""source\"":{\""index\"":\""test\"",\""remote\"":{\""host\"":\"""" + remote + ""\""}}, \""dest\"":{\""index\"":\""des\""}}"",
                ContentType.APPLICATION_JSON)));
        assertThat(response, hasEntry(""total"", count));
        assertThat(response, hasEntry(""created"", count));
    }
    public void testUpdateByQuery() throws IOException {
        Map<String, Object> response = toMap(client().performRequest(""POST"", ""/test/_update_by_query""));
        assertThat(response, hasEntry(""total"", count));
        assertThat(response, hasEntry(""updated"", count));
    }
    public void testDeleteByQuery() throws IOException {
        Map<String, Object> response = toMap(client().performRequest(""POST"", ""/test/_delete_by_query"", emptyMap(), new StringEntity(
                ""{\""query\"":{\""match_all\"":{}}}"",
                ContentType.APPLICATION_JSON)));
        assertThat(response, hasEntry(""total"", count));
        assertThat(response, hasEntry(""deleted"", count));
    }
    static Map<String, Object> toMap(Response response) throws IOException {
        return XContentHelper.convertToMap(JsonXContent.jsonXContent, response.getEntity().getContent(), false);
    }
}",method,
"    public void testUpdateByQuery() throws IOException {
        Map<String, Object> response = toMap(client().performRequest(""POST"", ""/test/_update_by_query""));
        assertThat(response, hasEntry(""total"", count));
        assertThat(response, hasEntry(""updated"", count));
    }",method,
"    public void testDeleteByQuery() throws IOException {
        Map<String, Object> response = toMap(client().performRequest(""POST"", ""/test/_delete_by_query"", emptyMap(), new StringEntity(
                ""{\""query\"":{\""match_all\"":{}}}"",
                ContentType.APPLICATION_JSON)));
        assertThat(response, hasEntry(""total"", count));
        assertThat(response, hasEntry(""deleted"", count));
    }",method,
"    static Map<String, Object> toMap(Response response) throws IOException {
        return XContentHelper.convertToMap(JsonXContent.jsonXContent, response.getEntity().getContent(), false);
    }",method,
"public class GroovyQuoteHandler implements MultiCharQuoteHandler {
  @Override
  public boolean isClosingQuote(HighlighterIterator iterator, int offset) {
    final IElementType tokenType = iterator.getTokenType();
    if (tokenType == GroovyTokenTypes.mGSTRING_END) return true;
    if (tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_LITERAL) {
      int start = iterator.getStart();
      int end = iterator.getEnd();
      return end - start >= 1 && offset == end - 1 ||
             end - start >= 5 && offset >= end - 3;
    }
    if (tokenType == GroovyTokenTypes.mREGEX_END) {
      int start = iterator.getStart();
      int end = iterator.getEnd();
      return end - start >= 1 && offset == end - 1;
    }
    return false;
  }
  @Override
  public boolean isOpeningQuote(HighlighterIterator iterator, int offset) {
    final IElementType tokenType = iterator.getTokenType();
    if (tokenType == GroovyTokenTypes.mGSTRING_BEGIN || tokenType == GroovyTokenTypes.mREGEX_BEGIN) return true;
    if (tokenType == GroovyTokenTypes.mGSTRING_LITERAL || tokenType == GroovyTokenTypes.mSTRING_LITERAL) {
      int start = iterator.getStart();
      return offset == start;
    }
    return false;
  }
  @Override
  public boolean hasNonClosedLiteral(Editor editor, HighlighterIterator iterator, int offset) {
    final IElementType tokenType = iterator.getTokenType();
    if (tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_BEGIN || tokenType ==
                                                                                                         GroovyTokenTypes.mGSTRING_LITERAL || tokenType ==
                                                                                                                                              GroovyTokenTypes.mGSTRING_CONTENT) {
      final Document document = iterator.getDocument();
      if (document == null) return false;
      final String literal = document.getText().substring(iterator.getStart(), offset + 1);
      if (""'''"".equals(literal) || ""\""\""\"""".equals(literal) || ""'"".equals(literal) || ""\"""".equals(literal)) {
        return true;
      }
    }
    return !(tokenType == GroovyTokenTypes.mGSTRING_CONTENT || tokenType == GroovyTokenTypes.mGSTRING_LITERAL || tokenType ==
                                                                                                                 GroovyTokenTypes.mSTRING_LITERAL || tokenType ==
                                                                                                                                                     GroovyTokenTypes.mGSTRING_END);
  }
  @Override
  public boolean isInsideLiteral(HighlighterIterator iterator) {
    final IElementType tokenType = iterator.getTokenType();
    return tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_LITERAL;
  }
  @Override
  public CharSequence getClosingQuote(HighlighterIterator iterator, int offset) {
    if (offset >= 3) {
      Document document = iterator.getDocument();
      if (document == null) return null;
      String quote = document.getText(new TextRange(offset - 3, offset));
      if (""'''"".equals(quote)) return quote;
      if (""\""\""\"""".equals(quote)) return quote;
    }
    if (offset >= 2) {
      Document document = iterator.getDocument();
      if (document == null) return null;
      String quote = document.getText(new TextRange(offset - 2, offset));
      if (""$/"".equals(quote)) return ""/$"";
    }
    return null;
  }
}",class,
"  @Override
  public boolean isClosingQuote(HighlighterIterator iterator, int offset) {
    final IElementType tokenType = iterator.getTokenType();
    if (tokenType == GroovyTokenTypes.mGSTRING_END) return true;
    if (tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_LITERAL) {
      int start = iterator.getStart();
      int end = iterator.getEnd();
      return end - start >= 1 && offset == end - 1 ||
             end - start >= 5 && offset >= end - 3;
    }
    if (tokenType == GroovyTokenTypes.mREGEX_END) {
      int start = iterator.getStart();
      int end = iterator.getEnd();
      return end - start >= 1 && offset == end - 1;
    }
    return false;
  }",method,
"    if (tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_LITERAL) {
      int start = iterator.getStart();
      int end = iterator.getEnd();
      return end - start >= 1 && offset == end - 1 ||
             end - start >= 5 && offset >= end - 3;
    }",method,
"    if (tokenType == GroovyTokenTypes.mREGEX_END) {
      int start = iterator.getStart();
      int end = iterator.getEnd();
      return end - start >= 1 && offset == end - 1;
    }",method,
"  @Override
  public boolean isOpeningQuote(HighlighterIterator iterator, int offset) {
    final IElementType tokenType = iterator.getTokenType();
    if (tokenType == GroovyTokenTypes.mGSTRING_BEGIN || tokenType == GroovyTokenTypes.mREGEX_BEGIN) return true;
    if (tokenType == GroovyTokenTypes.mGSTRING_LITERAL || tokenType == GroovyTokenTypes.mSTRING_LITERAL) {
      int start = iterator.getStart();
      return offset == start;
    }
    return false;
  }",method,
"    if (tokenType == GroovyTokenTypes.mGSTRING_LITERAL || tokenType == GroovyTokenTypes.mSTRING_LITERAL) {
      int start = iterator.getStart();
      return offset == start;
    }",method,
"  @Override
  public boolean hasNonClosedLiteral(Editor editor, HighlighterIterator iterator, int offset) {
    final IElementType tokenType = iterator.getTokenType();
    if (tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_BEGIN || tokenType ==
                                                                                                         GroovyTokenTypes.mGSTRING_LITERAL || tokenType ==
                                                                                                                                              GroovyTokenTypes.mGSTRING_CONTENT) {
      final Document document = iterator.getDocument();
      if (document == null) return false;
      final String literal = document.getText().substring(iterator.getStart(), offset + 1);
      if (""'''"".equals(literal) || ""\""\""\"""".equals(literal) || ""'"".equals(literal) || ""\"""".equals(literal)) {
        return true;
      }
    }
    return !(tokenType == GroovyTokenTypes.mGSTRING_CONTENT || tokenType == GroovyTokenTypes.mGSTRING_LITERAL || tokenType ==
                                                                                                                 GroovyTokenTypes.mSTRING_LITERAL || tokenType ==
                                                                                                                                                     GroovyTokenTypes.mGSTRING_END);
  }",method,
"    if (tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_BEGIN || tokenType ==
                                                                                                         GroovyTokenTypes.mGSTRING_LITERAL || tokenType ==
                                                                                                                                              GroovyTokenTypes.mGSTRING_CONTENT) {
      final Document document = iterator.getDocument();
      if (document == null) return false;
      final String literal = document.getText().substring(iterator.getStart(), offset + 1);
      if (""'''"".equals(literal) || ""\""\""\"""".equals(literal) || ""'"".equals(literal) || ""\"""".equals(literal)) {
        return true;
      }
    }",method,
"  @Override
  public boolean isInsideLiteral(HighlighterIterator iterator) {
    final IElementType tokenType = iterator.getTokenType();
    return tokenType == GroovyTokenTypes.mSTRING_LITERAL || tokenType == GroovyTokenTypes.mGSTRING_LITERAL;
  }",method,
"  @Override
  public CharSequence getClosingQuote(HighlighterIterator iterator, int offset) {
    if (offset >= 3) {
      Document document = iterator.getDocument();
      if (document == null) return null;
      String quote = document.getText(new TextRange(offset - 3, offset));
      if (""'''"".equals(quote)) return quote;
      if (""\""\""\"""".equals(quote)) return quote;
    }
    if (offset >= 2) {
      Document document = iterator.getDocument();
      if (document == null) return null;
      String quote = document.getText(new TextRange(offset - 2, offset));
      if (""$/"".equals(quote)) return ""/$"";
    }
    return null;
  }",method,
"    if (offset >= 3) {
      Document document = iterator.getDocument();
      if (document == null) return null;
      String quote = document.getText(new TextRange(offset - 3, offset));
      if (""'''"".equals(quote)) return quote;
      if (""\""\""\"""".equals(quote)) return quote;
    }",method,
"    if (offset >= 2) {
      Document document = iterator.getDocument();
      if (document == null) return null;
      String quote = document.getText(new TextRange(offset - 2, offset));
      if (""$/"".equals(quote)) return ""/$"";
    }",method,
"public class PathResource extends AbstractResource implements WritableResource {
	private final Path path;
	public PathResource(Path path) {
		Assert.notNull(path, ""Path must not be null"");
		this.path = path.normalize();
	}
	public PathResource(String path) {
		Assert.notNull(path, ""Path must not be null"");
		this.path = Paths.get(path).normalize();
	}
	public PathResource(URI uri) {
		Assert.notNull(uri, ""URI must not be null"");
		this.path = Paths.get(uri).normalize();
	}
	public final String getPath() {
		return this.path.toString();
	}
	@Override
	public boolean exists() {
		return Files.exists(this.path);
	}
	@Override
	public boolean isReadable() {
		return (Files.isReadable(this.path) && !Files.isDirectory(this.path));
	}
	@Override
	public InputStream getInputStream() throws IOException {
		if (!exists()) {
			throw new FileNotFoundException(getPath() + "" (no such file or directory)"");
		}
		if (Files.isDirectory(this.path)) {
			throw new FileNotFoundException(getPath() + "" (is a directory)"");
		}
		return Files.newInputStream(this.path);
	}
	@Override
	public boolean isWritable() {
		return (Files.isWritable(this.path) && !Files.isDirectory(this.path));
	}
	@Override
	public OutputStream getOutputStream() throws IOException {
		if (Files.isDirectory(this.path)) {
			throw new FileNotFoundException(getPath() + "" (is a directory)"");
		}
		return Files.newOutputStream(this.path);
	}
	@Override
	public URL getURL() throws IOException {
		return this.path.toUri().toURL();
	}
	@Override
	public URI getURI() throws IOException {
		return this.path.toUri();
	}
	@Override
	public boolean isFile() {
		return true;
	}
	@Override
	public File getFile() throws IOException {
		try {
			return this.path.toFile();
		}
		catch (UnsupportedOperationException ex) {
			// Only paths on the default file system can be converted to a File:
			// Do exception translation for cases where conversion is not possible.
			throw new FileNotFoundException(this.path + "" cannot be resolved to absolute file path"");
		}
	}
	@Override
	public ReadableByteChannel readableChannel() throws IOException {
		return Files.newByteChannel(this.path, StandardOpenOption.READ);
	}
	@Override
	public WritableByteChannel writableChannel() throws IOException {
		return Files.newByteChannel(this.path, StandardOpenOption.WRITE);
	}
	@Override
	public long contentLength() throws IOException {
		return Files.size(this.path);
	}
	@Override
	public long lastModified() throws IOException {
		// We can not use the superclass method since it uses conversion to a File and
		// only a Path on the default file system can be converted to a File...
		return Files.getLastModifiedTime(this.path).toMillis();
	}
	@Override
	public Resource createRelative(String relativePath) throws IOException {
		return new PathResource(this.path.resolve(relativePath));
	}
	@Override
	public String getFilename() {
		return this.path.getFileName().toString();
	}
	@Override
	public String getDescription() {
		return ""path ["" + this.path.toAbsolutePath() + ""]"";
	}
	@Override
	public boolean equals(Object obj) {
		return (this == obj ||
			(obj instanceof PathResource && this.path.equals(((PathResource) obj).path)));
	}
	@Override
	public int hashCode() {
		return this.path.hashCode();
	}
}",class,
"	public PathResource(Path path) {
		Assert.notNull(path, ""Path must not be null"");
		this.path = path.normalize();
	}",method,
"	public PathResource(String path) {
		Assert.notNull(path, ""Path must not be null"");
		this.path = Paths.get(path).normalize();
	}",method,
"	public PathResource(URI uri) {
		Assert.notNull(uri, ""URI must not be null"");
		this.path = Paths.get(uri).normalize();
	}",method,
"	public final String getPath() {
		return this.path.toString();
	}",method,
"	@Override
	public boolean exists() {
		return Files.exists(this.path);
	}",method,
"	@Override
	public boolean isReadable() {
		return (Files.isReadable(this.path) && !Files.isDirectory(this.path));
	}",method,
"	@Override
	public InputStream getInputStream() throws IOException {
		if (!exists()) {
			throw new FileNotFoundException(getPath() + "" (no such file or directory)"");
		}
		if (Files.isDirectory(this.path)) {
			throw new FileNotFoundException(getPath() + "" (is a directory)"");
		}
		return Files.newInputStream(this.path);
	}",method,
"	@Override
	public boolean isWritable() {
		return (Files.isWritable(this.path) && !Files.isDirectory(this.path));
	}",method,
"	@Override
	public OutputStream getOutputStream() throws IOException {
		if (Files.isDirectory(this.path)) {
			throw new FileNotFoundException(getPath() + "" (is a directory)"");
		}
		return Files.newOutputStream(this.path);
	}",method,
"	@Override
	public URL getURL() throws IOException {
		return this.path.toUri().toURL();
	}",method,
"	@Override
	public URI getURI() throws IOException {
		return this.path.toUri();
	}",method,
"	@Override
	public boolean isFile() {
		return true;
	}",method,
"	@Override
	public File getFile() throws IOException {
		try {
			return this.path.toFile();
		}
		catch (UnsupportedOperationException ex) {
			// Only paths on the default file system can be converted to a File:
			// Do exception translation for cases where conversion is not possible.
			throw new FileNotFoundException(this.path + "" cannot be resolved to absolute file path"");
		}
	}",method,
"		catch (UnsupportedOperationException ex) {
			// Only paths on the default file system can be converted to a File:
			// Do exception translation for cases where conversion is not possible.
			throw new FileNotFoundException(this.path + "" cannot be resolved to absolute file path"");
		}",method,
"	@Override
	public ReadableByteChannel readableChannel() throws IOException {
		return Files.newByteChannel(this.path, StandardOpenOption.READ);
	}",method,
"	@Override
	public WritableByteChannel writableChannel() throws IOException {
		return Files.newByteChannel(this.path, StandardOpenOption.WRITE);
	}",method,
"	@Override
	public long contentLength() throws IOException {
		return Files.size(this.path);
	}",method,
"	@Override
	public long lastModified() throws IOException {
		// We can not use the superclass method since it uses conversion to a File and
		// only a Path on the default file system can be converted to a File...
		return Files.getLastModifiedTime(this.path).toMillis();
	}",method,
"	@Override
	public Resource createRelative(String relativePath) throws IOException {
		return new PathResource(this.path.resolve(relativePath));
	}",method,
"	@Override
	public String getFilename() {
		return this.path.getFileName().toString();
	}",method,
"	@Override
	public String getDescription() {
		return ""path ["" + this.path.toAbsolutePath() + ""]"";
	}",method,
"	@Override
	public boolean equals(Object obj) {
		return (this == obj ||
			(obj instanceof PathResource && this.path.equals(((PathResource) obj).path)));
	}",method,
"	@Override
	public int hashCode() {
		return this.path.hashCode();
	}",method,
"public class PluginDescriptorChooser {
  private static final Map<String, String> INTELLIJ_MODULES =
    ContainerUtil.<String, String>immutableMapBuilder()
      .put(""platform-api"", ""PlatformExtensions.xml"")
      .put(""platform-impl"", ""PlatformExtensions.xml"")
      .put(""lang-api"", ""LangExtensions.xml"")
      .put(""lang-impl"", ""LangExtensions.xml"")
      .put(""vcs-api"", ""VcsExtensions.xml"")
      .put(""vcs-impl"", ""VcsExtensions.xml"")
      .put(""openapi"", ""IdeaPlugin.xml"")
      .put(""java-impl"", ""IdeaPlugin.xml"")
      .put(""java-analysis-impl"", ""IdeaPlugin.xml"")
      .build();
  public static void show(final Project project,
                          final Editor editor,
                          final PsiFile file,
                          final Consumer<DomFileElement<IdeaPlugin>> consumer) {
    final Module module = ModuleUtilCore.findModuleForPsiElement(file);
    assert module != null;
    List<DomFileElement<IdeaPlugin>> elements = DomService.getInstance().getFileElements(IdeaPlugin.class, project,
                                                                                         module.getModuleWithDependentsScope());
    elements = ContainerUtil.filter(elements, element -> {
      VirtualFile virtualFile = element.getFile().getVirtualFile();
      return virtualFile != null && ProjectRootManager.getInstance(project).getFileIndex().isInContent(virtualFile);
    });
    elements = findAppropriateIntelliJModule(module.getName(), elements);
    if (elements.isEmpty()) {
      HintManager.getInstance().showErrorHint(editor, ""Cannot find plugin descriptor"");
      return;
    }
    if (elements.size() == 1) {
      consumer.consume(elements.get(0));
      return;
    }
    final BaseListPopupStep<PluginDescriptorCandidate> popupStep =
      new BaseListPopupStep<PluginDescriptorCandidate>(""Choose Plugin Descriptor"", createCandidates(module, elements)) {
        @Override
        public boolean isSpeedSearchEnabled() {
          return true;
        }
        @Override
        public Icon getIconFor(PluginDescriptorCandidate candidate) {
          return candidate.getIcon();
        }
        @NotNull
        @Override
        public String getTextFor(PluginDescriptorCandidate candidate) {
          return candidate.getText();
        }
        @Nullable
        @Override
        public ListSeparator getSeparatorAbove(PluginDescriptorCandidate candidate) {
          final String separatorText = candidate.getSeparatorText();
          if (separatorText != null) {
            return new ListSeparator(separatorText);
          }
          return null;
        }
        @Override
        public PopupStep onChosen(PluginDescriptorCandidate selectedValue, boolean finalChoice) {
          consumer.consume(selectedValue.myDomFileElement);
          return FINAL_CHOICE;
        }
      };
    JBPopupFactory.getInstance().createListPopup(popupStep).showInBestPositionFor(editor);
  }
  @NotNull
  public static Extensions findOrCreateExtensionsForEP(DomFileElement<IdeaPlugin> domFileElement, String epName) {
    final IdeaPlugin ideaPlugin = domFileElement.getRootElement();
    final List<Extensions> extensionsList = ideaPlugin.getExtensions();
    for (Extensions extensions : extensionsList) {
      if (extensions.getXmlTag() instanceof IncludedXmlTag) {
        continue;
      }
      String s = extensions.getDefaultExtensionNs().getStringValue();
      if (s != null && epName.startsWith(s)) {
        return extensions;
      }
    }
    Extensions extensions = ideaPlugin.addExtensions();
    final String epPrefix = StringUtil.getPackageName(epName);
    extensions.getDefaultExtensionNs().setStringValue(epPrefix);
    return extensions;
  }
  private static List<PluginDescriptorCandidate> createCandidates(final Module currentModule,
                                                                  List<DomFileElement<IdeaPlugin>> elements) {
    ModuleGrouper grouper = ModuleGrouper.instanceFor(currentModule.getProject());
    final List<String> groupPath = grouper.getGroupPath(currentModule);
    elements.sort((o1, o2) -> {
      // current module = first group
      final Module module1 = o1.getModule();
      final Module module2 = o2.getModule();
      if (!Comparing.equal(module1, module2)) {
        if (currentModule.equals(module1)) return -1;
        if (currentModule.equals(module2)) return 1;
      }
      if (module1 != null && module2 != null) {
        int groupComparison = Comparing.compare(groupMatchLevel(groupPath, grouper.getGroupPath(module2)),
                                                groupMatchLevel(groupPath, grouper.getGroupPath(module1)));
        if (groupComparison != 0) {
          return groupComparison;
        }
      }
      return ModulesAlphaComparator.INSTANCE.compare(module1, module2);
    });
    elements.sort((o1, o2) -> {
      if (!Comparing.equal(o1.getModule(), o2.getModule())) return 0;
      String pluginId1 = o1.getRootElement().getPluginId();
      String pluginId2 = o2.getRootElement().getPluginId();
      if (pluginId1 == null && pluginId2 == null) {
        return o1.getFile().getName().compareTo(o2.getFile().getName());
      }
      if (pluginId1 == null) return 1;
      if (pluginId2 == null) return -1;
      return Comparing.compare(pluginId1, pluginId2);
    });
    return ContainerUtil.map(elements, new Function<DomFileElement<IdeaPlugin>, PluginDescriptorCandidate>() {
      private Module myLastModule = currentModule;
      @Override
      public PluginDescriptorCandidate fun(DomFileElement<IdeaPlugin> element) {
        final Module module = element.getModule();
        boolean startsNewGroup = !myLastModule.equals(module);
        myLastModule = module;
        return new PluginDescriptorCandidate(element, startsNewGroup);
      }
    });
  }
  private static int groupMatchLevel(@NotNull List<String> targetGroupPath, @NotNull List<String> groupPath) {
    for (int i = 0; i < Math.min(targetGroupPath.size(), groupPath.size()); i++) {
      if (!targetGroupPath.get(i).equals(groupPath.get(i))) {
        return i;
      }
    }
    return Math.min(targetGroupPath.size(), groupPath.size());
  }
  public static List<DomFileElement<IdeaPlugin>> findAppropriateIntelliJModule(String moduleName,
                                                                                List<DomFileElement<IdeaPlugin>> elements) {
    String extensionsFile = INTELLIJ_MODULES.get(moduleName);
    if (extensionsFile != null) {
      for (DomFileElement<IdeaPlugin> element : elements) {
        if (element.getFile().getName().equals(extensionsFile)) {
          return Collections.singletonList(element);
        }
      }
    }
    return elements;
  }
  private static class PluginDescriptorCandidate {
    private final DomFileElement<IdeaPlugin> myDomFileElement;
    private final boolean myStartsNewGroup;
    private PluginDescriptorCandidate(DomFileElement<IdeaPlugin> domFileElement,
                                      boolean startsNewGroup) {
      myDomFileElement = domFileElement;
      myStartsNewGroup = startsNewGroup;
    }
    public String getText() {
      final String name = myDomFileElement.getFile().getName();
      final String pluginId = getPluginId();
      return pluginId != null ? name + "" ["" + pluginId + ""]"" : name;
    }
    public Icon getIcon() {
      return getPluginId() != null ? AllIcons.Nodes.Plugin : EmptyIcon.create(AllIcons.Nodes.Plugin);
    }
    public String getSeparatorText() {
      if (!myStartsNewGroup) return null;
      final Module module = myDomFileElement.getModule();
      return module == null ? null : module.getName();
    }
    private String getPluginId() {
      return myDomFileElement.getRootElement().getPluginId();
    }
  }
}",class,
"  private static class PluginDescriptorCandidate {
    private final DomFileElement<IdeaPlugin> myDomFileElement;
    private final boolean myStartsNewGroup;
    private PluginDescriptorCandidate(DomFileElement<IdeaPlugin> domFileElement,
                                      boolean startsNewGroup) {
      myDomFileElement = domFileElement;
      myStartsNewGroup = startsNewGroup;
    }
    public String getText() {
      final String name = myDomFileElement.getFile().getName();
      final String pluginId = getPluginId();
      return pluginId != null ? name + "" ["" + pluginId + ""]"" : name;
    }
    public Icon getIcon() {
      return getPluginId() != null ? AllIcons.Nodes.Plugin : EmptyIcon.create(AllIcons.Nodes.Plugin);
    }
    public String getSeparatorText() {
      if (!myStartsNewGroup) return null;
      final Module module = myDomFileElement.getModule();
      return module == null ? null : module.getName();
    }
    private String getPluginId() {
      return myDomFileElement.getRootElement().getPluginId();
    }
  }",class,
"  public static void show(final Project project,
                          final Editor editor,
                          final PsiFile file,
                          final Consumer<DomFileElement<IdeaPlugin>> consumer) {
    final Module module = ModuleUtilCore.findModuleForPsiElement(file);
    assert module != null;
    List<DomFileElement<IdeaPlugin>> elements = DomService.getInstance().getFileElements(IdeaPlugin.class, project,
                                                                                         module.getModuleWithDependentsScope());
    elements = ContainerUtil.filter(elements, element -> {
      VirtualFile virtualFile = element.getFile().getVirtualFile();
      return virtualFile != null && ProjectRootManager.getInstance(project).getFileIndex().isInContent(virtualFile);
    });
    elements = findAppropriateIntelliJModule(module.getName(), elements);
    if (elements.isEmpty()) {
      HintManager.getInstance().showErrorHint(editor, ""Cannot find plugin descriptor"");
      return;
    }
    if (elements.size() == 1) {
      consumer.consume(elements.get(0));
      return;
    }
    final BaseListPopupStep<PluginDescriptorCandidate> popupStep =
      new BaseListPopupStep<PluginDescriptorCandidate>(""Choose Plugin Descriptor"", createCandidates(module, elements)) {
        @Override
        public boolean isSpeedSearchEnabled() {
          return true;
        }
        @Override
        public Icon getIconFor(PluginDescriptorCandidate candidate) {
          return candidate.getIcon();
        }
        @NotNull
        @Override
        public String getTextFor(PluginDescriptorCandidate candidate) {
          return candidate.getText();
        }
        @Nullable
        @Override
        public ListSeparator getSeparatorAbove(PluginDescriptorCandidate candidate) {
          final String separatorText = candidate.getSeparatorText();
          if (separatorText != null) {
            return new ListSeparator(separatorText);
          }
          return null;
        }
        @Override
        public PopupStep onChosen(PluginDescriptorCandidate selectedValue, boolean finalChoice) {
          consumer.consume(selectedValue.myDomFileElement);
          return FINAL_CHOICE;
        }
      };
    JBPopupFactory.getInstance().createListPopup(popupStep).showInBestPositionFor(editor);
  }",method,
"        @Override
        public boolean isSpeedSearchEnabled() {
          return true;
        }",method,
"        @Override
        public Icon getIconFor(PluginDescriptorCandidate candidate) {
          return candidate.getIcon();
        }",method,
"        @NotNull
        @Override
        public String getTextFor(PluginDescriptorCandidate candidate) {
          return candidate.getText();
        }",method,
"        @Nullable
        @Override
        public ListSeparator getSeparatorAbove(PluginDescriptorCandidate candidate) {
          final String separatorText = candidate.getSeparatorText();
          if (separatorText != null) {
            return new ListSeparator(separatorText);
          }
          return null;
        }",method,
"          if (separatorText != null) {
            return new ListSeparator(separatorText);
          }",method,
"        @Override
        public PopupStep onChosen(PluginDescriptorCandidate selectedValue, boolean finalChoice) {
          consumer.consume(selectedValue.myDomFileElement);
          return FINAL_CHOICE;
        }",method,
"  @NotNull
  public static Extensions findOrCreateExtensionsForEP(DomFileElement<IdeaPlugin> domFileElement, String epName) {
    final IdeaPlugin ideaPlugin = domFileElement.getRootElement();
    final List<Extensions> extensionsList = ideaPlugin.getExtensions();
    for (Extensions extensions : extensionsList) {
      if (extensions.getXmlTag() instanceof IncludedXmlTag) {
        continue;
      }
      String s = extensions.getDefaultExtensionNs().getStringValue();
      if (s != null && epName.startsWith(s)) {
        return extensions;
      }
    }
    Extensions extensions = ideaPlugin.addExtensions();
    final String epPrefix = StringUtil.getPackageName(epName);
    extensions.getDefaultExtensionNs().setStringValue(epPrefix);
    return extensions;
  }",method,
"    for (Extensions extensions : extensionsList) {
      if (extensions.getXmlTag() instanceof IncludedXmlTag) {
        continue;
      }
      String s = extensions.getDefaultExtensionNs().getStringValue();
      if (s != null && epName.startsWith(s)) {
        return extensions;
      }
    }",method,
"  private static List<PluginDescriptorCandidate> createCandidates(final Module currentModule,
                                                                  List<DomFileElement<IdeaPlugin>> elements) {
    ModuleGrouper grouper = ModuleGrouper.instanceFor(currentModule.getProject());
    final List<String> groupPath = grouper.getGroupPath(currentModule);
    elements.sort((o1, o2) -> {
      // current module = first group
      final Module module1 = o1.getModule();
      final Module module2 = o2.getModule();
      if (!Comparing.equal(module1, module2)) {
        if (currentModule.equals(module1)) return -1;
        if (currentModule.equals(module2)) return 1;
      }
      if (module1 != null && module2 != null) {
        int groupComparison = Comparing.compare(groupMatchLevel(groupPath, grouper.getGroupPath(module2)),
                                                groupMatchLevel(groupPath, grouper.getGroupPath(module1)));
        if (groupComparison != 0) {
          return groupComparison;
        }
      }
      return ModulesAlphaComparator.INSTANCE.compare(module1, module2);
    });
    elements.sort((o1, o2) -> {
      if (!Comparing.equal(o1.getModule(), o2.getModule())) return 0;
      String pluginId1 = o1.getRootElement().getPluginId();
      String pluginId2 = o2.getRootElement().getPluginId();
      if (pluginId1 == null && pluginId2 == null) {
        return o1.getFile().getName().compareTo(o2.getFile().getName());
      }
      if (pluginId1 == null) return 1;
      if (pluginId2 == null) return -1;
      return Comparing.compare(pluginId1, pluginId2);
    });
    return ContainerUtil.map(elements, new Function<DomFileElement<IdeaPlugin>, PluginDescriptorCandidate>() {
      private Module myLastModule = currentModule;
      @Override
      public PluginDescriptorCandidate fun(DomFileElement<IdeaPlugin> element) {
        final Module module = element.getModule();
        boolean startsNewGroup = !myLastModule.equals(module);
        myLastModule = module;
        return new PluginDescriptorCandidate(element, startsNewGroup);
      }
    });
  }",method,
"      if (module1 != null && module2 != null) {
        int groupComparison = Comparing.compare(groupMatchLevel(groupPath, grouper.getGroupPath(module2)),
                                                groupMatchLevel(groupPath, grouper.getGroupPath(module1)));
        if (groupComparison != 0) {
          return groupComparison;
        }
      }",method,
"        if (groupComparison != 0) {
          return groupComparison;
        }",method,
"      if (pluginId1 == null && pluginId2 == null) {
        return o1.getFile().getName().compareTo(o2.getFile().getName());
      }",method,
"    return ContainerUtil.map(elements, new Function<DomFileElement<IdeaPlugin>, PluginDescriptorCandidate>() {
      private Module myLastModule = currentModule;
      @Override
      public PluginDescriptorCandidate fun(DomFileElement<IdeaPlugin> element) {
        final Module module = element.getModule();
        boolean startsNewGroup = !myLastModule.equals(module);
        myLastModule = module;
        return new PluginDescriptorCandidate(element, startsNewGroup);
      }
    }",method,
"      @Override
      public PluginDescriptorCandidate fun(DomFileElement<IdeaPlugin> element) {
        final Module module = element.getModule();
        boolean startsNewGroup = !myLastModule.equals(module);
        myLastModule = module;
        return new PluginDescriptorCandidate(element, startsNewGroup);
      }",method,
"  private static int groupMatchLevel(@NotNull List<String> targetGroupPath, @NotNull List<String> groupPath) {
    for (int i = 0; i < Math.min(targetGroupPath.size(), groupPath.size()); i++) {
      if (!targetGroupPath.get(i).equals(groupPath.get(i))) {
        return i;
      }
    }
    return Math.min(targetGroupPath.size(), groupPath.size());
  }",method,
"  public static List<DomFileElement<IdeaPlugin>> findAppropriateIntelliJModule(String moduleName,
                                                                                List<DomFileElement<IdeaPlugin>> elements) {
    String extensionsFile = INTELLIJ_MODULES.get(moduleName);
    if (extensionsFile != null) {
      for (DomFileElement<IdeaPlugin> element : elements) {
        if (element.getFile().getName().equals(extensionsFile)) {
          return Collections.singletonList(element);
        }
      }
    }
    return elements;
  }",method,
"    if (extensionsFile != null) {
      for (DomFileElement<IdeaPlugin> element : elements) {
        if (element.getFile().getName().equals(extensionsFile)) {
          return Collections.singletonList(element);
        }
      }
    }",method,
"      for (DomFileElement<IdeaPlugin> element : elements) {
        if (element.getFile().getName().equals(extensionsFile)) {
          return Collections.singletonList(element);
        }
      }",method,
"    private PluginDescriptorCandidate(DomFileElement<IdeaPlugin> domFileElement,
                                      boolean startsNewGroup) {
      myDomFileElement = domFileElement;
      myStartsNewGroup = startsNewGroup;
    }",method,
"    public String getText() {
      final String name = myDomFileElement.getFile().getName();
      final String pluginId = getPluginId();
      return pluginId != null ? name + "" ["" + pluginId + ""]"" : name;
    }",method,
"    public Icon getIcon() {
      return getPluginId() != null ? AllIcons.Nodes.Plugin : EmptyIcon.create(AllIcons.Nodes.Plugin);
    }",method,
"    public String getSeparatorText() {
      if (!myStartsNewGroup) return null;
      final Module module = myDomFileElement.getModule();
      return module == null ? null : module.getName();
    }",method,
"    private String getPluginId() {
      return myDomFileElement.getRootElement().getPluginId();
    }",method,
"public final class SnapshotMatchers {
    private SnapshotMatchers() {
    }
    public static Matcher<Translog.Snapshot> size(int size) {
        return new SizeMatcher(size);
    }
    public static Matcher<Translog.Snapshot> equalsTo(Translog.Operation... ops) {
        return new EqualMatcher(ops);
    }
    public static Matcher<Translog.Snapshot> equalsTo(ArrayList<Translog.Operation> ops) {
        return new EqualMatcher(ops.toArray(new Translog.Operation[ops.size()]));
    }
    public static class SizeMatcher extends TypeSafeMatcher<Translog.Snapshot> {
        private final int size;
        public SizeMatcher(int size) {
            this.size = size;
        }
        @Override
        public boolean matchesSafely(Translog.Snapshot snapshot) {
            int count = 0;
            try {
                while (snapshot.next() != null) {
                    count++;
                }
            } catch (IOException ex) {
                throw new ElasticsearchException(""failed to advance snapshot"", ex);
            }
            return size == count;
        }
        @Override
        public void describeTo(Description description) {
            description.appendText(""a snapshot with size "").appendValue(size);
        }
    }
    public static class EqualMatcher extends TypeSafeMatcher<Translog.Snapshot> {
        private final Translog.Operation[] expectedOps;
        String failureMsg = null;
        public EqualMatcher(Translog.Operation[] expectedOps) {
            this.expectedOps = expectedOps;
        }
        @Override
        protected boolean matchesSafely(Translog.Snapshot snapshot) {
            try {
                Translog.Operation op;
                int i;
                for (i = 0, op = snapshot.next(); op != null && i < expectedOps.length; i++, op = snapshot.next()) {
                    if (expectedOps[i].equals(op) == false) {
                        failureMsg = ""position ["" + i + ""] expected ["" + expectedOps[i] + ""] but found ["" + op + ""]"";
                        return false;
                    }
                }
                if (i < expectedOps.length) {
                    failureMsg = ""expected ["" + expectedOps.length + ""] ops but only found ["" + i + ""]"";
                    return false;
                }
                if (op != null) {
                    int count = 1; // to account for the op we already read
                    while (snapshot.next() != null) {
                        count++;
                    }
                    failureMsg = ""expected ["" + expectedOps.length + ""] ops but got ["" + (expectedOps.length + count) + ""]"";
                    return false;
                }
                return true;
            } catch (IOException ex) {
                throw new ElasticsearchException(""failed to read snapshot content"", ex);
            }
        }
        @Override
        public void describeTo(Description description) {
            description.appendText(failureMsg);
        }
    }
}",class,

code_snippet,type,score
"    public int getL() {
        return this.l;
    }",method,
"public final class OverscrollHelper {
	static final String LOG_TAG = ""OverscrollHelper"";
	static final float DEFAULT_OVERSCROLL_SCALE = 1f;
	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
			final int deltaY, final int scrollY, final boolean isTouchEvent) {
		overScrollBy(view, deltaX, scrollX, deltaY, scrollY, 0, isTouchEvent);
	}
	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
			final int deltaY, final int scrollY, final int scrollRange, final boolean isTouchEvent) {
		overScrollBy(view, deltaX, scrollX, deltaY, scrollY, scrollRange, 0, DEFAULT_OVERSCROLL_SCALE, isTouchEvent);
	}
	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
			final int deltaY, final int scrollY, final int scrollRange, final int fuzzyThreshold,
			final float scaleFactor, final boolean isTouchEvent) {
		final int deltaValue, currentScrollValue, scrollValue;
		switch (view.getPullToRefreshScrollDirection()) {
			case HORIZONTAL:
				deltaValue = deltaX;
				scrollValue = scrollX;
				currentScrollValue = view.getScrollX();
				break;
			case VERTICAL:
			default:
				deltaValue = deltaY;
				scrollValue = scrollY;
				currentScrollValue = view.getScrollY();
				break;
		}
		// Check that OverScroll is enabled and that we're not currently
		// refreshing.
		if (view.isPullToRefreshOverScrollEnabled() && !view.isRefreshing()) {
			final Mode mode = view.getMode();
			// Check that Pull-to-Refresh is enabled, and the event isn't from
			// touch
			if (mode.permitsPullToRefresh() && !isTouchEvent && deltaValue != 0) {
				final int newScrollValue = (deltaValue + scrollValue);
				if (PullToRefreshBase.DEBUG) {
					Log.d(LOG_TAG, ""OverScroll. DeltaX: "" + deltaX + "", ScrollX: "" + scrollX + "", DeltaY: "" + deltaY
							+ "", ScrollY: "" + scrollY + "", NewY: "" + newScrollValue + "", ScrollRange: "" + scrollRange
							+ "", CurrentScroll: "" + currentScrollValue);
				}
				if (newScrollValue < (0 - fuzzyThreshold)) {
					// Check the mode supports the overscroll direction, and
					// then move scroll
					if (mode.showHeaderLoadingLayout()) {
						// If we're currently at zero, we're about to start
						// overscrolling, so change the state
						if (currentScrollValue == 0) {
							view.setState(State.OVERSCROLLING);
						}
						view.setHeaderScroll((int) (scaleFactor * (currentScrollValue + newScrollValue)));
					}
				} else if (newScrollValue > (scrollRange + fuzzyThreshold)) {
					// Check the mode supports the overscroll direction, and
					// then move scroll
					if (mode.showFooterLoadingLayout()) {
						// If we're currently at zero, we're about to start
						// overscrolling, so change the state
						if (currentScrollValue == 0) {
							view.setState(State.OVERSCROLLING);
						}
						view.setHeaderScroll((int) (scaleFactor * (currentScrollValue + newScrollValue - scrollRange)));
					}
				} else if (Math.abs(newScrollValue) <= fuzzyThreshold
						|| Math.abs(newScrollValue - scrollRange) <= fuzzyThreshold) {
					// Means we've stopped overscrolling, so scroll back to 0
					view.setState(State.RESET);
				}
			} else if (isTouchEvent && State.OVERSCROLLING == view.getState()) {
				// This condition means that we were overscrolling from a fling,
				// but the user has touched the View and is now overscrolling
				// from touch instead. We need to just reset.
				view.setState(State.RESET);
			}
		}
	}
	static boolean isAndroidOverScrollEnabled(View view) {
		return view.getOverScrollMode() != View.OVER_SCROLL_NEVER;
	}
}",class,
"	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
			final int deltaY, final int scrollY, final boolean isTouchEvent) {
		overScrollBy(view, deltaX, scrollX, deltaY, scrollY, 0, isTouchEvent);
	}",method,
"	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
			final int deltaY, final int scrollY, final int scrollRange, final boolean isTouchEvent) {
		overScrollBy(view, deltaX, scrollX, deltaY, scrollY, scrollRange, 0, DEFAULT_OVERSCROLL_SCALE, isTouchEvent);
	}",method,
"	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
			final int deltaY, final int scrollY, final int scrollRange, final int fuzzyThreshold,
			final float scaleFactor, final boolean isTouchEvent) {
		final int deltaValue, currentScrollValue, scrollValue;
		switch (view.getPullToRefreshScrollDirection()) {
			case HORIZONTAL:
				deltaValue = deltaX;
				scrollValue = scrollX;
				currentScrollValue = view.getScrollX();
				break;
			case VERTICAL:
			default:
				deltaValue = deltaY;
				scrollValue = scrollY;
				currentScrollValue = view.getScrollY();
				break;
		}
		// Check that OverScroll is enabled and that we're not currently
		// refreshing.
		if (view.isPullToRefreshOverScrollEnabled() && !view.isRefreshing()) {
			final Mode mode = view.getMode();
			// Check that Pull-to-Refresh is enabled, and the event isn't from
			// touch
			if (mode.permitsPullToRefresh() && !isTouchEvent && deltaValue != 0) {
				final int newScrollValue = (deltaValue + scrollValue);
				if (PullToRefreshBase.DEBUG) {
					Log.d(LOG_TAG, ""OverScroll. DeltaX: "" + deltaX + "", ScrollX: "" + scrollX + "", DeltaY: "" + deltaY
							+ "", ScrollY: "" + scrollY + "", NewY: "" + newScrollValue + "", ScrollRange: "" + scrollRange
							+ "", CurrentScroll: "" + currentScrollValue);
				}
				if (newScrollValue < (0 - fuzzyThreshold)) {
					// Check the mode supports the overscroll direction, and
					// then move scroll
					if (mode.showHeaderLoadingLayout()) {
						// If we're currently at zero, we're about to start
						// overscrolling, so change the state
						if (currentScrollValue == 0) {
							view.setState(State.OVERSCROLLING);
						}
						view.setHeaderScroll((int) (scaleFactor * (currentScrollValue + newScrollValue)));
					}
				} else if (newScrollValue > (scrollRange + fuzzyThreshold)) {
					// Check the mode supports the overscroll direction, and
					// then move scroll
					if (mode.showFooterLoadingLayout()) {
						// If we're currently at zero, we're about to start
						// overscrolling, so change the state
						if (currentScrollValue == 0) {
							view.setState(State.OVERSCROLLING);
						}
						view.setHeaderScroll((int) (scaleFactor * (currentScrollValue + newScrollValue - scrollRange)));
					}
				} else if (Math.abs(newScrollValue) <= fuzzyThreshold
						|| Math.abs(newScrollValue - scrollRange) <= fuzzyThreshold) {
					// Means we've stopped overscrolling, so scroll back to 0
					view.setState(State.RESET);
				}
			} else if (isTouchEvent && State.OVERSCROLLING == view.getState()) {
				// This condition means that we were overscrolling from a fling,
				// but the user has touched the View and is now overscrolling
				// from touch instead. We need to just reset.
				view.setState(State.RESET);
			}
		}
	}",method,
"				if (PullToRefreshBase.DEBUG) {
					Log.d(LOG_TAG, ""OverScroll. DeltaX: "" + deltaX + "", ScrollX: "" + scrollX + "", DeltaY: "" + deltaY
							+ "", ScrollY: "" + scrollY + "", NewY: "" + newScrollValue + "", ScrollRange: "" + scrollRange
							+ "", CurrentScroll: "" + currentScrollValue);
				}",method,
"						if (currentScrollValue == 0) {
							view.setState(State.OVERSCROLLING);
						}",method,
"						if (currentScrollValue == 0) {
							view.setState(State.OVERSCROLLING);
						}",method,
"	static boolean isAndroidOverScrollEnabled(View view) {
		return view.getOverScrollMode() != View.OVER_SCROLL_NEVER;
	}",method,
"public class SocksAuthRequestDecoderTest {
    private static final String username = ""testUserName"";
    private static final String password = ""testPassword"";
    @Test
    public void testAuthRequestDecoder() {
        SocksAuthRequest msg = new SocksAuthRequest(username, password);
        SocksAuthRequestDecoder decoder = new SocksAuthRequestDecoder();
        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
        SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
        msg = embedder.readInbound();
        assertEquals(username, msg.username());
        assertEquals(password, msg.password());
        assertNull(embedder.readInbound());
    }
    @Test
    public void testAuthRequestDecoderPartialSend() {
        EmbeddedChannel ch = new EmbeddedChannel(new SocksAuthRequestDecoder());
        ByteBuf byteBuf = Unpooled.buffer(16);
        // Send username and password size
        byteBuf.writeByte(SocksSubnegotiationVersion.AUTH_PASSWORD.byteValue());
        byteBuf.writeByte(username.length());
        byteBuf.writeBytes(username.getBytes());
        byteBuf.writeByte(password.length());
        ch.writeInbound(byteBuf);
        // Check that channel is empty
        assertNull(ch.readInbound());
        // Send password
        ByteBuf byteBuf2 = Unpooled.buffer();
        byteBuf2.writeBytes(password.getBytes());
        ch.writeInbound(byteBuf2);
        // Read message from channel
        SocksAuthRequest msg = ch.readInbound();
        // Check message
        assertEquals(username, msg.username());
        assertEquals(password, msg.password());
        assertFalse(ch.finishAndReleaseAll());
    }
}",class,
"    @Test
    public void testAuthRequestDecoder() {
        SocksAuthRequest msg = new SocksAuthRequest(username, password);
        SocksAuthRequestDecoder decoder = new SocksAuthRequestDecoder();
        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
        SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
        msg = embedder.readInbound();
        assertEquals(username, msg.username());
        assertEquals(password, msg.password());
        assertNull(embedder.readInbound());
    }",method,
"    @Test
    public void testAuthRequestDecoderPartialSend() {
        EmbeddedChannel ch = new EmbeddedChannel(new SocksAuthRequestDecoder());
        ByteBuf byteBuf = Unpooled.buffer(16);
        // Send username and password size
        byteBuf.writeByte(SocksSubnegotiationVersion.AUTH_PASSWORD.byteValue());
        byteBuf.writeByte(username.length());
        byteBuf.writeBytes(username.getBytes());
        byteBuf.writeByte(password.length());
        ch.writeInbound(byteBuf);
        // Check that channel is empty
        assertNull(ch.readInbound());
        // Send password
        ByteBuf byteBuf2 = Unpooled.buffer();
        byteBuf2.writeBytes(password.getBytes());
        ch.writeInbound(byteBuf2);
        // Read message from channel
        SocksAuthRequest msg = ch.readInbound();
        // Check message
        assertEquals(username, msg.username());
        assertEquals(password, msg.password());
        assertFalse(ch.finishAndReleaseAll());
    }",method,
"public class AppModule
{
    public static void bind(ServiceBinder binder)
    {
        // binder.bind(MyServiceInterface.class, MyServiceImpl.class);
        // Make bind() calls on the binder object to define most IoC services.
        // Use service builder methods (example below) when the implementation
        // is provided inline, or requires more initialization than simply
        // invoking the constructor.
    }
    public static void contributeFactoryDefaults(
            MappedConfiguration<String, Object> configuration)
    {
        // The application version number is incorprated into URLs for some
        // assets. Web browsers will cache assets because of the far future expires
        // header. If existing assets are changed, the version number should also
        // change, to force the browser to download new versions. This overrides Tapesty's default
        // (a random hexadecimal number), but may be further overriden by DevelopmentModule or
        // QaModule.
        configuration.override(SymbolConstants.APPLICATION_VERSION, ""1.0-SNAPSHOT"");
    }
    public static void contributeApplicationDefaults(
            MappedConfiguration<String, Object> configuration)
    {
        // Contributions to ApplicationDefaults will override any contributions to
        // FactoryDefaults (with the same key). Here we're restricting the supported
        // locales to just ""en"" (English). As you add localised message catalogs and other assets,
        // you can extend this list of locales (it's a comma separated series of locale names;
        // the first locale name is the default when there's no reasonable match).
        configuration.add(SymbolConstants.SUPPORTED_LOCALES, ""en"");
        configuration.add(SymbolConstants.OMIT_GENERATOR_META, true);
        configuration.add(SymbolConstants.INCLUDE_CORE_STACK, false);
        configuration.add(SymbolConstants.GZIP_COMPRESSION_ENABLED, false); 
    }
}",class,
"    public static void bind(ServiceBinder binder)
    {
        // binder.bind(MyServiceInterface.class, MyServiceImpl.class);
        // Make bind() calls on the binder object to define most IoC services.
        // Use service builder methods (example below) when the implementation
        // is provided inline, or requires more initialization than simply
        // invoking the constructor.
    }",method,
"    public static void contributeFactoryDefaults(
            MappedConfiguration<String, Object> configuration)
    {
        // The application version number is incorprated into URLs for some
        // assets. Web browsers will cache assets because of the far future expires
        // header. If existing assets are changed, the version number should also
        // change, to force the browser to download new versions. This overrides Tapesty's default
        // (a random hexadecimal number), but may be further overriden by DevelopmentModule or
        // QaModule.
        configuration.override(SymbolConstants.APPLICATION_VERSION, ""1.0-SNAPSHOT"");
    }",method,
"    public static void contributeApplicationDefaults(
            MappedConfiguration<String, Object> configuration)
    {
        // Contributions to ApplicationDefaults will override any contributions to
        // FactoryDefaults (with the same key). Here we're restricting the supported
        // locales to just ""en"" (English). As you add localised message catalogs and other assets,
        // you can extend this list of locales (it's a comma separated series of locale names;
        // the first locale name is the default when there's no reasonable match).
        configuration.add(SymbolConstants.SUPPORTED_LOCALES, ""en"");
        configuration.add(SymbolConstants.OMIT_GENERATOR_META, true);
        configuration.add(SymbolConstants.INCLUDE_CORE_STACK, false);
        configuration.add(SymbolConstants.GZIP_COMPRESSION_ENABLED, false); 
    }",method,
"public class DesugarMainClassTest {
  @Test
  public void testVerifyLambdaDumpDirectoryRegistration() throws Exception {
    if (Strings.isNullOrEmpty(System.getProperty(LAMBDA_METAFACTORY_DUMPER_PROPERTY))) {
      testLambdaDumpDirSpecifiedInProgramFail();
    } else {
      testLambdaDumpDirPassSpecifiedInCmdPass();
    }
  }
  private void testLambdaDumpDirSpecifiedInProgramFail() throws Exception {
    // This lambda will fail the dump directory registration, which is intended.
    Supplier<Path> supplier =
        () -> {
          Path path = Paths.get(""."").toAbsolutePath();
          System.setProperty(LAMBDA_METAFACTORY_DUMPER_PROPERTY, path.toString());
          return path;
        };
    try {
      Desugar.verifyLambdaDumpDirectoryRegistered(supplier.get());
      fail(""Expected NullPointerException"");
    } catch (NullPointerException e) {
      // Expected
    }
  }
  private void testLambdaDumpDirPassSpecifiedInCmdPass() throws IOException {
    // The following lambda ensures that the LambdaMetafactory is loaded at the beggining of this
    // test, so that the dump directory can be registered.
    Supplier<Path> supplier =
        () -> {
          try {
            return Desugar.createAndRegisterLambdaDumpDirectory();
          } catch (IOException e) {
            throw new IOError(e);
          }
        };
    Path dumpDirectory = supplier.get();
    assertThat(dumpDirectory.toAbsolutePath().toString())
        .isEqualTo(
            Paths.get(System.getProperty(LAMBDA_METAFACTORY_DUMPER_PROPERTY))
                .toAbsolutePath()
                .toString());
    Desugar.verifyLambdaDumpDirectoryRegistered(dumpDirectory);
  }
}",class,
"  @Test
  public void testVerifyLambdaDumpDirectoryRegistration() throws Exception {
    if (Strings.isNullOrEmpty(System.getProperty(LAMBDA_METAFACTORY_DUMPER_PROPERTY))) {
      testLambdaDumpDirSpecifiedInProgramFail();
    } else {
      testLambdaDumpDirPassSpecifiedInCmdPass();
    }
  }",method,
"  private void testLambdaDumpDirSpecifiedInProgramFail() throws Exception {
    // This lambda will fail the dump directory registration, which is intended.
    Supplier<Path> supplier =
        () -> {
          Path path = Paths.get(""."").toAbsolutePath();
          System.setProperty(LAMBDA_METAFACTORY_DUMPER_PROPERTY, path.toString());
          return path;
        };
    try {
      Desugar.verifyLambdaDumpDirectoryRegistered(supplier.get());
      fail(""Expected NullPointerException"");
    } catch (NullPointerException e) {
      // Expected
    }
  }",method,
"  private void testLambdaDumpDirPassSpecifiedInCmdPass() throws IOException {
    // The following lambda ensures that the LambdaMetafactory is loaded at the beggining of this
    // test, so that the dump directory can be registered.
    Supplier<Path> supplier =
        () -> {
          try {
            return Desugar.createAndRegisterLambdaDumpDirectory();
          } catch (IOException e) {
            throw new IOError(e);
          }
        };
    Path dumpDirectory = supplier.get();
    assertThat(dumpDirectory.toAbsolutePath().toString())
        .isEqualTo(
            Paths.get(System.getProperty(LAMBDA_METAFACTORY_DUMPER_PROPERTY))
                .toAbsolutePath()
                .toString());
    Desugar.verifyLambdaDumpDirectoryRegistered(dumpDirectory);
  }",method,
"public class PopupDispatcher implements AWTEventListener, KeyEventDispatcher, IdePopupEventDispatcher {
  private static WizardPopup ourActiveWizardRoot;
  private static WizardPopup ourShowingStep;
  private static final PopupDispatcher ourInstance = new PopupDispatcher();
  static {
    if (System.getProperty(""is.popup.test"") != null ||
      (ApplicationManagerEx.getApplicationEx() != null && ApplicationManagerEx.getApplicationEx().isUnitTestMode())) {
      Toolkit.getDefaultToolkit().addAWTEventListener(ourInstance, MouseEvent.MOUSE_PRESSED);
      KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(ourInstance);
    }
  }
  private PopupDispatcher() {
  }
  public static PopupDispatcher getInstance() {
    return ourInstance;
  }
  public static void setActiveRoot(WizardPopup aRootPopup) {
    disposeActiveWizard();
    ourActiveWizardRoot = aRootPopup;
    ourShowingStep = aRootPopup;
    if (ApplicationManager.getApplication() != null) {
      IdeEventQueue.getInstance().getPopupManager().push(ourInstance);
    }
  }
  public static void clearRootIfNeeded(WizardPopup aRootPopup) {
    if (ourActiveWizardRoot == aRootPopup) {
      ourActiveWizardRoot = null;
      ourShowingStep = null;
      if (ApplicationManager.getApplication() != null) {
        IdeEventQueue.getInstance().getPopupManager().remove(ourInstance);
      }
    }
  }
  public void eventDispatched(AWTEvent event) {
    dispatchMouseEvent(event);
  }
  private boolean dispatchMouseEvent(AWTEvent event) {
    if (event.getID() != MouseEvent.MOUSE_PRESSED) {
      return false;
    }
    if (ourShowingStep == null) {
      return false;
    }
    WizardPopup eachParent = ourShowingStep;
    final MouseEvent mouseEvent = ((MouseEvent) event);
    Point point = (Point) mouseEvent.getPoint().clone();
    SwingUtilities.convertPointToScreen(point, mouseEvent.getComponent());
    while (true) {
      JComponent content = eachParent.getContent();
      if (content == null || !content.isShowing()) {
        getActiveRoot().cancel();
        return false;
      }
      if (eachParent.getBounds().contains(point) || !eachParent.canClose()) {
        return false;
      }
      eachParent = eachParent.getParent();
      if (eachParent == null) {
        getActiveRoot().cancel();
        return false;
      }
    }
  }
  public static boolean disposeActiveWizard() {
    if (ourActiveWizardRoot != null) {
      ourActiveWizardRoot.disposeChildren();
      Disposer.dispose(ourActiveWizardRoot);
      return true;
    }
    return false;
  }
  public boolean dispatchKeyEvent(final KeyEvent e) {
    if (ourShowingStep == null) {
      return false;
    }
    return ourShowingStep.dispatch(e);
  }
  public static void setShowing(WizardPopup aBaseWizardPopup) {
    ourShowingStep = aBaseWizardPopup;
  }
  public static void unsetShowing(WizardPopup aBaseWizardPopup) {
    if (ourActiveWizardRoot != null) {
      for (WizardPopup wp = aBaseWizardPopup; wp != null; wp = wp.getParent()) {
        if (wp == ourActiveWizardRoot) {
          ourShowingStep = aBaseWizardPopup.getParent();
          return;
        }
      }
    }
   }
  public static WizardPopup getActiveRoot() {
    return ourActiveWizardRoot;
  }
  public static boolean isWizardShowing() {
    return ourActiveWizardRoot != null;
  }
  public Component getComponent() {
    return ourShowingStep != null ? ourShowingStep.getContent() : null;
  }
  @Nullable
  @Override
  public Stream<JBPopup> getPopupStream() {
    return Stream.of(ourActiveWizardRoot);
  }
  public boolean dispatch(AWTEvent event) {
   if (event instanceof KeyEvent) {
      return dispatchKeyEvent(((KeyEvent) event));
   } else if (event instanceof MouseEvent) {
     return dispatchMouseEvent(event);
   } else {
     return false;
   }
  }
  public boolean requestFocus() {
    if (ourShowingStep != null) {
      ourShowingStep.requestFocus();
    }
    return true;
  }
  public boolean close() {
    final String s = ""sdfsf"";
    return disposeActiveWizard();
  }
  @Override
  public void setRestoreFocusSilentely() {}
}",class,
"  private PopupDispatcher() {
  }",method,
"  public static PopupDispatcher getInstance() {
    return ourInstance;
  }",method,
"  public static void setActiveRoot(WizardPopup aRootPopup) {
    disposeActiveWizard();
    ourActiveWizardRoot = aRootPopup;
    ourShowingStep = aRootPopup;
    if (ApplicationManager.getApplication() != null) {
      IdeEventQueue.getInstance().getPopupManager().push(ourInstance);
    }
  }",method,
"  public static void clearRootIfNeeded(WizardPopup aRootPopup) {
    if (ourActiveWizardRoot == aRootPopup) {
      ourActiveWizardRoot = null;
      ourShowingStep = null;
      if (ApplicationManager.getApplication() != null) {
        IdeEventQueue.getInstance().getPopupManager().remove(ourInstance);
      }
    }
  }",method,
"    if (ourActiveWizardRoot == aRootPopup) {
      ourActiveWizardRoot = null;
      ourShowingStep = null;
      if (ApplicationManager.getApplication() != null) {
        IdeEventQueue.getInstance().getPopupManager().remove(ourInstance);
      }
    }",method,
"  public void eventDispatched(AWTEvent event) {
    dispatchMouseEvent(event);
  }",method,
"  private boolean dispatchMouseEvent(AWTEvent event) {
    if (event.getID() != MouseEvent.MOUSE_PRESSED) {
      return false;
    }
    if (ourShowingStep == null) {
      return false;
    }
    WizardPopup eachParent = ourShowingStep;
    final MouseEvent mouseEvent = ((MouseEvent) event);
    Point point = (Point) mouseEvent.getPoint().clone();
    SwingUtilities.convertPointToScreen(point, mouseEvent.getComponent());
    while (true) {
      JComponent content = eachParent.getContent();
      if (content == null || !content.isShowing()) {
        getActiveRoot().cancel();
        return false;
      }
      if (eachParent.getBounds().contains(point) || !eachParent.canClose()) {
        return false;
      }
      eachParent = eachParent.getParent();
      if (eachParent == null) {
        getActiveRoot().cancel();
        return false;
      }
    }
  }",method,
"    if (ourShowingStep == null) {
      return false;
    }",method,
"    while (true) {
      JComponent content = eachParent.getContent();
      if (content == null || !content.isShowing()) {
        getActiveRoot().cancel();
        return false;
      }
      if (eachParent.getBounds().contains(point) || !eachParent.canClose()) {
        return false;
      }
      eachParent = eachParent.getParent();
      if (eachParent == null) {
        getActiveRoot().cancel();
        return false;
      }
    }",method,
"      if (eachParent == null) {
        getActiveRoot().cancel();
        return false;
      }",method,
"  public static boolean disposeActiveWizard() {
    if (ourActiveWizardRoot != null) {
      ourActiveWizardRoot.disposeChildren();
      Disposer.dispose(ourActiveWizardRoot);
      return true;
    }
    return false;
  }",method,
"    if (ourActiveWizardRoot != null) {
      ourActiveWizardRoot.disposeChildren();
      Disposer.dispose(ourActiveWizardRoot);
      return true;
    }",method,
"  public boolean dispatchKeyEvent(final KeyEvent e) {
    if (ourShowingStep == null) {
      return false;
    }
    return ourShowingStep.dispatch(e);
  }",method,
"    if (ourShowingStep == null) {
      return false;
    }",method,
"  public static void setShowing(WizardPopup aBaseWizardPopup) {
    ourShowingStep = aBaseWizardPopup;
  }",method,
"  public static void unsetShowing(WizardPopup aBaseWizardPopup) {
    if (ourActiveWizardRoot != null) {
      for (WizardPopup wp = aBaseWizardPopup; wp != null; wp = wp.getParent()) {
        if (wp == ourActiveWizardRoot) {
          ourShowingStep = aBaseWizardPopup.getParent();
          return;
        }
      }
    }
   }",method,
"    if (ourActiveWizardRoot != null) {
      for (WizardPopup wp = aBaseWizardPopup; wp != null; wp = wp.getParent()) {
        if (wp == ourActiveWizardRoot) {
          ourShowingStep = aBaseWizardPopup.getParent();
          return;
        }
      }
    }",method,
"        if (wp == ourActiveWizardRoot) {
          ourShowingStep = aBaseWizardPopup.getParent();
          return;
        }",method,
"  public static WizardPopup getActiveRoot() {
    return ourActiveWizardRoot;
  }",method,
"  public static boolean isWizardShowing() {
    return ourActiveWizardRoot != null;
  }",method,
"  public Component getComponent() {
    return ourShowingStep != null ? ourShowingStep.getContent() : null;
  }",method,
"  @Nullable
  @Override
  public Stream<JBPopup> getPopupStream() {
    return Stream.of(ourActiveWizardRoot);
  }",method,
"  public boolean dispatch(AWTEvent event) {
   if (event instanceof KeyEvent) {
      return dispatchKeyEvent(((KeyEvent) event));
   } else if (event instanceof MouseEvent) {
     return dispatchMouseEvent(event);
   } else {
     return false;
   }
  }",method,
"   if (event instanceof KeyEvent) {
      return dispatchKeyEvent(((KeyEvent) event));
   }",method,
"  public boolean requestFocus() {
    if (ourShowingStep != null) {
      ourShowingStep.requestFocus();
    }
    return true;
  }",method,
"    if (ourShowingStep != null) {
      ourShowingStep.requestFocus();
    }",method,
"  public boolean close() {
    final String s = ""sdfsf"";
    return disposeActiveWizard();
  }",method,
"  @Override
  public void setRestoreFocusSilentely() {}",method,
"public class GradleBuildComparison {
    private static final String SOURCE_FILESTORE_PREFIX = ""source"";
    private static final String TARGET_FILESTORE_PREFIX = ""target"";
    public static final String HTML_REPORT_FILE_NAME = ""index.html"";
    private static final String FILES_DIR_NAME = ""files"";
    private final ComparableGradleBuildExecuter sourceBuildExecuter;
    private final ComparableGradleBuildExecuter targetBuildExecuter;
    private final DefaultBuildOutcomeComparatorFactory outcomeComparatorFactory = new DefaultBuildOutcomeComparatorFactory();
    private final List<BuildOutcomeAssociator> outcomeAssociators = new LinkedList<BuildOutcomeAssociator>();
    private final DefaultBuildOutcomeComparisonResultRendererFactory<HtmlRenderContext> comparisonResultRenderers = new DefaultBuildOutcomeComparisonResultRendererFactory<HtmlRenderContext>(HtmlRenderContext.class);
    private final DefaultBuildOutcomeRendererFactory<HtmlRenderContext> outcomeRenderers = new DefaultBuildOutcomeRendererFactory<HtmlRenderContext>(HtmlRenderContext.class);
    private final Logger logger;
    private final ProgressLogger progressLogger;
    private final Gradle gradle;
    public GradleBuildComparison(
            ComparableGradleBuildExecuter sourceBuildExecuter,
            ComparableGradleBuildExecuter targetBuildExecuter,
            Logger logger,
            ProgressLogger progressLogger,
            Gradle gradle) {
        this.sourceBuildExecuter = sourceBuildExecuter;
        this.targetBuildExecuter = targetBuildExecuter;
        this.logger = logger;
        this.progressLogger = progressLogger;
        this.gradle = gradle;
    }
    public <T extends BuildOutcome, R extends BuildOutcomeComparisonResult<T>> void registerType(
            Class<T> outcomeType,
            BuildOutcomeComparator<T, R> outcomeComparator,
            BuildOutcomeComparisonResultRenderer<R, HtmlRenderContext> comparisonResultRenderer,
            BuildOutcomeRenderer<T, HtmlRenderContext> outcomeRenderer
    ) {
        outcomeComparatorFactory.registerComparator(outcomeComparator);
        comparisonResultRenderers.registerRenderer(comparisonResultRenderer);
        outcomeRenderers.registerRenderer(outcomeRenderer);
        outcomeAssociators.add(new ByTypeAndNameBuildOutcomeAssociator<T>(outcomeType));
    }
    private String executingMessage(String name, ComparableGradleBuildExecuter executer) {
        return String.format(""executing %s build %s"", name, executer.getSpec());
    }
    public BuildComparisonResult compare(FileStore<String> fileStore, File reportDir, Map<String, String> hostAttributes) {
        String executingSourceBuildMessage = executingMessage(""source"", sourceBuildExecuter);
        String executingTargetBuildMessage = executingMessage(""target"", targetBuildExecuter);
        if (!sourceBuildExecuter.isExecutable() || !targetBuildExecuter.isExecutable()) {
            throw new GradleException(String.format(
                    ""Builds must be executed with %s or newer (source: %s, target: %s)"",
                    ComparableGradleBuildExecuter.EXEC_MINIMUM_VERSION,
                    sourceBuildExecuter.getSpec().getGradleVersion(),
                    targetBuildExecuter.getSpec().getGradleVersion()
            ));
        }
        Set<BuildOutcome> sourceOutcomes;
        logger.info(executingSourceBuildMessage);
        progressLogger.started(executingSourceBuildMessage);
        ProjectOutcomes sourceOutput = executeBuild(sourceBuildExecuter);
        progressLogger.progress(""inspecting source build outcomes"");
        GradleBuildOutcomeSetTransformer sourceOutcomeTransformer = createOutcomeSetTransformer(fileStore, SOURCE_FILESTORE_PREFIX);
        sourceOutcomes = sourceOutcomeTransformer.transform(sourceOutput);
        logger.info(executingTargetBuildMessage);
        progressLogger.progress(executingTargetBuildMessage);
        ProjectOutcomes targetOutput = executeBuild(targetBuildExecuter);
        Set<BuildOutcome> targetOutcomes;
        progressLogger.progress(""inspecting target build outcomes"");
        GradleBuildOutcomeSetTransformer targetOutcomeTransformer = createOutcomeSetTransformer(fileStore, TARGET_FILESTORE_PREFIX);
        targetOutcomes = targetOutcomeTransformer.transform(targetOutput);
        progressLogger.progress(""comparing build outcomes"");
        BuildComparisonResult result = compareBuilds(sourceOutcomes, targetOutcomes);
        writeReport(result, reportDir, fileStore, hostAttributes);
        progressLogger.completed();
        return result;
    }
    private BuildComparisonResult compareBuilds(Set<BuildOutcome> sourceOutcomes, Set<BuildOutcome> targetOutcomes) {
        BuildComparisonSpecFactory specFactory = new BuildComparisonSpecFactory(createBuildOutcomeAssociator());
        BuildComparisonSpec comparisonSpec = specFactory.createSpec(sourceOutcomes, targetOutcomes);
        BuildComparator buildComparator = new DefaultBuildComparator(outcomeComparatorFactory);
        return buildComparator.compareBuilds(comparisonSpec);
    }
    private CompositeBuildOutcomeAssociator createBuildOutcomeAssociator() {
        return new CompositeBuildOutcomeAssociator(outcomeAssociators);
    }
    private GradleBuildOutcomeSetTransformer createOutcomeSetTransformer(FileStore<String> fileStore, String filesPath) {
        return new GradleBuildOutcomeSetTransformer(fileStore, filesPath);
    }
    private ProjectOutcomes executeBuild(ComparableGradleBuildExecuter executer) {
        ProjectConnection connection = createProjectConnection(executer);
        try {
            return executer.executeWith(connection);
        } finally {
            connection.close();
        }
    }
    private ProjectConnection createProjectConnection(ComparableGradleBuildExecuter executer) {
        DefaultGradleConnector connector = (DefaultGradleConnector) GradleConnector.newConnector();
        connector.forProjectDirectory(executer.getSpec().getProjectDir());
        connector.searchUpwards(false);
        File gradleUserHomeDir = gradle.getStartParameter().getGradleUserHomeDir();
        if (gradleUserHomeDir != null) {
            connector.useGradleUserHomeDir(gradleUserHomeDir);
        }
        GradleVersion gradleVersion = executer.getGradleVersion();
        if (gradleVersion.equals(GradleVersion.current())) {
            connector.useInstallation(gradle.getGradleHomeDir());
        } else {
            connector.useGradleVersion(gradleVersion.getVersion());
        }
        return connector.connect();
    }
    private void writeReport(final BuildComparisonResult result, final File reportDir, FileStore<String> fileStore, final Map<String, String> hostAttributes) {
        if (reportDir.exists() && reportDir.list().length > 0) {
            GFileUtils.cleanDirectory(reportDir);
        }
        fileStore.moveFilestore(new File(reportDir, FILES_DIR_NAME));
        final Charset encoding = Charset.defaultCharset();
        IoActions.writeTextFile(new File(reportDir, HTML_REPORT_FILE_NAME), encoding.name(), new Action<BufferedWriter>() {
            public void execute(BufferedWriter writer) {
                createResultRenderer(encoding, reportDir, hostAttributes).render(result, writer);
            }
        });
    }
    private BuildComparisonResultRenderer<Writer> createResultRenderer(Charset encoding, final File reportDir, final Map<String, String> hostAttributes) {
        return new GradleBuildComparisonResultHtmlRenderer(
                comparisonResultRenderers,
                outcomeRenderers,
                encoding,
                sourceBuildExecuter,
                targetBuildExecuter,
                hostAttributes,
                new Transformer<String, File>() {
                    public String transform(File original) {
                        return RelativePathUtil.relativePath(reportDir, original);
                    }
                }
        );
    }
}",class,
"    public GradleBuildComparison(
            ComparableGradleBuildExecuter sourceBuildExecuter,
            ComparableGradleBuildExecuter targetBuildExecuter,
            Logger logger,
            ProgressLogger progressLogger,
            Gradle gradle) {
        this.sourceBuildExecuter = sourceBuildExecuter;
        this.targetBuildExecuter = targetBuildExecuter;
        this.logger = logger;
        this.progressLogger = progressLogger;
        this.gradle = gradle;
    }",method,
"    public <T extends BuildOutcome, R extends BuildOutcomeComparisonResult<T>> void registerType(
            Class<T> outcomeType,
            BuildOutcomeComparator<T, R> outcomeComparator,
            BuildOutcomeComparisonResultRenderer<R, HtmlRenderContext> comparisonResultRenderer,
            BuildOutcomeRenderer<T, HtmlRenderContext> outcomeRenderer
    ) {
        outcomeComparatorFactory.registerComparator(outcomeComparator);
        comparisonResultRenderers.registerRenderer(comparisonResultRenderer);
        outcomeRenderers.registerRenderer(outcomeRenderer);
        outcomeAssociators.add(new ByTypeAndNameBuildOutcomeAssociator<T>(outcomeType));
    }",method,
"    private String executingMessage(String name, ComparableGradleBuildExecuter executer) {
        return String.format(""executing %s build %s"", name, executer.getSpec());
    }",method,
"    public BuildComparisonResult compare(FileStore<String> fileStore, File reportDir, Map<String, String> hostAttributes) {
        String executingSourceBuildMessage = executingMessage(""source"", sourceBuildExecuter);
        String executingTargetBuildMessage = executingMessage(""target"", targetBuildExecuter);
        if (!sourceBuildExecuter.isExecutable() || !targetBuildExecuter.isExecutable()) {
            throw new GradleException(String.format(
                    ""Builds must be executed with %s or newer (source: %s, target: %s)"",
                    ComparableGradleBuildExecuter.EXEC_MINIMUM_VERSION,
                    sourceBuildExecuter.getSpec().getGradleVersion(),
                    targetBuildExecuter.getSpec().getGradleVersion()
            ));
        }
        Set<BuildOutcome> sourceOutcomes;
        logger.info(executingSourceBuildMessage);
        progressLogger.started(executingSourceBuildMessage);
        ProjectOutcomes sourceOutput = executeBuild(sourceBuildExecuter);
        progressLogger.progress(""inspecting source build outcomes"");
        GradleBuildOutcomeSetTransformer sourceOutcomeTransformer = createOutcomeSetTransformer(fileStore, SOURCE_FILESTORE_PREFIX);
        sourceOutcomes = sourceOutcomeTransformer.transform(sourceOutput);
        logger.info(executingTargetBuildMessage);
        progressLogger.progress(executingTargetBuildMessage);
        ProjectOutcomes targetOutput = executeBuild(targetBuildExecuter);
        Set<BuildOutcome> targetOutcomes;
        progressLogger.progress(""inspecting target build outcomes"");
        GradleBuildOutcomeSetTransformer targetOutcomeTransformer = createOutcomeSetTransformer(fileStore, TARGET_FILESTORE_PREFIX);
        targetOutcomes = targetOutcomeTransformer.transform(targetOutput);
        progressLogger.progress(""comparing build outcomes"");
        BuildComparisonResult result = compareBuilds(sourceOutcomes, targetOutcomes);
        writeReport(result, reportDir, fileStore, hostAttributes);
        progressLogger.completed();
        return result;
    }",method,
"    private BuildComparisonResult compareBuilds(Set<BuildOutcome> sourceOutcomes, Set<BuildOutcome> targetOutcomes) {
        BuildComparisonSpecFactory specFactory = new BuildComparisonSpecFactory(createBuildOutcomeAssociator());
        BuildComparisonSpec comparisonSpec = specFactory.createSpec(sourceOutcomes, targetOutcomes);
        BuildComparator buildComparator = new DefaultBuildComparator(outcomeComparatorFactory);
        return buildComparator.compareBuilds(comparisonSpec);
    }",method,
"    private CompositeBuildOutcomeAssociator createBuildOutcomeAssociator() {
        return new CompositeBuildOutcomeAssociator(outcomeAssociators);
    }",method,
"    private GradleBuildOutcomeSetTransformer createOutcomeSetTransformer(FileStore<String> fileStore, String filesPath) {
        return new GradleBuildOutcomeSetTransformer(fileStore, filesPath);
    }",method,
"    private ProjectOutcomes executeBuild(ComparableGradleBuildExecuter executer) {
        ProjectConnection connection = createProjectConnection(executer);
        try {
            return executer.executeWith(connection);
        } finally {
            connection.close();
        }
    }",method,
"    private ProjectConnection createProjectConnection(ComparableGradleBuildExecuter executer) {
        DefaultGradleConnector connector = (DefaultGradleConnector) GradleConnector.newConnector();
        connector.forProjectDirectory(executer.getSpec().getProjectDir());
        connector.searchUpwards(false);
        File gradleUserHomeDir = gradle.getStartParameter().getGradleUserHomeDir();
        if (gradleUserHomeDir != null) {
            connector.useGradleUserHomeDir(gradleUserHomeDir);
        }
        GradleVersion gradleVersion = executer.getGradleVersion();
        if (gradleVersion.equals(GradleVersion.current())) {
            connector.useInstallation(gradle.getGradleHomeDir());
        } else {
            connector.useGradleVersion(gradleVersion.getVersion());
        }
        return connector.connect();
    }",method,
"        if (gradleUserHomeDir != null) {
            connector.useGradleUserHomeDir(gradleUserHomeDir);
        }",method,
"    private void writeReport(final BuildComparisonResult result, final File reportDir, FileStore<String> fileStore, final Map<String, String> hostAttributes) {
        if (reportDir.exists() && reportDir.list().length > 0) {
            GFileUtils.cleanDirectory(reportDir);
        }
        fileStore.moveFilestore(new File(reportDir, FILES_DIR_NAME));
        final Charset encoding = Charset.defaultCharset();
        IoActions.writeTextFile(new File(reportDir, HTML_REPORT_FILE_NAME), encoding.name(), new Action<BufferedWriter>() {
            public void execute(BufferedWriter writer) {
                createResultRenderer(encoding, reportDir, hostAttributes).render(result, writer);
            }
        });
    }",method,
"            public void execute(BufferedWriter writer) {
                createResultRenderer(encoding, reportDir, hostAttributes).render(result, writer);
            }",method,
"    private BuildComparisonResultRenderer<Writer> createResultRenderer(Charset encoding, final File reportDir, final Map<String, String> hostAttributes) {
        return new GradleBuildComparisonResultHtmlRenderer(
                comparisonResultRenderers,
                outcomeRenderers,
                encoding,
                sourceBuildExecuter,
                targetBuildExecuter,
                hostAttributes,
                new Transformer<String, File>() {
                    public String transform(File original) {
                        return RelativePathUtil.relativePath(reportDir, original);
                    }
                }
        );
    }",method,
"        return new GradleBuildComparisonResultHtmlRenderer(
                comparisonResultRenderers,
                outcomeRenderers,
                encoding,
                sourceBuildExecuter,
                targetBuildExecuter,
                hostAttributes,
                new Transformer<String, File>() {
                    public String transform(File original) {
                        return RelativePathUtil.relativePath(reportDir, original);
                    }
                }",method,
"                    public String transform(File original) {
                        return RelativePathUtil.relativePath(reportDir, original);
                    }",method,
"public class CloudTest implements Runnable {   
    private class NomadsAppThread extends Thread {
	CloudTest client; //Replace with current class name
	public NomadsAppThread(CloudTest _client) {
	    client = _client;
	}
	public void run()    {			
	    NGlobals.lPrint(""NomadsAppThread -> run()"");
	    while (true)  {
		client.handle();
	    }
	}
    }
    private Thread       thread = null;
    NSand cloudTestSand;
    private NomadsAppThread nThread;
    Random randNum;
    URL imgWebBase;
    Thread runner;
    String cloudString[] = new String[31];
    int tNum, tNumL;
    public static void main(String args[])
    {
	CloudTest  applet = null;
	applet = new CloudTest();
    }
    public void init()
    {  	
	int i;
	NGlobals.cPrint(""CloudTest -> init()"");
	i=0;
	cloudString[i++] = new String(""loud"");
	cloudString[i++] = new String(""quiet"");
	cloudString[i++] = new String(""wierd"");
	cloudString[i++] = new String(""buzzy"");
	cloudString[i++] = new String(""harmonic"");
	cloudString[i++] = new String(""melody"");
	cloudString[i++] = new String(""Radiohead"");
	cloudString[i++] = new String(""RJD2"");
	cloudString[i++] = new String(""sine wave"");
	cloudString[i++] = new String(""square wave"");
	cloudString[i++] = new String(""FM synthesis"");
	cloudString[i++] = new String(""Max Matthews"");
	cloudString[i++] = new String(""Additive Synthesis"");
	cloudString[i++] = new String(""rave"");
	cloudString[i++] = new String(""techno"");
	cloudString[i++] = new String(""Moby"");
	cloudString[i++] = new String(""funky"");
	cloudString[i++] = new String(""groovy"");
	cloudString[i++] = new String(""wow"");
	cloudString[i++] = new String(""cool"");
	cloudString[i++] = new String(""dance"");
	cloudString[i++] = new String(""trippy"");
	cloudString[i++] = new String(""DEADMAU5"");
	cloudString[i++] = new String(""metal"");
	cloudString[i++] = new String(""new age"");
	cloudString[i++] = new String(""science"");
	cloudString[i++] = new String(""computers"");
	cloudString[i++] = new String(""NOMADS"");
	cloudString[i++] = new String(""crank"");
	cloudString[i++] = new String(""rap"");
	cloudString[i++] = new String(""reggae"");
	cloudTestSand = new NSand(); 
	cloudTestSand.connect();
	int d[] = new int[1];
	d[0] = 0;
	nThread = new NomadsAppThread(this);
	nThread.start();
	cloudTestSand.sendGrain((byte)NAppID.BINDLE, (byte)NCommand.REGISTER, (byte)NDataType.UINT8, 1, d );
	String tString = new String(""testCloud"");
	int tLen = tString.length();
	byte[] tStringAsBytes = tString.getBytes();
	cloudTestSand.sendGrain((byte)NAppID.BINDLE, (byte)NCommand.LOGIN, (byte)NDataType.CHAR, tLen, tStringAsBytes );
    }	
    public CloudTest() {  	    
	randNum = new Random();
	init();
	start();
    }
    public void start()  {  
	NGlobals.cPrint(""CloudTest -> start()"");
	runner = new Thread(this);
	runner.start();
    }
    public void stop() {  
	if (thread != null)  {  
	    thread.stop(); 
	    thread = null;
	}
    }
    public void run () {
	NGlobals.cPrint(""CloudTest -> run()"");
	int i = 0;
	while (true) {
	    String tString;
	    // if (i>500) {
	    // 	tString = new String(""RESETTING CLOUD TEST STRING"");
	    // 	i=0;
	    // }
	    // else {
	    // 	tString = new String(""CLOUD TEST "" + i++);
	    // }
	    tNumL = tNum;
	    System.out.println(""tNumL = "" + tNumL);
	    tNum = randNum.nextInt(15)+randNum.nextInt(16);
	    while (tNum == tNumL) {
		tNum = randNum.nextInt(15)+randNum.nextInt(16);
		System.out.println(""tNum = "" + tNum);
	    }
	    System.out.println(""#tNum = "" + tNum);
	    tString = new String(cloudString[tNum]);
	    int tLen = tString.length();
	    byte[] tBytes = tString.getBytes();
	    try {
		NGlobals.cPrint(""CloudTest -> NSand.send()"");
		cloudTestSand.sendGrain((byte)NAppID.CLOUD_CHAT, (byte)NCommand.SEND_MESSAGE, (byte)NDataType.CHAR, tLen, tBytes );
		runner.sleep(500);
	    }
	    catch (InterruptedException ie) {}
	}
    }
    public void handle() {
	NGrain grain;
	NGlobals.cPrint(""CloudTest -> handle()"");
	grain = cloudTestSand.getGrain();
	grain.print();
	System.out.println(""CloudTest handle()"");
    }
}",class,
"    private class NomadsAppThread extends Thread {
	CloudTest client; //Replace with current class name
	public NomadsAppThread(CloudTest _client) {
	    client = _client;
	}
	public void run()    {			
	    NGlobals.lPrint(""NomadsAppThread -> run()"");
	    while (true)  {
		client.handle();
	    }
	}
    }",class,
"	CloudTest client; //Replace with current class name
	public NomadsAppThread(CloudTest _client) {
	    client = _client;
	}",class,
"	public NomadsAppThread(CloudTest _client) {
	    client = _client;
	}",method,
"	public void run()    {			
	    NGlobals.lPrint(""NomadsAppThread -> run()"");
	    while (true)  {
		client.handle();
	    }
	}",method,
"	    while (true)  {
		client.handle();
	    }",method,
"    public static void main(String args[])
    {
	CloudTest  applet = null;
	applet = new CloudTest();
    }",method,
"    public void init()
    {  	
	int i;
	NGlobals.cPrint(""CloudTest -> init()"");
	i=0;
	cloudString[i++] = new String(""loud"");
	cloudString[i++] = new String(""quiet"");
	cloudString[i++] = new String(""wierd"");
	cloudString[i++] = new String(""buzzy"");
	cloudString[i++] = new String(""harmonic"");
	cloudString[i++] = new String(""melody"");
	cloudString[i++] = new String(""Radiohead"");
	cloudString[i++] = new String(""RJD2"");
	cloudString[i++] = new String(""sine wave"");
	cloudString[i++] = new String(""square wave"");
	cloudString[i++] = new String(""FM synthesis"");
	cloudString[i++] = new String(""Max Matthews"");
	cloudString[i++] = new String(""Additive Synthesis"");
	cloudString[i++] = new String(""rave"");
	cloudString[i++] = new String(""techno"");
	cloudString[i++] = new String(""Moby"");
	cloudString[i++] = new String(""funky"");
	cloudString[i++] = new String(""groovy"");
	cloudString[i++] = new String(""wow"");
	cloudString[i++] = new String(""cool"");
	cloudString[i++] = new String(""dance"");
	cloudString[i++] = new String(""trippy"");
	cloudString[i++] = new String(""DEADMAU5"");
	cloudString[i++] = new String(""metal"");
	cloudString[i++] = new String(""new age"");
	cloudString[i++] = new String(""science"");
	cloudString[i++] = new String(""computers"");
	cloudString[i++] = new String(""NOMADS"");
	cloudString[i++] = new String(""crank"");
	cloudString[i++] = new String(""rap"");
	cloudString[i++] = new String(""reggae"");
	cloudTestSand = new NSand(); 
	cloudTestSand.connect();
	int d[] = new int[1];
	d[0] = 0;
	nThread = new NomadsAppThread(this);
	nThread.start();
	cloudTestSand.sendGrain((byte)NAppID.BINDLE, (byte)NCommand.REGISTER, (byte)NDataType.UINT8, 1, d );
	String tString = new String(""testCloud"");
	int tLen = tString.length();
	byte[] tStringAsBytes = tString.getBytes();
	cloudTestSand.sendGrain((byte)NAppID.BINDLE, (byte)NCommand.LOGIN, (byte)NDataType.CHAR, tLen, tStringAsBytes );
    }",method,
"    public CloudTest() {  	    
	randNum = new Random();
	init();
	start();
    }",method,
"    public void start()  {  
	NGlobals.cPrint(""CloudTest -> start()"");
	runner = new Thread(this);
	runner.start();
    }",method,
"    public void stop() {  
	if (thread != null)  {  
	    thread.stop(); 
	    thread = null;
	}
    }",method,
"	if (thread != null)  {  
	    thread.stop(); 
	    thread = null;
	}",method,
"    public void run () {
	NGlobals.cPrint(""CloudTest -> run()"");
	int i = 0;
	while (true) {
	    String tString;
	    // if (i>500) {
	    // 	tString = new String(""RESETTING CLOUD TEST STRING"");
	    // 	i=0;
	    // }
	    // else {
	    // 	tString = new String(""CLOUD TEST "" + i++);
	    // }
	    tNumL = tNum;
	    System.out.println(""tNumL = "" + tNumL);
	    tNum = randNum.nextInt(15)+randNum.nextInt(16);
	    while (tNum == tNumL) {
		tNum = randNum.nextInt(15)+randNum.nextInt(16);
		System.out.println(""tNum = "" + tNum);
	    }
	    System.out.println(""#tNum = "" + tNum);
	    tString = new String(cloudString[tNum]);
	    int tLen = tString.length();
	    byte[] tBytes = tString.getBytes();
	    try {
		NGlobals.cPrint(""CloudTest -> NSand.send()"");
		cloudTestSand.sendGrain((byte)NAppID.CLOUD_CHAT, (byte)NCommand.SEND_MESSAGE, (byte)NDataType.CHAR, tLen, tBytes );
		runner.sleep(500);
	    }
	    catch (InterruptedException ie) {}
	}
    }",method,
"	while (true) {
	    String tString;
	    // if (i>500) {
	    // 	tString = new String(""RESETTING CLOUD TEST STRING"");
	    // 	i=0;
	    // }
	    // else {
	    // 	tString = new String(""CLOUD TEST "" + i++);
	    // }
	    tNumL = tNum;
	    System.out.println(""tNumL = "" + tNumL);
	    tNum = randNum.nextInt(15)+randNum.nextInt(16);
	    while (tNum == tNumL) {
		tNum = randNum.nextInt(15)+randNum.nextInt(16);
		System.out.println(""tNum = "" + tNum);
	    }
	    System.out.println(""#tNum = "" + tNum);
	    tString = new String(cloudString[tNum]);
	    int tLen = tString.length();
	    byte[] tBytes = tString.getBytes();
	    try {
		NGlobals.cPrint(""CloudTest -> NSand.send()"");
		cloudTestSand.sendGrain((byte)NAppID.CLOUD_CHAT, (byte)NCommand.SEND_MESSAGE, (byte)NDataType.CHAR, tLen, tBytes );
		runner.sleep(500);
	    }
	    catch (InterruptedException ie) {}
	}",method,
"	    while (tNum == tNumL) {
		tNum = randNum.nextInt(15)+randNum.nextInt(16);
		System.out.println(""tNum = "" + tNum);
	    }",method,
	    catch (InterruptedException ie) {},method,
"    public void handle() {
	NGrain grain;
	NGlobals.cPrint(""CloudTest -> handle()"");
	grain = cloudTestSand.getGrain();
	grain.print();
	System.out.println(""CloudTest handle()"");
    }",method,
"public class AutoConfigurationReportLoggingInitializerTests {
	@Rule
	public OutputCapture outputCapture = new OutputCapture();
	private AutoConfigurationReportLoggingInitializer initializer = new AutoConfigurationReportLoggingInitializer();
	@Test
	public void logsDebugOnContextRefresh() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(Config.class);
		context.refresh();
		withDebugLogging(() -> this.initializer
				.onApplicationEvent(new ContextRefreshedEvent(context)));
		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
	}
	@Test
	public void logsDebugOnError() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(ErrorConfig.class);
		try {
			context.refresh();
			fail(""Did not error"");
		}
		catch (Exception ex) {
			withDebugLogging(
					() -> this.initializer.onApplicationEvent(new ApplicationFailedEvent(
							new SpringApplication(), new String[0], context, ex)));
		}
		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
	}
	@Test
	public void logsInfoOnErrorIfDebugDisabled() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(ErrorConfig.class);
		try {
			context.refresh();
			fail(""Did not error"");
		}
		catch (Exception ex) {
			this.initializer.onApplicationEvent(new ApplicationFailedEvent(
					new SpringApplication(), new String[0], context, ex));
		}
		assertThat(this.outputCapture.toString()).contains(""Error starting""
				+ "" ApplicationContext. To display the auto-configuration report re-run""
				+ "" your application with 'debug' enabled."");
	}
	@Test
	public void logsOutput() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(Config.class);
		ConditionEvaluationReport.get(context.getBeanFactory())
				.recordExclusions(Arrays.asList(""com.foo.Bar""));
		context.refresh();
		withDebugLogging(() -> this.initializer
				.onApplicationEvent(new ContextRefreshedEvent(context)));
		assertThat(this.outputCapture.toString())
				.contains(""not a servlet web application (OnWebApplicationCondition)"");
	}
	@Test
	public void canBeUsedInApplicationContext() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(Config.class);
		new AutoConfigurationReportLoggingInitializer().initialize(context);
		context.refresh();
		assertThat(context.getBean(ConditionEvaluationReport.class)).isNotNull();
	}
	@Test
	public void canBeUsedInNonGenericApplicationContext() throws Exception {
		AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
		context.setServletContext(new MockServletContext());
		context.register(Config.class);
		new AutoConfigurationReportLoggingInitializer().initialize(context);
		context.refresh();
		assertThat(context.getBean(ConditionEvaluationReport.class)).isNotNull();
	}
	@Test
	public void noErrorIfNotInitialized() throws Exception {
		this.initializer
				.onApplicationEvent(new ApplicationFailedEvent(new SpringApplication(),
						new String[0], null, new RuntimeException(""Planned"")));
		assertThat(this.outputCapture.toString())
				.contains(""Unable to provide auto-configuration report"");
	}
	private void withDebugLogging(Runnable runnable) {
		LoggerContext context = (LoggerContext) StaticLoggerBinder.getSingleton()
				.getLoggerFactory();
		Logger logger = context
				.getLogger(AutoConfigurationReportLoggingInitializer.class);
		Level currentLevel = logger.getLevel();
		logger.setLevel(Level.DEBUG);
		try {
			runnable.run();
		}
		finally {
			logger.setLevel(currentLevel);
		}
	}
	@Configuration
	@Import({ WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	static class Config {
	}
	@Configuration
	@Import(WebMvcAutoConfiguration.class)
	static class ErrorConfig {
		@Bean
		public String iBreak() {
			throw new RuntimeException();
		}
	}
}",class,
"	static class Config {
	}",class,
"	static class ErrorConfig {
		@Bean
		public String iBreak() {
			throw new RuntimeException();
		}
	}",class,
"	@Test
	public void logsDebugOnContextRefresh() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(Config.class);
		context.refresh();
		withDebugLogging(() -> this.initializer
				.onApplicationEvent(new ContextRefreshedEvent(context)));
		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
	}",method,
"	@Test
	public void logsDebugOnError() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(ErrorConfig.class);
		try {
			context.refresh();
			fail(""Did not error"");
		}
		catch (Exception ex) {
			withDebugLogging(
					() -> this.initializer.onApplicationEvent(new ApplicationFailedEvent(
							new SpringApplication(), new String[0], context, ex)));
		}
		assertThat(this.outputCapture.toString()).contains(""AUTO-CONFIGURATION REPORT"");
	}",method,
"		catch (Exception ex) {
			withDebugLogging(
					() -> this.initializer.onApplicationEvent(new ApplicationFailedEvent(
							new SpringApplication(), new String[0], context, ex)));
		}",method,
"	@Test
	public void logsInfoOnErrorIfDebugDisabled() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(ErrorConfig.class);
		try {
			context.refresh();
			fail(""Did not error"");
		}
		catch (Exception ex) {
			this.initializer.onApplicationEvent(new ApplicationFailedEvent(
					new SpringApplication(), new String[0], context, ex));
		}
		assertThat(this.outputCapture.toString()).contains(""Error starting""
				+ "" ApplicationContext. To display the auto-configuration report re-run""
				+ "" your application with 'debug' enabled."");
	}",method,
"		catch (Exception ex) {
			this.initializer.onApplicationEvent(new ApplicationFailedEvent(
					new SpringApplication(), new String[0], context, ex));
		}",method,
"	@Test
	public void logsOutput() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(Config.class);
		ConditionEvaluationReport.get(context.getBeanFactory())
				.recordExclusions(Arrays.asList(""com.foo.Bar""));
		context.refresh();
		withDebugLogging(() -> this.initializer
				.onApplicationEvent(new ContextRefreshedEvent(context)));
		assertThat(this.outputCapture.toString())
				.contains(""not a servlet web application (OnWebApplicationCondition)"");
	}",method,
"	@Test
	public void canBeUsedInApplicationContext() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(Config.class);
		new AutoConfigurationReportLoggingInitializer().initialize(context);
		context.refresh();
		assertThat(context.getBean(ConditionEvaluationReport.class)).isNotNull();
	}",method,
"	@Test
	public void canBeUsedInNonGenericApplicationContext() throws Exception {
		AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
		context.setServletContext(new MockServletContext());
		context.register(Config.class);
		new AutoConfigurationReportLoggingInitializer().initialize(context);
		context.refresh();
		assertThat(context.getBean(ConditionEvaluationReport.class)).isNotNull();
	}",method,
"	@Test
	public void noErrorIfNotInitialized() throws Exception {
		this.initializer
				.onApplicationEvent(new ApplicationFailedEvent(new SpringApplication(),
						new String[0], null, new RuntimeException(""Planned"")));
		assertThat(this.outputCapture.toString())
				.contains(""Unable to provide auto-configuration report"");
	}",method,
"	private void withDebugLogging(Runnable runnable) {
		LoggerContext context = (LoggerContext) StaticLoggerBinder.getSingleton()
				.getLoggerFactory();
		Logger logger = context
				.getLogger(AutoConfigurationReportLoggingInitializer.class);
		Level currentLevel = logger.getLevel();
		logger.setLevel(Level.DEBUG);
		try {
			runnable.run();
		}
		finally {
			logger.setLevel(currentLevel);
		}
	}",method,
"		@Bean
		public String iBreak() {
			throw new RuntimeException();
		}",method,
"public class DependencyStringNotationConverter<T extends ExternalDependency> implements NotationConverter<String, T> {
    private final Instantiator instantiator;
    private final Class<T> wantedType;
    public DependencyStringNotationConverter(Instantiator instantiator, Class<T> wantedType) {
        this.instantiator = instantiator;
        this.wantedType = wantedType;
    }
    @Override
    public void describe(DiagnosticsVisitor visitor) {
        visitor.candidate(""String or CharSequence values"").example(""'org.gradle:gradle-core:1.0'"");
    }
    public void convert(String notation, NotationConvertResult<? super T> result) throws TypeConversionException {
        result.converted(createDependencyFromString(notation));
    }
    private T createDependencyFromString(String notation) {
        ParsedModuleStringNotation parsedNotation = splitModuleFromExtension(notation);
        T moduleDependency = instantiator.newInstance(wantedType,
            parsedNotation.getGroup(), parsedNotation.getName(), parsedNotation.getVersion());
        ModuleFactoryHelper.addExplicitArtifactsIfDefined(moduleDependency, parsedNotation.getArtifactType(), parsedNotation.getClassifier());
        return moduleDependency;
    }
    private ParsedModuleStringNotation splitModuleFromExtension(String notation) {
        int idx = notation.lastIndexOf('@');
        if (idx == -1 || ClientModule.class.isAssignableFrom(wantedType)) {
            return new ParsedModuleStringNotation(notation, null);
        }
        int versionIndx = notation.lastIndexOf(':');
        if (versionIndx<idx) {
            return new ParsedModuleStringNotation(notation.substring(0, idx), notation.substring(idx + 1));
        }
        return new ParsedModuleStringNotation(notation, null);
    }
}",class,
"    public DependencyStringNotationConverter(Instantiator instantiator, Class<T> wantedType) {
        this.instantiator = instantiator;
        this.wantedType = wantedType;
    }",method,
"    @Override
    public void describe(DiagnosticsVisitor visitor) {
        visitor.candidate(""String or CharSequence values"").example(""'org.gradle:gradle-core:1.0'"");
    }",method,
"    public void convert(String notation, NotationConvertResult<? super T> result) throws TypeConversionException {
        result.converted(createDependencyFromString(notation));
    }",method,
"    private T createDependencyFromString(String notation) {
        ParsedModuleStringNotation parsedNotation = splitModuleFromExtension(notation);
        T moduleDependency = instantiator.newInstance(wantedType,
            parsedNotation.getGroup(), parsedNotation.getName(), parsedNotation.getVersion());
        ModuleFactoryHelper.addExplicitArtifactsIfDefined(moduleDependency, parsedNotation.getArtifactType(), parsedNotation.getClassifier());
        return moduleDependency;
    }",method,

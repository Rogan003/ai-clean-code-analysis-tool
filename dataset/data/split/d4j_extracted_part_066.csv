code_snippet,type,score
"  public Assignment getDefinition(LValue variable) {
    return assignmentMap.get(variable);
  }",method,
"  public BasicBlock getDefinitionBlock(LValue a) {
    return defBlockMap.get(a);
  }",method,
"  public Collection<SsaEdge> getSsaEdges(LValue lhs) {
    return ssaEdges.get(lhs);
  }",method,
"  public boolean isUsed(LValue variable) {
    return variableUsages.contains(variable);
  }",method,
"  public Set<LValue> getUsedVariables() {
    return variableUsages;
  }",method,
"  public Collection<BasicBlock> getUsedBlocks(LValue a) {
    return useBlockMap.get(a);
  }",method,
"public final class RotationLockControllerImpl implements RotationLockController {
    private final Context mContext;
    private final CopyOnWriteArrayList<RotationLockControllerCallback> mCallbacks =
            new CopyOnWriteArrayList<RotationLockControllerCallback>();
    private final RotationPolicy.RotationPolicyListener mRotationPolicyListener =
            new RotationPolicy.RotationPolicyListener() {
        @Override
        public void onChange() {
            notifyChanged();
        }
    };
    public RotationLockControllerImpl(Context context) {
        mContext = context;
        setListening(true);
    }
    public void addCallback(RotationLockControllerCallback callback) {
        mCallbacks.add(callback);
        notifyChanged(callback);
    }
    public void removeCallback(RotationLockControllerCallback callback) {
        mCallbacks.remove(callback);
    }
    public int getRotationLockOrientation() {
        return RotationPolicy.getRotationLockOrientation(mContext);
    }
    public boolean isRotationLocked() {
        return RotationPolicy.isRotationLocked(mContext);
    }
    public void setRotationLocked(boolean locked) {
        RotationPolicy.setRotationLock(mContext, locked);
    }
    public boolean isRotationLockAffordanceVisible() {
        return RotationPolicy.isRotationLockToggleVisible(mContext);
    }
    @Override
    public void setListening(boolean listening) {
        if (listening) {
            RotationPolicy.registerRotationPolicyListener(mContext, mRotationPolicyListener,
                    UserHandle.USER_ALL);
        } else {
            RotationPolicy.unregisterRotationPolicyListener(mContext, mRotationPolicyListener);
        }
    }
    private void notifyChanged() {
        for (RotationLockControllerCallback callback : mCallbacks) {
            notifyChanged(callback);
        }
    }
    private void notifyChanged(RotationLockControllerCallback callback) {
        callback.onRotationLockStateChanged(RotationPolicy.isRotationLocked(mContext),
                RotationPolicy.isRotationLockToggleVisible(mContext));
    }
}",class,
"            new RotationPolicy.RotationPolicyListener() {
        @Override
        public void onChange() {
            notifyChanged();
        }
    }",method,
"        @Override
        public void onChange() {
            notifyChanged();
        }",method,
"    public RotationLockControllerImpl(Context context) {
        mContext = context;
        setListening(true);
    }",method,
"    public void addCallback(RotationLockControllerCallback callback) {
        mCallbacks.add(callback);
        notifyChanged(callback);
    }",method,
"    public void removeCallback(RotationLockControllerCallback callback) {
        mCallbacks.remove(callback);
    }",method,
"    public int getRotationLockOrientation() {
        return RotationPolicy.getRotationLockOrientation(mContext);
    }",method,
"    public boolean isRotationLocked() {
        return RotationPolicy.isRotationLocked(mContext);
    }",method,
"    public void setRotationLocked(boolean locked) {
        RotationPolicy.setRotationLock(mContext, locked);
    }",method,
"    public boolean isRotationLockAffordanceVisible() {
        return RotationPolicy.isRotationLockToggleVisible(mContext);
    }",method,
"    @Override
    public void setListening(boolean listening) {
        if (listening) {
            RotationPolicy.registerRotationPolicyListener(mContext, mRotationPolicyListener,
                    UserHandle.USER_ALL);
        } else {
            RotationPolicy.unregisterRotationPolicyListener(mContext, mRotationPolicyListener);
        }
    }",method,
"        if (listening) {
            RotationPolicy.registerRotationPolicyListener(mContext, mRotationPolicyListener,
                    UserHandle.USER_ALL);
        }",method,
"    private void notifyChanged() {
        for (RotationLockControllerCallback callback : mCallbacks) {
            notifyChanged(callback);
        }
    }",method,
"        for (RotationLockControllerCallback callback : mCallbacks) {
            notifyChanged(callback);
        }",method,
"    private void notifyChanged(RotationLockControllerCallback callback) {
        callback.onRotationLockStateChanged(RotationPolicy.isRotationLocked(mContext),
                RotationPolicy.isRotationLockToggleVisible(mContext));
    }",method,
"public class UtenteTabella implements Serializable {
    private static final long serialVersionUID = 1L;
    private Long idTabellaUtente;
    private String tabella;
    private boolean selected;
    private Utente utente;
    public UtenteTabella() {
    }
    public UtenteTabella(Long idTabellaUtente) {
	this.idTabellaUtente = idTabellaUtente;
    }
    public UtenteTabella(Long idTabellaUtente, String tabella, boolean selected) {
	this.idTabellaUtente = idTabellaUtente;
	this.tabella = tabella;
	this.selected = selected;
    }
    public boolean isSelected() {
	return selected;
    }
    public void setSelected(boolean selected) {
	this.selected = selected;
    }
    public Long getIdTabellaUtente() {
	return idTabellaUtente;
    }
    public void setIdTabellaUtente(Long idTabellaUtente) {
	this.idTabellaUtente = idTabellaUtente;
    }
    public String getTabella() {
	return tabella;
    }
    public void setTabella(String tabella) {
	this.tabella = tabella;
    }
    public Utente getUtente() {
	return utente;
    }
    public void setUtente(Utente utente) {
	this.utente = utente;
    }
    @Override
    public int hashCode() {
	int hash = 0;
	hash += (idTabellaUtente != null ? idTabellaUtente.hashCode() : 0);
	return hash;
    }
    @Override
    public boolean equals(Object object) {
	// TODO: Warning - this method won't work in the case the id fields are not set
	if (!(object instanceof UtenteTabella)) {
	    return false;
	}
	UtenteTabella other = (UtenteTabella) object;
	if ((this.idTabellaUtente == null && other.idTabellaUtente != null) || (this.idTabellaUtente != null && !this.idTabellaUtente.equals(other.idTabellaUtente))) {
	    return false;
	}
	return true;
    }
    @Override
    public String toString() {
	return ""com.serandp.datarise.profiling.entity.UtenteTabella[ idTabellaUtente="" + idTabellaUtente + "" ]"";
    }
}",class,
"    public UtenteTabella() {
    }",method,
"    public UtenteTabella(Long idTabellaUtente) {
	this.idTabellaUtente = idTabellaUtente;
    }",method,
"    public UtenteTabella(Long idTabellaUtente, String tabella, boolean selected) {
	this.idTabellaUtente = idTabellaUtente;
	this.tabella = tabella;
	this.selected = selected;
    }",method,
"    public boolean isSelected() {
	return selected;
    }",method,
"    public void setSelected(boolean selected) {
	this.selected = selected;
    }",method,
"    public Long getIdTabellaUtente() {
	return idTabellaUtente;
    }",method,
"    public void setIdTabellaUtente(Long idTabellaUtente) {
	this.idTabellaUtente = idTabellaUtente;
    }",method,
"    public String getTabella() {
	return tabella;
    }",method,
"    public void setTabella(String tabella) {
	this.tabella = tabella;
    }",method,
"    public Utente getUtente() {
	return utente;
    }",method,
"    public void setUtente(Utente utente) {
	this.utente = utente;
    }",method,
"    @Override
    public int hashCode() {
	int hash = 0;
	hash += (idTabellaUtente != null ? idTabellaUtente.hashCode() : 0);
	return hash;
    }",method,
"    @Override
    public boolean equals(Object object) {
	// TODO: Warning - this method won't work in the case the id fields are not set
	if (!(object instanceof UtenteTabella)) {
	    return false;
	}
	UtenteTabella other = (UtenteTabella) object;
	if ((this.idTabellaUtente == null && other.idTabellaUtente != null) || (this.idTabellaUtente != null && !this.idTabellaUtente.equals(other.idTabellaUtente))) {
	    return false;
	}
	return true;
    }",method,
"    @Override
    public String toString() {
	return ""com.serandp.datarise.profiling.entity.UtenteTabella[ idTabellaUtente="" + idTabellaUtente + "" ]"";
    }",method,
"public abstract class BaseTripleValueSpanParticleModifier<T extends IEntity> extends BaseDoubleValueSpanParticleModifier<T> {
	// ===========================================================
	// Constants
	// ===========================================================
	// ===========================================================
	// Fields
	// ===========================================================
	private float mFromValueC;
	private float mValueSpanC;
	// ===========================================================
	// Constructors
	// ===========================================================
	public BaseTripleValueSpanParticleModifier(final float pFromTime, final float pToTime, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC) {
		this(pFromTime, pToTime, pFromValueA, pToValueA, pFromValueB, pToValueB, pFromValueC, pToValueC, EaseLinear.getInstance());
	}
	public BaseTripleValueSpanParticleModifier(final float pFromTime, final float pToTime, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC, final IEaseFunction pEaseFunction) {
		super(pFromTime, pToTime, pFromValueA, pToValueA, pFromValueB, pToValueB, pEaseFunction);
		this.mFromValueC = pFromValueC;
		this.mValueSpanC = pToValueC - pFromValueC;
	}
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	protected abstract void onSetInitialValues(final Particle<T> pParticle, final float pValueA, final float pValueB, final float pValueC);
	protected abstract void onSetValues(final Particle<T> pParticle, final float pPercentageDone, final float pValueA, final float pValueB, final float pValueC);
	@Override
	public void onSetInitialValues(final Particle<T> pParticle, final float pValueA, final float pValueB) {
		this.onSetInitialValues(pParticle, pValueA, pValueB, this.mFromValueC);
	}
	@Override
	protected void onSetValues(final Particle<T> pParticle, final float pPercentageDone, final float pValueA, final float pValueB) {
		this.onSetValues(pParticle, pPercentageDone, pValueA, pValueB, this.mFromValueC + pPercentageDone * this.mValueSpanC);
	}
	@Override
	@Deprecated
	public void reset(float pFromValueA, float pToValueA, float pFromValueB, float pToValueB, float pFromTime, float pToTime) {
		super.reset(pFromValueA, pToValueA, pFromValueB, pToValueB, pFromTime, pToTime);
	}
	// ===========================================================
	// Methods
	// ===========================================================
	public void reset(final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC, final float pFromTime, final float pToTime) {
		super.reset(pFromValueA, pToValueA, pFromValueB, pToValueB, pFromTime, pToTime);
		this.mFromValueC = pFromValueC;
		this.mValueSpanC = pToValueC - pFromValueC;
	}
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,
"	public BaseTripleValueSpanParticleModifier(final float pFromTime, final float pToTime, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC) {
		this(pFromTime, pToTime, pFromValueA, pToValueA, pFromValueB, pToValueB, pFromValueC, pToValueC, EaseLinear.getInstance());
	}",method,
"	public BaseTripleValueSpanParticleModifier(final float pFromTime, final float pToTime, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC, final IEaseFunction pEaseFunction) {
		super(pFromTime, pToTime, pFromValueA, pToValueA, pFromValueB, pToValueB, pEaseFunction);
		this.mFromValueC = pFromValueC;
		this.mValueSpanC = pToValueC - pFromValueC;
	}",method,
"	@Override
	public void onSetInitialValues(final Particle<T> pParticle, final float pValueA, final float pValueB) {
		this.onSetInitialValues(pParticle, pValueA, pValueB, this.mFromValueC);
	}",method,
"	@Override
	protected void onSetValues(final Particle<T> pParticle, final float pPercentageDone, final float pValueA, final float pValueB) {
		this.onSetValues(pParticle, pPercentageDone, pValueA, pValueB, this.mFromValueC + pPercentageDone * this.mValueSpanC);
	}",method,
"	@Override
	@Deprecated
	public void reset(float pFromValueA, float pToValueA, float pFromValueB, float pToValueB, float pFromTime, float pToTime) {
		super.reset(pFromValueA, pToValueA, pFromValueB, pToValueB, pFromTime, pToTime);
	}",method,
"	public void reset(final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC, final float pFromTime, final float pToTime) {
		super.reset(pFromValueA, pToValueA, pFromValueB, pToValueB, pFromTime, pToTime);
		this.mFromValueC = pFromValueC;
		this.mValueSpanC = pToValueC - pFromValueC;
	}",method,
"public class ByAll extends By implements Serializable {
  private static final long serialVersionUID = 4573668832699497306L;
  private By[] bys;
  public ByAll(By... bys) {
    this.bys = bys;
  }
  @Override
  public WebElement findElement(SearchContext context) {
    for (By by : bys) {
      List<WebElement> elements = context.findElements(by);
      if (!elements.isEmpty()) {
        return elements.get(0);
      }
    }
    throw new NoSuchElementException(""Cannot locate an element using "" + toString());
  }
  @Override
  public List<WebElement> findElements(SearchContext context) {
    List<WebElement> elems = new ArrayList<>();
    for (By by : bys) {
      elems.addAll(context.findElements(by));
    }
    return elems;
  }
  @Override
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder(""By.all("");
    stringBuilder.append(""{"");
    boolean first = true;
    for (By by : bys) {
      stringBuilder.append((first ? """" : "","")).append(by);
      first = false;
    }
    stringBuilder.append(""})"");
    return stringBuilder.toString();
  }
}",class,
"  public ByAll(By... bys) {
    this.bys = bys;
  }",method,
"  @Override
  public WebElement findElement(SearchContext context) {
    for (By by : bys) {
      List<WebElement> elements = context.findElements(by);
      if (!elements.isEmpty()) {
        return elements.get(0);
      }
    }
    throw new NoSuchElementException(""Cannot locate an element using "" + toString());
  }",method,
"    for (By by : bys) {
      List<WebElement> elements = context.findElements(by);
      if (!elements.isEmpty()) {
        return elements.get(0);
      }
    }",method,
"  @Override
  public List<WebElement> findElements(SearchContext context) {
    List<WebElement> elems = new ArrayList<>();
    for (By by : bys) {
      elems.addAll(context.findElements(by));
    }
    return elems;
  }",method,
"    for (By by : bys) {
      elems.addAll(context.findElements(by));
    }",method,
"  @Override
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder(""By.all("");
    stringBuilder.append(""{"");
    boolean first = true;
    for (By by : bys) {
      stringBuilder.append((first ? """" : "","")).append(by);
      first = false;
    }
    stringBuilder.append(""})"");
    return stringBuilder.toString();
  }",method,
"    for (By by : bys) {
      stringBuilder.append((first ? """" : "","")).append(by);
      first = false;
    }",method,
"public class SSLClient extends SSLCTX
{
    public SSLClient(int options, int num_sessions)
    {
        super(options, num_sessions);
    }
    public SSL connect(Socket s, byte[] session_id)
    {
        int client_fd = axtlsj.getFd(s);
        byte sess_id_size = (byte)(session_id != null ? 
                                session_id.length : 0);
        return new SSL(axtlsj.ssl_client_new(m_ctx, client_fd, session_id,
                        sess_id_size));
    }
}",class,
"    public SSLClient(int options, int num_sessions)
    {
        super(options, num_sessions);
    }",method,
"    public SSL connect(Socket s, byte[] session_id)
    {
        int client_fd = axtlsj.getFd(s);
        byte sess_id_size = (byte)(session_id != null ? 
                                session_id.length : 0);
        return new SSL(axtlsj.ssl_client_new(m_ctx, client_fd, session_id,
                        sess_id_size));
    }",method,
"public class IndexSortIT extends ESIntegTestCase {
    private static final XContentBuilder TEST_MAPPING = createTestMapping();
    private static XContentBuilder createTestMapping() {
        try {
            return jsonBuilder()
                .startObject()
                    .startObject(""properties"")
                        .startObject(""date"")
                        .field(""type"", ""date"")
                    .endObject()
                    .startObject(""numeric"")
                        .field(""type"", ""integer"")
                    .field(""doc_values"", false)
                    .endObject()
                    .startObject(""numeric_dv"")
                        .field(""type"", ""integer"")
                        .field(""doc_values"", true)
                    .endObject()
                    .startObject(""keyword_dv"")
                        .field(""type"", ""keyword"")
                        .field(""doc_values"", true)
                    .endObject()
                    .startObject(""keyword"")
                        .field(""type"", ""keyword"")
                        .field(""doc_values"", false)
                    .endObject()
                .endObject().endObject();
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }
    public void testIndexSort() {
        SortField dateSort = new SortedNumericSortField(""date"", SortField.Type.LONG, false);
        dateSort.setMissingValue(Long.MAX_VALUE);
        SortField numericSort = new SortedNumericSortField(""numeric_dv"", SortField.Type.LONG, false);
        numericSort.setMissingValue(Long.MAX_VALUE);
        SortField keywordSort = new SortedSetSortField(""keyword_dv"", false);
        keywordSort.setMissingValue(SortField.STRING_LAST);
        Sort indexSort = new Sort(dateSort, numericSort, keywordSort);
        prepareCreate(""test"")
            .setSettings(Settings.builder()
                .put(indexSettings())
                .put(""index.number_of_shards"", ""1"")
                .put(""index.number_of_replicas"", ""1"")
                .putList(""index.sort.field"", ""date"", ""numeric_dv"", ""keyword_dv"")
            )
            .addMapping(""test"", TEST_MAPPING)
            .get();
        for (int i = 0; i < 20; i++) {
            client().prepareIndex(""test"", ""test"", Integer.toString(i))
                .setSource(""numeric_dv"", randomInt(), ""keyword_dv"", randomAlphaOfLengthBetween(10, 20))
                .get();
        }
        flushAndRefresh();
        ensureYellow();
        assertSortedSegments(""test"", indexSort);
    }
    public void testInvalidIndexSort() {
        IllegalArgumentException exc = expectThrows(IllegalArgumentException.class,
            () -> prepareCreate(""test"")
                .setSettings(Settings.builder()
                    .put(indexSettings())
                    .putList(""index.sort.field"", ""invalid_field"")
                )
                .addMapping(""test"", TEST_MAPPING)
                .get()
        );
        assertThat(exc.getMessage(), containsString(""unknown index sort field:[invalid_field]""));
        exc = expectThrows(IllegalArgumentException.class,
            () -> prepareCreate(""test"")
                .setSettings(Settings.builder()
                    .put(indexSettings())
                    .putList(""index.sort.field"", ""numeric"")
                )
                .addMapping(""test"", TEST_MAPPING)
                .get()
        );
        assertThat(exc.getMessage(), containsString(""docvalues not found for index sort field:[numeric]""));
        exc = expectThrows(IllegalArgumentException.class,
            () -> prepareCreate(""test"")
                .setSettings(Settings.builder()
                    .put(indexSettings())
                    .putList(""index.sort.field"", ""keyword"")
                )
                .addMapping(""test"", TEST_MAPPING)
                .get()
        );
        assertThat(exc.getMessage(), containsString(""docvalues not found for index sort field:[keyword]""));
    }
}",class,
"    private static XContentBuilder createTestMapping() {
        try {
            return jsonBuilder()
                .startObject()
                    .startObject(""properties"")
                        .startObject(""date"")
                        .field(""type"", ""date"")
                    .endObject()
                    .startObject(""numeric"")
                        .field(""type"", ""integer"")
                    .field(""doc_values"", false)
                    .endObject()
                    .startObject(""numeric_dv"")
                        .field(""type"", ""integer"")
                        .field(""doc_values"", true)
                    .endObject()
                    .startObject(""keyword_dv"")
                        .field(""type"", ""keyword"")
                        .field(""doc_values"", true)
                    .endObject()
                    .startObject(""keyword"")
                        .field(""type"", ""keyword"")
                        .field(""doc_values"", false)
                    .endObject()
                .endObject().endObject();
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }",method,
"    public void testIndexSort() {
        SortField dateSort = new SortedNumericSortField(""date"", SortField.Type.LONG, false);
        dateSort.setMissingValue(Long.MAX_VALUE);
        SortField numericSort = new SortedNumericSortField(""numeric_dv"", SortField.Type.LONG, false);
        numericSort.setMissingValue(Long.MAX_VALUE);
        SortField keywordSort = new SortedSetSortField(""keyword_dv"", false);
        keywordSort.setMissingValue(SortField.STRING_LAST);
        Sort indexSort = new Sort(dateSort, numericSort, keywordSort);
        prepareCreate(""test"")
            .setSettings(Settings.builder()
                .put(indexSettings())
                .put(""index.number_of_shards"", ""1"")
                .put(""index.number_of_replicas"", ""1"")
                .putList(""index.sort.field"", ""date"", ""numeric_dv"", ""keyword_dv"")
            )
            .addMapping(""test"", TEST_MAPPING)
            .get();
        for (int i = 0; i < 20; i++) {
            client().prepareIndex(""test"", ""test"", Integer.toString(i))
                .setSource(""numeric_dv"", randomInt(), ""keyword_dv"", randomAlphaOfLengthBetween(10, 20))
                .get();
        }
        flushAndRefresh();
        ensureYellow();
        assertSortedSegments(""test"", indexSort);
    }",method,
"        for (int i = 0; i < 20; i++) {
            client().prepareIndex(""test"", ""test"", Integer.toString(i))
                .setSource(""numeric_dv"", randomInt(), ""keyword_dv"", randomAlphaOfLengthBetween(10, 20))
                .get();
        }",method,
"    public void testInvalidIndexSort() {
        IllegalArgumentException exc = expectThrows(IllegalArgumentException.class,
            () -> prepareCreate(""test"")
                .setSettings(Settings.builder()
                    .put(indexSettings())
                    .putList(""index.sort.field"", ""invalid_field"")
                )
                .addMapping(""test"", TEST_MAPPING)
                .get()
        );
        assertThat(exc.getMessage(), containsString(""unknown index sort field:[invalid_field]""));
        exc = expectThrows(IllegalArgumentException.class,
            () -> prepareCreate(""test"")
                .setSettings(Settings.builder()
                    .put(indexSettings())
                    .putList(""index.sort.field"", ""numeric"")
                )
                .addMapping(""test"", TEST_MAPPING)
                .get()
        );
        assertThat(exc.getMessage(), containsString(""docvalues not found for index sort field:[numeric]""));
        exc = expectThrows(IllegalArgumentException.class,
            () -> prepareCreate(""test"")
                .setSettings(Settings.builder()
                    .put(indexSettings())
                    .putList(""index.sort.field"", ""keyword"")
                )
                .addMapping(""test"", TEST_MAPPING)
                .get()
        );
        assertThat(exc.getMessage(), containsString(""docvalues not found for index sort field:[keyword]""));
    }",method,
"import com.google.protobuf.InvalidProtocolBufferException;
class ConformanceJavaLite {
  private int testCount = 0;
  private boolean readFromStdin(byte[] buf, int len) throws Exception {
    int ofs = 0;
    while (len > 0) {
      int read = System.in.read(buf, ofs, len);
      if (read == -1) {
        return false;  // EOF
      }
      ofs += read;
      len -= read;
    }
    return true;
  }
  private void writeToStdout(byte[] buf) throws Exception {
    System.out.write(buf);
  }
  // Returns -1 on EOF (the actual values will always be positive).
  private int readLittleEndianIntFromStdin() throws Exception {
    byte[] buf = new byte[4];
    if (!readFromStdin(buf, 4)) {
      return -1;
    }
    return (buf[0] & 0xff)
        | ((buf[1] & 0xff) << 8)
        | ((buf[2] & 0xff) << 16)
        | ((buf[3] & 0xff) << 24);
  }
  private void writeLittleEndianIntToStdout(int val) throws Exception {
    byte[] buf = new byte[4];
    buf[0] = (byte)val;
    buf[1] = (byte)(val >> 8);
    buf[2] = (byte)(val >> 16);
    buf[3] = (byte)(val >> 24);
    writeToStdout(buf);
  }
  private Conformance.ConformanceResponse doTest(Conformance.ConformanceRequest request) {
    Conformance.TestAllTypes testMessage;
    switch (request.getPayloadCase()) {
      case PROTOBUF_PAYLOAD: {
        try {
          testMessage = Conformance.TestAllTypes.parseFrom(request.getProtobufPayload());
        } catch (InvalidProtocolBufferException e) {
          return Conformance.ConformanceResponse.newBuilder().setParseError(e.getMessage()).build();
        }
        break;
      }
      case JSON_PAYLOAD: {
        return Conformance.ConformanceResponse.newBuilder().setSkipped(
            ""Lite runtime does not support JSON format."").build();
      }
      case PAYLOAD_NOT_SET: {
        throw new RuntimeException(""Request didn't have payload."");
      }
      default: {
        throw new RuntimeException(""Unexpected payload case."");
      }
    }
    switch (request.getRequestedOutputFormat()) {
      case UNSPECIFIED:
        throw new RuntimeException(""Unspecified output format."");
      case PROTOBUF:
        return Conformance.ConformanceResponse.newBuilder().setProtobufPayload(testMessage.toByteString()).build();
      case JSON:
        return Conformance.ConformanceResponse.newBuilder().setSkipped(
            ""Lite runtime does not support JSON format."").build();
      default: {
        throw new RuntimeException(""Unexpected request output."");
      }
    }
  }
  private boolean doTestIo() throws Exception {
    int bytes = readLittleEndianIntFromStdin();
    if (bytes == -1) {
      return false;  // EOF
    }
    byte[] serializedInput = new byte[bytes];
    if (!readFromStdin(serializedInput, bytes)) {
      throw new RuntimeException(""Unexpected EOF from test program."");
    }
    Conformance.ConformanceRequest request =
        Conformance.ConformanceRequest.parseFrom(serializedInput);
    Conformance.ConformanceResponse response = doTest(request);
    byte[] serializedOutput = response.toByteArray();
    writeLittleEndianIntToStdout(serializedOutput.length);
    writeToStdout(serializedOutput);
    return true;
  }
  public void run() throws Exception {
    while (doTestIo()) {
      this.testCount++;
    }
    System.err.println(""ConformanceJavaLite: received EOF from test runner after "" +
        this.testCount + "" tests"");
  }
  public static void main(String[] args) throws Exception {
    new ConformanceJavaLite().run();
  }
}",class,
"  private boolean readFromStdin(byte[] buf, int len) throws Exception {
    int ofs = 0;
    while (len > 0) {
      int read = System.in.read(buf, ofs, len);
      if (read == -1) {
        return false;  // EOF
      }
      ofs += read;
      len -= read;
    }
    return true;
  }",method,
"    while (len > 0) {
      int read = System.in.read(buf, ofs, len);
      if (read == -1) {
        return false;  // EOF
      }
      ofs += read;
      len -= read;
    }",method,
"      if (read == -1) {
        return false;  // EOF
      }",method,
"  private void writeToStdout(byte[] buf) throws Exception {
    System.out.write(buf);
  }",method,
"  private int readLittleEndianIntFromStdin() throws Exception {
    byte[] buf = new byte[4];
    if (!readFromStdin(buf, 4)) {
      return -1;
    }
    return (buf[0] & 0xff)
        | ((buf[1] & 0xff) << 8)
        | ((buf[2] & 0xff) << 16)
        | ((buf[3] & 0xff) << 24);
  }",method,
"  private void writeLittleEndianIntToStdout(int val) throws Exception {
    byte[] buf = new byte[4];
    buf[0] = (byte)val;
    buf[1] = (byte)(val >> 8);
    buf[2] = (byte)(val >> 16);
    buf[3] = (byte)(val >> 24);
    writeToStdout(buf);
  }",method,
"  private Conformance.ConformanceResponse doTest(Conformance.ConformanceRequest request) {
    Conformance.TestAllTypes testMessage;
    switch (request.getPayloadCase()) {
      case PROTOBUF_PAYLOAD: {
        try {
          testMessage = Conformance.TestAllTypes.parseFrom(request.getProtobufPayload());
        } catch (InvalidProtocolBufferException e) {
          return Conformance.ConformanceResponse.newBuilder().setParseError(e.getMessage()).build();
        }
        break;
      }
      case JSON_PAYLOAD: {
        return Conformance.ConformanceResponse.newBuilder().setSkipped(
            ""Lite runtime does not support JSON format."").build();
      }
      case PAYLOAD_NOT_SET: {
        throw new RuntimeException(""Request didn't have payload."");
      }
      default: {
        throw new RuntimeException(""Unexpected payload case."");
      }
    }
    switch (request.getRequestedOutputFormat()) {
      case UNSPECIFIED:
        throw new RuntimeException(""Unspecified output format."");
      case PROTOBUF:
        return Conformance.ConformanceResponse.newBuilder().setProtobufPayload(testMessage.toByteString()).build();
      case JSON:
        return Conformance.ConformanceResponse.newBuilder().setSkipped(
            ""Lite runtime does not support JSON format."").build();
      default: {
        throw new RuntimeException(""Unexpected request output."");
      }
    }
  }",method,
"  private boolean doTestIo() throws Exception {
    int bytes = readLittleEndianIntFromStdin();
    if (bytes == -1) {
      return false;  // EOF
    }
    byte[] serializedInput = new byte[bytes];
    if (!readFromStdin(serializedInput, bytes)) {
      throw new RuntimeException(""Unexpected EOF from test program."");
    }
    Conformance.ConformanceRequest request =
        Conformance.ConformanceRequest.parseFrom(serializedInput);
    Conformance.ConformanceResponse response = doTest(request);
    byte[] serializedOutput = response.toByteArray();
    writeLittleEndianIntToStdout(serializedOutput.length);
    writeToStdout(serializedOutput);
    return true;
  }",method,
"    if (bytes == -1) {
      return false;  // EOF
    }",method,
"  public void run() throws Exception {
    while (doTestIo()) {
      this.testCount++;
    }
    System.err.println(""ConformanceJavaLite: received EOF from test runner after "" +
        this.testCount + "" tests"");
  }",method,
"  public static void main(String[] args) throws Exception {
    new ConformanceJavaLite().run();
  }",method,
"public class RearrangeCodeAction extends AnAction {
  @Override
  public void update(AnActionEvent e) {
    PsiFile file = CommonDataKeys.PSI_FILE.getData(e.getDataContext());
    boolean enabled = file != null && Rearranger.EXTENSION.forLanguage(file.getLanguage()) != null;
    e.getPresentation().setEnabled(enabled);
  }
  @Override
  public void actionPerformed(AnActionEvent e) {
    final Project project = e.getProject();
    if (project == null) {
      return;
    }
    final Editor editor = e.getData(CommonDataKeys.EDITOR);
    if (editor == null) {
      return;
    }
    PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);
    Document document = editor.getDocument();
    documentManager.commitDocument(document);
    final PsiFile file = documentManager.getPsiFile(document);
    if (file == null) {
      return;
    }
    SelectionModel model = editor.getSelectionModel();
    if (model.hasSelection()) {
      new RearrangeCodeProcessor(file, model).run();
    }
    else {
      new RearrangeCodeProcessor(file).run();
    }
  }
}",class,
"  @Override
  public void update(AnActionEvent e) {
    PsiFile file = CommonDataKeys.PSI_FILE.getData(e.getDataContext());
    boolean enabled = file != null && Rearranger.EXTENSION.forLanguage(file.getLanguage()) != null;
    e.getPresentation().setEnabled(enabled);
  }",method,
"  @Override
  public void actionPerformed(AnActionEvent e) {
    final Project project = e.getProject();
    if (project == null) {
      return;
    }
    final Editor editor = e.getData(CommonDataKeys.EDITOR);
    if (editor == null) {
      return;
    }
    PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);
    Document document = editor.getDocument();
    documentManager.commitDocument(document);
    final PsiFile file = documentManager.getPsiFile(document);
    if (file == null) {
      return;
    }
    SelectionModel model = editor.getSelectionModel();
    if (model.hasSelection()) {
      new RearrangeCodeProcessor(file, model).run();
    }
    else {
      new RearrangeCodeProcessor(file).run();
    }
  }",method,
"    if (project == null) {
      return;
    }",method,
"    if (editor == null) {
      return;
    }",method,
"    if (file == null) {
      return;
    }",method,
"public class MapToJsonCast
        extends SqlOperator
{
    public static final MapToJsonCast MAP_TO_JSON = new MapToJsonCast();
    private static final MethodHandle METHOD_HANDLE = methodHandle(MapToJsonCast.class, ""toJson"", ObjectKeyProvider.class, JsonGeneratorWriter.class, ConnectorSession.class, Block.class);
    private MapToJsonCast()
    {
        super(OperatorType.CAST,
                ImmutableList.of(typeVariable(""K""), typeVariable(""V"")),
                ImmutableList.of(),
                parseTypeSignature(StandardTypes.JSON),
                ImmutableList.of(parseTypeSignature(""map(K,V)"")));
    }
    @Override
    public ScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionRegistry functionRegistry)
    {
        checkArgument(arity == 1, ""Expected arity to be 1"");
        Type keyType = boundVariables.getTypeVariable(""K"");
        Type valueType = boundVariables.getTypeVariable(""V"");
        Type mapType = typeManager.getParameterizedType(StandardTypes.MAP, ImmutableList.of(
                TypeSignatureParameter.of(keyType.getTypeSignature()),
                TypeSignatureParameter.of(valueType.getTypeSignature())));
        checkCondition(canCastToJson(mapType), INVALID_CAST_ARGUMENT, ""Cannot cast %s to JSON"", mapType);
        ObjectKeyProvider provider = ObjectKeyProvider.createObjectKeyProvider(keyType);
        JsonGeneratorWriter writer = JsonGeneratorWriter.createJsonGeneratorWriter(valueType);
        MethodHandle methodHandle = METHOD_HANDLE.bindTo(provider).bindTo(writer);
        return new ScalarFunctionImplementation(
                false,
                ImmutableList.of(valueTypeArgumentProperty(RETURN_NULL_ON_NULL)),
                methodHandle,
                isDeterministic());
    }
    @UsedByGeneratedCode
    public static Slice toJson(ObjectKeyProvider provider, JsonGeneratorWriter writer, ConnectorSession session, Block block)
    {
        try {
            Map<String, Integer> orderedKeyToValuePosition = new TreeMap<>();
            for (int i = 0; i < block.getPositionCount(); i += 2) {
                String objectKey = provider.getObjectKey(block, i);
                orderedKeyToValuePosition.put(objectKey, i + 1);
            }
            SliceOutput output = new DynamicSliceOutput(40);
            try (JsonGenerator jsonGenerator = createJsonGenerator(JSON_FACTORY, output)) {
                jsonGenerator.writeStartObject();
                for (Map.Entry<String, Integer> entry : orderedKeyToValuePosition.entrySet()) {
                    jsonGenerator.writeFieldName(entry.getKey());
                    writer.writeJsonValue(jsonGenerator, block, entry.getValue(), session);
                }
                jsonGenerator.writeEndObject();
            }
            return output.slice();
        }
        catch (IOException e) {
            throwIfUnchecked(e);
            throw new RuntimeException(e);
        }
    }
}",class,
"    private MapToJsonCast()
    {
        super(OperatorType.CAST,
                ImmutableList.of(typeVariable(""K""), typeVariable(""V"")),
                ImmutableList.of(),
                parseTypeSignature(StandardTypes.JSON),
                ImmutableList.of(parseTypeSignature(""map(K,V)"")));
    }",method,
"    @Override
    public ScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionRegistry functionRegistry)
    {
        checkArgument(arity == 1, ""Expected arity to be 1"");
        Type keyType = boundVariables.getTypeVariable(""K"");
        Type valueType = boundVariables.getTypeVariable(""V"");
        Type mapType = typeManager.getParameterizedType(StandardTypes.MAP, ImmutableList.of(
                TypeSignatureParameter.of(keyType.getTypeSignature()),
                TypeSignatureParameter.of(valueType.getTypeSignature())));
        checkCondition(canCastToJson(mapType), INVALID_CAST_ARGUMENT, ""Cannot cast %s to JSON"", mapType);
        ObjectKeyProvider provider = ObjectKeyProvider.createObjectKeyProvider(keyType);
        JsonGeneratorWriter writer = JsonGeneratorWriter.createJsonGeneratorWriter(valueType);
        MethodHandle methodHandle = METHOD_HANDLE.bindTo(provider).bindTo(writer);
        return new ScalarFunctionImplementation(
                false,
                ImmutableList.of(valueTypeArgumentProperty(RETURN_NULL_ON_NULL)),
                methodHandle,
                isDeterministic());
    }",method,
"    @UsedByGeneratedCode
    public static Slice toJson(ObjectKeyProvider provider, JsonGeneratorWriter writer, ConnectorSession session, Block block)
    {
        try {
            Map<String, Integer> orderedKeyToValuePosition = new TreeMap<>();
            for (int i = 0; i < block.getPositionCount(); i += 2) {
                String objectKey = provider.getObjectKey(block, i);
                orderedKeyToValuePosition.put(objectKey, i + 1);
            }
            SliceOutput output = new DynamicSliceOutput(40);
            try (JsonGenerator jsonGenerator = createJsonGenerator(JSON_FACTORY, output)) {
                jsonGenerator.writeStartObject();
                for (Map.Entry<String, Integer> entry : orderedKeyToValuePosition.entrySet()) {
                    jsonGenerator.writeFieldName(entry.getKey());
                    writer.writeJsonValue(jsonGenerator, block, entry.getValue(), session);
                }
                jsonGenerator.writeEndObject();
            }
            return output.slice();
        }
        catch (IOException e) {
            throwIfUnchecked(e);
            throw new RuntimeException(e);
        }
    }",method,
"        catch (IOException e) {
            throwIfUnchecked(e);
            throw new RuntimeException(e);
        }",method,
"final class EmbeddedEventLoop extends AbstractScheduledEventExecutor implements EventLoop {
    private final Queue<Runnable> tasks = new ArrayDeque<Runnable>(2);
    @Override
    public EventLoopGroup parent() {
        return (EventLoopGroup) super.parent();
    }
    @Override
    public EventLoop next() {
        return (EventLoop) super.next();
    }
    @Override
    public void execute(Runnable command) {
        if (command == null) {
            throw new NullPointerException(""command"");
        }
        tasks.add(command);
    }
    void runTasks() {
        for (;;) {
            Runnable task = tasks.poll();
            if (task == null) {
                break;
            }
            task.run();
        }
    }
    long runScheduledTasks() {
        long time = AbstractScheduledEventExecutor.nanoTime();
        for (;;) {
            Runnable task = pollScheduledTask(time);
            if (task == null) {
                return nextScheduledTaskNano();
            }
            task.run();
        }
    }
    long nextScheduledTask() {
        return nextScheduledTaskNano();
    }
    @Override
    protected void cancelScheduledTasks() {
        super.cancelScheduledTasks();
    }
    @Override
    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
        throw new UnsupportedOperationException();
    }
    @Override
    public Future<?> terminationFuture() {
        throw new UnsupportedOperationException();
    }
    @Override
    @Deprecated
    public void shutdown() {
        throw new UnsupportedOperationException();
    }
    @Override
    public boolean isShuttingDown() {
        return false;
    }
    @Override
    public boolean isShutdown() {
        return false;
    }
    @Override
    public boolean isTerminated() {
        return false;
    }
    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) {
        return false;
    }
    @Override
    public ChannelFuture register(Channel channel) {
        return register(new DefaultChannelPromise(channel, this));
    }
    @Override
    public ChannelFuture register(ChannelPromise promise) {
        ObjectUtil.checkNotNull(promise, ""promise"");
        promise.channel().unsafe().register(this, promise);
        return promise;
    }
    @Deprecated
    @Override
    public ChannelFuture register(Channel channel, ChannelPromise promise) {
        channel.unsafe().register(this, promise);
        return promise;
    }
    @Override
    public boolean inEventLoop() {
        return true;
    }
    @Override
    public boolean inEventLoop(Thread thread) {
        return true;
    }
}",class,
"    @Override
    public EventLoopGroup parent() {
        return (EventLoopGroup) super.parent();
    }",method,
"    @Override
    public EventLoop next() {
        return (EventLoop) super.next();
    }",method,
"    @Override
    public void execute(Runnable command) {
        if (command == null) {
            throw new NullPointerException(""command"");
        }
        tasks.add(command);
    }",method,
"        if (command == null) {
            throw new NullPointerException(""command"");
        }",method,
"    void runTasks() {
        for (;;) {
            Runnable task = tasks.poll();
            if (task == null) {
                break;
            }
            task.run();
        }
    }",method,
"        for (;;) {
            Runnable task = tasks.poll();
            if (task == null) {
                break;
            }
            task.run();
        }",method,
"            if (task == null) {
                break;
            }",method,
"    long runScheduledTasks() {
        long time = AbstractScheduledEventExecutor.nanoTime();
        for (;;) {
            Runnable task = pollScheduledTask(time);
            if (task == null) {
                return nextScheduledTaskNano();
            }
            task.run();
        }
    }",method,
"        for (;;) {
            Runnable task = pollScheduledTask(time);
            if (task == null) {
                return nextScheduledTaskNano();
            }
            task.run();
        }",method,
"            if (task == null) {
                return nextScheduledTaskNano();
            }",method,
"    long nextScheduledTask() {
        return nextScheduledTaskNano();
    }",method,
"    @Override
    protected void cancelScheduledTasks() {
        super.cancelScheduledTasks();
    }",method,
"    @Override
    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
        throw new UnsupportedOperationException();
    }",method,
"    @Override
    public Future<?> terminationFuture() {
        throw new UnsupportedOperationException();
    }",method,
"    @Override
    @Deprecated
    public void shutdown() {
        throw new UnsupportedOperationException();
    }",method,
"    @Override
    public boolean isShuttingDown() {
        return false;
    }",method,
"    @Override
    public boolean isShutdown() {
        return false;
    }",method,
"    @Override
    public boolean isTerminated() {
        return false;
    }",method,

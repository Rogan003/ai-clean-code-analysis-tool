code_snippet,type,score
"        if (isViewportCalculationEnabled) {
            int rendererIndex = 0;
            for (ChartRenderer renderer : renderers) {
                renderer.onChartViewportChanged();
                if (rendererIndex == 0) {
                    unionViewport.set(renderer.getMaximumViewport());
                } else {
                    unionViewport.union(renderer.getMaximumViewport());
                }
                ++rendererIndex;
            }
            computator.setMaxViewport(unionViewport);
            computator.setCurrentViewport(unionViewport);
        }",method,
"            for (ChartRenderer renderer : renderers) {
                renderer.onChartViewportChanged();
                if (rendererIndex == 0) {
                    unionViewport.set(renderer.getMaximumViewport());
                } else {
                    unionViewport.union(renderer.getMaximumViewport());
                }
                ++rendererIndex;
            }",method,
"                if (rendererIndex == 0) {
                    unionViewport.set(renderer.getMaximumViewport());
                }",method,
"    public void draw(Canvas canvas) {
        for (ChartRenderer renderer : renderers) {
            renderer.draw(canvas);
        }
    }",method,
"        for (ChartRenderer renderer : renderers) {
            renderer.draw(canvas);
        }",method,
"    @Override
    public void drawUnclipped(Canvas canvas) {
        for (ChartRenderer renderer : renderers) {
            renderer.drawUnclipped(canvas);
        }
    }",method,
"        for (ChartRenderer renderer : renderers) {
            renderer.drawUnclipped(canvas);
        }",method,
"    public boolean checkTouch(float touchX, float touchY) {
        selectedValue.clear();
        int rendererIndex = renderers.size() - 1;
        for (; rendererIndex >= 0; rendererIndex--) {
            ChartRenderer renderer = renderers.get(rendererIndex);
            if (renderer.checkTouch(touchX, touchY)) {
                selectedValue.set(renderer.getSelectedValue());
                break;
            }
        }
        //clear the rest of renderers if value was selected, if value was not selected this loop
        // will not be executed.
        for (rendererIndex--; rendererIndex >= 0; rendererIndex--) {
            ChartRenderer renderer = renderers.get(rendererIndex);
            renderer.clearTouch();
        }
        return isTouched();
    }",method,
"        for (; rendererIndex >= 0; rendererIndex--) {
            ChartRenderer renderer = renderers.get(rendererIndex);
            if (renderer.checkTouch(touchX, touchY)) {
                selectedValue.set(renderer.getSelectedValue());
                break;
            }
        }",method,
"        for (rendererIndex--; rendererIndex >= 0; rendererIndex--) {
            ChartRenderer renderer = renderers.get(rendererIndex);
            renderer.clearTouch();
        }",method,
"    @Override
    public void clearTouch() {
        for (ChartRenderer renderer : renderers) {
            renderer.clearTouch();
        }
        selectedValue.clear();
    }",method,
"        for (ChartRenderer renderer : renderers) {
            renderer.clearTouch();
        }",method,
"public class OverridableNewExposerTest extends InterpTestCase implements PyTypes, Opcodes {
    public void setUp() throws Exception {
        super.setUp();
        ne = new OverridableNewExposer(Type.getType(Instantiable.class),
                                Type.getType(Instantiable.class),
                                ACC_PUBLIC,
                                ""creator"",
                                Type.getMethodDescriptor(VOID, new Type[] {APYOBJ, ASTRING}),
                                new String[] {});
        Class descriptor = ne.load(new BytecodeLoader.Loader());
        instance = (PyNewWrapper)descriptor.newInstance();
        type = PyType.fromClass(Instantiable.class);
        instance.setWrappedType(type);
    }
    public void testSimple() throws Exception {
        assertEquals(""org/python/expose/generate/OverridableNewExposerTest$Instantiable$exposed___new__"",
                     ne.getInternalName());
        assertEquals(""org.python.expose.generate.OverridableNewExposerTest$Instantiable$exposed___new__"",
                     ne.getClassName());
        assertSame(""__new__"", instance.__getattr__(""__name__"").toString());
        Instantiable created = (Instantiable)instance.__call__(type);
        assertEquals(""Just calling the actual new doesn't call its init"", 0, created.timesCalled);
        created = (Instantiable)instance.new_impl(true, type, Py.EmptyObjects, Py.NoKeywords);
        assertEquals(""Passing true to new_init should get the init method called"",
                     1,
                     created.timesCalled);
        assertEquals(""the regular type is passed in for normal instantiation"",
                     type,
                     created.forType);
    }
    public void testSubtype() throws Exception {
        PyType sub = (PyType)PyType.newType(new PyNewWrapper() {
            public PyObject new_impl(boolean init,
                                     PyType subtype,
                                     PyObject[] args,
                                     String[] keywords) {
                return new Instantiable(subtype);
            }
        }, PyType.TYPE, ""subinst"", new PyTuple(new PyObject[] {type}), new PyDictionary());
        Instantiable created = (Instantiable)instance.new_impl(true,
                                                               sub,
                                                               Py.EmptyObjects,
                                                               Py.NoKeywords);
        assertEquals(""new's init isn't called when a subtype comes in"", 0, created.timesCalled);
        assertSame(""the subtype is created when a subtype is passed in"", sub, created.forType);
    }
    @ExposedType()
    public static class Instantiable extends PyObject {
        public Instantiable(PyType forType) {
            this.forType = forType;
        }
        @ExposedNew
        public void creator(PyObject[] args, String[] keywords) {
            timesCalled++;
        }
        private PyType forType;
        private int timesCalled;
    }
    private OverridableNewExposer ne;
    private PyNewWrapper instance;
    private PyType type;
}",class,
"    public static class Instantiable extends PyObject {
        public Instantiable(PyType forType) {
            this.forType = forType;
        }
        @ExposedNew
        public void creator(PyObject[] args, String[] keywords) {
            timesCalled++;
        }
        private PyType forType;
        private int timesCalled;
    }",class,
"    public void setUp() throws Exception {
        super.setUp();
        ne = new OverridableNewExposer(Type.getType(Instantiable.class),
                                Type.getType(Instantiable.class),
                                ACC_PUBLIC,
                                ""creator"",
                                Type.getMethodDescriptor(VOID, new Type[] {APYOBJ, ASTRING}),
                                new String[] {});
        Class descriptor = ne.load(new BytecodeLoader.Loader());
        instance = (PyNewWrapper)descriptor.newInstance();
        type = PyType.fromClass(Instantiable.class);
        instance.setWrappedType(type);
    }",method,
"    public void testSimple() throws Exception {
        assertEquals(""org/python/expose/generate/OverridableNewExposerTest$Instantiable$exposed___new__"",
                     ne.getInternalName());
        assertEquals(""org.python.expose.generate.OverridableNewExposerTest$Instantiable$exposed___new__"",
                     ne.getClassName());
        assertSame(""__new__"", instance.__getattr__(""__name__"").toString());
        Instantiable created = (Instantiable)instance.__call__(type);
        assertEquals(""Just calling the actual new doesn't call its init"", 0, created.timesCalled);
        created = (Instantiable)instance.new_impl(true, type, Py.EmptyObjects, Py.NoKeywords);
        assertEquals(""Passing true to new_init should get the init method called"",
                     1,
                     created.timesCalled);
        assertEquals(""the regular type is passed in for normal instantiation"",
                     type,
                     created.forType);
    }",method,
"    public void testSubtype() throws Exception {
        PyType sub = (PyType)PyType.newType(new PyNewWrapper() {
            public PyObject new_impl(boolean init,
                                     PyType subtype,
                                     PyObject[] args,
                                     String[] keywords) {
                return new Instantiable(subtype);
            }
        }, PyType.TYPE, ""subinst"", new PyTuple(new PyObject[] {type}), new PyDictionary());
        Instantiable created = (Instantiable)instance.new_impl(true,
                                                               sub,
                                                               Py.EmptyObjects,
                                                               Py.NoKeywords);
        assertEquals(""new's init isn't called when a subtype comes in"", 0, created.timesCalled);
        assertSame(""the subtype is created when a subtype is passed in"", sub, created.forType);
    }",method,
"            public PyObject new_impl(boolean init,
                                     PyType subtype,
                                     PyObject[] args,
                                     String[] keywords) {
                return new Instantiable(subtype);
            }",method,
"        public Instantiable(PyType forType) {
            this.forType = forType;
        }",method,
"        @ExposedNew
        public void creator(PyObject[] args, String[] keywords) {
            timesCalled++;
        }",method,
"public class FrameState {
  private Rectangle myBounds;
  private boolean myMaximized;
  private boolean myFullScreen;
  public Point getLocation() {
    return myBounds == null ? null : myBounds.getLocation();
  }
  public Dimension getSize() {
    return myBounds == null ? null : myBounds.getSize();
  }
  public Rectangle getBounds() {
    return myBounds == null ? null : new Rectangle(myBounds);
  }
  public boolean isMaximized() {
    return myMaximized;
  }
  public boolean isFullScreen() {
    return myFullScreen;
  }
  public static int getExtendedState(Component component) {
    int state = Frame.NORMAL;
    if (component instanceof Frame) {
      state = ((Frame)component).getExtendedState();
      if (SystemInfo.isMacOSLion) {
        // workaround: frame.state is not updated by jdk so get it directly from peer
        ComponentPeer peer = component.getPeer();
        if (peer instanceof FramePeer) {
          state = ((FramePeer)peer).getState();
        }
      }
    }
    return state;
  }
  public static boolean isFullScreen(Component component) {
    return component instanceof IdeFrameEx
           && WindowManager.getInstance().isFullScreenSupportedInCurrentOS()
           && ((IdeFrameEx)component).isInFullScreen();
  }
  public static boolean isMaximized(int state) {
    return (state & Frame.MAXIMIZED_BOTH) == Frame.MAXIMIZED_BOTH;
  }
  private static FrameState findFrameState(@NotNull Component component) {
    for (ComponentListener listener : component.getComponentListeners()) {
      if (listener instanceof FrameState) {
        return (FrameState)listener;
      }
    }
    return null;
  }
  public static FrameState getFrameState(@NotNull Component component) {
    FrameState state = findFrameState(component);
    if (state == null) {
      state = new FrameState();
    }
    if (state.myBounds == null) {
      state.update(component);
    }
    return state;
  }
  public static void setFrameStateListener(@NotNull Component component) {
    if (component instanceof Frame) {
      // it makes sense for a frame only
      FrameState state = findFrameState(component);
      if (state == null) {
        component.addComponentListener(new Listener());
      }
    }
  }
  private static final class Listener extends FrameState implements ComponentListener {
    @Override
    public void componentMoved(ComponentEvent event) {
      update(event.getComponent());
    }
    @Override
    public void componentResized(ComponentEvent event) {
      update(event.getComponent());
    }
    @Override
    public void componentShown(ComponentEvent event) {
    }
    @Override
    public void componentHidden(ComponentEvent event) {
    }
  }
  final void update(Component component) {
    Rectangle bounds = component.getBounds();
    myFullScreen = isFullScreen(component);
    myMaximized = isMaximized(getExtendedState(component));
    if (myBounds != null) {
      if (myFullScreen || myMaximized) {
        if (bounds.contains(myBounds.x + myBounds.width / 2, myBounds.y + myBounds.height / 2)) {
          return; // preserve old bounds for the maximized frame if its state can be restored
        }
      }
    }
    myBounds = bounds;
  }
}",class,
"  private static final class Listener extends FrameState implements ComponentListener {
    @Override
    public void componentMoved(ComponentEvent event) {
      update(event.getComponent());
    }
    @Override
    public void componentResized(ComponentEvent event) {
      update(event.getComponent());
    }
    @Override
    public void componentShown(ComponentEvent event) {
    }
    @Override
    public void componentHidden(ComponentEvent event) {
    }
  }",class,
"  public Point getLocation() {
    return myBounds == null ? null : myBounds.getLocation();
  }",method,
"  public Dimension getSize() {
    return myBounds == null ? null : myBounds.getSize();
  }",method,
"  public Rectangle getBounds() {
    return myBounds == null ? null : new Rectangle(myBounds);
  }",method,
"  public boolean isMaximized() {
    return myMaximized;
  }",method,
"  public boolean isFullScreen() {
    return myFullScreen;
  }",method,
"  public static int getExtendedState(Component component) {
    int state = Frame.NORMAL;
    if (component instanceof Frame) {
      state = ((Frame)component).getExtendedState();
      if (SystemInfo.isMacOSLion) {
        // workaround: frame.state is not updated by jdk so get it directly from peer
        ComponentPeer peer = component.getPeer();
        if (peer instanceof FramePeer) {
          state = ((FramePeer)peer).getState();
        }
      }
    }
    return state;
  }",method,
"    if (component instanceof Frame) {
      state = ((Frame)component).getExtendedState();
      if (SystemInfo.isMacOSLion) {
        // workaround: frame.state is not updated by jdk so get it directly from peer
        ComponentPeer peer = component.getPeer();
        if (peer instanceof FramePeer) {
          state = ((FramePeer)peer).getState();
        }
      }
    }",method,
"      if (SystemInfo.isMacOSLion) {
        // workaround: frame.state is not updated by jdk so get it directly from peer
        ComponentPeer peer = component.getPeer();
        if (peer instanceof FramePeer) {
          state = ((FramePeer)peer).getState();
        }
      }",method,
"        if (peer instanceof FramePeer) {
          state = ((FramePeer)peer).getState();
        }",method,
"  public static boolean isFullScreen(Component component) {
    return component instanceof IdeFrameEx
           && WindowManager.getInstance().isFullScreenSupportedInCurrentOS()
           && ((IdeFrameEx)component).isInFullScreen();
  }",method,
"  public static boolean isMaximized(int state) {
    return (state & Frame.MAXIMIZED_BOTH) == Frame.MAXIMIZED_BOTH;
  }",method,
"  private static FrameState findFrameState(@NotNull Component component) {
    for (ComponentListener listener : component.getComponentListeners()) {
      if (listener instanceof FrameState) {
        return (FrameState)listener;
      }
    }
    return null;
  }",method,
"      if (listener instanceof FrameState) {
        return (FrameState)listener;
      }",method,
"  public static FrameState getFrameState(@NotNull Component component) {
    FrameState state = findFrameState(component);
    if (state == null) {
      state = new FrameState();
    }
    if (state.myBounds == null) {
      state.update(component);
    }
    return state;
  }",method,
"    if (state == null) {
      state = new FrameState();
    }",method,
"    if (state.myBounds == null) {
      state.update(component);
    }",method,
"  public static void setFrameStateListener(@NotNull Component component) {
    if (component instanceof Frame) {
      // it makes sense for a frame only
      FrameState state = findFrameState(component);
      if (state == null) {
        component.addComponentListener(new Listener());
      }
    }
  }",method,
"    if (component instanceof Frame) {
      // it makes sense for a frame only
      FrameState state = findFrameState(component);
      if (state == null) {
        component.addComponentListener(new Listener());
      }
    }",method,
"      if (state == null) {
        component.addComponentListener(new Listener());
      }",method,
"    @Override
    public void componentMoved(ComponentEvent event) {
      update(event.getComponent());
    }",method,
"    @Override
    public void componentResized(ComponentEvent event) {
      update(event.getComponent());
    }",method,
"    @Override
    public void componentShown(ComponentEvent event) {
    }",method,
"    @Override
    public void componentHidden(ComponentEvent event) {
    }",method,
"  final void update(Component component) {
    Rectangle bounds = component.getBounds();
    myFullScreen = isFullScreen(component);
    myMaximized = isMaximized(getExtendedState(component));
    if (myBounds != null) {
      if (myFullScreen || myMaximized) {
        if (bounds.contains(myBounds.x + myBounds.width / 2, myBounds.y + myBounds.height / 2)) {
          return; // preserve old bounds for the maximized frame if its state can be restored
        }
      }
    }
    myBounds = bounds;
  }",method,
"    if (myBounds != null) {
      if (myFullScreen || myMaximized) {
        if (bounds.contains(myBounds.x + myBounds.width / 2, myBounds.y + myBounds.height / 2)) {
          return; // preserve old bounds for the maximized frame if its state can be restored
        }
      }
    }",method,
"      if (myFullScreen || myMaximized) {
        if (bounds.contains(myBounds.x + myBounds.width / 2, myBounds.y + myBounds.height / 2)) {
          return; // preserve old bounds for the maximized frame if its state can be restored
        }
      }",method,
"public class UpdateOutputLineConverter {
  private final static String MERGING = ""--- Merging"";
  private final static String RECORDING_MERGE_INFO = ""--- Recording mergeinfo"";
  private final static String UPDATING = ""Updating"";
  private final static String SKIPPED = ""Skipped"";
  private final static String RESTORED = ""Restored"";
  private final static String FETCHING_EXTERNAL = ""Fetching external"";
  private final static Pattern ourAtRevision = Pattern.compile(""At revision (\\d+)\\."");
  private final static Pattern ourUpdatedToRevision = Pattern.compile(""Updated to revision (\\d+)\\."");
  private final static Pattern ourCheckedOutRevision = Pattern.compile(""Checked out revision (\\d+)\\."");
  // export from repository
  private final static Pattern ourExportedRevision = Pattern.compile(""Exported revision (\\d+)\\."");
  // export from working copy
  private final static Pattern ourExportComplete = Pattern.compile(""Export complete\\."");
  // update operation with no changes - still we're interested in revision number
  private final static Pattern ourExternal = Pattern.compile(""External at revision (\\d+)\\."");
  // update operation with some changes
  private final static Pattern ourUpdatedExternal = Pattern.compile(""Updated external to revision (\\d+)\\."");
  private final static Pattern ourCheckedOutExternal = Pattern.compile(""Checked out external at revision (\\d+)\\."");
  private final static Pattern[] ourCompletePatterns =
    new Pattern[]{ourAtRevision, ourUpdatedToRevision, ourCheckedOutRevision, ourExportedRevision, ourExternal, ourUpdatedExternal,
      ourCheckedOutExternal, ourExportComplete};
  private final File myBase;
  @NotNull private final Stack<File> myRootsUnderProcessing;
  public UpdateOutputLineConverter(File base) {
    myBase = base;
    myRootsUnderProcessing = ContainerUtil.newStack();
  }
  @Nullable
  public ProgressEvent convert(final String line) {
    // TODO: Add direct processing of ""Summary of conflicts"" lines at the end of ""svn update"" output (if there are conflicts).
    // TODO: Now it works ok because parseNormalLine could not determine necessary statuses from that and further lines
    if (StringUtil.isEmptyOrSpaces(line)) return null;
    if (line.startsWith(MERGING) || line.startsWith(RECORDING_MERGE_INFO)) {
      return null;
    } else if (line.startsWith(UPDATING)) {
      myRootsUnderProcessing.push(parseForPath(line));
      return createEvent(myRootsUnderProcessing.peek(), EventAction.UPDATE_NONE);
    } else if (line.startsWith(RESTORED)) {
      return createEvent(parseForPath(line), EventAction.RESTORE);
    } else if (line.startsWith(SKIPPED)) {
      // called, for instance, when folder is not working copy
      final String comment = parseComment(line);
      return createEvent(parseForPath(line), -1, EventAction.SKIP,
                         comment == null ? null : SVNErrorMessage.create(SVNErrorCode.WC_OBSTRUCTED_UPDATE, comment));
    } else if (line.startsWith(FETCHING_EXTERNAL)) {
      myRootsUnderProcessing.push(parseForPath(line));
      return createEvent(myRootsUnderProcessing.peek(), EventAction.UPDATE_EXTERNAL);
    }
    for (final Pattern pattern : ourCompletePatterns) {
      final long revision = matchAndGetRevision(pattern, line);
      if (revision != -1) {
        // checkout output does not have special line like ""Updating '.'"" on start - so stack could be empty and we should use myBase
        File currentRoot = myRootsUnderProcessing.size() > 0 ? myRootsUnderProcessing.pop() : myBase;
        return createEvent(currentRoot, revision, EventAction.UPDATE_COMPLETED, null);
      }
    }
    return parseNormalString(line);
  }
  @NotNull
  private static ProgressEvent createEvent(File file, @NotNull EventAction action) {
    return createEvent(file, -1, action, null);
  }
  @NotNull
  private static ProgressEvent createEvent(File file,
                                           long revision,
                                           @NotNull EventAction action,
                                           @Nullable SVNErrorMessage error) {
    return new ProgressEvent(file, revision, null, null, action, error, null);
  }
  private final static Set<Character> ourActions = new HashSet<>(Arrays.asList(new Character[]{'A', 'D', 'U', 'C', 'G', 'E', 'R'}));
  @Nullable
  private ProgressEvent parseNormalString(final String line) {
    if (line.length() < 5) return null;
    final char first = line.charAt(0);
    if (' ' != first && ! ourActions.contains(first)) return null;
    final StatusType contentsStatus = CommandUtil.getStatusType(first);
    final char second = line.charAt(1);
    final StatusType propertiesStatus = CommandUtil.getStatusType(second);
    final char lock = line.charAt(2); // dont know what to do with stolen lock info
    if (' ' != lock && 'B' != lock) return null;
    final char treeConflict = line.charAt(3);
    if (' ' != treeConflict && 'C' != treeConflict) return null;
    final boolean haveTreeConflict = 'C' == treeConflict;
    final String path = line.substring(4).trim();
    if (StringUtil.isEmptyOrSpaces(path)) return null;
    final File file = SvnUtil.resolvePath(myBase, path);
    if (StatusType.STATUS_OBSTRUCTED.equals(contentsStatus)) {
      // obstructed
      return new ProgressEvent(file, -1, contentsStatus, propertiesStatus, EventAction.UPDATE_SKIP_OBSTRUCTION, null, null);
    }
    EventAction action;
    EventAction expectedAction;
    if (StatusType.STATUS_ADDED.equals(contentsStatus)) {
      expectedAction = EventAction.UPDATE_ADD;
    } else if (StatusType.STATUS_DELETED.equals(contentsStatus)) {
      expectedAction = EventAction.UPDATE_DELETE;
    } else {
      expectedAction = EventAction.UPDATE_UPDATE;
    }
    action = expectedAction;
    if (haveTreeConflict) {
      action = EventAction.TREE_CONFLICT;
    }
    return new ProgressEvent(file, -1, contentsStatus, propertiesStatus, action, null, null);
  }
  private static long matchAndGetRevision(final Pattern pattern, final String line) {
    final Matcher matcher = pattern.matcher(line);
    if (matcher.matches()) {
      if (pattern == ourExportComplete) {
        return 0;
      }
      final String group = matcher.group(1);
      if (group == null) return -1;
      try {
        return Long.parseLong(group);
      } catch (NumberFormatException e) {
        //                                                                                    
      }
    }
    return -1;
  }
  @Nullable
  private static String parseComment(final String line) {
    int index = line.lastIndexOf(""--"");
    return index != -1 && index < line.length() - 2 ? line.substring(index + 2).trim() : null;
  }
  @Nullable
  private File parseForPath(@NotNull String line) {
    File result = null;
    int start = line.indexOf('\'');
    if (start != -1) {
      int end = line.indexOf('\'', start + 1);
      if (end != -1) {
        String path = line.substring(start + 1, end);
        result = SvnUtil.resolvePath(myBase, path);
      }
    }
    return result;
  }
}",class,
"  @NotNull private final Stack<File> myRootsUnderProcessing;
  public UpdateOutputLineConverter(File base) {
    myBase = base;
    myRootsUnderProcessing = ContainerUtil.newStack();
  }",method,
"  @Nullable
  public ProgressEvent convert(final String line) {
    // TODO: Add direct processing of ""Summary of conflicts"" lines at the end of ""svn update"" output (if there are conflicts).
    // TODO: Now it works ok because parseNormalLine could not determine necessary statuses from that and further lines
    if (StringUtil.isEmptyOrSpaces(line)) return null;
    if (line.startsWith(MERGING) || line.startsWith(RECORDING_MERGE_INFO)) {
      return null;
    } else if (line.startsWith(UPDATING)) {
      myRootsUnderProcessing.push(parseForPath(line));
      return createEvent(myRootsUnderProcessing.peek(), EventAction.UPDATE_NONE);
    } else if (line.startsWith(RESTORED)) {
      return createEvent(parseForPath(line), EventAction.RESTORE);
    } else if (line.startsWith(SKIPPED)) {
      // called, for instance, when folder is not working copy
      final String comment = parseComment(line);
      return createEvent(parseForPath(line), -1, EventAction.SKIP,
                         comment == null ? null : SVNErrorMessage.create(SVNErrorCode.WC_OBSTRUCTED_UPDATE, comment));
    } else if (line.startsWith(FETCHING_EXTERNAL)) {
      myRootsUnderProcessing.push(parseForPath(line));
      return createEvent(myRootsUnderProcessing.peek(), EventAction.UPDATE_EXTERNAL);
    }
    for (final Pattern pattern : ourCompletePatterns) {
      final long revision = matchAndGetRevision(pattern, line);
      if (revision != -1) {
        // checkout output does not have special line like ""Updating '.'"" on start - so stack could be empty and we should use myBase
        File currentRoot = myRootsUnderProcessing.size() > 0 ? myRootsUnderProcessing.pop() : myBase;
        return createEvent(currentRoot, revision, EventAction.UPDATE_COMPLETED, null);
      }
    }
    return parseNormalString(line);
  }",method,
"    for (final Pattern pattern : ourCompletePatterns) {
      final long revision = matchAndGetRevision(pattern, line);
      if (revision != -1) {
        // checkout output does not have special line like ""Updating '.'"" on start - so stack could be empty and we should use myBase
        File currentRoot = myRootsUnderProcessing.size() > 0 ? myRootsUnderProcessing.pop() : myBase;
        return createEvent(currentRoot, revision, EventAction.UPDATE_COMPLETED, null);
      }
    }",method,
"      if (revision != -1) {
        // checkout output does not have special line like ""Updating '.'"" on start - so stack could be empty and we should use myBase
        File currentRoot = myRootsUnderProcessing.size() > 0 ? myRootsUnderProcessing.pop() : myBase;
        return createEvent(currentRoot, revision, EventAction.UPDATE_COMPLETED, null);
      }",method,
"  @NotNull
  private static ProgressEvent createEvent(File file, @NotNull EventAction action) {
    return createEvent(file, -1, action, null);
  }",method,
"  @NotNull
  private static ProgressEvent createEvent(File file,
                                           long revision,
                                           @NotNull EventAction action,
                                           @Nullable SVNErrorMessage error) {
    return new ProgressEvent(file, revision, null, null, action, error, null);
  }",method,
"  @Nullable
  private ProgressEvent parseNormalString(final String line) {
    if (line.length() < 5) return null;
    final char first = line.charAt(0);
    if (' ' != first && ! ourActions.contains(first)) return null;
    final StatusType contentsStatus = CommandUtil.getStatusType(first);
    final char second = line.charAt(1);
    final StatusType propertiesStatus = CommandUtil.getStatusType(second);
    final char lock = line.charAt(2); // dont know what to do with stolen lock info
    if (' ' != lock && 'B' != lock) return null;
    final char treeConflict = line.charAt(3);
    if (' ' != treeConflict && 'C' != treeConflict) return null;
    final boolean haveTreeConflict = 'C' == treeConflict;
    final String path = line.substring(4).trim();
    if (StringUtil.isEmptyOrSpaces(path)) return null;
    final File file = SvnUtil.resolvePath(myBase, path);
    if (StatusType.STATUS_OBSTRUCTED.equals(contentsStatus)) {
      // obstructed
      return new ProgressEvent(file, -1, contentsStatus, propertiesStatus, EventAction.UPDATE_SKIP_OBSTRUCTION, null, null);
    }
    EventAction action;
    EventAction expectedAction;
    if (StatusType.STATUS_ADDED.equals(contentsStatus)) {
      expectedAction = EventAction.UPDATE_ADD;
    } else if (StatusType.STATUS_DELETED.equals(contentsStatus)) {
      expectedAction = EventAction.UPDATE_DELETE;
    } else {
      expectedAction = EventAction.UPDATE_UPDATE;
    }
    action = expectedAction;
    if (haveTreeConflict) {
      action = EventAction.TREE_CONFLICT;
    }
    return new ProgressEvent(file, -1, contentsStatus, propertiesStatus, action, null, null);
  }",method,
"    if (haveTreeConflict) {
      action = EventAction.TREE_CONFLICT;
    }",method,
"  private static long matchAndGetRevision(final Pattern pattern, final String line) {
    final Matcher matcher = pattern.matcher(line);
    if (matcher.matches()) {
      if (pattern == ourExportComplete) {
        return 0;
      }
      final String group = matcher.group(1);
      if (group == null) return -1;
      try {
        return Long.parseLong(group);
      } catch (NumberFormatException e) {
        //                                                                                    
      }
    }
    return -1;
  }",method,
"      if (pattern == ourExportComplete) {
        return 0;
      }",method,
"  @Nullable
  private static String parseComment(final String line) {
    int index = line.lastIndexOf(""--"");
    return index != -1 && index < line.length() - 2 ? line.substring(index + 2).trim() : null;
  }",method,
"  @Nullable
  private File parseForPath(@NotNull String line) {
    File result = null;
    int start = line.indexOf('\'');
    if (start != -1) {
      int end = line.indexOf('\'', start + 1);
      if (end != -1) {
        String path = line.substring(start + 1, end);
        result = SvnUtil.resolvePath(myBase, path);
      }
    }
    return result;
  }",method,
"    if (start != -1) {
      int end = line.indexOf('\'', start + 1);
      if (end != -1) {
        String path = line.substring(start + 1, end);
        result = SvnUtil.resolvePath(myBase, path);
      }
    }",method,
"      if (end != -1) {
        String path = line.substring(start + 1, end);
        result = SvnUtil.resolvePath(myBase, path);
      }",method,
"public class CountriesFragment extends ListFragment implements Renamer {
	//private String[] countries = {""Afghanistan"", ""Albania"", ""Algeria"", ""American Samoa"", ""Andorra"", ""Angola"", ""Anguilla"", ""Antarctica"", ""Antigua and Barbuda"", ""Argentina"", ""Armenia"", ""Aruba"", ""Australia"", ""Austria"", ""Azerbaijan"", ""Bahamas"", ""Bahrain"", ""Bangladesh"", ""Barbados"", ""Belarus"", ""Belgium"", ""Belize"", ""Benin"", ""Bermuda"", ""Bhutan"", ""Bolivia"", ""Bosnia and Herzegowina"", ""Botswana"", ""Bouvet Island"", ""Brazil"", ""British Indian Ocean Territory"", ""Brunei Darussalam"", ""Bulgaria"", ""Burkina Faso"", ""Burundi"", ""Cambodia"", ""Cameroon"", ""Canada"", ""Cape Verde"", ""Cayman Islands"", ""Central African Republic"", ""Chad"", ""Chile"", ""China"", ""Christmas Island"", ""Cocos (Keeling) Islands"", ""Colombia"", ""Comoros"", ""Congo"", ""Congo, the Democratic Republic of the"", ""Cook Islands"", ""Costa Rica"", ""Cote d'Ivoire"", ""Croatia (Hrvatska)"", ""Cuba"", ""Cyprus"", ""Czech Republic"", ""Denmark"", ""Djibouti"", ""Dominica"", ""Dominican Republic"", ""East Timor"", ""Ecuador"", ""Egypt"", ""El Salvador"", ""Equatorial Guinea"", ""Eritrea"", ""Estonia"", ""Ethiopia"", ""Falkland Islands (Malvinas)"", ""Faroe Islands"", ""Fiji"", ""Finland"", ""France"", ""France Metropolitan"", ""French Guiana"", ""French Polynesia"", ""French Southern Territories"", ""Gabon"", ""Gambia"", ""Georgia"", ""Germany"", ""Ghana"", ""Gibraltar"", ""Greece"", ""Greenland"", ""Grenada"", ""Guadeloupe"", ""Guam"", ""Guatemala"", ""Guinea"", ""Guinea-Bissau"", ""Guyana"", ""Haiti"", ""Heard and Mc Donald Islands"", ""Holy See (Vatican City State)"", ""Honduras"", ""Hong Kong"", ""Hungary"", ""Iceland"", ""India"", ""Indonesia"", ""Iran (Islamic Republic of)"", ""Iraq"", ""Ireland"", ""Israel"", ""Italy"", ""Jamaica"", ""Japan"", ""Jordan"", ""Kazakhstan"", ""Kenya"", ""Kiribati"", ""Korea, Democratic People's Republic of"", ""Korea, Republic of"", ""Kuwait"", ""Kyrgyzstan"", ""Lao, People's Democratic Republic"", ""Latvia"", ""Lebanon"", ""Lesotho"", ""Liberia"", ""Libyan Arab Jamahiriya"", ""Liechtenstein"", ""Lithuania"", ""Luxembourg"", ""Macau"", ""Macedonia, The Former Yugoslav Republic of"", ""Madagascar"", ""Malawi"", ""Malaysia"", ""Maldives"", ""Mali"", ""Malta"", ""Marshall Islands"", ""Martinique"", ""Mauritania"", ""Mauritius"", ""Mayotte"", ""Mexico"", ""Micronesia, Federated States of"", ""Moldova, Republic of"", ""Monaco"", ""Mongolia"", ""Montserrat"", ""Morocco"", ""Mozambique"", ""Myanmar"", ""Namibia"", ""Nauru"", ""Nepal"", ""Netherlands"", ""Netherlands Antilles"", ""New Caledonia"", ""New Zealand"", ""Nicaragua"", ""Niger"", ""Nigeria"", ""Niue"", ""Norfolk Island"", ""Northern Mariana Islands"", ""Norway"", ""Oman"", ""Pakistan"", ""Palau"", ""Panama"", ""Papua New Guinea"", ""Paraguay"", ""Peru"", ""Philippines"", ""Pitcairn"", ""Poland"", ""Portugal"", ""Puerto Rico"", ""Qatar"", ""Reunion"", ""Romania"", ""Russian Federation"", ""Rwanda"", ""Saint Kitts and Nevis"", ""Saint Lucia"", ""Saint Vincent and the Grenadines"", ""Samoa"", ""San Marino"", ""Sao Tome and Principe"", ""Saudi Arabia"", ""Senegal"", ""Seychelles"", ""Sierra Leone"", ""Singapore"", ""Slovakia (Slovak Republic)"", ""Slovenia"", ""Solomon Islands"", ""Somalia"", ""South Africa"", ""South Georgia and the South Sandwich Islands"", ""Spain"", ""Sri Lanka"", ""St. Helena"", ""St. Pierre and Miquelon"", ""Sudan"", ""Suriname"", ""Svalbard and Jan Mayen Islands"", ""Swaziland"", ""Sweden"", ""Switzerland"", ""Syrian Arab Republic"", ""Taiwan, Province of China"", ""Tajikistan"", ""Tanzania, United Republic of"", ""Thailand"", ""Togo"", ""Tokelau"", ""Tonga"", ""Trinidad and Tobago"", ""Tunisia"", ""Turkey"", ""Turkmenistan"", ""Turks and Caicos Islands"", ""Tuvalu"", ""Uganda"", ""Ukraine"", ""United Arab Emirates"", ""United Kingdom"", ""United States"", ""United States Minor Outlying Islands"", ""Uruguay"", ""Uzbekistan"", ""Vanuatu"", ""Venezuela"", ""Vietnam"", ""Virgin Islands (British)"", ""Virgin Islands (U.S.)"", ""Wallis and Futuna Islands"", ""Western Sahara"", ""Yemen"", ""Yugoslavia"", ""Zambia"", ""Zimbabwe""};
	private String[] countries;
	List<String> countriesList;
	listOfCountries sender;
	MyAdapter theAdapter;
	public interface listOfCountries{
		public void clickedElement(String element);
	}
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		return inflater.inflate(R.layout.list_fragment, container, false);
	}
	@Override
	public void onListItemClick(ListView l, View v, int position, long id) {
		// TODO Auto-generated method stub
		super.onListItemClick(l, v, position, id);
//		Toast itemClicked = Toast.makeText(getActivity().getApplicationContext(), ""Click en p:""+position+"" e:""+countries[position], Toast.LENGTH_SHORT);
//		itemClicked.show();
		sender.clickedElement(countries[position]);
	}
	@Override
	public void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		countries = getResources().getStringArray(R.array.countries_array);
		countriesList = new ArrayList<String>();
		for(int i=0; i<countries.length; i++){
			countriesList.add(countries[i]);
		}
		theAdapter = new MyAdapter(
				getActivity(), 
				android.R.layout.simple_list_item_1, 
				countriesList); 
		setListAdapter(theAdapter);
//				new ArrayAdapter<String>(
//						getActivity(),
//						android.R.layout.simple_list_item_1,
//						countries));
	}
	public class MyAdapter extends ArrayAdapter<String>{
		private List<String> elements;
		private Context theContext;
		public MyAdapter(Context context, int resource, List<String> objects) {
			super(context, resource, objects);
			theContext = context;
			elements = objects;
		}
		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			LayoutInflater inflater = (LayoutInflater) theContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
			View toReturn = inflater.inflate(R.layout.row_list, parent, false);
			TextView name = (TextView)toReturn.findViewById(R.id.itemNameRow);
			TextView index = (TextView)toReturn.findViewById(R.id.itemIndexRow);
			name.setText(elements.get(position));
			index.setText(""elements[""+position+""]"");
			return toReturn;
		}
	}
	@Override
	public void onViewCreated(View view, Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onViewCreated(view, savedInstanceState);
		// Una vez haya vista creada, podemos asignar el menu de contexto 
		registerForContextMenu(getListView());
	}
	@Override
  public void onAttach(Activity activity) {
    super.onAttach(activity);
    // This makes sure that the container activity has implemented
    // the callback interface. If not, it throws an exception
    try {
        sender = (listOfCountries) activity;
    } catch (ClassCastException e) {
        throw new ClassCastException(activity.toString()
                + "" la clase no ha implementado la interfaz"");
    }
  }
	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
		// TODO Auto-generated method stub
		super.onCreateContextMenu(menu, v, menuInfo);
		MenuInflater contextMenu = getActivity().getMenuInflater();
		contextMenu.inflate(R.menu.context_menu, menu);
	}
	@Override
	public boolean onContextItemSelected(MenuItem item) {
		// TODO Auto-generated method stub
		AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
	    final int index = info.position;
		switch(item.getItemId()){
		case R.id.do_toast:
			Toast.makeText(getActivity(), ""Toast: ""+index+""-""+countries[index], Toast.LENGTH_SHORT).show();
			// Ojo con esto, se puede pero no es recomendado...
			// ((MainActivity)getActivity()).clickedElement2(countries[index]);
			break;
		case R.id.do_edit:
//			Toast.makeText(getActivity(), ""Edit: ""+index+""-""+countries[index], Toast.LENGTH_SHORT).show();
			RenameItemDialog myDialog = new RenameItemDialog();
			myDialog.theItemPosition = index;
			myDialog.theItemName = countries[index];
			myDialog.theFragment = this;
			myDialog.show(getFragmentManager(), ""dialog"");
			break;
		case R.id.do_delete:
			AlertDialog.Builder builderConfirm = new AlertDialog.Builder(getActivity());
			builderConfirm.setMessage(""Seguro que desea eliminar el elemento: ""+countries[index]+""?"");
			builderConfirm.setNegativeButton(R.string.edit_dialog_negative_button, new OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					Toast.makeText(getActivity(), ""Cancelado"", Toast.LENGTH_SHORT).show();
				}
			});
			builderConfirm.setPositiveButton(""Eliminar"", new OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					countriesList.remove(index);
					theAdapter.notifyDataSetChanged();
					Toast.makeText(getActivity(), ""Eliminado"", Toast.LENGTH_SHORT).show();
				}
			});
			builderConfirm.create().show();
			break;
		}
		return super.onContextItemSelected(item);
	}
	@Override
	public void rename(int pos, String newName) {
		this.countriesList.set(pos, newName);
		theAdapter.notifyDataSetChanged();
		Toast.makeText(getActivity(), ""Aceptando:""+newName, Toast.LENGTH_SHORT).show();
	}
}",class,
"	public class MyAdapter extends ArrayAdapter<String>{
		private List<String> elements;
		private Context theContext;
		public MyAdapter(Context context, int resource, List<String> objects) {
			super(context, resource, objects);
			theContext = context;
			elements = objects;
		}
		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			LayoutInflater inflater = (LayoutInflater) theContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
			View toReturn = inflater.inflate(R.layout.row_list, parent, false);
			TextView name = (TextView)toReturn.findViewById(R.id.itemNameRow);
			TextView index = (TextView)toReturn.findViewById(R.id.itemIndexRow);
			name.setText(elements.get(position));
			index.setText(""elements[""+position+""]"");
			return toReturn;
		}
	}",class,
"	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		return inflater.inflate(R.layout.list_fragment, container, false);
	}",method,
"	@Override
	public void onListItemClick(ListView l, View v, int position, long id) {
		// TODO Auto-generated method stub
		super.onListItemClick(l, v, position, id);
//		Toast itemClicked = Toast.makeText(getActivity().getApplicationContext(), ""Click en p:""+position+"" e:""+countries[position], Toast.LENGTH_SHORT);
//		itemClicked.show();
		sender.clickedElement(countries[position]);
	}",method,
"	@Override
	public void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		countries = getResources().getStringArray(R.array.countries_array);
		countriesList = new ArrayList<String>();
		for(int i=0; i<countries.length; i++){
			countriesList.add(countries[i]);
		}
		theAdapter = new MyAdapter(
				getActivity(), 
				android.R.layout.simple_list_item_1, 
				countriesList); 
		setListAdapter(theAdapter);
//				new ArrayAdapter<String>(
//						getActivity(),
//						android.R.layout.simple_list_item_1,
//						countries));
	}",method,
"		for(int i=0; i<countries.length; i++){
			countriesList.add(countries[i]);
		}",method,
"		public MyAdapter(Context context, int resource, List<String> objects) {
			super(context, resource, objects);
			theContext = context;
			elements = objects;
		}",method,
"		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			LayoutInflater inflater = (LayoutInflater) theContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
			View toReturn = inflater.inflate(R.layout.row_list, parent, false);
			TextView name = (TextView)toReturn.findViewById(R.id.itemNameRow);
			TextView index = (TextView)toReturn.findViewById(R.id.itemIndexRow);
			name.setText(elements.get(position));
			index.setText(""elements[""+position+""]"");
			return toReturn;
		}",method,
"	@Override
	public void onViewCreated(View view, Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onViewCreated(view, savedInstanceState);
		// Una vez haya vista creada, podemos asignar el menu de contexto 
		registerForContextMenu(getListView());
	}",method,
"	@Override
  public void onAttach(Activity activity) {
    super.onAttach(activity);
    // This makes sure that the container activity has implemented
    // the callback interface. If not, it throws an exception
    try {
        sender = (listOfCountries) activity;
    } catch (ClassCastException e) {
        throw new ClassCastException(activity.toString()
                + "" la clase no ha implementado la interfaz"");
    }
  }",method,
"	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
		// TODO Auto-generated method stub
		super.onCreateContextMenu(menu, v, menuInfo);
		MenuInflater contextMenu = getActivity().getMenuInflater();
		contextMenu.inflate(R.menu.context_menu, menu);
	}",method,
"	@Override
	public boolean onContextItemSelected(MenuItem item) {
		// TODO Auto-generated method stub
		AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
	    final int index = info.position;
		switch(item.getItemId()){
		case R.id.do_toast:
			Toast.makeText(getActivity(), ""Toast: ""+index+""-""+countries[index], Toast.LENGTH_SHORT).show();
			// Ojo con esto, se puede pero no es recomendado...
			// ((MainActivity)getActivity()).clickedElement2(countries[index]);
			break;
		case R.id.do_edit:
//			Toast.makeText(getActivity(), ""Edit: ""+index+""-""+countries[index], Toast.LENGTH_SHORT).show();
			RenameItemDialog myDialog = new RenameItemDialog();
			myDialog.theItemPosition = index;
			myDialog.theItemName = countries[index];
			myDialog.theFragment = this;
			myDialog.show(getFragmentManager(), ""dialog"");
			break;
		case R.id.do_delete:
			AlertDialog.Builder builderConfirm = new AlertDialog.Builder(getActivity());
			builderConfirm.setMessage(""Seguro que desea eliminar el elemento: ""+countries[index]+""?"");
			builderConfirm.setNegativeButton(R.string.edit_dialog_negative_button, new OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					Toast.makeText(getActivity(), ""Cancelado"", Toast.LENGTH_SHORT).show();
				}
			});
			builderConfirm.setPositiveButton(""Eliminar"", new OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					countriesList.remove(index);
					theAdapter.notifyDataSetChanged();
					Toast.makeText(getActivity(), ""Eliminado"", Toast.LENGTH_SHORT).show();
				}
			});
			builderConfirm.create().show();
			break;
		}
		return super.onContextItemSelected(item);
	}",method,
"			builderConfirm.setNegativeButton(R.string.edit_dialog_negative_button, new OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					Toast.makeText(getActivity(), ""Cancelado"", Toast.LENGTH_SHORT).show();
				}
			}",method,
"				@Override
				public void onClick(DialogInterface dialog, int which) {
					Toast.makeText(getActivity(), ""Cancelado"", Toast.LENGTH_SHORT).show();
				}",method,
"			builderConfirm.setPositiveButton(""Eliminar"", new OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					countriesList.remove(index);
					theAdapter.notifyDataSetChanged();
					Toast.makeText(getActivity(), ""Eliminado"", Toast.LENGTH_SHORT).show();
				}
			}",method,
"				@Override
				public void onClick(DialogInterface dialog, int which) {
					countriesList.remove(index);
					theAdapter.notifyDataSetChanged();
					Toast.makeText(getActivity(), ""Eliminado"", Toast.LENGTH_SHORT).show();
				}",method,
"	@Override
	public void rename(int pos, String newName) {
		this.countriesList.set(pos, newName);
		theAdapter.notifyDataSetChanged();
		Toast.makeText(getActivity(), ""Aceptando:""+newName, Toast.LENGTH_SHORT).show();
	}",method,
"public class PrintedPdfDocument extends PdfDocument {
    private static final int MILS_PER_INCH = 1000;
    private static final int POINTS_IN_INCH = 72;
    private final int mPageWidth;
    private final int mPageHeight;
    private final Rect mContentRect;
    public PrintedPdfDocument(@NonNull Context context, @NonNull PrintAttributes attributes) {
        MediaSize mediaSize = attributes.getMediaSize();
        // Compute the size of the target canvas from the attributes.
        mPageWidth = (int) (((float) mediaSize.getWidthMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        mPageHeight = (int) (((float) mediaSize.getHeightMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        // Compute the content size from the attributes.
        Margins minMargins = attributes.getMinMargins();
        final int marginLeft = (int) (((float) minMargins.getLeftMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        final int marginTop = (int) (((float) minMargins.getTopMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        final int marginRight = (int) (((float) minMargins.getRightMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        final int marginBottom = (int) (((float) minMargins.getBottomMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        mContentRect = new Rect(marginLeft, marginTop, mPageWidth - marginRight,
                mPageHeight - marginBottom);
    }
    public @NonNull Page startPage(@IntRange(from = 0) int pageNumber) {
        PageInfo pageInfo = new PageInfo
                .Builder(mPageWidth, mPageHeight, pageNumber)
                .setContentRect(mContentRect)
                .create();
        return startPage(pageInfo);
    }
    public @IntRange(from = 0) int getPageWidth() {
        return mPageWidth;
    }
    public @IntRange(from = 0) int getPageHeight() {
        return mPageHeight;
    }
    public @NonNull Rect getPageContentRect() {
        return mContentRect;
    }
}",class,
"    public PrintedPdfDocument(@NonNull Context context, @NonNull PrintAttributes attributes) {
        MediaSize mediaSize = attributes.getMediaSize();
        // Compute the size of the target canvas from the attributes.
        mPageWidth = (int) (((float) mediaSize.getWidthMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        mPageHeight = (int) (((float) mediaSize.getHeightMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        // Compute the content size from the attributes.
        Margins minMargins = attributes.getMinMargins();
        final int marginLeft = (int) (((float) minMargins.getLeftMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        final int marginTop = (int) (((float) minMargins.getTopMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        final int marginRight = (int) (((float) minMargins.getRightMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        final int marginBottom = (int) (((float) minMargins.getBottomMils() / MILS_PER_INCH)
                * POINTS_IN_INCH);
        mContentRect = new Rect(marginLeft, marginTop, mPageWidth - marginRight,
                mPageHeight - marginBottom);
    }",method,
"public class SmsReceiveJob extends ContextJob {
  private static final long serialVersionUID = 1L;
  private static final String TAG = SmsReceiveJob.class.getSimpleName();
  private final @Nullable Object[] pdus;
  private final int      subscriptionId;
  public SmsReceiveJob(@NonNull Context context, @Nullable Object[] pdus, int subscriptionId) {
    super(context, JobParameters.newBuilder()
                                .withPersistence()
                                .withWakeLock(true)
                                .create());
    this.pdus           = pdus;
    this.subscriptionId = subscriptionId;
  }
  @Override
  public void onAdded() {}
  @Override
  public void onRun() {
    Log.w(TAG, ""onRun()"");
    Optional<IncomingTextMessage> message      = assembleMessageFragments(pdus, subscriptionId);
    MasterSecret                  masterSecret = KeyCachingService.getMasterSecret(context);
    MasterSecretUnion masterSecretUnion;
    if (masterSecret == null) {
      masterSecretUnion = new MasterSecretUnion(MasterSecretUtil.getAsymmetricMasterSecret(context, null));
    } else {
      masterSecretUnion = new MasterSecretUnion(masterSecret);
    }
    if (message.isPresent() && !isBlocked(message.get())) {
      Optional<InsertResult> insertResult = storeMessage(masterSecretUnion, message.get());
      if (insertResult.isPresent()) {
        MessageNotifier.updateNotification(context, masterSecret, insertResult.get().getThreadId());
      }
    } else if (message.isPresent()) {
      Log.w(TAG, ""*** Received blocked SMS, ignoring..."");
    } else {
      Log.w(TAG, ""*** Failed to assemble message fragments!"");
    }
  }
  @Override
  public void onCanceled() {
  }
  @Override
  public boolean onShouldRetry(Exception exception) {
    return false;
  }
  private boolean isBlocked(IncomingTextMessage message) {
    if (message.getSender() != null) {
      Recipient recipient = Recipient.from(context, message.getSender(), false);
      return recipient.isBlocked();
    }
    return false;
  }
  private Optional<InsertResult> storeMessage(MasterSecretUnion masterSecret, IncomingTextMessage message) {
    EncryptingSmsDatabase database = DatabaseFactory.getEncryptingSmsDatabase(context);
    if (message.isSecureMessage()) {
      IncomingTextMessage    placeholder  = new IncomingTextMessage(message, """");
      Optional<InsertResult> insertResult = database.insertMessageInbox(placeholder);
      database.markAsLegacyVersion(insertResult.get().getMessageId());
      return insertResult;
    } else {
      return database.insertMessageInbox(masterSecret, message);
    }
  }
  private Optional<IncomingTextMessage> assembleMessageFragments(@Nullable Object[] pdus, int subscriptionId) {
    if (pdus == null) {
      return Optional.absent();
    }
    List<IncomingTextMessage> messages = new LinkedList<>();
    for (Object pdu : pdus) {
      messages.add(new IncomingTextMessage(context, SmsMessage.createFromPdu((byte[])pdu), subscriptionId));
    }
    if (messages.isEmpty()) {
      return Optional.absent();
    }
    return Optional.of(new IncomingTextMessage(messages));
  }
}",class,
"  public SmsReceiveJob(@NonNull Context context, @Nullable Object[] pdus, int subscriptionId) {
    super(context, JobParameters.newBuilder()
                                .withPersistence()
                                .withWakeLock(true)
                                .create());
    this.pdus           = pdus;
    this.subscriptionId = subscriptionId;
  }",method,
"  @Override
  public void onAdded() {}",method,
"  @Override
  public void onRun() {
    Log.w(TAG, ""onRun()"");
    Optional<IncomingTextMessage> message      = assembleMessageFragments(pdus, subscriptionId);
    MasterSecret                  masterSecret = KeyCachingService.getMasterSecret(context);
    MasterSecretUnion masterSecretUnion;
    if (masterSecret == null) {
      masterSecretUnion = new MasterSecretUnion(MasterSecretUtil.getAsymmetricMasterSecret(context, null));
    } else {
      masterSecretUnion = new MasterSecretUnion(masterSecret);
    }
    if (message.isPresent() && !isBlocked(message.get())) {
      Optional<InsertResult> insertResult = storeMessage(masterSecretUnion, message.get());
      if (insertResult.isPresent()) {
        MessageNotifier.updateNotification(context, masterSecret, insertResult.get().getThreadId());
      }
    } else if (message.isPresent()) {
      Log.w(TAG, ""*** Received blocked SMS, ignoring..."");
    } else {
      Log.w(TAG, ""*** Failed to assemble message fragments!"");
    }
  }",method,
"    if (masterSecret == null) {
      masterSecretUnion = new MasterSecretUnion(MasterSecretUtil.getAsymmetricMasterSecret(context, null));
    }",method,
"  @Override
  public void onCanceled() {
  }",method,
"  @Override
  public boolean onShouldRetry(Exception exception) {
    return false;
  }",method,
"  private boolean isBlocked(IncomingTextMessage message) {
    if (message.getSender() != null) {
      Recipient recipient = Recipient.from(context, message.getSender(), false);
      return recipient.isBlocked();
    }
    return false;
  }",method,
"  private Optional<InsertResult> storeMessage(MasterSecretUnion masterSecret, IncomingTextMessage message) {
    EncryptingSmsDatabase database = DatabaseFactory.getEncryptingSmsDatabase(context);
    if (message.isSecureMessage()) {
      IncomingTextMessage    placeholder  = new IncomingTextMessage(message, """");
      Optional<InsertResult> insertResult = database.insertMessageInbox(placeholder);
      database.markAsLegacyVersion(insertResult.get().getMessageId());
      return insertResult;
    } else {
      return database.insertMessageInbox(masterSecret, message);
    }
  }",method,
"  private Optional<IncomingTextMessage> assembleMessageFragments(@Nullable Object[] pdus, int subscriptionId) {
    if (pdus == null) {
      return Optional.absent();
    }
    List<IncomingTextMessage> messages = new LinkedList<>();
    for (Object pdu : pdus) {
      messages.add(new IncomingTextMessage(context, SmsMessage.createFromPdu((byte[])pdu), subscriptionId));
    }
    if (messages.isEmpty()) {
      return Optional.absent();
    }
    return Optional.of(new IncomingTextMessage(messages));
  }",method,
"    if (pdus == null) {
      return Optional.absent();
    }",method,
"    for (Object pdu : pdus) {
      messages.add(new IncomingTextMessage(context, SmsMessage.createFromPdu((byte[])pdu), subscriptionId));
    }",method,
"public class PathMacrosCollector extends PathMacroMap {
  public static final ExtensionPointName<PathMacroFilter> MACRO_FILTER_EXTENSION_POINT_NAME = ExtensionPointName.create(""com.intellij.pathMacroFilter"");
  public static final Pattern MACRO_PATTERN = Pattern.compile(""\\$([\\w\\-\\.]+?)\\$"");
  private final Matcher myMatcher;
  private final Map<String, String> myMacroMap = ContainerUtilRt.newLinkedHashMap();
  private PathMacrosCollector() {
    myMatcher = MACRO_PATTERN.matcher("""");
  }
  @NotNull
  public static Set<String> getMacroNames(@NotNull final Element e) {
    return getMacroNames(e, new CompositePathMacroFilter(Extensions.getExtensions(MACRO_FILTER_EXTENSION_POINT_NAME)),
                         PathMacrosImpl.getInstanceEx());
  }
  @NotNull
  public static Set<String> getMacroNames(Element root, @Nullable PathMacroFilter filter, @NotNull PathMacrosImpl pathMacros) {
    final PathMacrosCollector collector = new PathMacrosCollector();
    collector.substitute(root, true, false, filter);
    Set<String> preResult = collector.myMacroMap.keySet();
    if (preResult.isEmpty()) {
      return Collections.emptySet();
    }
    Set<String> result = new SmartHashSet<>(preResult);
    result.removeAll(pathMacros.getSystemMacroNames());
    result.removeAll(pathMacros.getLegacyMacroNames());
    result.removeAll(pathMacros.getToolMacroNames());
    result.removeAll(pathMacros.getIgnoredMacroNames());
    return result;
  }
  @NotNull
  @Override
  public String substituteRecursively(@NotNull String text, boolean caseSensitive) {
    if (StringUtil.isEmpty(text)) {
      return text;
    }
    myMatcher.reset(text);
    while (myMatcher.find()) {
      myMacroMap.put(myMatcher.group(1), null);
    }
    return text;
  }
  @Override
  public String substitute(String text, boolean caseSensitive) {
    if (StringUtil.isEmpty(text)) {
      return text;
    }
    int startPos = -1;
    if (text.charAt(0) == '$') {
      startPos = 0;
    }
    else {
      for (String protocol : ReplacePathToMacroMap.PROTOCOLS) {
        if (text.length() > protocol.length() + 4 && text.startsWith(protocol) && text.charAt(protocol.length()) == ':') {
          startPos = protocol.length() + 1;
          if (text.charAt(startPos) == '/') startPos++;
          if (text.charAt(startPos) == '/') startPos++;
        }
      }
    }
    if (startPos < 0) {
      return text;
    }
    myMatcher.reset(text).region(startPos, text.length());
    if (myMatcher.lookingAt()) {
      myMacroMap.put(myMatcher.group(1), null);
    }
    return text;
  }
  @Override
  public int hashCode() {
    return myMacroMap.hashCode();
  }
}",class,
"  private PathMacrosCollector() {
    myMatcher = MACRO_PATTERN.matcher("""");
  }",method,
"  @NotNull
  public static Set<String> getMacroNames(@NotNull final Element e) {
    return getMacroNames(e, new CompositePathMacroFilter(Extensions.getExtensions(MACRO_FILTER_EXTENSION_POINT_NAME)),
                         PathMacrosImpl.getInstanceEx());
  }",method,
"  @NotNull
  public static Set<String> getMacroNames(Element root, @Nullable PathMacroFilter filter, @NotNull PathMacrosImpl pathMacros) {
    final PathMacrosCollector collector = new PathMacrosCollector();
    collector.substitute(root, true, false, filter);
    Set<String> preResult = collector.myMacroMap.keySet();
    if (preResult.isEmpty()) {
      return Collections.emptySet();
    }
    Set<String> result = new SmartHashSet<>(preResult);
    result.removeAll(pathMacros.getSystemMacroNames());
    result.removeAll(pathMacros.getLegacyMacroNames());
    result.removeAll(pathMacros.getToolMacroNames());
    result.removeAll(pathMacros.getIgnoredMacroNames());
    return result;
  }",method,
"  @NotNull
  @Override
  public String substituteRecursively(@NotNull String text, boolean caseSensitive) {
    if (StringUtil.isEmpty(text)) {
      return text;
    }
    myMatcher.reset(text);
    while (myMatcher.find()) {
      myMacroMap.put(myMatcher.group(1), null);
    }
    return text;
  }",method,
"  @Override
  public String substitute(String text, boolean caseSensitive) {
    if (StringUtil.isEmpty(text)) {
      return text;
    }
    int startPos = -1;
    if (text.charAt(0) == '$') {
      startPos = 0;
    }
    else {
      for (String protocol : ReplacePathToMacroMap.PROTOCOLS) {
        if (text.length() > protocol.length() + 4 && text.startsWith(protocol) && text.charAt(protocol.length()) == ':') {
          startPos = protocol.length() + 1;
          if (text.charAt(startPos) == '/') startPos++;
          if (text.charAt(startPos) == '/') startPos++;
        }
      }
    }
    if (startPos < 0) {
      return text;
    }
    myMatcher.reset(text).region(startPos, text.length());
    if (myMatcher.lookingAt()) {
      myMacroMap.put(myMatcher.group(1), null);
    }
    return text;
  }",method,
"      for (String protocol : ReplacePathToMacroMap.PROTOCOLS) {
        if (text.length() > protocol.length() + 4 && text.startsWith(protocol) && text.charAt(protocol.length()) == ':') {
          startPos = protocol.length() + 1;
          if (text.charAt(startPos) == '/') startPos++;
          if (text.charAt(startPos) == '/') startPos++;
        }
      }",method,

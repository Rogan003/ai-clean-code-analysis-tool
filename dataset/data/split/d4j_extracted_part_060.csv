code_snippet,type,score
"    public ImmutableSet<BuildTarget> getBuildRules() {
      return buildRules;
    }",method,
"    public int getNumRules() {
      return numRules;
    }",method,
"    @Override
    public String getEventName() {
      return ""RuleCountCalculated"";
    }",method,
"    @Override
    protected String getValueString() {
      return Joiner.on("", "").join(buildRules);
    }",method,
"    @Override
    public boolean equals(Object o) {
      if (!super.equals(o)) {
        return false;
      }
      // Because super.equals compares the EventKey, getting here means that we've somehow managed
      // to create 2 Finished events for the same Started event.
      throw new UnsupportedOperationException(""Multiple conflicting Finished events detected."");
    }",method,
"    @Override
    public int hashCode() {
      return Objects.hashCode(super.hashCode(), buildRules, numRules);
    }",method,
"    protected UnskippedRuleCountUpdated(int numRulesToBuild) {
      super(EventKey.unique());
      this.numRules = numRulesToBuild;
    }",method,
"    public int getNumRules() {
      return numRules;
    }",method,
"    @Override
    public String getEventName() {
      return ""UnskippedRuleCountUpdated"";
    }",method,
"    @Override
    protected String getValueString() {
      return Integer.toString(numRules);
    }",method,
"    @Override
    public boolean equals(Object o) {
      return this == o;
    }",method,
"    @Override
    public int hashCode() {
      return System.identityHashCode(this);
    }",method,
"public class PyMethodDescriptor implements MethodDescriptor<PyParameterInfo, String> {
  private final PyFunction myFunction;
  public PyMethodDescriptor(PyFunction function) {
    myFunction = function;
  }
  @Override
  public String getName() {
    return myFunction.getName();
  }
  @Override
  public List<PyParameterInfo> getParameters() {
    List<PyParameterInfo> parameterInfos = new ArrayList<>();
    PyParameter[] parameters = myFunction.getParameterList().getParameters();
    for (int i = 0; i < parameters.length; i++) {
      PyParameter parameter = parameters[i];
      final PyExpression defaultValue = parameter.getDefaultValue();
      final String name;
      if (parameter instanceof PyNamedParameter) {
        if (((PyNamedParameter)parameter).isPositionalContainer()) {
          name = ""*"" + parameter.getName();
        }
        else if (((PyNamedParameter)parameter).isKeywordContainer()) {
          name = ""**"" + parameter.getName();
        }
        else {
          name = parameter.getName();
        }
      }
      else {
        name = parameter.getText();
      }
      parameterInfos.add(new PyParameterInfo(i, name, defaultValue == null ? null : defaultValue.getText(),
                                             defaultValue != null && !StringUtil.isEmptyOrSpaces(defaultValue.getText())));
    }
    return parameterInfos;
  }
  @Override
  public int getParametersCount() {
    return myFunction.getParameterList().getParameters().length;
  }
  @Override
  public String getVisibility() {
    return """";
  }
  @Override
  public PyFunction getMethod() {
    return myFunction;
  }
  @Override
  public boolean canChangeVisibility() {
    return false;
  }
  @Override
  public boolean canChangeParameters() {
    return true;
  }
  @Override
  public boolean canChangeName() {
    return true;
  }
  @Override
  public ReadWriteOption canChangeReturnType() {
    return ReadWriteOption.None;
  }
}",class,
"  public PyMethodDescriptor(PyFunction function) {
    myFunction = function;
  }",method,
"  @Override
  public String getName() {
    return myFunction.getName();
  }",method,
"  @Override
  public List<PyParameterInfo> getParameters() {
    List<PyParameterInfo> parameterInfos = new ArrayList<>();
    PyParameter[] parameters = myFunction.getParameterList().getParameters();
    for (int i = 0; i < parameters.length; i++) {
      PyParameter parameter = parameters[i];
      final PyExpression defaultValue = parameter.getDefaultValue();
      final String name;
      if (parameter instanceof PyNamedParameter) {
        if (((PyNamedParameter)parameter).isPositionalContainer()) {
          name = ""*"" + parameter.getName();
        }
        else if (((PyNamedParameter)parameter).isKeywordContainer()) {
          name = ""**"" + parameter.getName();
        }
        else {
          name = parameter.getName();
        }
      }
      else {
        name = parameter.getText();
      }
      parameterInfos.add(new PyParameterInfo(i, name, defaultValue == null ? null : defaultValue.getText(),
                                             defaultValue != null && !StringUtil.isEmptyOrSpaces(defaultValue.getText())));
    }
    return parameterInfos;
  }",method,
"    for (int i = 0; i < parameters.length; i++) {
      PyParameter parameter = parameters[i];
      final PyExpression defaultValue = parameter.getDefaultValue();
      final String name;
      if (parameter instanceof PyNamedParameter) {
        if (((PyNamedParameter)parameter).isPositionalContainer()) {
          name = ""*"" + parameter.getName();
        }
        else if (((PyNamedParameter)parameter).isKeywordContainer()) {
          name = ""**"" + parameter.getName();
        }
        else {
          name = parameter.getName();
        }
      }
      else {
        name = parameter.getText();
      }
      parameterInfos.add(new PyParameterInfo(i, name, defaultValue == null ? null : defaultValue.getText(),
                                             defaultValue != null && !StringUtil.isEmptyOrSpaces(defaultValue.getText())));
    }",method,
"      if (parameter instanceof PyNamedParameter) {
        if (((PyNamedParameter)parameter).isPositionalContainer()) {
          name = ""*"" + parameter.getName();
        }
        else if (((PyNamedParameter)parameter).isKeywordContainer()) {
          name = ""**"" + parameter.getName();
        }
        else {
          name = parameter.getName();
        }
      }",method,
"  @Override
  public int getParametersCount() {
    return myFunction.getParameterList().getParameters().length;
  }",method,
"  @Override
  public String getVisibility() {
    return """";
  }",method,
"  @Override
  public PyFunction getMethod() {
    return myFunction;
  }",method,
"  @Override
  public boolean canChangeVisibility() {
    return false;
  }",method,
"  @Override
  public boolean canChangeParameters() {
    return true;
  }",method,
"  @Override
  public boolean canChangeName() {
    return true;
  }",method,
"  @Override
  public ReadWriteOption canChangeReturnType() {
    return ReadWriteOption.None;
  }",method,
"public class RealmQueryBenchmarks {
    private static final int DATA_SIZE = 1000;
    @BenchmarkConfiguration
    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
    private Realm realm;
    @BeforeExperiment
    public void before() {
        RealmConfiguration config = new RealmConfiguration.Builder().build();
        Realm.deleteRealm(config);
        realm = Realm.getInstance(config);
        realm.beginTransaction();
        for (int i = 0; i < DATA_SIZE; i++) {
            AllTypes obj = realm.createObject(AllTypes.class);
            obj.setColumnLong(i);
            obj.setColumnBoolean(i % 2 == 0);
            obj.setColumnString(""Foo "" + i);
            obj.setColumnDouble(i + 1.234D);
        }
        realm.commitTransaction();
    }
    @AfterExperiment
    public void after() {
        realm.close();
    }
    @Benchmark
    public void containsQuery(long reps) {
        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> realmResults = realm.where(AllTypes.class).contains(AllTypes.FIELD_STRING, ""Foo 1"").findAll();
        }
    }
    @Benchmark
    public void count(long reps) {
        for (long i = 0; i < reps; i++) {
            long size = realm.where(AllTypes.class).count();
        }
    }
    @Benchmark
    public void findAll(long reps) {
        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
        }
    }
    @Benchmark
    public void findAllSortedOneField(long reps) {
        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_STRING, Sort.ASCENDING);
        }
    }
}",class,
"    @BeforeExperiment
    public void before() {
        RealmConfiguration config = new RealmConfiguration.Builder().build();
        Realm.deleteRealm(config);
        realm = Realm.getInstance(config);
        realm.beginTransaction();
        for (int i = 0; i < DATA_SIZE; i++) {
            AllTypes obj = realm.createObject(AllTypes.class);
            obj.setColumnLong(i);
            obj.setColumnBoolean(i % 2 == 0);
            obj.setColumnString(""Foo "" + i);
            obj.setColumnDouble(i + 1.234D);
        }
        realm.commitTransaction();
    }",method,
"        for (int i = 0; i < DATA_SIZE; i++) {
            AllTypes obj = realm.createObject(AllTypes.class);
            obj.setColumnLong(i);
            obj.setColumnBoolean(i % 2 == 0);
            obj.setColumnString(""Foo "" + i);
            obj.setColumnDouble(i + 1.234D);
        }",method,
"    @AfterExperiment
    public void after() {
        realm.close();
    }",method,
"    @Benchmark
    public void containsQuery(long reps) {
        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> realmResults = realm.where(AllTypes.class).contains(AllTypes.FIELD_STRING, ""Foo 1"").findAll();
        }
    }",method,
"        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> realmResults = realm.where(AllTypes.class).contains(AllTypes.FIELD_STRING, ""Foo 1"").findAll();
        }",method,
"    @Benchmark
    public void count(long reps) {
        for (long i = 0; i < reps; i++) {
            long size = realm.where(AllTypes.class).count();
        }
    }",method,
"        for (long i = 0; i < reps; i++) {
            long size = realm.where(AllTypes.class).count();
        }",method,
"    @Benchmark
    public void findAll(long reps) {
        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
        }
    }",method,
"        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
        }",method,
"    @Benchmark
    public void findAllSortedOneField(long reps) {
        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_STRING, Sort.ASCENDING);
        }
    }",method,
"        for (long i = 0; i < reps; i++) {
            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_STRING, Sort.ASCENDING);
        }",method,
"final class ProtoAttributes {
  private static final ImmutableSet<String> UPPERCASE_SEGMENTS =
      ImmutableSet.of(""url"", ""http"", ""https"");
  @VisibleForTesting
  static final String PORTABLE_PROTO_FILTERS_EMPTY_ERROR =
      ""The portable_proto_filters attribute can't be empty"";
  @VisibleForTesting
  static final String NO_PROTOS_ERROR =
      ""no protos to compile - a non-empty deps attribute is required"";
  private final RuleContext ruleContext;
  ProtoAttributes(RuleContext ruleContext) {
    this.ruleContext = ruleContext;
  }
  public void validate() throws RuleErrorException {
    if (getProtoFiles().isEmpty() && !hasObjcProtoLibraryDependencies()) {
      ruleContext.throwWithAttributeError(""deps"", NO_PROTOS_ERROR);
    }
    if (hasPortableProtoFilters() && getPortableProtoFilters().isEmpty()) {
      ruleContext.throwWithAttributeError(
          ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR, PORTABLE_PROTO_FILTERS_EMPTY_ERROR);
    }
  }
  boolean isObjcProtoLibrary() {
    return ruleContext.attributes().has(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR);
  }
  boolean hasPortableProtoFilters() {
    return ruleContext
        .attributes()
        .isAttributeValueExplicitlySpecified(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR);
  }
  ImmutableList<Artifact> getPortableProtoFilters() {
    if (ruleContext
        .attributes()
        .has(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR, LABEL_LIST)) {
      return ruleContext
          .getPrerequisiteArtifacts(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR, Mode.HOST)
          .list();
    }
    return ImmutableList.of();
  }
  ImmutableList<Artifact> getWellKnownTypeProtos() {
    return ruleContext
        .getPrerequisiteArtifacts(ObjcRuleClasses.PROTOBUF_WELL_KNOWN_TYPES, Mode.HOST)
        .list();
  }
  NestedSet<Artifact> getProtoFiles() {
    return NestedSetBuilder.<Artifact>stableOrder()
        .addTransitive(getProtoDepsSources())
        .build();
  }
  Artifact getProtoCompiler() {
    return ruleContext.getPrerequisiteArtifact(ObjcRuleClasses.PROTO_COMPILER_ATTR, Mode.HOST);
  }
  Iterable<Artifact> getProtoCompilerSupport() {
    return ruleContext
        .getPrerequisiteArtifacts(ObjcRuleClasses.PROTO_COMPILER_SUPPORT_ATTR, Mode.HOST)
        .list();
  }
  Iterable<Artifact> filterWellKnownProtos(Iterable<Artifact> protoFiles) {
    ProtoSourceFileBlacklist wellKnownProtoBlacklist =
        new ProtoSourceFileBlacklist(ruleContext, getWellKnownTypeProtos());
    return wellKnownProtoBlacklist.filter(protoFiles);
  }
  boolean isProtoWellKnown(Artifact protoFile) {
    ProtoSourceFileBlacklist wellKnownProtoBlacklist =
        new ProtoSourceFileBlacklist(ruleContext, getWellKnownTypeProtos());
    return wellKnownProtoBlacklist.isBlacklisted(protoFile);
  }
  String getGeneratedProtoFilename(String protoFilename, boolean upcaseReservedWords) {
    boolean lastCharWasDigit = false;
    boolean lastCharWasUpper = false;
    boolean lastCharWasLower = false;
    StringBuilder currentSegment = new StringBuilder();
    ArrayList<String> segments = new ArrayList<>();
    for (int i = 0; i < protoFilename.length(); i++) {
      char currentChar = protoFilename.charAt(i);
      if (CharMatcher.javaDigit().matches(currentChar)) {
        if (!lastCharWasDigit) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }
        currentSegment.append(currentChar);
        lastCharWasDigit = true;
        lastCharWasUpper = false;
        lastCharWasLower = false;
      } else if (CharMatcher.javaLowerCase().matches(currentChar)) {
        if (!lastCharWasLower && !lastCharWasUpper) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }
        currentSegment.append(currentChar);
        lastCharWasDigit = false;
        lastCharWasUpper = false;
        lastCharWasLower = true;
      } else if (CharMatcher.javaUpperCase().matches(currentChar)) {
        if (!lastCharWasUpper) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }
        currentSegment.append(Character.toLowerCase(currentChar));
        lastCharWasDigit = false;
        lastCharWasUpper = true;
        lastCharWasLower = false;
      } else {
        lastCharWasDigit = false;
        lastCharWasUpper = false;
        lastCharWasLower = false;
      }
    }
    segments.add(currentSegment.toString());
    StringBuilder casedSegments = new StringBuilder();
    for (String segment : segments) {
      if (upcaseReservedWords && UPPERCASE_SEGMENTS.contains(segment)) {
        casedSegments.append(segment.toUpperCase());
      } else {
        casedSegments.append(LOWER_UNDERSCORE.to(UPPER_CAMEL, segment));
      }
    }
    return casedSegments.toString();
  }
  private NestedSet<Artifact> getProtoDepsSources() {
    NestedSetBuilder<Artifact> artifacts = NestedSetBuilder.stableOrder();
    Iterable<ProtoSourcesProvider> providers =
        ruleContext.getPrerequisites(""deps"", Mode.TARGET, ProtoSourcesProvider.class);
    for (ProtoSourcesProvider provider : providers) {
      artifacts.addTransitive(provider.getTransitiveProtoSources());
    }
    return artifacts.build();
  }
  private boolean hasObjcProtoLibraryDependencies() {
    for (TransitiveInfoCollection dep : ruleContext.getPrerequisites(""deps"", Mode.TARGET)) {
      if (isObjcProtoLibrary(dep)) {
        return true;
      }
    }
    return false;
  }
  private boolean isObjcProtoLibrary(TransitiveInfoCollection dependency) {
    try {
      AbstractConfiguredTarget target = (AbstractConfiguredTarget) dependency;
      String targetName = target.getTarget().getTargetKind();
      return targetName.equals(""objc_proto_library rule"");
    } catch (Exception e) {
      return false;
    }
  }
}",class,
"  ProtoAttributes(RuleContext ruleContext) {
    this.ruleContext = ruleContext;
  }",method,
"  public void validate() throws RuleErrorException {
    if (getProtoFiles().isEmpty() && !hasObjcProtoLibraryDependencies()) {
      ruleContext.throwWithAttributeError(""deps"", NO_PROTOS_ERROR);
    }
    if (hasPortableProtoFilters() && getPortableProtoFilters().isEmpty()) {
      ruleContext.throwWithAttributeError(
          ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR, PORTABLE_PROTO_FILTERS_EMPTY_ERROR);
    }
  }",method,
"  boolean isObjcProtoLibrary() {
    return ruleContext.attributes().has(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR);
  }",method,
"  boolean hasPortableProtoFilters() {
    return ruleContext
        .attributes()
        .isAttributeValueExplicitlySpecified(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR);
  }",method,
"  ImmutableList<Artifact> getPortableProtoFilters() {
    if (ruleContext
        .attributes()
        .has(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR, LABEL_LIST)) {
      return ruleContext
          .getPrerequisiteArtifacts(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR, Mode.HOST)
          .list();
    }
    return ImmutableList.of();
  }",method,
"  ImmutableList<Artifact> getWellKnownTypeProtos() {
    return ruleContext
        .getPrerequisiteArtifacts(ObjcRuleClasses.PROTOBUF_WELL_KNOWN_TYPES, Mode.HOST)
        .list();
  }",method,
"  NestedSet<Artifact> getProtoFiles() {
    return NestedSetBuilder.<Artifact>stableOrder()
        .addTransitive(getProtoDepsSources())
        .build();
  }",method,
"  Artifact getProtoCompiler() {
    return ruleContext.getPrerequisiteArtifact(ObjcRuleClasses.PROTO_COMPILER_ATTR, Mode.HOST);
  }",method,
"  Iterable<Artifact> getProtoCompilerSupport() {
    return ruleContext
        .getPrerequisiteArtifacts(ObjcRuleClasses.PROTO_COMPILER_SUPPORT_ATTR, Mode.HOST)
        .list();
  }",method,
"  Iterable<Artifact> filterWellKnownProtos(Iterable<Artifact> protoFiles) {
    ProtoSourceFileBlacklist wellKnownProtoBlacklist =
        new ProtoSourceFileBlacklist(ruleContext, getWellKnownTypeProtos());
    return wellKnownProtoBlacklist.filter(protoFiles);
  }",method,
"  boolean isProtoWellKnown(Artifact protoFile) {
    ProtoSourceFileBlacklist wellKnownProtoBlacklist =
        new ProtoSourceFileBlacklist(ruleContext, getWellKnownTypeProtos());
    return wellKnownProtoBlacklist.isBlacklisted(protoFile);
  }",method,
"  String getGeneratedProtoFilename(String protoFilename, boolean upcaseReservedWords) {
    boolean lastCharWasDigit = false;
    boolean lastCharWasUpper = false;
    boolean lastCharWasLower = false;
    StringBuilder currentSegment = new StringBuilder();
    ArrayList<String> segments = new ArrayList<>();
    for (int i = 0; i < protoFilename.length(); i++) {
      char currentChar = protoFilename.charAt(i);
      if (CharMatcher.javaDigit().matches(currentChar)) {
        if (!lastCharWasDigit) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }
        currentSegment.append(currentChar);
        lastCharWasDigit = true;
        lastCharWasUpper = false;
        lastCharWasLower = false;
      } else if (CharMatcher.javaLowerCase().matches(currentChar)) {
        if (!lastCharWasLower && !lastCharWasUpper) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }
        currentSegment.append(currentChar);
        lastCharWasDigit = false;
        lastCharWasUpper = false;
        lastCharWasLower = true;
      } else if (CharMatcher.javaUpperCase().matches(currentChar)) {
        if (!lastCharWasUpper) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }
        currentSegment.append(Character.toLowerCase(currentChar));
        lastCharWasDigit = false;
        lastCharWasUpper = true;
        lastCharWasLower = false;
      } else {
        lastCharWasDigit = false;
        lastCharWasUpper = false;
        lastCharWasLower = false;
      }
    }
    segments.add(currentSegment.toString());
    StringBuilder casedSegments = new StringBuilder();
    for (String segment : segments) {
      if (upcaseReservedWords && UPPERCASE_SEGMENTS.contains(segment)) {
        casedSegments.append(segment.toUpperCase());
      } else {
        casedSegments.append(LOWER_UNDERSCORE.to(UPPER_CAMEL, segment));
      }
    }
    return casedSegments.toString();
  }",method,
"        if (!lastCharWasDigit) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }",method,
"        if (!lastCharWasLower && !lastCharWasUpper) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }",method,
"        if (!lastCharWasUpper) {
          segments.add(currentSegment.toString());
          currentSegment = new StringBuilder();
        }",method,
"    for (String segment : segments) {
      if (upcaseReservedWords && UPPERCASE_SEGMENTS.contains(segment)) {
        casedSegments.append(segment.toUpperCase());
      } else {
        casedSegments.append(LOWER_UNDERSCORE.to(UPPER_CAMEL, segment));
      }
    }",method,
"  private NestedSet<Artifact> getProtoDepsSources() {
    NestedSetBuilder<Artifact> artifacts = NestedSetBuilder.stableOrder();
    Iterable<ProtoSourcesProvider> providers =
        ruleContext.getPrerequisites(""deps"", Mode.TARGET, ProtoSourcesProvider.class);
    for (ProtoSourcesProvider provider : providers) {
      artifacts.addTransitive(provider.getTransitiveProtoSources());
    }
    return artifacts.build();
  }",method,
"    for (ProtoSourcesProvider provider : providers) {
      artifacts.addTransitive(provider.getTransitiveProtoSources());
    }",method,
"  private boolean hasObjcProtoLibraryDependencies() {
    for (TransitiveInfoCollection dep : ruleContext.getPrerequisites(""deps"", Mode.TARGET)) {
      if (isObjcProtoLibrary(dep)) {
        return true;
      }
    }
    return false;
  }",method,
"  private boolean isObjcProtoLibrary(TransitiveInfoCollection dependency) {
    try {
      AbstractConfiguredTarget target = (AbstractConfiguredTarget) dependency;
      String targetName = target.getTarget().getTargetKind();
      return targetName.equals(""objc_proto_library rule"");
    } catch (Exception e) {
      return false;
    }
  }",method,
"public class PackageRemapper extends Remapper {
    private static final Logger LOG = LoggerFactory.getLogger(PackageRemapper.class);
    private static final String RESOURCE_SUFFIX = ""RESOURCE"";
    private final List<ClassRename> patterns;
    private final Map<String, String> typeCache = new HashMap<String, String>();
    private final Map<String, String> pathCache = new HashMap<String, String>();
    private final Map<Object, String> valueCache = new HashMap<Object, String>();
    public PackageRemapper(@Nonnull Iterable<? extends ClassRename> patterns) {
        this.patterns = PatternUtils.toList(patterns);
    }
    public PackageRemapper(@Nonnull ClassRename... patterns) {
        this(Arrays.asList(patterns));
    }
    public void addRule(@Nonnull ClassRename pattern) {
        this.patterns.add(pattern);
    }
    @Override
    public String map(String key) {
        String s = typeCache.get(key);
        if (s == null) {
            s = replaceHelper(key);
            if (key.equals(s))
                s = null;
            typeCache.put(key, s);
        }
        return s;
    }
    public String mapPath(String path) {
        String s = pathCache.get(path);
        if (s == null) {
            s = path;
            int slash = s.lastIndexOf('/');
            String end;
            if (slash < 0) {
                end = s;
                s = RESOURCE_SUFFIX;
            } else {
                end = s.substring(slash + 1);
                s = s.substring(0, slash + 1) + RESOURCE_SUFFIX;
            }
            boolean absolute = s.startsWith(""/"");
            if (absolute)
                s = s.substring(1);
            s = replaceHelper(s);
            if (absolute)
                s = ""/"" + s;
            if (s.indexOf(RESOURCE_SUFFIX) < 0)
                return path;
            s = s.substring(0, s.length() - RESOURCE_SUFFIX.length()) + end;
            pathCache.put(path, s);
        }
        return s;
    }
    @Override
    public Object mapValue(Object value) {
        if (value instanceof String) {
            String s = valueCache.get(value);
            if (s == null) {
                s = (String) value;
                if (ClassNameUtils.isArrayForName(s)) {
                    String desc1 = s.replace('.', '/');
                    String desc2 = mapDesc(desc1);
                    if (!desc2.equals(desc1))
                        return desc2.replace('/', '.');
                } else {
                    s = mapPath(s);
                    if (s.equals(value)) {
                        boolean hasDot = s.indexOf('.') >= 0;
                        boolean hasSlash = s.indexOf('/') >= 0;
                        if (!(hasDot && hasSlash)) {
                            if (hasDot) {
                                s = replaceHelper(s.replace('.', '/')).replace('/', '.');
                            } else {
                                s = replaceHelper(s);
                            }
                        }
                    }
                }
                valueCache.put(value, s);
            }
            // TODO: add back class name to verbose message
            if (!s.equals(value))
                if (LOG.isDebugEnabled())
                    LOG.debug(""Changed \"""" + value + ""\"" -> \"""" + s + ""\"""");
            return s;
        } else {
            return super.mapValue(value);
        }
    }
    private String replaceHelper(String value) {
        for (ClassRename pattern : patterns) {
            String result = pattern.replace(value);
            if (result != null)
                return result;
        }
        return value;
    }
}",class,
"            // TODO: add back class name to verbose message
            if (!s.equals(value))
                if (LOG.isDebugEnabled())
                    LOG.debug(""Changed \"""" + value + ""\"" -> \"""" + s + ""\"""");
            return s;
        } else {
            return super.mapValue(value);
        }",class,
"    public PackageRemapper(@Nonnull Iterable<? extends ClassRename> patterns) {
        this.patterns = PatternUtils.toList(patterns);
    }",method,
"    public PackageRemapper(@Nonnull ClassRename... patterns) {
        this(Arrays.asList(patterns));
    }",method,
"    public void addRule(@Nonnull ClassRename pattern) {
        this.patterns.add(pattern);
    }",method,
"    @Override
    public String map(String key) {
        String s = typeCache.get(key);
        if (s == null) {
            s = replaceHelper(key);
            if (key.equals(s))
                s = null;
            typeCache.put(key, s);
        }
        return s;
    }",method,
"        if (s == null) {
            s = replaceHelper(key);
            if (key.equals(s))
                s = null;
            typeCache.put(key, s);
        }",method,
"    public String mapPath(String path) {
        String s = pathCache.get(path);
        if (s == null) {
            s = path;
            int slash = s.lastIndexOf('/');
            String end;
            if (slash < 0) {
                end = s;
                s = RESOURCE_SUFFIX;
            } else {
                end = s.substring(slash + 1);
                s = s.substring(0, slash + 1) + RESOURCE_SUFFIX;
            }
            boolean absolute = s.startsWith(""/"");
            if (absolute)
                s = s.substring(1);
            s = replaceHelper(s);
            if (absolute)
                s = ""/"" + s;
            if (s.indexOf(RESOURCE_SUFFIX) < 0)
                return path;
            s = s.substring(0, s.length() - RESOURCE_SUFFIX.length()) + end;
            pathCache.put(path, s);
        }
        return s;
    }",method,
"        if (s == null) {
            s = path;
            int slash = s.lastIndexOf('/');
            String end;
            if (slash < 0) {
                end = s;
                s = RESOURCE_SUFFIX;
            } else {
                end = s.substring(slash + 1);
                s = s.substring(0, slash + 1) + RESOURCE_SUFFIX;
            }
            boolean absolute = s.startsWith(""/"");
            if (absolute)
                s = s.substring(1);
            s = replaceHelper(s);
            if (absolute)
                s = ""/"" + s;
            if (s.indexOf(RESOURCE_SUFFIX) < 0)
                return path;
            s = s.substring(0, s.length() - RESOURCE_SUFFIX.length()) + end;
            pathCache.put(path, s);
        }",method,
"            if (slash < 0) {
                end = s;
                s = RESOURCE_SUFFIX;
            }",method,
"    @Override
    public Object mapValue(Object value) {
        if (value instanceof String) {
            String s = valueCache.get(value);
            if (s == null) {
                s = (String) value;
                if (ClassNameUtils.isArrayForName(s)) {
                    String desc1 = s.replace('.', '/');
                    String desc2 = mapDesc(desc1);
                    if (!desc2.equals(desc1))
                        return desc2.replace('/', '.');
                } else {
                    s = mapPath(s);
                    if (s.equals(value)) {
                        boolean hasDot = s.indexOf('.') >= 0;
                        boolean hasSlash = s.indexOf('/') >= 0;
                        if (!(hasDot && hasSlash)) {
                            if (hasDot) {
                                s = replaceHelper(s.replace('.', '/')).replace('/', '.');
                            } else {
                                s = replaceHelper(s);
                            }
                        }
                    }
                }
                valueCache.put(value, s);
            }
            // TODO: add back class name to verbose message
            if (!s.equals(value))
                if (LOG.isDebugEnabled())
                    LOG.debug(""Changed \"""" + value + ""\"" -> \"""" + s + ""\"""");
            return s;
        } else {
            return super.mapValue(value);
        }
    }",method,
"        if (value instanceof String) {
            String s = valueCache.get(value);
            if (s == null) {
                s = (String) value;
                if (ClassNameUtils.isArrayForName(s)) {
                    String desc1 = s.replace('.', '/');
                    String desc2 = mapDesc(desc1);
                    if (!desc2.equals(desc1))
                        return desc2.replace('/', '.');
                } else {
                    s = mapPath(s);
                    if (s.equals(value)) {
                        boolean hasDot = s.indexOf('.') >= 0;
                        boolean hasSlash = s.indexOf('/') >= 0;
                        if (!(hasDot && hasSlash)) {
                            if (hasDot) {
                                s = replaceHelper(s.replace('.', '/')).replace('/', '.');
                            } else {
                                s = replaceHelper(s);
                            }
                        }
                    }
                }
                valueCache.put(value, s);
            }
            // TODO: add back class name to verbose message
            if (!s.equals(value))
                if (LOG.isDebugEnabled())
                    LOG.debug(""Changed \"""" + value + ""\"" -> \"""" + s + ""\"""");
            return s;
        }",method,
"            if (s == null) {
                s = (String) value;
                if (ClassNameUtils.isArrayForName(s)) {
                    String desc1 = s.replace('.', '/');
                    String desc2 = mapDesc(desc1);
                    if (!desc2.equals(desc1))
                        return desc2.replace('/', '.');
                } else {
                    s = mapPath(s);
                    if (s.equals(value)) {
                        boolean hasDot = s.indexOf('.') >= 0;
                        boolean hasSlash = s.indexOf('/') >= 0;
                        if (!(hasDot && hasSlash)) {
                            if (hasDot) {
                                s = replaceHelper(s.replace('.', '/')).replace('/', '.');
                            } else {
                                s = replaceHelper(s);
                            }
                        }
                    }
                }
                valueCache.put(value, s);
            }",method,
"                            if (hasDot) {
                                s = replaceHelper(s.replace('.', '/')).replace('/', '.');
                            }",method,
"    private String replaceHelper(String value) {
        for (ClassRename pattern : patterns) {
            String result = pattern.replace(value);
            if (result != null)
                return result;
        }
        return value;
    }",method,
"        for (ClassRename pattern : patterns) {
            String result = pattern.replace(value);
            if (result != null)
                return result;
        }",method,
"final public class UntrustedChecker extends PKIXCertPathChecker {
    private static final Debug debug = Debug.getInstance(""certpath"");
    public UntrustedChecker() {
        // blank
    }
    @Override
    public void init(boolean forward) throws CertPathValidatorException {
        // Note that this class supports both forward and reverse modes.
    }
    @Override
    public boolean isForwardCheckingSupported() {
        // Note that this class supports both forward and reverse modes.
        return true;
    }
    @Override
    public Set<String> getSupportedExtensions() {
        return null;
    }
    @Override
    public void check(Certificate cert,
            Collection<String> unresolvedCritExts)
            throws CertPathValidatorException {
        X509Certificate currCert = (X509Certificate)cert;
        if (UntrustedCertificates.isUntrusted(currCert)) {
            if (debug != null) {
                debug.println(""UntrustedChecker: untrusted certificate "" +
                        currCert.getSubjectX500Principal());
            }
            throw new CertPathValidatorException(
                ""Untrusted certificate: "" + currCert.getSubjectX500Principal());
        }
    }
}",class,
"        // Note that this class supports both forward and reverse modes.
    }
    @Override
    public boolean isForwardCheckingSupported() {
        // Note that this class supports both forward and reverse modes.
        return true;
    }",class,
"        // Note that this class supports both forward and reverse modes.
        return true;
    }
    @Override
    public Set<String> getSupportedExtensions() {
        return null;
    }",class,
"    public UntrustedChecker() {
        // blank
    }",method,
"    @Override
    public void init(boolean forward) throws CertPathValidatorException {
        // Note that this class supports both forward and reverse modes.
    }",method,
"    @Override
    public boolean isForwardCheckingSupported() {
        // Note that this class supports both forward and reverse modes.
        return true;
    }",method,
"    @Override
    public Set<String> getSupportedExtensions() {
        return null;
    }",method,
"    @Override
    public void check(Certificate cert,
            Collection<String> unresolvedCritExts)
            throws CertPathValidatorException {
        X509Certificate currCert = (X509Certificate)cert;
        if (UntrustedCertificates.isUntrusted(currCert)) {
            if (debug != null) {
                debug.println(""UntrustedChecker: untrusted certificate "" +
                        currCert.getSubjectX500Principal());
            }
            throw new CertPathValidatorException(
                ""Untrusted certificate: "" + currCert.getSubjectX500Principal());
        }
    }",method,
"            if (debug != null) {
                debug.println(""UntrustedChecker: untrusted certificate "" +
                        currCert.getSubjectX500Principal());
            }",method,
"public class TestDisable extends TestCase {
    private MockDriver      driver;
    private DruidDataSource dataSource;
    protected void setUp() throws Exception {
        DruidDataSourceStatManager.clear();
        driver = new MockDriver();
        dataSource = new DruidDataSource();
        dataSource.setUrl(""jdbc:mock:xxx"");
        dataSource.setDriver(driver);
        dataSource.setInitialSize(1);
        dataSource.setMaxActive(2);
        dataSource.setMaxIdle(2);
        dataSource.setMinIdle(1);
        dataSource.setMinEvictableIdleTimeMillis(300 * 1000); // 300 / 10
        dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); // 180 / 10
        dataSource.setTestWhileIdle(true);
        dataSource.setTestOnBorrow(false);
        dataSource.setValidationQuery(""SELECT 1"");
        dataSource.setFilters(""stat"");
    }
    protected void tearDown() throws Exception {
        dataSource.close();
        Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
    }
    public void test_close() throws Exception {
        final int threadCount = 100;
        Thread[] threads = new Thread[threadCount];
        final CountDownLatch startLatch = new CountDownLatch(1);
        final CountDownLatch endLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; ++i) {
            threads[i] = new Thread(""thread-"" + i) {
                public void run() {
                    try {
                        startLatch.await();
                        Connection conn = dataSource.getConnection();
                    } catch (DataSourceDisableException e) {
                        // skip
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        endLatch.countDown();
                    }
                }
            };
        }
        startLatch.countDown();
        for (int i = 0; i < threadCount; ++i) {
            threads[i].start();
        }
        Thread.sleep(1000);
        new Thread(""close thread"") {
            public void run() {
                dataSource.setEnable(false);
            }
        }.start();
        endLatch.await();
    }
}",class,
"    protected void setUp() throws Exception {
        DruidDataSourceStatManager.clear();
        driver = new MockDriver();
        dataSource = new DruidDataSource();
        dataSource.setUrl(""jdbc:mock:xxx"");
        dataSource.setDriver(driver);
        dataSource.setInitialSize(1);
        dataSource.setMaxActive(2);
        dataSource.setMaxIdle(2);
        dataSource.setMinIdle(1);
        dataSource.setMinEvictableIdleTimeMillis(300 * 1000); // 300 / 10
        dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); // 180 / 10
        dataSource.setTestWhileIdle(true);
        dataSource.setTestOnBorrow(false);
        dataSource.setValidationQuery(""SELECT 1"");
        dataSource.setFilters(""stat"");
    }",method,
"    protected void tearDown() throws Exception {
        dataSource.close();
        Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
    }",method,
"    public void test_close() throws Exception {
        final int threadCount = 100;
        Thread[] threads = new Thread[threadCount];
        final CountDownLatch startLatch = new CountDownLatch(1);
        final CountDownLatch endLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; ++i) {
            threads[i] = new Thread(""thread-"" + i) {
                public void run() {
                    try {
                        startLatch.await();
                        Connection conn = dataSource.getConnection();
                    } catch (DataSourceDisableException e) {
                        // skip
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        endLatch.countDown();
                    }
                }
            };
        }
        startLatch.countDown();
        for (int i = 0; i < threadCount; ++i) {
            threads[i].start();
        }
        Thread.sleep(1000);
        new Thread(""close thread"") {
            public void run() {
                dataSource.setEnable(false);
            }
        }.start();
        endLatch.await();
    }",method,
"        for (int i = 0; i < threadCount; ++i) {
            threads[i] = new Thread(""thread-"" + i) {
                public void run() {
                    try {
                        startLatch.await();
                        Connection conn = dataSource.getConnection();
                    } catch (DataSourceDisableException e) {
                        // skip
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        endLatch.countDown();
                    }
                }
            };
        }",method,
"                public void run() {
                    try {
                        startLatch.await();
                        Connection conn = dataSource.getConnection();
                    } catch (DataSourceDisableException e) {
                        // skip
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        endLatch.countDown();
                    }
                }",method,
"        for (int i = 0; i < threadCount; ++i) {
            threads[i].start();
        }",method,
"        new Thread(""close thread"") {
            public void run() {
                dataSource.setEnable(false);
            }
        }",method,
"            public void run() {
                dataSource.setEnable(false);
            }",method,
"public class DefaultTransformationSupport implements AstTransformationSupport {
  @Override
  public void applyTransformation(@NotNull TransformationContext context) {
    for (GrField field : context.getFields()) {
      if (!field.isProperty()) continue;
      final String fieldName = field.getName();
      String nameNonBoolean = getGetterNameNonBoolean(fieldName);
      if (!hasContradictingMethods(context, nameNonBoolean, false)) {
        context.addMethod(new GrAccessorMethodImpl(field, false, nameNonBoolean));
        if (PsiType.BOOLEAN.equals(field.getDeclaredType())) {
          String nameBoolean = getGetterNameBoolean(fieldName);
          if (!hasContradictingMethods(context, nameBoolean, false)) {
            context.addMethod(new GrAccessorMethodImpl(field, false, nameBoolean));
          }
        }
      }
      if (!field.hasModifierProperty(PsiModifier.FINAL)) {
        String setterName = getSetterName(fieldName);
        if (!hasContradictingMethods(context, setterName, true)) {
          context.addMethod(new GrAccessorMethodImpl(field, true, setterName));
        }
      }
    }
  }
  public static boolean hasContradictingMethods(@NotNull TransformationContext helper, String name, boolean isSetter) {
    Collection<PsiMethod> methods = helper.findMethodsByName(name, true);
    final int paramCount = isSetter ? 1 : 0;
    for (PsiMethod method : methods) {
      if (paramCount != method.getParameterList().getParametersCount()) continue;
      if (helper.getCodeClass().equals(method.getContainingClass())) return true;
      if (PsiUtil.isAccessible(helper.getCodeClass(), method) && method.hasModifierProperty(PsiModifier.FINAL)) return true;
    }
    return false;
  }
}",class,
"  @Override
  public void applyTransformation(@NotNull TransformationContext context) {
    for (GrField field : context.getFields()) {
      if (!field.isProperty()) continue;
      final String fieldName = field.getName();
      String nameNonBoolean = getGetterNameNonBoolean(fieldName);
      if (!hasContradictingMethods(context, nameNonBoolean, false)) {
        context.addMethod(new GrAccessorMethodImpl(field, false, nameNonBoolean));
        if (PsiType.BOOLEAN.equals(field.getDeclaredType())) {
          String nameBoolean = getGetterNameBoolean(fieldName);
          if (!hasContradictingMethods(context, nameBoolean, false)) {
            context.addMethod(new GrAccessorMethodImpl(field, false, nameBoolean));
          }
        }
      }
      if (!field.hasModifierProperty(PsiModifier.FINAL)) {
        String setterName = getSetterName(fieldName);
        if (!hasContradictingMethods(context, setterName, true)) {
          context.addMethod(new GrAccessorMethodImpl(field, true, setterName));
        }
      }
    }
  }",method,
"  public static boolean hasContradictingMethods(@NotNull TransformationContext helper, String name, boolean isSetter) {
    Collection<PsiMethod> methods = helper.findMethodsByName(name, true);
    final int paramCount = isSetter ? 1 : 0;
    for (PsiMethod method : methods) {
      if (paramCount != method.getParameterList().getParametersCount()) continue;
      if (helper.getCodeClass().equals(method.getContainingClass())) return true;
      if (PsiUtil.isAccessible(helper.getCodeClass(), method) && method.hasModifierProperty(PsiModifier.FINAL)) return true;
    }
    return false;
  }",method,
"    for (PsiMethod method : methods) {
      if (paramCount != method.getParameterList().getParametersCount()) continue;
      if (helper.getCodeClass().equals(method.getContainingClass())) return true;
      if (PsiUtil.isAccessible(helper.getCodeClass(), method) && method.hasModifierProperty(PsiModifier.FINAL)) return true;
    }",method,
"public class BinaryVectorOpNode extends LoopNode {
  private String operatorName;
  private LoopNode[] operands = new LoopNode[2];
  private int lengthLocal1;
  private int lengthLocal2;
  private int lengthLocal;
  private Method applyMethod;
  private Class argumentType;
  public BinaryVectorOpNode(String operatorName, Method operator, LoopNode x, LoopNode y) {
    this.operatorName = operatorName;
    this.operands[0] = x;
    this.operands[1] = y;
    applyMethod = operator;
    assert applyMethod != null;
    argumentType = applyMethod.getParameterTypes()[0];
  }
  public static Method findMethod(Vector vector) {
    for (Method method : vector.getClass().getMethods()) {
      if (method.getName().equals(""compute"") &&
              Modifier.isPublic(method.getModifiers()) &&
              Modifier.isStatic(method.getModifiers()) &&
              method.getParameterTypes().length == 2) {
        if (supportedType(method.getReturnType()) &&
            supportedType(method.getParameterTypes()[0]) &&
            supportedType(method.getParameterTypes()[1])) {
          return method;
        }
      }
    }
    return null;
  }
  @Override
  public void init(ComputeMethod method) {
    MethodVisitor mv = method.getVisitor();
    operands[0].init(method);
    operands[1].init(method);
    lengthLocal1 = method.reserveLocal(1);
    lengthLocal2 = method.reserveLocal(1);
    lengthLocal = method.reserveLocal(1);
    operands[0].pushLength(method);
    mv.visitInsn(DUP);
    mv.visitVarInsn(ISTORE, lengthLocal1);
    operands[1].pushLength(method);
    mv.visitInsn(DUP);
    mv.visitVarInsn(ISTORE, lengthLocal2);
    method.getVisitor().visitMethodInsn(INVOKESTATIC, ""java/lang/Math"", ""max"", ""(II)I"", false);
    mv.visitVarInsn(ISTORE, lengthLocal);
  }
  @Override
  public void pushLength(ComputeMethod method) {
    method.getVisitor().visitVarInsn(ILOAD, lengthLocal);
  }
  @Override
  public void pushElementAsInt(ComputeMethod method, Optional<Label> integerNaLabel) {
    if (argumentType.equals(double.class)) {
      computeDouble(method, integerNaLabel);
    } else if(argumentType.equals(int.class)) {
      computeInt(method, integerNaLabel);
    } else {
      throw new UnsupportedOperationException();
    }
    cast(method.getVisitor(), applyMethod.getReturnType(), int.class);
  }
  @Override
  public boolean mustCheckForIntegerNAs() {
    return operands[0].mustCheckForIntegerNAs() || operands[1].mustCheckForIntegerNAs();
  }
  @Override
  public void appendToKey(StringBuilder key) {
    key.append(operatorName);
    key.append('(');
    for (LoopNode operandAccessor : operands) {
      operandAccessor.appendToKey(key);
      key.append(';');
    }
    key.append(')');
  }
  @Override
  public void pushElementAsDouble(ComputeMethod method, Optional<Label> naIntegerLabel) {
    if (argumentType.equals(double.class)) {
      computeDouble(method, naIntegerLabel);
    } else if (argumentType.equals(int.class)) {
      computeInt(method, naIntegerLabel);
    } else {
      throw new UnsupportedOperationException(argumentType.getName());
    }
    cast(method.getVisitor(), applyMethod.getReturnType(), double.class);
  }
  private void computeInt(ComputeMethod method, Optional<Label> naLabel) {
    // If we've been asked to handle NA checking, then we have to set up our
    // internal NA handler block to handle the case that one of the arguments
    // is NA so that we can clean up the stack before jumping to the outer naLabel.
    // The Java bytecode verifier will not accept that multiple execution paths
    // arrive at the same point with different types on the stack.
    Optional<Label> argNaLabel = Optional.absent();
    if(naLabel.isPresent() &&
            (operands[0].mustCheckForIntegerNAs() || operands[1].mustCheckForIntegerNAs())) {
      argNaLabel = Optional.of(new Label());
    }
    Optional<Label> done = Optional.absent();
    if(argNaLabel.isPresent()) {
      done = Optional.of(new Label());
    }
    MethodVisitor mv = method.getVisitor();
    mv.visitInsn(DUP);
    mv.visitVarInsn(ILOAD, lengthLocal1);
    // stack => { index, index, length1 }
    mv.visitInsn(IREM);
    // stack => { index, index1 }
    operands[0].pushElementAsInt(method, argNaLabel);
    // stack => { index, value1 }
    mv.visitInsn(SWAP);
    // stack => { value1, index}
    mv.visitVarInsn(ILOAD, lengthLocal2);
    // stack => { value1, index, length2 }
    mv.visitInsn(IREM);
    // stack => { value1, index2 }
    operands[1].pushElementAsInt(method, argNaLabel);
    // stack => { value1, value2}
    mv.visitMethodInsn(INVOKESTATIC,
            Type.getInternalName(applyMethod.getDeclaringClass()),
            applyMethod.getName(),
            Type.getMethodDescriptor(applyMethod), false);
    if(done.isPresent()) {
      mv.visitJumpInsn(GOTO, done.get());
    }
    if(argNaLabel.isPresent()) {
      mv.visitLabel(argNaLabel.get());
      // upon arriving here, the stack either contains
      // { index, value1 } if is.na(arg1), or
      // { value1, value2 } if !is.na(arg1) && is.na(arg2).
      // in either case, we have to get rid of one of the ints
      // so that we jump to the outer na block, there is exactly
      // one extra int on the stack as expected.
      mv.visitInsn(POP);
      mv.visitJumpInsn(GOTO, naLabel.get());
    }
    if(done.isPresent()) {
      mv.visitLabel(done.get());
    }
  }
  private void computeDouble(ComputeMethod method, Optional<Label> integerNaLabel) {
    // If we've been asked to handle NA checking, then it gets even more complicated
    // than above because the stack will look different depending on which argument is NA,
    // because the double value of the first operand we push onto the stack requires
    // two positions on the stack.
    Optional<Label> argNaLabel1 = Optional.absent();
    if(integerNaLabel.isPresent() && operands[0].mustCheckForIntegerNAs()) {
      argNaLabel1 = Optional.of(new Label());
    }
    Optional<Label> argNaLabel2 = Optional.absent();
    if(integerNaLabel.isPresent() && operands[1].mustCheckForIntegerNAs()) {
      argNaLabel2 = Optional.of(new Label());
    }
    Optional<Label> done = Optional.absent();
    if(argNaLabel1.isPresent() || argNaLabel2.isPresent()) {
      done = Optional.of(new Label());
    }
    MethodVisitor mv = method.getVisitor();
    mv.visitInsn(DUP);
    mv.visitVarInsn(ILOAD, lengthLocal1);
    // stack => { index, index, length1 }
    mv.visitInsn(IREM);
    // stack => { index, index1 }
    operands[0].pushElementAsDouble(method, argNaLabel1);
    // stack => { index, [value1, value1] }
    mv.visitInsn(DUP2_X1); // next two instructions equivalent to swap
    mv.visitInsn(POP2);
    // stack => { value1, value1, index}
    mv.visitVarInsn(ILOAD, lengthLocal2);
    // stack => { value1, value1, index, length2 }
    mv.visitInsn(IREM);
    // stack => { value1, value1, index2 }
    operands[1].pushElementAsDouble(method, argNaLabel2);
    // stack => { value1, value2}
    mv.visitMethodInsn(INVOKESTATIC,
            Type.getInternalName(applyMethod.getDeclaringClass()),
            applyMethod.getName(),
            Type.getMethodDescriptor(applyMethod), false);
    if(done.isPresent()) {
      mv.visitJumpInsn(GOTO, done.get());
    }
    if(argNaLabel1.isPresent()) {
      mv.visitLabel(argNaLabel1.get());
      // upon arriving here, the stack contains
      // { index, value1::int } if is.na(arg1)
      // get rid of one of the ints
      // so that we jump to the outer na block, there is exactly
      // one extra int on the stack as expected.
      mv.visitInsn(POP);
      mv.visitJumpInsn(GOTO, integerNaLabel.get());
    }
    if(argNaLabel2.isPresent()) {
      mv.visitLabel(argNaLabel2.get());
      // upon arriving here, the stack contains
      // {value1, value1}, value2::int if is.na(arg2)
      // because the first value has already been converted to a double,
      // which occupies two slots on the stack
      mv.visitInsn(POP);
      mv.visitInsn(POP2);
      mv.visitInsn(ICONST_0);
      mv.visitJumpInsn(GOTO, integerNaLabel.get());
    }
    if(done.isPresent()) {
      mv.visitLabel(done.get());
    }
  }
  @Override
  public String toString() {
    return ""("" + operands[0] + operatorName +  operands[1] + "")"";
  }
}",class,
"  public BinaryVectorOpNode(String operatorName, Method operator, LoopNode x, LoopNode y) {
    this.operatorName = operatorName;
    this.operands[0] = x;
    this.operands[1] = y;
    applyMethod = operator;
    assert applyMethod != null;
    argumentType = applyMethod.getParameterTypes()[0];
  }",method,
"  public static Method findMethod(Vector vector) {
    for (Method method : vector.getClass().getMethods()) {
      if (method.getName().equals(""compute"") &&
              Modifier.isPublic(method.getModifiers()) &&
              Modifier.isStatic(method.getModifiers()) &&
              method.getParameterTypes().length == 2) {
        if (supportedType(method.getReturnType()) &&
            supportedType(method.getParameterTypes()[0]) &&
            supportedType(method.getParameterTypes()[1])) {
          return method;
        }
      }
    }
    return null;
  }",method,
"  @Override
  public void init(ComputeMethod method) {
    MethodVisitor mv = method.getVisitor();
    operands[0].init(method);
    operands[1].init(method);
    lengthLocal1 = method.reserveLocal(1);
    lengthLocal2 = method.reserveLocal(1);
    lengthLocal = method.reserveLocal(1);
    operands[0].pushLength(method);
    mv.visitInsn(DUP);
    mv.visitVarInsn(ISTORE, lengthLocal1);
    operands[1].pushLength(method);
    mv.visitInsn(DUP);
    mv.visitVarInsn(ISTORE, lengthLocal2);
    method.getVisitor().visitMethodInsn(INVOKESTATIC, ""java/lang/Math"", ""max"", ""(II)I"", false);
    mv.visitVarInsn(ISTORE, lengthLocal);
  }",method,
"  @Override
  public void pushLength(ComputeMethod method) {
    method.getVisitor().visitVarInsn(ILOAD, lengthLocal);
  }",method,

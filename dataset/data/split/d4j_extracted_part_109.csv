code_snippet,type,score
"   public void setSWF(final String testSWF)
   {
      configuration.setSwf(testSWF);
   }",method,
"   public void setToDir(final String toDir)
   {
      configuration.setReportDir(toDir);
   }",method,
"   public void setHaltonfailure(final boolean fail)
   {
      configuration.setFailOnTestFailure(fail);
   }",method,
"   public void setFailureproperty(final String failprop)
   {
      configuration.setFailureProperty(failprop);
   }",method,
"   public void setVerbose(final boolean verbose)
   {
      configuration.setVerbose(verbose);
   }",method,
"   public void setPlayer(String player)
   {
      configuration.setPlayer(player);
   }",method,
"   public void setCommand(String executableFilePath)
   {
      configuration.setCommand(executableFilePath);
   }",method,
"   public void setHeadless(boolean headless)
   {
      configuration.setHeadless(headless);
   }",method,
"   public void setDisplay(int number)
   {
      configuration.setDisplay(number);
   }",method,
"   public void addSource(FileSet fileset)
   {
      configuration.addSource(fileset);
   }",method,
"   public void addTestSource(FileSet fileset)
   {
      configuration.addTestSource(fileset);
   }",method,
"   public void addLibrary(FileSet fileset)
   {
      configuration.addLibrary(fileset);
   }",method,
"   public void setWorkingDir(String workingDirPath)
   {
      configuration.setWorkingDir(workingDirPath);
   }",method,
"   public void execute() throws BuildException
   {
      //verify entire configuration
      configuration.verify();
      //compile tests if necessary
      if(configuration.shouldCompile())
      {
         Compilation compilation = new Compilation(getProject(), configuration.getCompilationConfiguration());
         configuration.setSwf(compilation.compile());
      }
      //executes tests
      TestRun testRun = new TestRun(getProject(), configuration.getTestRunConfiguration());
      testRun.run();
   }",method,
"   public void setDebug(boolean value)
   {
       configuration.setDebug(value);
   }",method,
"	public Object createDynamicElement(String arg0) throws BuildException 
	{
	  if(""load-config"".equals(arg0))
	  {
	      LoadConfig loadconfig = new LoadConfig();
	      configuration.setLoadConfig(loadconfig);
	      return loadconfig;
	  } 
	  else
	  {
	      throw new BuildException( ""The <flexUnit> type doesn't support the "" + arg0 + ""nested element"");
	  }
	}",method,
"public class MainActivity extends FlutterActivity {
  private static final String BATTERY_CHANNEL = ""samples.flutter.io/battery"";
  private static final String CHARGING_CHANNEL = ""samples.flutter.io/charging"";
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    GeneratedPluginRegistrant.registerWith(this);
    new EventChannel(getFlutterView(), CHARGING_CHANNEL).setStreamHandler(
        new StreamHandler() {
          private BroadcastReceiver chargingStateChangeReceiver;
          @Override
          public void onListen(Object arguments, EventSink events) {
            chargingStateChangeReceiver = createChargingStateChangeReceiver(events);
            registerReceiver(
                chargingStateChangeReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
          }
          @Override
          public void onCancel(Object arguments) {
            unregisterReceiver(chargingStateChangeReceiver);
            chargingStateChangeReceiver = null;
          }
        }
    );
    new MethodChannel(getFlutterView(), BATTERY_CHANNEL).setMethodCallHandler(
        new MethodCallHandler() {
          @Override
          public void onMethodCall(MethodCall call, Result result) {
            if (call.method.equals(""getBatteryLevel"")) {
              int batteryLevel = getBatteryLevel();
              if (batteryLevel != -1) {
                result.success(batteryLevel);
              } else {
                result.error(""UNAVAILABLE"", ""Battery level not available."", null);
              }
            } else {
              result.notImplemented();
            }
          }
        }
    );
  }
  private BroadcastReceiver createChargingStateChangeReceiver(final EventSink events) {
    return new BroadcastReceiver() {
      @Override
      public void onReceive(Context context, Intent intent) {
        int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_UNKNOWN) {
          events.error(""UNAVAILABLE"", ""Charging status unavailable"", null);
        } else {
          boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                               status == BatteryManager.BATTERY_STATUS_FULL;
          events.success(isCharging ? ""charging"" : ""discharging"");
        }
      }
    };
  }
  private int getBatteryLevel() {
    int batteryLevel = -1;
    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
      BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE);
      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
    } else {
      Intent intent = new ContextWrapper(getApplicationContext()).
          registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
      batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) /
          intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
    }
    return batteryLevel;
  }
}",class,
"  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    GeneratedPluginRegistrant.registerWith(this);
    new EventChannel(getFlutterView(), CHARGING_CHANNEL).setStreamHandler(
        new StreamHandler() {
          private BroadcastReceiver chargingStateChangeReceiver;
          @Override
          public void onListen(Object arguments, EventSink events) {
            chargingStateChangeReceiver = createChargingStateChangeReceiver(events);
            registerReceiver(
                chargingStateChangeReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
          }
          @Override
          public void onCancel(Object arguments) {
            unregisterReceiver(chargingStateChangeReceiver);
            chargingStateChangeReceiver = null;
          }
        }
    );
    new MethodChannel(getFlutterView(), BATTERY_CHANNEL).setMethodCallHandler(
        new MethodCallHandler() {
          @Override
          public void onMethodCall(MethodCall call, Result result) {
            if (call.method.equals(""getBatteryLevel"")) {
              int batteryLevel = getBatteryLevel();
              if (batteryLevel != -1) {
                result.success(batteryLevel);
              } else {
                result.error(""UNAVAILABLE"", ""Battery level not available."", null);
              }
            } else {
              result.notImplemented();
            }
          }
        }
    );
  }",method,
"        new StreamHandler() {
          private BroadcastReceiver chargingStateChangeReceiver;
          @Override
          public void onListen(Object arguments, EventSink events) {
            chargingStateChangeReceiver = createChargingStateChangeReceiver(events);
            registerReceiver(
                chargingStateChangeReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
          }
          @Override
          public void onCancel(Object arguments) {
            unregisterReceiver(chargingStateChangeReceiver);
            chargingStateChangeReceiver = null;
          }
        }",method,
"          @Override
          public void onListen(Object arguments, EventSink events) {
            chargingStateChangeReceiver = createChargingStateChangeReceiver(events);
            registerReceiver(
                chargingStateChangeReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
          }",method,
"          @Override
          public void onCancel(Object arguments) {
            unregisterReceiver(chargingStateChangeReceiver);
            chargingStateChangeReceiver = null;
          }",method,
"        new MethodCallHandler() {
          @Override
          public void onMethodCall(MethodCall call, Result result) {
            if (call.method.equals(""getBatteryLevel"")) {
              int batteryLevel = getBatteryLevel();
              if (batteryLevel != -1) {
                result.success(batteryLevel);
              } else {
                result.error(""UNAVAILABLE"", ""Battery level not available."", null);
              }
            } else {
              result.notImplemented();
            }
          }
        }",method,
"          @Override
          public void onMethodCall(MethodCall call, Result result) {
            if (call.method.equals(""getBatteryLevel"")) {
              int batteryLevel = getBatteryLevel();
              if (batteryLevel != -1) {
                result.success(batteryLevel);
              } else {
                result.error(""UNAVAILABLE"", ""Battery level not available."", null);
              }
            } else {
              result.notImplemented();
            }
          }",method,
"              if (batteryLevel != -1) {
                result.success(batteryLevel);
              }",method,
"  private BroadcastReceiver createChargingStateChangeReceiver(final EventSink events) {
    return new BroadcastReceiver() {
      @Override
      public void onReceive(Context context, Intent intent) {
        int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_UNKNOWN) {
          events.error(""UNAVAILABLE"", ""Charging status unavailable"", null);
        } else {
          boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                               status == BatteryManager.BATTERY_STATUS_FULL;
          events.success(isCharging ? ""charging"" : ""discharging"");
        }
      }
    };
  }",method,
"    return new BroadcastReceiver() {
      @Override
      public void onReceive(Context context, Intent intent) {
        int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_UNKNOWN) {
          events.error(""UNAVAILABLE"", ""Charging status unavailable"", null);
        } else {
          boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                               status == BatteryManager.BATTERY_STATUS_FULL;
          events.success(isCharging ? ""charging"" : ""discharging"");
        }
      }
    }",method,
"      @Override
      public void onReceive(Context context, Intent intent) {
        int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_UNKNOWN) {
          events.error(""UNAVAILABLE"", ""Charging status unavailable"", null);
        } else {
          boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                               status == BatteryManager.BATTERY_STATUS_FULL;
          events.success(isCharging ? ""charging"" : ""discharging"");
        }
      }",method,
"        if (status == BatteryManager.BATTERY_STATUS_UNKNOWN) {
          events.error(""UNAVAILABLE"", ""Charging status unavailable"", null);
        }",method,
"  private int getBatteryLevel() {
    int batteryLevel = -1;
    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
      BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE);
      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
    } else {
      Intent intent = new ContextWrapper(getApplicationContext()).
          registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
      batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) /
          intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
    }
    return batteryLevel;
  }",method,
"    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
      BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE);
      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
    }",method,
"public class FastJsonViewControllerTest {
    @RequestMapping(""test1"")
    @FastJsonView(
            include = {@FastJsonFilter(clazz = Company.class,props ={""id"",""name""})})
    public @ResponseBody Company test1() {
        Company company = new Company();
        company.setId(100L);
        company.setName(""测试"");
        company.setDescription(""fastjsonview注解测试"");
        company.setStock(""haha"");
        return company;
    }
    @RequestMapping(""test2"")
    @FastJsonView(
            exclude = {@FastJsonFilter(clazz = Company.class,props ={""id"",""name""})})
    public @ResponseBody Company test2() {
        Company company = new Company();
        company.setId(100L);
        company.setName(""测试"");
        company.setDescription(""fastjsonview注解测试"");
        company.setStock(""haha"");
        return company;
    }
    @RequestMapping(""test3"")
    @FastJsonView(
            include = {@FastJsonFilter(clazz = Company.class,props ={""id"",""name"",""rootDepartment""}),@FastJsonFilter(clazz = Department.class,props = {""description""})})
    public @ResponseBody Company test3() {
        Company company = new Company();
        company.setId(100L);
        company.setName(""测试"");
        company.setDescription(""fastjsonview注解测试"");
        company.setStock(""haha"");
        Department department = new Department();
        department.setName(""部门1"");
        department.setDescription(""部门1描述"");
        department.setId(1L);
        company.setRootDepartment(department);
        return company;
    }
    @RequestMapping(""test4"")
    @FastJsonView(
            include = {@FastJsonFilter(clazz = Company.class,props ={""id"",""name"",""rootDepartment""})},
            exclude = {@FastJsonFilter(clazz = Department.class,props = {""description""})})
    public @ResponseBody Company test4() {
        Company company = new Company();
        company.setId(100L);
        company.setName(""测试"");
        company.setDescription(""fastjsonview注解测试"");
        company.setStock(""haha"");
        Department department = new Department();
        department.setName(""部门1"");
        department.setDescription(""部门1描述"");
        department.setId(1L);
        company.setRootDepartment(department);
        return company;
    }
    @RequestMapping(""test5"")
    @FastJsonView(
            exclude = {@FastJsonFilter(clazz = Department.class,props = {""description""})})
    public @ResponseBody Company test5() {
        Company company = new Company();
        company.setId(100L);
        company.setName(""测试"");
        company.setDescription(""fastjsonview注解测试"");
        company.setStock(""haha"");
        Department department = new Department();
        department.setName(""部门1"");
        department.setDescription(""部门1描述"");
        department.setId(1L);
        company.setRootDepartment(department);
        return company;
    }
    @RequestMapping(""test6"")
    @FastJsonView(
            include = {@FastJsonFilter(clazz = Company.class,props ={""id""})},
            exclude = {@FastJsonFilter(clazz = Company.class,props = {""name""})})
    public @ResponseBody Company test6() {
        Company company = new Company();
        company.setId(100L);
        company.setName(""测试"");
        company.setDescription(""fastjsonview注解测试"");
        company.setStock(""haha"");
        return company;
    }
}",class,
"public class FastJsonEnumTestVO {
    public enum SmsType {
        USER_REGISTER, USER_LOGIN, USER_LOGOUT;
    }
    public class Packet {
        private SmsType smsType;
        public SmsType getSmsType() {
            return smsType;
        }
        public void setSmsType(SmsType smsType) {
            this.smsType = smsType;
        }
    }
    private Packet packet;
    public Packet getPacket() {
        return packet;
    }
    public void setPacket(Packet packet) {
        this.packet = packet;
    }
}",class,
"    public class Packet {
        private SmsType smsType;
        public SmsType getSmsType() {
            return smsType;
        }
        public void setSmsType(SmsType smsType) {
            this.smsType = smsType;
        }
    }",class,
"public class FastJsonGenericityTestVO<T> {
    private T t;
    public T getT() {
        return t;
    }
    public void setT(T t) {
        this.t = t;
    }
}",class,
"        public SmsType getSmsType() {
            return smsType;
        }",method,
"        public void setSmsType(SmsType smsType) {
            this.smsType = smsType;
        }",method,
"    public Packet getPacket() {
        return packet;
    }",method,
"    public void setPacket(Packet packet) {
        this.packet = packet;
    }",method,
"    public T getT() {
        return t;
    }",method,
"    public void setT(T t) {
        this.t = t;
    }",method,
"public class Netty4SizeHeaderFrameDecoderTests extends ESTestCase {
    private final Settings settings = Settings.builder()
        .put(""node.name"", ""NettySizeHeaderFrameDecoderTests"")
        .put(TcpTransport.BIND_HOST.getKey(), ""127.0.0.1"")
        .put(TcpTransport.PORT.getKey(), ""0"")
        .build();
    private ThreadPool threadPool;
    private Netty4Transport nettyTransport;
    private int port;
    private InetAddress host;
    @Before
    public void startThreadPool() {
        threadPool = new ThreadPool(settings);
        NetworkService networkService = new NetworkService(Collections.emptyList());
        BigArrays bigArrays = new MockBigArrays(Settings.EMPTY, new NoneCircuitBreakerService());
        nettyTransport = new Netty4Transport(settings, threadPool, networkService, bigArrays,
            new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService());
        nettyTransport.start();
        TransportAddress[] boundAddresses = nettyTransport.boundAddress().boundAddresses();
        TransportAddress transportAddress = (TransportAddress) randomFrom(boundAddresses);
        port = transportAddress.address().getPort();
        host = transportAddress.address().getAddress();
    }
    @After
    public void terminateThreadPool() throws InterruptedException {
        nettyTransport.stop();
        terminate(threadPool);
        threadPool = null;
    }
    public void testThatTextMessageIsReturnedOnHTTPLikeRequest() throws Exception {
        String randomMethod = randomFrom(""GET"", ""POST"", ""PUT"", ""DELETE"", ""HEAD"", ""OPTIONS"", ""PATCH"");
        String data = randomMethod + "" / HTTP/1.1"";
        try (Socket socket = new MockSocket(host, port)) {
            socket.getOutputStream().write(data.getBytes(StandardCharsets.UTF_8));
            socket.getOutputStream().flush();
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8))) {
                assertThat(reader.readLine(), is(""This is not a HTTP port""));
            }
        }
    }
    public void testThatNothingIsReturnedForOtherInvalidPackets() throws Exception {
        try (Socket socket = new MockSocket(host, port)) {
            socket.getOutputStream().write(""FOOBAR"".getBytes(StandardCharsets.UTF_8));
            socket.getOutputStream().flush();
            // end of stream
            assertThat(socket.getInputStream().read(), is(-1));
        }
    }
}",class,
"    @Before
    public void startThreadPool() {
        threadPool = new ThreadPool(settings);
        NetworkService networkService = new NetworkService(Collections.emptyList());
        BigArrays bigArrays = new MockBigArrays(Settings.EMPTY, new NoneCircuitBreakerService());
        nettyTransport = new Netty4Transport(settings, threadPool, networkService, bigArrays,
            new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService());
        nettyTransport.start();
        TransportAddress[] boundAddresses = nettyTransport.boundAddress().boundAddresses();
        TransportAddress transportAddress = (TransportAddress) randomFrom(boundAddresses);
        port = transportAddress.address().getPort();
        host = transportAddress.address().getAddress();
    }",method,
"    @After
    public void terminateThreadPool() throws InterruptedException {
        nettyTransport.stop();
        terminate(threadPool);
        threadPool = null;
    }",method,
"    public void testThatTextMessageIsReturnedOnHTTPLikeRequest() throws Exception {
        String randomMethod = randomFrom(""GET"", ""POST"", ""PUT"", ""DELETE"", ""HEAD"", ""OPTIONS"", ""PATCH"");
        String data = randomMethod + "" / HTTP/1.1"";
        try (Socket socket = new MockSocket(host, port)) {
            socket.getOutputStream().write(data.getBytes(StandardCharsets.UTF_8));
            socket.getOutputStream().flush();
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8))) {
                assertThat(reader.readLine(), is(""This is not a HTTP port""));
            }
        }
    }",method,
"    public void testThatNothingIsReturnedForOtherInvalidPackets() throws Exception {
        try (Socket socket = new MockSocket(host, port)) {
            socket.getOutputStream().write(""FOOBAR"".getBytes(StandardCharsets.UTF_8));
            socket.getOutputStream().flush();
            // end of stream
            assertThat(socket.getInputStream().read(), is(-1));
        }
    }",method,
"public class NewHttpArchiveRule implements RuleDefinition {
  public static final String NAME = ""new_http_archive"";
  @Override
  public RuleClass build(RuleClass.Builder builder, RuleDefinitionEnvironment environment) {
    return builder
        .add(attr(""url"", STRING))
        .add(attr(""urls"", STRING_LIST))
        .add(attr(""sha256"", STRING))
        .add(attr(""build_file"", STRING))
        .add(attr(""build_file_content"", STRING))
        .add(attr(""workspace_file"", STRING))
        .add(attr(""workspace_file_content"", STRING))
        .add(attr(""type"", STRING))
        .add(attr(""strip_prefix"", STRING))
        .setWorkspaceOnly()
        .build();
  }
  @Override
  public Metadata getMetadata() {
    return RuleDefinition.Metadata.builder()
        .name(NewHttpArchiveRule.NAME)
        .type(RuleClass.Builder.RuleClassType.WORKSPACE)
        .ancestors(WorkspaceBaseRule.class)
        .factoryClass(WorkspaceConfiguredTargetFactory.class)
        .build();
  }
}",class,
"  @Override
  public RuleClass build(RuleClass.Builder builder, RuleDefinitionEnvironment environment) {
    return builder
        .add(attr(""url"", STRING))
        .add(attr(""urls"", STRING_LIST))
        .add(attr(""sha256"", STRING))
        .add(attr(""build_file"", STRING))
        .add(attr(""build_file_content"", STRING))
        .add(attr(""workspace_file"", STRING))
        .add(attr(""workspace_file_content"", STRING))
        .add(attr(""type"", STRING))
        .add(attr(""strip_prefix"", STRING))
        .setWorkspaceOnly()
        .build();
  }",method,
"  @Override
  public Metadata getMetadata() {
    return RuleDefinition.Metadata.builder()
        .name(NewHttpArchiveRule.NAME)
        .type(RuleClass.Builder.RuleClassType.WORKSPACE)
        .ancestors(WorkspaceBaseRule.class)
        .factoryClass(WorkspaceConfiguredTargetFactory.class)
        .build();
  }",method,
"public class ComputerCraftPacket
{
    // Packet types
    // To server
    public static final byte TurnOn = 1;
    public static final byte Reboot = 2;
    public static final byte Shutdown = 3;
    public static final byte QueueEvent = 4;
    public static final byte RequestComputerUpdate = 5;
    public static final byte SetLabel = 6;
    public static final byte RequestTileEntityUpdate = 9;
    // To client
    public static final byte ComputerChanged = 7;
    public static final byte ComputerDeleted = 8;
    // Packet class
    public byte m_packetType;
    public String[] m_dataString;
    public int[] m_dataInt;
    public byte[][] m_dataByte;
    public NBTTagCompound m_dataNBT;
    public ComputerCraftPacket()
    {
        m_packetType = 0;
        m_dataString = null;
        m_dataInt = null;
        m_dataByte = null;
        m_dataNBT = null;
    }
    public void toBytes( PacketBuffer buffer )
    {
        buffer.writeByte( m_packetType );
        if( m_dataString != null )
        {
            buffer.writeByte( m_dataString.length );
        }
        else
        {
            buffer.writeByte( 0 );
        }
        if( m_dataInt != null )
        {
            buffer.writeByte( m_dataInt.length );
        }
        else
        {
            buffer.writeByte( 0 );
        }
        if( m_dataByte != null )
        {
            buffer.writeInt( m_dataByte.length );
        }
        else
        {
            buffer.writeInt( 0 );
        }
        if( m_dataString != null )
        {
            for( String s : m_dataString )
            {
                if( s != null )
                {
                    try
                    {
                        byte[] b = s.getBytes( ""UTF-8"" );
                        buffer.writeBoolean( true );
                        buffer.writeInt( b.length );
                        buffer.writeBytes( b );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        buffer.writeBoolean( false );
                    }
                }
                else
                {
                    buffer.writeBoolean( false );
                }
            }
        }
        if( m_dataInt != null )
        {
            for( int i : m_dataInt )
            {
                buffer.writeInt( i );
            }
        }
        if( m_dataByte != null )
        {
            for( byte[] bytes : m_dataByte )
            {
                if( bytes != null )
                {
                    buffer.writeInt( bytes.length );
                    buffer.writeBytes( bytes );
                }
                else
                {
                    buffer.writeInt( 0 );
                }
            }
        }
        if( m_dataNBT != null )
        {
            try
            {
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                CompressedStreamTools.writeCompressed( m_dataNBT, bos );
                byte[] bytes = bos.toByteArray();
                buffer.writeBoolean( true );
                buffer.writeInt( bytes.length );
                buffer.writeBytes( bytes );
            }
            catch( IOException e )
            {
                buffer.writeBoolean( false );
            }
        }
        else
        {
            buffer.writeBoolean( false );
        }
    }
    public void fromBytes( ByteBuf buffer )
    {
        m_packetType = buffer.readByte();
        byte nString = buffer.readByte();
        byte nInt = buffer.readByte();
        int nByte = buffer.readInt();
        if( nString == 0 )
        {
            m_dataString = null;
        }
        else
        {
            m_dataString = new String[ nString ];
            for( int k = 0; k < nString; k++ )
            {
                if( buffer.readBoolean() )
                {
                    int len = buffer.readInt();
                    byte[] b = new byte[len];
                    buffer.readBytes( b );
                    try
                    {
                        m_dataString[ k ] = new String( b, ""UTF-8"" );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        m_dataString[ k ] = null;
                    }
                }
            }
        }
        if( nInt == 0 )
        {
            m_dataInt = null;
        }
        else
        {
            m_dataInt = new int[ nInt ];
            for( int k = 0; k < nInt; k++ )
            {
                m_dataInt[ k ] = buffer.readInt();
            }
        }
        if( nByte == 0 )
        {
            m_dataByte = null;
        }
        else
        {
            m_dataByte = new byte[ nByte ][];
            for( int k = 0; k < nByte; k++ )
            {
                int length = buffer.readInt();
                if( length > 0 )
                {
                    m_dataByte[ k ] = new byte[ length ];
                    buffer.getBytes( buffer.readerIndex(), m_dataByte[ k ] );
                }
            }
        }
        boolean bNBT = buffer.readBoolean();
        if( !bNBT )
        {
            m_dataNBT = null;
        }
        else
        {
            int byteLength = buffer.readInt();
            byte[] bytes = new byte[ byteLength ];
            buffer.getBytes( buffer.readerIndex(), bytes );
            try
            {
                ByteArrayInputStream bis = new ByteArrayInputStream( bytes );
                m_dataNBT = CompressedStreamTools.readCompressed( bis );
            }
            catch( IOException e )
            {
                m_dataNBT = null;
            }
        }
    }
    public boolean requiresContainer() {
        return m_packetType != RequestComputerUpdate && m_packetType != RequestTileEntityUpdate;
    }
}",class,
"    // Packet class
    public byte m_packetType;
    public String[] m_dataString;
    public int[] m_dataInt;
    public byte[][] m_dataByte;
    public NBTTagCompound m_dataNBT;
    public ComputerCraftPacket()
    {
        m_packetType = 0;
        m_dataString = null;
        m_dataInt = null;
        m_dataByte = null;
        m_dataNBT = null;
    }",class,
"    public ComputerCraftPacket()
    {
        m_packetType = 0;
        m_dataString = null;
        m_dataInt = null;
        m_dataByte = null;
        m_dataNBT = null;
    }",method,
"    public void toBytes( PacketBuffer buffer )
    {
        buffer.writeByte( m_packetType );
        if( m_dataString != null )
        {
            buffer.writeByte( m_dataString.length );
        }
        else
        {
            buffer.writeByte( 0 );
        }
        if( m_dataInt != null )
        {
            buffer.writeByte( m_dataInt.length );
        }
        else
        {
            buffer.writeByte( 0 );
        }
        if( m_dataByte != null )
        {
            buffer.writeInt( m_dataByte.length );
        }
        else
        {
            buffer.writeInt( 0 );
        }
        if( m_dataString != null )
        {
            for( String s : m_dataString )
            {
                if( s != null )
                {
                    try
                    {
                        byte[] b = s.getBytes( ""UTF-8"" );
                        buffer.writeBoolean( true );
                        buffer.writeInt( b.length );
                        buffer.writeBytes( b );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        buffer.writeBoolean( false );
                    }
                }
                else
                {
                    buffer.writeBoolean( false );
                }
            }
        }
        if( m_dataInt != null )
        {
            for( int i : m_dataInt )
            {
                buffer.writeInt( i );
            }
        }
        if( m_dataByte != null )
        {
            for( byte[] bytes : m_dataByte )
            {
                if( bytes != null )
                {
                    buffer.writeInt( bytes.length );
                    buffer.writeBytes( bytes );
                }
                else
                {
                    buffer.writeInt( 0 );
                }
            }
        }
        if( m_dataNBT != null )
        {
            try
            {
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                CompressedStreamTools.writeCompressed( m_dataNBT, bos );
                byte[] bytes = bos.toByteArray();
                buffer.writeBoolean( true );
                buffer.writeInt( bytes.length );
                buffer.writeBytes( bytes );
            }
            catch( IOException e )
            {
                buffer.writeBoolean( false );
            }
        }
        else
        {
            buffer.writeBoolean( false );
        }
    }",method,
"        if( m_dataString != null )
        {
            buffer.writeByte( m_dataString.length );
        }",method,
"        if( m_dataInt != null )
        {
            buffer.writeByte( m_dataInt.length );
        }",method,
"        if( m_dataByte != null )
        {
            buffer.writeInt( m_dataByte.length );
        }",method,
"        if( m_dataString != null )
        {
            for( String s : m_dataString )
            {
                if( s != null )
                {
                    try
                    {
                        byte[] b = s.getBytes( ""UTF-8"" );
                        buffer.writeBoolean( true );
                        buffer.writeInt( b.length );
                        buffer.writeBytes( b );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        buffer.writeBoolean( false );
                    }
                }
                else
                {
                    buffer.writeBoolean( false );
                }
            }
        }",method,
"            for( String s : m_dataString )
            {
                if( s != null )
                {
                    try
                    {
                        byte[] b = s.getBytes( ""UTF-8"" );
                        buffer.writeBoolean( true );
                        buffer.writeInt( b.length );
                        buffer.writeBytes( b );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        buffer.writeBoolean( false );
                    }
                }
                else
                {
                    buffer.writeBoolean( false );
                }
            }",method,
"                if( s != null )
                {
                    try
                    {
                        byte[] b = s.getBytes( ""UTF-8"" );
                        buffer.writeBoolean( true );
                        buffer.writeInt( b.length );
                        buffer.writeBytes( b );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        buffer.writeBoolean( false );
                    }
                }",method,
"                    catch( UnsupportedEncodingException e )
                    {
                        buffer.writeBoolean( false );
                    }",method,
"        if( m_dataInt != null )
        {
            for( int i : m_dataInt )
            {
                buffer.writeInt( i );
            }
        }",method,
"            for( int i : m_dataInt )
            {
                buffer.writeInt( i );
            }",method,
"        if( m_dataByte != null )
        {
            for( byte[] bytes : m_dataByte )
            {
                if( bytes != null )
                {
                    buffer.writeInt( bytes.length );
                    buffer.writeBytes( bytes );
                }
                else
                {
                    buffer.writeInt( 0 );
                }
            }
        }",method,
"            for( byte[] bytes : m_dataByte )
            {
                if( bytes != null )
                {
                    buffer.writeInt( bytes.length );
                    buffer.writeBytes( bytes );
                }
                else
                {
                    buffer.writeInt( 0 );
                }
            }",method,
"                if( bytes != null )
                {
                    buffer.writeInt( bytes.length );
                    buffer.writeBytes( bytes );
                }",method,
"        if( m_dataNBT != null )
        {
            try
            {
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                CompressedStreamTools.writeCompressed( m_dataNBT, bos );
                byte[] bytes = bos.toByteArray();
                buffer.writeBoolean( true );
                buffer.writeInt( bytes.length );
                buffer.writeBytes( bytes );
            }
            catch( IOException e )
            {
                buffer.writeBoolean( false );
            }
        }",method,
"            catch( IOException e )
            {
                buffer.writeBoolean( false );
            }",method,
"    public void fromBytes( ByteBuf buffer )
    {
        m_packetType = buffer.readByte();
        byte nString = buffer.readByte();
        byte nInt = buffer.readByte();
        int nByte = buffer.readInt();
        if( nString == 0 )
        {
            m_dataString = null;
        }
        else
        {
            m_dataString = new String[ nString ];
            for( int k = 0; k < nString; k++ )
            {
                if( buffer.readBoolean() )
                {
                    int len = buffer.readInt();
                    byte[] b = new byte[len];
                    buffer.readBytes( b );
                    try
                    {
                        m_dataString[ k ] = new String( b, ""UTF-8"" );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        m_dataString[ k ] = null;
                    }
                }
            }
        }
        if( nInt == 0 )
        {
            m_dataInt = null;
        }
        else
        {
            m_dataInt = new int[ nInt ];
            for( int k = 0; k < nInt; k++ )
            {
                m_dataInt[ k ] = buffer.readInt();
            }
        }
        if( nByte == 0 )
        {
            m_dataByte = null;
        }
        else
        {
            m_dataByte = new byte[ nByte ][];
            for( int k = 0; k < nByte; k++ )
            {
                int length = buffer.readInt();
                if( length > 0 )
                {
                    m_dataByte[ k ] = new byte[ length ];
                    buffer.getBytes( buffer.readerIndex(), m_dataByte[ k ] );
                }
            }
        }
        boolean bNBT = buffer.readBoolean();
        if( !bNBT )
        {
            m_dataNBT = null;
        }
        else
        {
            int byteLength = buffer.readInt();
            byte[] bytes = new byte[ byteLength ];
            buffer.getBytes( buffer.readerIndex(), bytes );
            try
            {
                ByteArrayInputStream bis = new ByteArrayInputStream( bytes );
                m_dataNBT = CompressedStreamTools.readCompressed( bis );
            }
            catch( IOException e )
            {
                m_dataNBT = null;
            }
        }
    }",method,
"        if( nString == 0 )
        {
            m_dataString = null;
        }",method,
"            for( int k = 0; k < nString; k++ )
            {
                if( buffer.readBoolean() )
                {
                    int len = buffer.readInt();
                    byte[] b = new byte[len];
                    buffer.readBytes( b );
                    try
                    {
                        m_dataString[ k ] = new String( b, ""UTF-8"" );
                    }
                    catch( UnsupportedEncodingException e )
                    {
                        m_dataString[ k ] = null;
                    }
                }
            }",method,
"                    catch( UnsupportedEncodingException e )
                    {
                        m_dataString[ k ] = null;
                    }",method,
"        if( nInt == 0 )
        {
            m_dataInt = null;
        }",method,
"            for( int k = 0; k < nInt; k++ )
            {
                m_dataInt[ k ] = buffer.readInt();
            }",method,
"        if( nByte == 0 )
        {
            m_dataByte = null;
        }",method,
"            for( int k = 0; k < nByte; k++ )
            {
                int length = buffer.readInt();
                if( length > 0 )
                {
                    m_dataByte[ k ] = new byte[ length ];
                    buffer.getBytes( buffer.readerIndex(), m_dataByte[ k ] );
                }
            }",method,
"                if( length > 0 )
                {
                    m_dataByte[ k ] = new byte[ length ];
                    buffer.getBytes( buffer.readerIndex(), m_dataByte[ k ] );
                }",method,
"        if( !bNBT )
        {
            m_dataNBT = null;
        }",method,
"            catch( IOException e )
            {
                m_dataNBT = null;
            }",method,
"    public boolean requiresContainer() {
        return m_packetType != RequestComputerUpdate && m_packetType != RequestTileEntityUpdate;
    }",method,
"public class WhileTranslator extends FunctionCallTranslator {
  @Override
  public Expression translateToExpression(IRBodyBuilder builder, TranslationContext context, Function resolvedFunction, FunctionCall call) {
    addLoop(builder, context, call);
    return Constant.NULL;
  }
  @Override
  public void addStatement(IRBodyBuilder builder, TranslationContext context, Function resolvedFunction, FunctionCall call) {
    addLoop(builder, context, call);
  }
  private void addLoop(IRBodyBuilder factory, TranslationContext context, FunctionCall call) {
    SEXP condition = call.getArgument(0);
    SEXP body = call.getArgument(1);
    IRLabel checkLabel = factory.newLabel();
    IRLabel bodyLabel = factory.newLabel();
    IRLabel exitLabel = factory.newLabel();
    // check the counter and potentially loop
    factory.addLabel(checkLabel);
    factory.addStatement(
        new IfStatement(factory.translateSimpleExpression(context, condition),
            bodyLabel, exitLabel));
    // start the body here
    factory.addLabel(bodyLabel);
    LoopContext loopContext = new LoopContext(context, checkLabel, exitLabel);
    factory.translateStatements(loopContext, body);
    // increment the counter
    factory.addStatement(new GotoStatement(checkLabel));
    factory.addLabel(exitLabel);
  }
}",class,
"  @Override
  public Expression translateToExpression(IRBodyBuilder builder, TranslationContext context, Function resolvedFunction, FunctionCall call) {
    addLoop(builder, context, call);
    return Constant.NULL;
  }",method,
"  @Override
  public void addStatement(IRBodyBuilder builder, TranslationContext context, Function resolvedFunction, FunctionCall call) {
    addLoop(builder, context, call);
  }",method,
"  private void addLoop(IRBodyBuilder factory, TranslationContext context, FunctionCall call) {
    SEXP condition = call.getArgument(0);
    SEXP body = call.getArgument(1);
    IRLabel checkLabel = factory.newLabel();
    IRLabel bodyLabel = factory.newLabel();
    IRLabel exitLabel = factory.newLabel();
    // check the counter and potentially loop
    factory.addLabel(checkLabel);
    factory.addStatement(
        new IfStatement(factory.translateSimpleExpression(context, condition),
            bodyLabel, exitLabel));
    // start the body here
    factory.addLabel(bodyLabel);
    LoopContext loopContext = new LoopContext(context, checkLabel, exitLabel);
    factory.translateStatements(loopContext, body);
    // increment the counter
    factory.addStatement(new GotoStatement(checkLabel));
    factory.addLabel(exitLabel);
  }",method,
"public class MapperProxy<T> implements InvocationHandler, Serializable {
  private static final long serialVersionUID = -6424540398559729838L;
  private final SqlSession sqlSession;
  private final Class<T> mapperInterface;
  private final Map<Method, MapperMethod> methodCache;
  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache) {
    this.sqlSession = sqlSession;
    this.mapperInterface = mapperInterface;
    this.methodCache = methodCache;
  }
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }
  private MapperMethod cachedMapperMethod(Method method) {
    MapperMethod mapperMethod = methodCache.get(method);
    if (mapperMethod == null) {
      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      methodCache.put(method, mapperMethod);
    }
    return mapperMethod;
  }
  @UsesJava7
  private Object invokeDefaultMethod(Object proxy, Method method, Object[] args)
      throws Throwable {
    final Constructor<MethodHandles.Lookup> constructor = MethodHandles.Lookup.class
        .getDeclaredConstructor(Class.class, int.class);
    if (!constructor.isAccessible()) {
      constructor.setAccessible(true);
    }
    final Class<?> declaringClass = method.getDeclaringClass();
    return constructor
        .newInstance(declaringClass,
            MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED
                | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)
        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);
  }
  private boolean isDefaultMethod(Method method) {
    return (method.getModifiers()
        & (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC
        && method.getDeclaringClass().isInterface();
  }
}",class,
"  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache) {
    this.sqlSession = sqlSession;
    this.mapperInterface = mapperInterface;
    this.methodCache = methodCache;
  }",method,
"  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }",method,
"  private MapperMethod cachedMapperMethod(Method method) {
    MapperMethod mapperMethod = methodCache.get(method);
    if (mapperMethod == null) {
      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      methodCache.put(method, mapperMethod);
    }
    return mapperMethod;
  }",method,
"    if (mapperMethod == null) {
      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      methodCache.put(method, mapperMethod);
    }",method,
"  @UsesJava7
  private Object invokeDefaultMethod(Object proxy, Method method, Object[] args)
      throws Throwable {
    final Constructor<MethodHandles.Lookup> constructor = MethodHandles.Lookup.class
        .getDeclaredConstructor(Class.class, int.class);
    if (!constructor.isAccessible()) {
      constructor.setAccessible(true);
    }
    final Class<?> declaringClass = method.getDeclaringClass();
    return constructor
        .newInstance(declaringClass,
            MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED
                | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)
        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);
  }",method,
"  private boolean isDefaultMethod(Method method) {
    return (method.getModifiers()
        & (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC
        && method.getDeclaringClass().isInterface();
  }",method,
"import java.lang.ref.SoftReference;
class Win32FsCache {
  private final IdeaWin32 myKernel = IdeaWin32.getInstance();
  private Reference<TIntObjectHashMap<THashMap<String, FileAttributes>>> myCache;
  void clearCache() {
    myCache = null;
  }
  @NotNull
  private TIntObjectHashMap<THashMap<String, FileAttributes>> getMap() {
    TIntObjectHashMap<THashMap<String, FileAttributes>> map = com.intellij.reference.SoftReference.dereference(myCache);
    if (map == null) {
      map = new TIntObjectHashMap<>();
      myCache = new SoftReference<>(map);
    }
    return map;
  }
  @NotNull
  String[] list(@NotNull VirtualFile file) {
    String path = file.getPath();
    FileInfo[] fileInfo = myKernel.listChildren(path);
    if (fileInfo == null || fileInfo.length == 0) {
      return ArrayUtil.EMPTY_STRING_ARRAY;
    }
    String[] names = new String[fileInfo.length];
    TIntObjectHashMap<THashMap<String, FileAttributes>> map = getMap();
    int parentId = ((VirtualFileWithId)file).getId();
    THashMap<String, FileAttributes> nestedMap = map.get(parentId);
    if (nestedMap == null) {
      nestedMap = new THashMap<>(fileInfo.length, FileUtil.PATH_HASHING_STRATEGY);
      map.put(parentId, nestedMap);
    }
    for (int i = 0, length = fileInfo.length; i < length; i++) {
      FileInfo info = fileInfo[i];
      String name = info.getName();
      nestedMap.put(name, info.toFileAttributes());
      names[i] = name;
    }
    return names;
  }
  @Nullable
  FileAttributes getAttributes(@NotNull VirtualFile file) {
    VirtualFile parent = file.getParent();
    int parentId = parent instanceof VirtualFileWithId ? ((VirtualFileWithId)parent).getId() : -((VirtualFileWithId)file).getId();
    TIntObjectHashMap<THashMap<String, FileAttributes>> map = getMap();
    THashMap<String, FileAttributes> nestedMap = map.get(parentId);
    String name = file.getName();
    FileAttributes attributes = nestedMap != null ? nestedMap.get(name) : null;
    if (attributes == null) {
      if (nestedMap != null && !(nestedMap instanceof IncompleteChildrenMap)) {
        return null; // our info from parent doesn't mention the child in this refresh session
      }
      FileInfo info = myKernel.getInfo(file.getPath());
      if (info == null) {
        return null;
      }
      attributes = info.toFileAttributes();
      if (nestedMap == null) {
        nestedMap = new IncompleteChildrenMap<>(FileUtil.PATH_HASHING_STRATEGY);
        map.put(parentId, nestedMap);
      }
      nestedMap.put(name, attributes);
    }
    return attributes;
  }
  private static class IncompleteChildrenMap<K, V> extends THashMap<K,V> {
    IncompleteChildrenMap(TObjectHashingStrategy<K> strategy) {
      super(strategy);
    }
  }
}",class,
"  private static class IncompleteChildrenMap<K, V> extends THashMap<K,V> {
    IncompleteChildrenMap(TObjectHashingStrategy<K> strategy) {
      super(strategy);
    }
  }",class,
"  void clearCache() {
    myCache = null;
  }",method,
"  @NotNull
  private TIntObjectHashMap<THashMap<String, FileAttributes>> getMap() {
    TIntObjectHashMap<THashMap<String, FileAttributes>> map = com.intellij.reference.SoftReference.dereference(myCache);
    if (map == null) {
      map = new TIntObjectHashMap<>();
      myCache = new SoftReference<>(map);
    }
    return map;
  }",method,
"    if (map == null) {
      map = new TIntObjectHashMap<>();
      myCache = new SoftReference<>(map);
    }",method,
"  @NotNull
  String[] list(@NotNull VirtualFile file) {
    String path = file.getPath();
    FileInfo[] fileInfo = myKernel.listChildren(path);
    if (fileInfo == null || fileInfo.length == 0) {
      return ArrayUtil.EMPTY_STRING_ARRAY;
    }
    String[] names = new String[fileInfo.length];
    TIntObjectHashMap<THashMap<String, FileAttributes>> map = getMap();
    int parentId = ((VirtualFileWithId)file).getId();
    THashMap<String, FileAttributes> nestedMap = map.get(parentId);
    if (nestedMap == null) {
      nestedMap = new THashMap<>(fileInfo.length, FileUtil.PATH_HASHING_STRATEGY);
      map.put(parentId, nestedMap);
    }
    for (int i = 0, length = fileInfo.length; i < length; i++) {
      FileInfo info = fileInfo[i];
      String name = info.getName();
      nestedMap.put(name, info.toFileAttributes());
      names[i] = name;
    }
    return names;
  }",method,
"    if (fileInfo == null || fileInfo.length == 0) {
      return ArrayUtil.EMPTY_STRING_ARRAY;
    }",method,
"    if (nestedMap == null) {
      nestedMap = new THashMap<>(fileInfo.length, FileUtil.PATH_HASHING_STRATEGY);
      map.put(parentId, nestedMap);
    }",method,
"    for (int i = 0, length = fileInfo.length; i < length; i++) {
      FileInfo info = fileInfo[i];
      String name = info.getName();
      nestedMap.put(name, info.toFileAttributes());
      names[i] = name;
    }",method,
"  @Nullable
  FileAttributes getAttributes(@NotNull VirtualFile file) {
    VirtualFile parent = file.getParent();
    int parentId = parent instanceof VirtualFileWithId ? ((VirtualFileWithId)parent).getId() : -((VirtualFileWithId)file).getId();
    TIntObjectHashMap<THashMap<String, FileAttributes>> map = getMap();
    THashMap<String, FileAttributes> nestedMap = map.get(parentId);
    String name = file.getName();
    FileAttributes attributes = nestedMap != null ? nestedMap.get(name) : null;
    if (attributes == null) {
      if (nestedMap != null && !(nestedMap instanceof IncompleteChildrenMap)) {
        return null; // our info from parent doesn't mention the child in this refresh session
      }
      FileInfo info = myKernel.getInfo(file.getPath());
      if (info == null) {
        return null;
      }
      attributes = info.toFileAttributes();
      if (nestedMap == null) {
        nestedMap = new IncompleteChildrenMap<>(FileUtil.PATH_HASHING_STRATEGY);
        map.put(parentId, nestedMap);
      }
      nestedMap.put(name, attributes);
    }
    return attributes;
  }",method,
"    if (attributes == null) {
      if (nestedMap != null && !(nestedMap instanceof IncompleteChildrenMap)) {
        return null; // our info from parent doesn't mention the child in this refresh session
      }
      FileInfo info = myKernel.getInfo(file.getPath());
      if (info == null) {
        return null;
      }
      attributes = info.toFileAttributes();
      if (nestedMap == null) {
        nestedMap = new IncompleteChildrenMap<>(FileUtil.PATH_HASHING_STRATEGY);
        map.put(parentId, nestedMap);
      }
      nestedMap.put(name, attributes);
    }",method,
"      if (info == null) {
        return null;
      }",method,

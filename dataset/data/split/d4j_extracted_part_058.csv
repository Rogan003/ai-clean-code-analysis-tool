code_snippet,type,score
"    if (startPos < 0) {
      return text;
    }",method,
"  @Override
  public int hashCode() {
    return myMacroMap.hashCode();
  }",method,
"  public ExternalProjectSerializer() {
    myKryo = new Kryo() {
      @Override
      public <T> T newInstance(Class<T> type) {
        LOG.error(""Serializing default type: "" + type);
        return super.newInstance(type);
      }
    };
    Util.isAndroid = false;
    configureKryo();
  }",method,
"      @Override
      public <T> T newInstance(Class<T> type) {
        LOG.error(""Serializing default type: "" + type);
        return super.newInstance(type);
      }",method,
"  private void configureKryo() {
    myKryo.setAutoReset(true);
    myKryo.setRegistrationRequired(true);
    Log.set(Log.LEVEL_WARN);
    myKryo.register(ArrayList.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new ArrayList();
      }
    });
    myKryo.register(HashMap.class, new MapSerializer() {
      @Override
      protected Map create(Kryo kryo, Input input, Class<Map> type) {
        return new HashMap();
      }
    });
    myKryo.register(HashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }
    });
    myKryo.register(File.class, new FileSerializer());
    myKryo.register(DefaultExternalProject.class, new FieldSerializer<DefaultExternalProject>(myKryo, DefaultExternalProject.class) {
      @Override
      protected DefaultExternalProject create(Kryo kryo, Input input, Class<DefaultExternalProject> type) {
        return new DefaultExternalProject();
      }
    });
    myKryo.register(DefaultExternalTask.class, new FieldSerializer<DefaultExternalTask>(myKryo, DefaultExternalTask.class) {
      @Override
      protected DefaultExternalTask create(Kryo kryo, Input input, Class<DefaultExternalTask> type) {
        return new DefaultExternalTask();
      }
    });
    myKryo.register(DefaultExternalPlugin.class, new FieldSerializer<DefaultExternalPlugin>(myKryo, DefaultExternalPlugin.class) {
      @Override
      protected DefaultExternalPlugin create(Kryo kryo, Input input, Class<DefaultExternalPlugin> type) {
        return new DefaultExternalPlugin();
      }
    });
    myKryo.register(DefaultExternalSourceSet.class, new FieldSerializer<DefaultExternalSourceSet>(myKryo, DefaultExternalSourceSet.class) {
      @Override
      protected DefaultExternalSourceSet create(Kryo kryo, Input input, Class<DefaultExternalSourceSet> type) {
        return new DefaultExternalSourceSet();
      }
    });
    myKryo.register(
      DefaultExternalSourceDirectorySet.class,
      new FieldSerializer<DefaultExternalSourceDirectorySet>(myKryo, DefaultExternalSourceDirectorySet.class) {
        @Override
        protected DefaultExternalSourceDirectorySet create(Kryo kryo, Input input, Class<DefaultExternalSourceDirectorySet> type) {
          return new DefaultExternalSourceDirectorySet();
        }
      }
    );
    myKryo.register(DefaultExternalFilter.class, new FieldSerializer<DefaultExternalFilter>(myKryo, DefaultExternalFilter.class) {
      @Override
      protected DefaultExternalFilter create(Kryo kryo, Input input, Class<DefaultExternalFilter> type) {
        return new DefaultExternalFilter();
      }
    });
    myKryo.register(ExternalSystemSourceType.class, new DefaultSerializers.EnumSerializer(ExternalSystemSourceType.class));
    myKryo.register(
      DefaultExternalProjectDependency.class,
      new FieldSerializer<DefaultExternalProjectDependency>(myKryo, DefaultExternalProjectDependency.class) {
        @Override
        protected DefaultExternalProjectDependency create(Kryo kryo, Input input, Class<DefaultExternalProjectDependency> type) {
          return new DefaultExternalProjectDependency();
        }
      }
    );
    myKryo.register(
      DefaultFileCollectionDependency.class,
      new FieldSerializer<DefaultFileCollectionDependency>(myKryo, DefaultFileCollectionDependency.class) {
        @Override
        protected DefaultFileCollectionDependency create(Kryo kryo, Input input, Class<DefaultFileCollectionDependency> type) {
          return new DefaultFileCollectionDependency();
        }
      }
    );
    myKryo.register(
      DefaultExternalLibraryDependency.class,
      new FieldSerializer<DefaultExternalLibraryDependency>(myKryo, DefaultExternalLibraryDependency.class) {
        @Override
        protected DefaultExternalLibraryDependency create(Kryo kryo, Input input, Class<DefaultExternalLibraryDependency> type) {
          return new DefaultExternalLibraryDependency();
        }
      }
    );
    myKryo.register(
      DefaultUnresolvedExternalDependency.class,
      new FieldSerializer<DefaultUnresolvedExternalDependency>(myKryo, DefaultUnresolvedExternalDependency.class) {
        @Override
        protected DefaultUnresolvedExternalDependency create(Kryo kryo, Input input, Class<DefaultUnresolvedExternalDependency> type) {
          return new DefaultUnresolvedExternalDependency();
        }
      }
    );
    myKryo.register(
      DefaultExternalDependencyId.class,
      new FieldSerializer<DefaultExternalDependencyId>(myKryo, DefaultExternalDependencyId.class) {
        @Override
        protected DefaultExternalDependencyId create(Kryo kryo, Input input, Class<DefaultExternalDependencyId> type) {
          return new DefaultExternalDependencyId();
        }
      }
    );
    myKryo.register(LinkedHashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new LinkedHashSet();
      }
    });
    myKryo.register(HashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }
    });
    myKryo.register(THashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new THashSet();
      }
    });
    myKryo.register(Set.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }
    });
    myKryo.register(THashMap.class, new MapSerializer() {
      @Override
      protected Map create(Kryo kryo, Input input, Class<Map> type) {
        return new THashMap();
      }
    });
  }",method,
"    myKryo.register(ArrayList.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new ArrayList();
      }
    }",method,
"      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new ArrayList();
      }",method,
"    myKryo.register(HashMap.class, new MapSerializer() {
      @Override
      protected Map create(Kryo kryo, Input input, Class<Map> type) {
        return new HashMap();
      }
    }",method,
"      @Override
      protected Map create(Kryo kryo, Input input, Class<Map> type) {
        return new HashMap();
      }",method,
"    myKryo.register(HashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }
    }",method,
"      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }",method,
"    myKryo.register(DefaultExternalProject.class, new FieldSerializer<DefaultExternalProject>(myKryo, DefaultExternalProject.class) {
      @Override
      protected DefaultExternalProject create(Kryo kryo, Input input, Class<DefaultExternalProject> type) {
        return new DefaultExternalProject();
      }
    }",method,
"      @Override
      protected DefaultExternalProject create(Kryo kryo, Input input, Class<DefaultExternalProject> type) {
        return new DefaultExternalProject();
      }",method,
"    myKryo.register(DefaultExternalTask.class, new FieldSerializer<DefaultExternalTask>(myKryo, DefaultExternalTask.class) {
      @Override
      protected DefaultExternalTask create(Kryo kryo, Input input, Class<DefaultExternalTask> type) {
        return new DefaultExternalTask();
      }
    }",method,
"      @Override
      protected DefaultExternalTask create(Kryo kryo, Input input, Class<DefaultExternalTask> type) {
        return new DefaultExternalTask();
      }",method,
"    myKryo.register(DefaultExternalPlugin.class, new FieldSerializer<DefaultExternalPlugin>(myKryo, DefaultExternalPlugin.class) {
      @Override
      protected DefaultExternalPlugin create(Kryo kryo, Input input, Class<DefaultExternalPlugin> type) {
        return new DefaultExternalPlugin();
      }
    }",method,
"      @Override
      protected DefaultExternalPlugin create(Kryo kryo, Input input, Class<DefaultExternalPlugin> type) {
        return new DefaultExternalPlugin();
      }",method,
"    myKryo.register(DefaultExternalSourceSet.class, new FieldSerializer<DefaultExternalSourceSet>(myKryo, DefaultExternalSourceSet.class) {
      @Override
      protected DefaultExternalSourceSet create(Kryo kryo, Input input, Class<DefaultExternalSourceSet> type) {
        return new DefaultExternalSourceSet();
      }
    }",method,
"      @Override
      protected DefaultExternalSourceSet create(Kryo kryo, Input input, Class<DefaultExternalSourceSet> type) {
        return new DefaultExternalSourceSet();
      }",method,
"    myKryo.register(
      DefaultExternalSourceDirectorySet.class,
      new FieldSerializer<DefaultExternalSourceDirectorySet>(myKryo, DefaultExternalSourceDirectorySet.class) {
        @Override
        protected DefaultExternalSourceDirectorySet create(Kryo kryo, Input input, Class<DefaultExternalSourceDirectorySet> type) {
          return new DefaultExternalSourceDirectorySet();
        }
      }",method,
"        @Override
        protected DefaultExternalSourceDirectorySet create(Kryo kryo, Input input, Class<DefaultExternalSourceDirectorySet> type) {
          return new DefaultExternalSourceDirectorySet();
        }",method,
"    myKryo.register(DefaultExternalFilter.class, new FieldSerializer<DefaultExternalFilter>(myKryo, DefaultExternalFilter.class) {
      @Override
      protected DefaultExternalFilter create(Kryo kryo, Input input, Class<DefaultExternalFilter> type) {
        return new DefaultExternalFilter();
      }
    }",method,
"      @Override
      protected DefaultExternalFilter create(Kryo kryo, Input input, Class<DefaultExternalFilter> type) {
        return new DefaultExternalFilter();
      }",method,
"    myKryo.register(
      DefaultExternalProjectDependency.class,
      new FieldSerializer<DefaultExternalProjectDependency>(myKryo, DefaultExternalProjectDependency.class) {
        @Override
        protected DefaultExternalProjectDependency create(Kryo kryo, Input input, Class<DefaultExternalProjectDependency> type) {
          return new DefaultExternalProjectDependency();
        }
      }",method,
"        @Override
        protected DefaultExternalProjectDependency create(Kryo kryo, Input input, Class<DefaultExternalProjectDependency> type) {
          return new DefaultExternalProjectDependency();
        }",method,
"    myKryo.register(
      DefaultFileCollectionDependency.class,
      new FieldSerializer<DefaultFileCollectionDependency>(myKryo, DefaultFileCollectionDependency.class) {
        @Override
        protected DefaultFileCollectionDependency create(Kryo kryo, Input input, Class<DefaultFileCollectionDependency> type) {
          return new DefaultFileCollectionDependency();
        }
      }",method,
"        @Override
        protected DefaultFileCollectionDependency create(Kryo kryo, Input input, Class<DefaultFileCollectionDependency> type) {
          return new DefaultFileCollectionDependency();
        }",method,
"    myKryo.register(
      DefaultExternalLibraryDependency.class,
      new FieldSerializer<DefaultExternalLibraryDependency>(myKryo, DefaultExternalLibraryDependency.class) {
        @Override
        protected DefaultExternalLibraryDependency create(Kryo kryo, Input input, Class<DefaultExternalLibraryDependency> type) {
          return new DefaultExternalLibraryDependency();
        }
      }",method,
"        @Override
        protected DefaultExternalLibraryDependency create(Kryo kryo, Input input, Class<DefaultExternalLibraryDependency> type) {
          return new DefaultExternalLibraryDependency();
        }",method,
"    myKryo.register(
      DefaultUnresolvedExternalDependency.class,
      new FieldSerializer<DefaultUnresolvedExternalDependency>(myKryo, DefaultUnresolvedExternalDependency.class) {
        @Override
        protected DefaultUnresolvedExternalDependency create(Kryo kryo, Input input, Class<DefaultUnresolvedExternalDependency> type) {
          return new DefaultUnresolvedExternalDependency();
        }
      }",method,
"        @Override
        protected DefaultUnresolvedExternalDependency create(Kryo kryo, Input input, Class<DefaultUnresolvedExternalDependency> type) {
          return new DefaultUnresolvedExternalDependency();
        }",method,
"    myKryo.register(
      DefaultExternalDependencyId.class,
      new FieldSerializer<DefaultExternalDependencyId>(myKryo, DefaultExternalDependencyId.class) {
        @Override
        protected DefaultExternalDependencyId create(Kryo kryo, Input input, Class<DefaultExternalDependencyId> type) {
          return new DefaultExternalDependencyId();
        }
      }",method,
"        @Override
        protected DefaultExternalDependencyId create(Kryo kryo, Input input, Class<DefaultExternalDependencyId> type) {
          return new DefaultExternalDependencyId();
        }",method,
"    myKryo.register(LinkedHashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new LinkedHashSet();
      }
    }",method,
"      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new LinkedHashSet();
      }",method,
"    myKryo.register(HashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }
    }",method,
"      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }",method,
"    myKryo.register(THashSet.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new THashSet();
      }
    }",method,
"      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new THashSet();
      }",method,
"    myKryo.register(Set.class, new CollectionSerializer() {
      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }
    }",method,
"      @Override
      protected Collection create(Kryo kryo, Input input, Class<Collection> type) {
        return new HashSet();
      }",method,
"    myKryo.register(THashMap.class, new MapSerializer() {
      @Override
      protected Map create(Kryo kryo, Input input, Class<Map> type) {
        return new THashMap();
      }
    }",method,
"      @Override
      protected Map create(Kryo kryo, Input input, Class<Map> type) {
        return new THashMap();
      }",method,
"public class CustomDateEditor extends PropertyEditorSupport {
	private final DateFormat dateFormat;
	private final boolean allowEmpty;
	private final int exactDateLength;
	public CustomDateEditor(DateFormat dateFormat, boolean allowEmpty) {
		this.dateFormat = dateFormat;
		this.allowEmpty = allowEmpty;
		this.exactDateLength = -1;
	}
	public CustomDateEditor(DateFormat dateFormat, boolean allowEmpty, int exactDateLength) {
		this.dateFormat = dateFormat;
		this.allowEmpty = allowEmpty;
		this.exactDateLength = exactDateLength;
	}
	@Override
	public void setAsText(@Nullable String text) throws IllegalArgumentException {
		if (this.allowEmpty && !StringUtils.hasText(text)) {
			// Treat empty String as null value.
			setValue(null);
		}
		else if (text != null && this.exactDateLength >= 0 && text.length() != this.exactDateLength) {
			throw new IllegalArgumentException(
					""Could not parse date: it is not exactly"" + this.exactDateLength + ""characters long"");
		}
		else {
			try {
				setValue(this.dateFormat.parse(text));
			}
			catch (ParseException ex) {
				throw new IllegalArgumentException(""Could not parse date: "" + ex.getMessage(), ex);
			}
		}
	}
	@Override
	public String getAsText() {
		Date value = (Date) getValue();
		return (value != null ? this.dateFormat.format(value) : """");
	}
}",class,
"	public CustomDateEditor(DateFormat dateFormat, boolean allowEmpty) {
		this.dateFormat = dateFormat;
		this.allowEmpty = allowEmpty;
		this.exactDateLength = -1;
	}",method,
"	public CustomDateEditor(DateFormat dateFormat, boolean allowEmpty, int exactDateLength) {
		this.dateFormat = dateFormat;
		this.allowEmpty = allowEmpty;
		this.exactDateLength = exactDateLength;
	}",method,
"	@Override
	public void setAsText(@Nullable String text) throws IllegalArgumentException {
		if (this.allowEmpty && !StringUtils.hasText(text)) {
			// Treat empty String as null value.
			setValue(null);
		}
		else if (text != null && this.exactDateLength >= 0 && text.length() != this.exactDateLength) {
			throw new IllegalArgumentException(
					""Could not parse date: it is not exactly"" + this.exactDateLength + ""characters long"");
		}
		else {
			try {
				setValue(this.dateFormat.parse(text));
			}
			catch (ParseException ex) {
				throw new IllegalArgumentException(""Could not parse date: "" + ex.getMessage(), ex);
			}
		}
	}",method,
"			catch (ParseException ex) {
				throw new IllegalArgumentException(""Could not parse date: "" + ex.getMessage(), ex);
			}",method,
"	@Override
	public String getAsText() {
		Date value = (Date) getValue();
		return (value != null ? this.dateFormat.format(value) : """");
	}",method,
"public class CommonStatsFlags implements Writeable, Cloneable {
    public static final CommonStatsFlags ALL = new CommonStatsFlags().all();
    public static final CommonStatsFlags NONE = new CommonStatsFlags().clear();
    private EnumSet<Flag> flags = EnumSet.allOf(Flag.class);
    private String[] types = null;
    private String[] groups = null;
    private String[] fieldDataFields = null;
    private String[] completionDataFields = null;
    private boolean includeSegmentFileSizes = false;
    public CommonStatsFlags(Flag... flags) {
        if (flags.length > 0) {
            clear();
            Collections.addAll(this.flags, flags);
        }
    }
    public CommonStatsFlags(StreamInput in) throws IOException {
        final long longFlags = in.readLong();
        flags.clear();
        for (Flag flag : Flag.values()) {
            if ((longFlags & (1 << flag.ordinal())) != 0) {
                flags.add(flag);
            }
        }
        types = in.readStringArray();
        groups = in.readStringArray();
        fieldDataFields = in.readStringArray();
        completionDataFields = in.readStringArray();
        includeSegmentFileSizes = in.readBoolean();
    }
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        long longFlags = 0;
        for (Flag flag : flags) {
            longFlags |= (1 << flag.ordinal());
        }
        out.writeLong(longFlags);
        out.writeStringArrayNullable(types);
        out.writeStringArrayNullable(groups);
        out.writeStringArrayNullable(fieldDataFields);
        out.writeStringArrayNullable(completionDataFields);
        out.writeBoolean(includeSegmentFileSizes);
    }
    public CommonStatsFlags all() {
        flags = EnumSet.allOf(Flag.class);
        types = null;
        groups = null;
        fieldDataFields = null;
        completionDataFields = null;
        includeSegmentFileSizes = false;
        return this;
    }
    public CommonStatsFlags clear() {
        flags = EnumSet.noneOf(Flag.class);
        types = null;
        groups = null;
        fieldDataFields = null;
        completionDataFields = null;
        includeSegmentFileSizes = false;
        return this;
    }
    public boolean anySet() {
        return !flags.isEmpty();
    }
    public Flag[] getFlags() {
        return flags.toArray(new Flag[flags.size()]);
    }
    public CommonStatsFlags types(String... types) {
        this.types = types;
        return this;
    }
    public String[] types() {
        return this.types;
    }
    public CommonStatsFlags groups(String... groups) {
        this.groups = groups;
        return this;
    }
    public String[] groups() {
        return this.groups;
    }
    public CommonStatsFlags fieldDataFields(String... fieldDataFields) {
        this.fieldDataFields = fieldDataFields;
        return this;
    }
    public String[] fieldDataFields() {
        return this.fieldDataFields;
    }
    public CommonStatsFlags completionDataFields(String... completionDataFields) {
        this.completionDataFields = completionDataFields;
        return this;
    }
    public String[] completionDataFields() {
        return this.completionDataFields;
    }
    public CommonStatsFlags includeSegmentFileSizes(boolean includeSegmentFileSizes) {
        this.includeSegmentFileSizes = includeSegmentFileSizes;
        return this;
    }
    public boolean includeSegmentFileSizes() {
        return this.includeSegmentFileSizes;
    }
    public boolean isSet(Flag flag) {
        return flags.contains(flag);
    }
    boolean unSet(Flag flag) {
        return flags.remove(flag);
    }
    void set(Flag flag) {
        flags.add(flag);
    }
    public CommonStatsFlags set(Flag flag, boolean add) {
        if (add) {
            set(flag);
        } else {
            unSet(flag);
        }
        return this;
    }
    @Override
    public CommonStatsFlags clone() {
        try {
            CommonStatsFlags cloned = (CommonStatsFlags) super.clone();
            cloned.flags = flags.clone();
            return cloned;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(e);
        }
    }
    public enum Flag {
        // Do not change the order of these flags we use
        // the ordinal for encoding! Only append to the end!
        Store(""store""),
        Indexing(""indexing""),
        Get(""get""),
        Search(""search""),
        Merge(""merge""),
        Flush(""flush""),
        Refresh(""refresh""),
        QueryCache(""query_cache""),
        FieldData(""fielddata""),
        Docs(""docs""),
        Warmer(""warmer""),
        Completion(""completion""),
        Segments(""segments""),
        Translog(""translog""),
        Suggest(""suggest""), // unused
        RequestCache(""request_cache""),
        Recovery(""recovery"");
        private final String restName;
        Flag(String restName) {
            this.restName = restName;
        }
        public String getRestName() {
            return restName;
        }
    }
}",class,
"    public CommonStatsFlags(Flag... flags) {
        if (flags.length > 0) {
            clear();
            Collections.addAll(this.flags, flags);
        }
    }",method,
"        if (flags.length > 0) {
            clear();
            Collections.addAll(this.flags, flags);
        }",method,
"    public CommonStatsFlags(StreamInput in) throws IOException {
        final long longFlags = in.readLong();
        flags.clear();
        for (Flag flag : Flag.values()) {
            if ((longFlags & (1 << flag.ordinal())) != 0) {
                flags.add(flag);
            }
        }
        types = in.readStringArray();
        groups = in.readStringArray();
        fieldDataFields = in.readStringArray();
        completionDataFields = in.readStringArray();
        includeSegmentFileSizes = in.readBoolean();
    }",method,
"    @Override
    public void writeTo(StreamOutput out) throws IOException {
        long longFlags = 0;
        for (Flag flag : flags) {
            longFlags |= (1 << flag.ordinal());
        }
        out.writeLong(longFlags);
        out.writeStringArrayNullable(types);
        out.writeStringArrayNullable(groups);
        out.writeStringArrayNullable(fieldDataFields);
        out.writeStringArrayNullable(completionDataFields);
        out.writeBoolean(includeSegmentFileSizes);
    }",method,
"        for (Flag flag : flags) {
            longFlags |= (1 << flag.ordinal());
        }",method,
"    public CommonStatsFlags all() {
        flags = EnumSet.allOf(Flag.class);
        types = null;
        groups = null;
        fieldDataFields = null;
        completionDataFields = null;
        includeSegmentFileSizes = false;
        return this;
    }",method,
"    public CommonStatsFlags clear() {
        flags = EnumSet.noneOf(Flag.class);
        types = null;
        groups = null;
        fieldDataFields = null;
        completionDataFields = null;
        includeSegmentFileSizes = false;
        return this;
    }",method,
"    public boolean anySet() {
        return !flags.isEmpty();
    }",method,
"    public Flag[] getFlags() {
        return flags.toArray(new Flag[flags.size()]);
    }",method,
"    public CommonStatsFlags types(String... types) {
        this.types = types;
        return this;
    }",method,
"    public String[] types() {
        return this.types;
    }",method,
"    public CommonStatsFlags groups(String... groups) {
        this.groups = groups;
        return this;
    }",method,
"    public String[] groups() {
        return this.groups;
    }",method,
"    public CommonStatsFlags fieldDataFields(String... fieldDataFields) {
        this.fieldDataFields = fieldDataFields;
        return this;
    }",method,
"    public String[] fieldDataFields() {
        return this.fieldDataFields;
    }",method,
"    public CommonStatsFlags completionDataFields(String... completionDataFields) {
        this.completionDataFields = completionDataFields;
        return this;
    }",method,
"    public String[] completionDataFields() {
        return this.completionDataFields;
    }",method,
"    public CommonStatsFlags includeSegmentFileSizes(boolean includeSegmentFileSizes) {
        this.includeSegmentFileSizes = includeSegmentFileSizes;
        return this;
    }",method,
"    public boolean includeSegmentFileSizes() {
        return this.includeSegmentFileSizes;
    }",method,
"    public boolean isSet(Flag flag) {
        return flags.contains(flag);
    }",method,
"    boolean unSet(Flag flag) {
        return flags.remove(flag);
    }",method,
"    void set(Flag flag) {
        flags.add(flag);
    }",method,
"    public CommonStatsFlags set(Flag flag, boolean add) {
        if (add) {
            set(flag);
        } else {
            unSet(flag);
        }
        return this;
    }",method,
"        if (add) {
            set(flag);
        }",method,
"    @Override
    public CommonStatsFlags clone() {
        try {
            CommonStatsFlags cloned = (CommonStatsFlags) super.clone();
            cloned.flags = flags.clone();
            return cloned;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(e);
        }
    }",method,
"        Flag(String restName) {
            this.restName = restName;
        }",method,
"        public String getRestName() {
            return restName;
        }",method,
"public class OracleSQLParserTest extends TestCase {
    public void test_1() throws Exception {
        String sql = ""SELECT employees_seq.nextval FROM DUAL;"";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        Assert.assertEquals(1, statementList.size());
        String text = output(statementList);
        System.out.println(text);
    }
    public void test_2() throws Exception {
        String sql = ""SELECT LPAD(' ',2*(LEVEL-1)) || last_name org_chart, employee_id, manager_id, job_id FROM employees WHERE job_id != 'FI_MGR' START WITH job_id = 'AD_VP' CONNECT BY PRIOR employee_id = manager_id; "";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        Assert.assertEquals(1, statementList.size());
        String text = output(statementList);
        System.out.println(text);
    }
    private String output(List<SQLStatement> stmtList) {
        StringBuilder out = new StringBuilder();
        OracleOutputVisitor visitor = new OracleOutputVisitor(out);
        for (SQLStatement stmt : stmtList) {
            stmt.accept(visitor);
        }
        return out.toString();
    }
}",class,
"    public void test_1() throws Exception {
        String sql = ""SELECT employees_seq.nextval FROM DUAL;"";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        Assert.assertEquals(1, statementList.size());
        String text = output(statementList);
        System.out.println(text);
    }",method,
"    public void test_2() throws Exception {
        String sql = ""SELECT LPAD(' ',2*(LEVEL-1)) || last_name org_chart, employee_id, manager_id, job_id FROM employees WHERE job_id != 'FI_MGR' START WITH job_id = 'AD_VP' CONNECT BY PRIOR employee_id = manager_id; "";
        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        Assert.assertEquals(1, statementList.size());
        String text = output(statementList);
        System.out.println(text);
    }",method,
"    private String output(List<SQLStatement> stmtList) {
        StringBuilder out = new StringBuilder();
        OracleOutputVisitor visitor = new OracleOutputVisitor(out);
        for (SQLStatement stmt : stmtList) {
            stmt.accept(visitor);
        }
        return out.toString();
    }",method,
"        for (SQLStatement stmt : stmtList) {
            stmt.accept(visitor);
        }",method,
"public abstract class ProcessFunction<I, T extends TBase> {
  private final String methodName;
  private static final Logger LOGGER = LoggerFactory.getLogger(ProcessFunction.class.getName());
  public ProcessFunction(String methodName) {
    this.methodName = methodName;
  }
  public final void process(int seqid, TProtocol iprot, TProtocol oprot, I iface) throws TException {
    T args = getEmptyArgsInstance();
    try {
      args.read(iprot);
    } catch (TProtocolException e) {
      iprot.readMessageEnd();
      TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
      oprot.writeMessageBegin(new TMessage(getMethodName(), TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.getTransport().flush();
      return;
    }
    iprot.readMessageEnd();
    TBase result = null;
    try {
      result = getResult(iface, args);
    } catch(TException tex) {
      LOGGER.error(""Internal error processing "" + getMethodName(), tex);
      handleException(seqid, oprot);
      return;
    } catch(RuntimeException rex) {
      LOGGER.error(""Internal error processing "" + getMethodName(), rex);
      if (handleRuntimeExceptions()) {
        handleException(seqid, oprot);
      }
      return;
    }
    if(!isOneway()) {
      oprot.writeMessageBegin(new TMessage(getMethodName(), TMessageType.REPLY, seqid));
      result.write(oprot);
      oprot.writeMessageEnd();
      oprot.getTransport().flush();
    }
  }
  private void handleException(int seqid, TProtocol oprot) throws TException {
    if (!isOneway()) {
      TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR,
        ""Internal error processing "" + getMethodName());
      oprot.writeMessageBegin(new TMessage(getMethodName(), TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.getTransport().flush();
    }
  }
  protected boolean handleRuntimeExceptions() {
    return false;
  }
  protected abstract boolean isOneway();
  public abstract TBase getResult(I iface, T args) throws TException;
  public abstract T getEmptyArgsInstance();
  public String getMethodName() {
    return methodName;
  }
}",class,
"public class ShortStack {
  private short[] vector;
  private int top = -1;
  public ShortStack(int initialCapacity) {
    vector = new short[initialCapacity];
  }
  public short pop() {
    return vector[top--];
  }
  public void push(short pushed) {
    if (vector.length == top + 1) {
      grow();
    }
    vector[++top] = pushed;
  }
  private void grow() {
    short[] newVector = new short[vector.length * 2];
    System.arraycopy(vector, 0, newVector, 0, vector.length);
    vector = newVector;
  }
  public short peek() {
    return vector[top];
  }
  public void clear() {
    top = -1;
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""<ShortStack vector:["");
    for (int i = 0; i < vector.length; i++) {
      if (i != 0) {
        sb.append("" "");
      }
      if (i == top) {
        sb.append("">>"");
      }
      sb.append(vector[i]);
      if (i == top) {
        sb.append(""<<"");
      }
    }
    sb.append(""]>"");
    return sb.toString();
  }
}",class,
"  public ProcessFunction(String methodName) {
    this.methodName = methodName;
  }",method,
"  public final void process(int seqid, TProtocol iprot, TProtocol oprot, I iface) throws TException {
    T args = getEmptyArgsInstance();
    try {
      args.read(iprot);
    } catch (TProtocolException e) {
      iprot.readMessageEnd();
      TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
      oprot.writeMessageBegin(new TMessage(getMethodName(), TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.getTransport().flush();
      return;
    }
    iprot.readMessageEnd();
    TBase result = null;
    try {
      result = getResult(iface, args);
    } catch(TException tex) {
      LOGGER.error(""Internal error processing "" + getMethodName(), tex);
      handleException(seqid, oprot);
      return;
    } catch(RuntimeException rex) {
      LOGGER.error(""Internal error processing "" + getMethodName(), rex);
      if (handleRuntimeExceptions()) {
        handleException(seqid, oprot);
      }
      return;
    }
    if(!isOneway()) {
      oprot.writeMessageBegin(new TMessage(getMethodName(), TMessageType.REPLY, seqid));
      result.write(oprot);
      oprot.writeMessageEnd();
      oprot.getTransport().flush();
    }
  }",method,
"  private void handleException(int seqid, TProtocol oprot) throws TException {
    if (!isOneway()) {
      TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR,
        ""Internal error processing "" + getMethodName());
      oprot.writeMessageBegin(new TMessage(getMethodName(), TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.getTransport().flush();
    }
  }",method,
"  protected boolean handleRuntimeExceptions() {
    return false;
  }",method,
"  public String getMethodName() {
    return methodName;
  }",method,
"  public ShortStack(int initialCapacity) {
    vector = new short[initialCapacity];
  }",method,
"  public short pop() {
    return vector[top--];
  }",method,
"  public void push(short pushed) {
    if (vector.length == top + 1) {
      grow();
    }
    vector[++top] = pushed;
  }",method,
"    if (vector.length == top + 1) {
      grow();
    }",method,
"  private void grow() {
    short[] newVector = new short[vector.length * 2];
    System.arraycopy(vector, 0, newVector, 0, vector.length);
    vector = newVector;
  }",method,
"  public short peek() {
    return vector[top];
  }",method,
"  public void clear() {
    top = -1;
  }",method,
"  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""<ShortStack vector:["");
    for (int i = 0; i < vector.length; i++) {
      if (i != 0) {
        sb.append("" "");
      }
      if (i == top) {
        sb.append("">>"");
      }
      sb.append(vector[i]);
      if (i == top) {
        sb.append(""<<"");
      }
    }
    sb.append(""]>"");
    return sb.toString();
  }",method,
"    for (int i = 0; i < vector.length; i++) {
      if (i != 0) {
        sb.append("" "");
      }
      if (i == top) {
        sb.append("">>"");
      }
      sb.append(vector[i]);
      if (i == top) {
        sb.append(""<<"");
      }
    }",method,
"      if (i != 0) {
        sb.append("" "");
      }",method,
"      if (i == top) {
        sb.append("">>"");
      }",method,
"      if (i == top) {
        sb.append(""<<"");
      }",method,

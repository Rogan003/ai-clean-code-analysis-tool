code_snippet,type,score
"                for (int i = 0; i < trace.length; i++) {
                    Assertions.assertThat(trace[i].getClassName()).isEqualTo(classes[i]);
                }",method,
"    public static Condition<StackTraceElement[]> onlyThoseClasses(final String... classes) {
        return new Condition<StackTraceElement[]>() {
            @Override
            public boolean matches(StackTraceElement[] traceElements) {
                Assertions.assertThat(traceElements.length)
                          .describedAs(""Number of classes does not match.\nExpected: %s\nGot: %s"",
                                       Arrays.toString(classes),
                                       Arrays.toString(traceElements))
                          .isEqualTo(classes.length);
                for (int i = 0; i < traceElements.length; i++) {
                    Assertions.assertThat(traceElements[i].getClassName()).isEqualTo(classes[i]);
                }
                return true;
            }
        };
    }",method,
"            @Override
            public boolean matches(StackTraceElement[] traceElements) {
                Assertions.assertThat(traceElements.length)
                          .describedAs(""Number of classes does not match.\nExpected: %s\nGot: %s"",
                                       Arrays.toString(classes),
                                       Arrays.toString(traceElements))
                          .isEqualTo(classes.length);
                for (int i = 0; i < traceElements.length; i++) {
                    Assertions.assertThat(traceElements[i].getClassName()).isEqualTo(classes[i]);
                }
                return true;
            }",method,
"                for (int i = 0; i < traceElements.length; i++) {
                    Assertions.assertThat(traceElements[i].getClassName()).isEqualTo(classes[i]);
                }",method,
"    public static Condition<Throwable> firstMethodInStackTrace(final String method) {
        return methodInStackTraceAt(0, method);
    }",method,
"    public static Condition<Throwable> methodInStackTraceAt(final int stackTraceIndex, final String method) {
        return new Condition<Throwable>() {
            private String actualMethodAtIndex;
            @Override
            public boolean matches(Throwable throwable) {
                actualMethodAtIndex = throwable.getStackTrace()[stackTraceIndex].getMethodName();
                return actualMethodAtIndex.equals(method);
            }
            @Override
            public Description description() {
                return new TextDescription(""Method at index: %d\nexpected to be: %s\nbut is: %s"", stackTraceIndex, method, actualMethodAtIndex);
            }
        };
    }",method,
"            @Override
            public boolean matches(Throwable throwable) {
                actualMethodAtIndex = throwable.getStackTrace()[stackTraceIndex].getMethodName();
                return actualMethodAtIndex.equals(method);
            }",method,
"            @Override
            public Description description() {
                return new TextDescription(""Method at index: %d\nexpected to be: %s\nbut is: %s"", stackTraceIndex, method, actualMethodAtIndex);
            }",method,
"    public static Condition<Object> bridgeMethod(final String methodName) {
        return new Condition<Object>() {
            public boolean matches(Object o) {
                Class<?> clazz = null;
                if (o instanceof Class) {
                    clazz = (Class<?>) o;
                } else {
                    clazz = o.getClass();
                }
                for (Method m : clazz.getMethods()) {
                    if (m.isBridge() && m.getName().equals(methodName)) {
                        return true;
                    }
                }
                Assertions.fail(""Bridge method ["" + methodName + ""]\nnot found in:\n"" + o);
                return false;
            }
        };
    }",method,
"            public boolean matches(Object o) {
                Class<?> clazz = null;
                if (o instanceof Class) {
                    clazz = (Class<?>) o;
                } else {
                    clazz = o.getClass();
                }
                for (Method m : clazz.getMethods()) {
                    if (m.isBridge() && m.getName().equals(methodName)) {
                        return true;
                    }
                }
                Assertions.fail(""Bridge method ["" + methodName + ""]\nnot found in:\n"" + o);
                return false;
            }",method,
"                if (o instanceof Class) {
                    clazz = (Class<?>) o;
                }",method,
"    public static org.hamcrest.Matcher<Object> clazz(Class<?> type) {
        return CoreMatchers.instanceOf(type);
    }",method,
"    public static Condition<Throwable> methodsInStackTrace(final String... methods) {
        return new Condition<Throwable>() {
            public boolean matches(Throwable value) {
                StackTraceElement[] trace = value.getStackTrace();
                for (int i = 0; i < methods.length; i++) {
                    Assertions.assertThat(trace[i].getMethodName()).describedAs(""Expected methods[%d] to be in the stack trace."", i).isEqualTo(methods[i]);
                }
                return true;
            }
        };
    }",method,
"            public boolean matches(Throwable value) {
                StackTraceElement[] trace = value.getStackTrace();
                for (int i = 0; i < methods.length; i++) {
                    Assertions.assertThat(trace[i].getMethodName()).describedAs(""Expected methods[%d] to be in the stack trace."", i).isEqualTo(methods[i]);
                }
                return true;
            }",method,
"                for (int i = 0; i < methods.length; i++) {
                    Assertions.assertThat(trace[i].getMethodName()).describedAs(""Expected methods[%d] to be in the stack trace."", i).isEqualTo(methods[i]);
                }",method,
"public abstract class DaoSupport implements InitializingBean {
	protected final Log logger = LogFactory.getLog(getClass());
	@Override
	public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
		// Let abstract subclasses check their configuration.
		checkDaoConfig();
		// Let concrete implementations initialize themselves.
		try {
			initDao();
		}
		catch (Exception ex) {
			throw new BeanInitializationException(""Initialization of DAO failed"", ex);
		}
	}
	protected abstract void checkDaoConfig() throws IllegalArgumentException;
	protected void initDao() throws Exception {
	}
}",class,
"	@Override
	public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
		// Let abstract subclasses check their configuration.
		checkDaoConfig();
		// Let concrete implementations initialize themselves.
		try {
			initDao();
		}
		catch (Exception ex) {
			throw new BeanInitializationException(""Initialization of DAO failed"", ex);
		}
	}",method,
"		catch (Exception ex) {
			throw new BeanInitializationException(""Initialization of DAO failed"", ex);
		}",method,
"	protected void initDao() throws Exception {
	}",method,
"public class MetricRegistry {
	public static final MetricRegistry INSTANCE = new MetricRegistry();
	private Double[] defaultPcts = new Double[] {};
	// 从get的性能考虑，没有使用ConcurrentSkipListMap而是仍然使用ConcurrentHashMap.
	private ConcurrentMap<String, Gauge> gauges = new ConcurrentHashMap<String, Gauge>();
	private ConcurrentMap<String, Counter> counters = new ConcurrentHashMap<String, Counter>();
	private ConcurrentMap<String, Histogram> histograms = new ConcurrentHashMap<String, Histogram>();
	private ConcurrentMap<String, Timer> timers = new ConcurrentHashMap<String, Timer>();
	private List<MetricRegistryListener> listeners = new ArrayList<MetricRegistryListener>();
	public void registerGauge(String name, Gauge gauge) {
		gauges.put(name, gauge);
	}
	public Counter counter(String name) {
		if (counters.containsKey(name)) {
			return counters.get(name);
		} else {
			Counter counter = new Counter();
			return register(counters, name, counter);
		}
	}
	public Histogram histogram(String name, Double... pcts) {
		if (histograms.containsKey(name)) {
			return histograms.get(name);
		} else {
			Histogram histogram = new Histogram(((pcts != null) && (pcts.length > 0)) ? pcts : defaultPcts);
			return register(histograms, name, histogram);
		}
	}
	public Timer timer(String name, Double... pcts) {
		if (timers.containsKey(name)) {
			return timers.get(name);
		} else {
			Timer timer = new Timer(((pcts != null) && (pcts.length > 0) ? pcts : defaultPcts));
			return register(timers, name, timer);
		}
	}
	public void clearAll() {
		//通知Listener
		for (MetricRegistryListener listener : listeners) {
			for (String key : gauges.keySet()) {
				listener.onGaugeRemoved(key);
			}
			for (String key : counters.keySet()) {
				listener.onCounterRemoved(key);
			}
			for (String key : histograms.keySet()) {
				listener.onHistogramRemoved(key);
			}
			for (String key : timers.keySet()) {
				listener.onTimerRemoved(key);
			}
		}
		//清空注册
		gauges.clear();
		counters.clear();
		histograms.clear();
		timers.clear();
	}
	private <T> T register(ConcurrentMap<String, T> metrics, String name, T newMetric) {
		T existingMetric = metrics.putIfAbsent(name, newMetric);
		if (existingMetric != null) {
			return existingMetric;
		} else {
			notifyNewMetric(name, newMetric);
			return newMetric;
		}
	}
	private void notifyNewMetric(String name, Object newMetric) {
		for (MetricRegistryListener listener : listeners) {
			if (newMetric instanceof Gauge) {
				listener.onGaugeAdded(name, (Gauge) newMetric);
			}
			if (newMetric instanceof Counter) {
				listener.onCounterAdded(name, (Counter) newMetric);
			}
			if (newMetric instanceof Histogram) {
				listener.onHistogramAdded(name, (Histogram) newMetric);
			}
			if (newMetric instanceof Timer) {
				listener.onTimerAdded(name, (Timer) newMetric);
			}
		}
	}
	public Map<String, Gauge> getGauges() {
		return gauges;
	}
	public Map<String, Counter> getCounters() {
		return counters;
	}
	public Map<String, Histogram> getHistograms() {
		return histograms;
	}
	public Map<String, Timer> getTimers() {
		return timers;
	}
	public void setDefaultPcts(Double[] defaultPcts) {
		this.defaultPcts = defaultPcts;
	}
	public void addListener(MetricRegistryListener listener) {
		listeners.add(listener);
	}
	public static String name(String name, String... subNames) {
		StringBuilder builder = new StringBuilder(name);
		if (subNames != null) {
			for (String s : subNames) {
				if ((s != null) && !s.isEmpty()) {
					builder.append('.').append(s);
				}
			}
		}
		return builder.toString();
	}
	public static <T> SortedMap<String, T> getSortedMetrics(Map<String, T> metrics) {
		return new TreeMap<String, T>(metrics);
	}
}",class,
"	public void registerGauge(String name, Gauge gauge) {
		gauges.put(name, gauge);
	}",method,
"	public Counter counter(String name) {
		if (counters.containsKey(name)) {
			return counters.get(name);
		} else {
			Counter counter = new Counter();
			return register(counters, name, counter);
		}
	}",method,
"	public Histogram histogram(String name, Double... pcts) {
		if (histograms.containsKey(name)) {
			return histograms.get(name);
		} else {
			Histogram histogram = new Histogram(((pcts != null) && (pcts.length > 0)) ? pcts : defaultPcts);
			return register(histograms, name, histogram);
		}
	}",method,
"	public Timer timer(String name, Double... pcts) {
		if (timers.containsKey(name)) {
			return timers.get(name);
		} else {
			Timer timer = new Timer(((pcts != null) && (pcts.length > 0) ? pcts : defaultPcts));
			return register(timers, name, timer);
		}
	}",method,
"	public void clearAll() {
		//通知Listener
		for (MetricRegistryListener listener : listeners) {
			for (String key : gauges.keySet()) {
				listener.onGaugeRemoved(key);
			}
			for (String key : counters.keySet()) {
				listener.onCounterRemoved(key);
			}
			for (String key : histograms.keySet()) {
				listener.onHistogramRemoved(key);
			}
			for (String key : timers.keySet()) {
				listener.onTimerRemoved(key);
			}
		}
		//清空注册
		gauges.clear();
		counters.clear();
		histograms.clear();
		timers.clear();
	}",method,
"		for (MetricRegistryListener listener : listeners) {
			for (String key : gauges.keySet()) {
				listener.onGaugeRemoved(key);
			}
			for (String key : counters.keySet()) {
				listener.onCounterRemoved(key);
			}
			for (String key : histograms.keySet()) {
				listener.onHistogramRemoved(key);
			}
			for (String key : timers.keySet()) {
				listener.onTimerRemoved(key);
			}
		}",method,
"	private <T> T register(ConcurrentMap<String, T> metrics, String name, T newMetric) {
		T existingMetric = metrics.putIfAbsent(name, newMetric);
		if (existingMetric != null) {
			return existingMetric;
		} else {
			notifyNewMetric(name, newMetric);
			return newMetric;
		}
	}",method,
"		if (existingMetric != null) {
			return existingMetric;
		}",method,
"	private void notifyNewMetric(String name, Object newMetric) {
		for (MetricRegistryListener listener : listeners) {
			if (newMetric instanceof Gauge) {
				listener.onGaugeAdded(name, (Gauge) newMetric);
			}
			if (newMetric instanceof Counter) {
				listener.onCounterAdded(name, (Counter) newMetric);
			}
			if (newMetric instanceof Histogram) {
				listener.onHistogramAdded(name, (Histogram) newMetric);
			}
			if (newMetric instanceof Timer) {
				listener.onTimerAdded(name, (Timer) newMetric);
			}
		}
	}",method,
"		for (MetricRegistryListener listener : listeners) {
			if (newMetric instanceof Gauge) {
				listener.onGaugeAdded(name, (Gauge) newMetric);
			}
			if (newMetric instanceof Counter) {
				listener.onCounterAdded(name, (Counter) newMetric);
			}
			if (newMetric instanceof Histogram) {
				listener.onHistogramAdded(name, (Histogram) newMetric);
			}
			if (newMetric instanceof Timer) {
				listener.onTimerAdded(name, (Timer) newMetric);
			}
		}",method,
"			if (newMetric instanceof Gauge) {
				listener.onGaugeAdded(name, (Gauge) newMetric);
			}",method,
"			if (newMetric instanceof Counter) {
				listener.onCounterAdded(name, (Counter) newMetric);
			}",method,
"			if (newMetric instanceof Histogram) {
				listener.onHistogramAdded(name, (Histogram) newMetric);
			}",method,
"			if (newMetric instanceof Timer) {
				listener.onTimerAdded(name, (Timer) newMetric);
			}",method,
"	public Map<String, Gauge> getGauges() {
		return gauges;
	}",method,
"	public Map<String, Counter> getCounters() {
		return counters;
	}",method,
"	public Map<String, Histogram> getHistograms() {
		return histograms;
	}",method,
"	public Map<String, Timer> getTimers() {
		return timers;
	}",method,
"	public void setDefaultPcts(Double[] defaultPcts) {
		this.defaultPcts = defaultPcts;
	}",method,
"	public void addListener(MetricRegistryListener listener) {
		listeners.add(listener);
	}",method,
"	public static String name(String name, String... subNames) {
		StringBuilder builder = new StringBuilder(name);
		if (subNames != null) {
			for (String s : subNames) {
				if ((s != null) && !s.isEmpty()) {
					builder.append('.').append(s);
				}
			}
		}
		return builder.toString();
	}",method,
"		if (subNames != null) {
			for (String s : subNames) {
				if ((s != null) && !s.isEmpty()) {
					builder.append('.').append(s);
				}
			}
		}",method,
"			for (String s : subNames) {
				if ((s != null) && !s.isEmpty()) {
					builder.append('.').append(s);
				}
			}",method,
"	public static <T> SortedMap<String, T> getSortedMetrics(Map<String, T> metrics) {
		return new TreeMap<String, T>(metrics);
	}",method,
"abstract class AClass extends ABase {
    protected final String name;
    protected final String extendsClass;
    protected final ArrayList<AField> fields = new ArrayList<AField>();
    protected final ArrayList<AMethod> methods = new ArrayList<AMethod>();
    protected AClass(Definitions definitions, ApexTypeMapper typeMapper, String name, String extendsClass) {
        super(definitions, typeMapper);
        this.name = name;
        this.extendsClass = extendsClass;
    }
    String getName() {
        return name;
    }
    void write(AWriter writer) throws CalloutException {
        writer.startBlock();
        if (extendsClass == null)
            writer.writeLine(""public class "", name, "" {"");
        else
            writer.writeLine(""public class "", name, "" extends "", extendsClass, "" {"");
        for (AField field : fields) {
            if (field.isPublic()) {
                field.write(writer);
            }
        }
        for (AField field : fields) {
            if (!field.isPublic()) {
                field.write(writer);
            }
        }
        for (AMethod method : methods) {
            method.write(writer);
        }
        writer.writeLine(""}"");
        writer.endBlock();
    }
}",class,
"package com.salesforce.ide.wsdl2apex.core;
class AField {
    private final String type;
    private final String name;
    private final String access;
    private final String value;
    AField(String access, String type, String name, String value) {
        this.access = access;
        this.type = type;
        this.name = name;
        this.value = value;
    }
    boolean isPublic() {
        return ""public"".equals(access);
    }
    void write(AWriter writer) throws CalloutException {
        writer.startBlock();
        if (value == null) {
            writer.writeLine(access, "" "", type, "" "", name, "";"");
        } else {
            writer.writeLine(access, "" "", type, "" "", name, "" = "", value, "";"");
        }
        writer.endBlock();
    }
}",class,
"    protected AClass(Definitions definitions, ApexTypeMapper typeMapper, String name, String extendsClass) {
        super(definitions, typeMapper);
        this.name = name;
        this.extendsClass = extendsClass;
    }",method,
"    String getName() {
        return name;
    }",method,
"    void write(AWriter writer) throws CalloutException {
        writer.startBlock();
        if (extendsClass == null)
            writer.writeLine(""public class "", name, "" {"");
        else
            writer.writeLine(""public class "", name, "" extends "", extendsClass, "" {"");
        for (AField field : fields) {
            if (field.isPublic()) {
                field.write(writer);
            }
        }
        for (AField field : fields) {
            if (!field.isPublic()) {
                field.write(writer);
            }
        }
        for (AMethod method : methods) {
            method.write(writer);
        }
        writer.writeLine(""}"");
        writer.endBlock();
    }",method,
"        for (AField field : fields) {
            if (field.isPublic()) {
                field.write(writer);
            }
        }",method,
"        for (AField field : fields) {
            if (!field.isPublic()) {
                field.write(writer);
            }
        }",method,
"        for (AMethod method : methods) {
            method.write(writer);
        }",method,
"    AField(String access, String type, String name, String value) {
        this.access = access;
        this.type = type;
        this.name = name;
        this.value = value;
    }",method,
"    boolean isPublic() {
        return ""public"".equals(access);
    }",method,
"    void write(AWriter writer) throws CalloutException {
        writer.startBlock();
        if (value == null) {
            writer.writeLine(access, "" "", type, "" "", name, "";"");
        } else {
            writer.writeLine(access, "" "", type, "" "", name, "" = "", value, "";"");
        }
        writer.endBlock();
    }",method,
"        if (value == null) {
            writer.writeLine(access, "" "", type, "" "", name, "";"");
        }",method,
"public class NestedBuildersTest extends TestCase {
  public void testMessagesAndBuilders() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(1);
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(2);
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(3);
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(4);
    vehicleBuilder.getEngineBuilder()
        .setLiters(10);
    Vehicle vehicle = vehicleBuilder.build();
    assertEquals(4, vehicle.getWheelCount());
    for (int i = 0; i < 4; i++) {
      Wheel wheel = vehicle.getWheel(i);
      assertEquals(4, wheel.getRadius());
      assertEquals(i + 1, wheel.getWidth());
    }
    assertEquals(10, vehicle.getEngine().getLiters());
    for (int i = 0; i < 4; i++) {
      vehicleBuilder.getWheelBuilder(i)
          .setRadius(5)
          .setWidth(i + 10);
    }
    vehicleBuilder.getEngineBuilder().setLiters(20);
    vehicle = vehicleBuilder.build();
    for (int i = 0; i < 4; i++) {
      Wheel wheel = vehicle.getWheel(i);
      assertEquals(5, wheel.getRadius());
      assertEquals(i + 10, wheel.getWidth());
    }
    assertEquals(20, vehicle.getEngine().getLiters());
    assertTrue(vehicle.hasEngine());
  }
  public void testMessagesAreCached() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheelBuilder()
        .setRadius(1)
        .setWidth(2);
    vehicleBuilder.addWheelBuilder()
        .setRadius(3)
        .setWidth(4);
    vehicleBuilder.addWheelBuilder()
        .setRadius(5)
        .setWidth(6);
    vehicleBuilder.addWheelBuilder()
        .setRadius(7)
        .setWidth(8);
    // Make sure messages are cached.
    List<Wheel> wheels = new ArrayList<Wheel>(vehicleBuilder.getWheelList());
    for (int i = 0; i < wheels.size(); i++) {
      assertSame(wheels.get(i), vehicleBuilder.getWheel(i));
    }
    // Now get builders and check they didn't change.
    for (int i = 0; i < wheels.size(); i++) {
      vehicleBuilder.getWheel(i);
    }
    for (int i = 0; i < wheels.size(); i++) {
      assertSame(wheels.get(i), vehicleBuilder.getWheel(i));
    }
    // Change just one
    vehicleBuilder.getWheelBuilder(3)
        .setRadius(20).setWidth(20);
    // Now get wheels and check that only that one changed
    for (int i = 0; i < wheels.size(); i++) {
      if (i < 3) {
        assertSame(wheels.get(i), vehicleBuilder.getWheel(i));
      } else {
        assertNotSame(wheels.get(i), vehicleBuilder.getWheel(i));
      }
    }
  }
  public void testRemove_WithNestedBuilders() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheelBuilder()
        .setRadius(1)
        .setWidth(1);
    vehicleBuilder.addWheelBuilder()
        .setRadius(2)
        .setWidth(2);
    vehicleBuilder.removeWheel(0);
    assertEquals(1, vehicleBuilder.getWheelCount());
    assertEquals(2, vehicleBuilder.getWheel(0).getRadius());
  }
  public void testRemove_WithNestedMessages() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheel(Wheel.newBuilder()
        .setRadius(1)
        .setWidth(1));
    vehicleBuilder.addWheel(Wheel.newBuilder()
        .setRadius(2)
        .setWidth(2));
    vehicleBuilder.removeWheel(0);
    assertEquals(1, vehicleBuilder.getWheelCount());
    assertEquals(2, vehicleBuilder.getWheel(0).getRadius());
  }
  public void testMerge() {
    Vehicle vehicle1 = Vehicle.newBuilder()
        .addWheel(Wheel.newBuilder().setRadius(1).build())
        .addWheel(Wheel.newBuilder().setRadius(2).build())
        .build();
    Vehicle vehicle2 = Vehicle.newBuilder()
        .mergeFrom(vehicle1)
        .build();
    // List should be the same -- no allocation
    assertSame(vehicle1.getWheelList(), vehicle2.getWheelList());
    Vehicle vehicle3 = vehicle1.toBuilder().build();
    assertSame(vehicle1.getWheelList(), vehicle3.getWheelList());
  }
  public void testGettingBuilderMarksFieldAsHaving() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.getEngineBuilder();
    Vehicle vehicle = vehicleBuilder.buildPartial();
    assertTrue(vehicle.hasEngine());
  }
}",class,
"  public void testMessagesAndBuilders() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(1);
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(2);
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(3);
    vehicleBuilder.addWheelBuilder()
        .setRadius(4)
        .setWidth(4);
    vehicleBuilder.getEngineBuilder()
        .setLiters(10);
    Vehicle vehicle = vehicleBuilder.build();
    assertEquals(4, vehicle.getWheelCount());
    for (int i = 0; i < 4; i++) {
      Wheel wheel = vehicle.getWheel(i);
      assertEquals(4, wheel.getRadius());
      assertEquals(i + 1, wheel.getWidth());
    }
    assertEquals(10, vehicle.getEngine().getLiters());
    for (int i = 0; i < 4; i++) {
      vehicleBuilder.getWheelBuilder(i)
          .setRadius(5)
          .setWidth(i + 10);
    }
    vehicleBuilder.getEngineBuilder().setLiters(20);
    vehicle = vehicleBuilder.build();
    for (int i = 0; i < 4; i++) {
      Wheel wheel = vehicle.getWheel(i);
      assertEquals(5, wheel.getRadius());
      assertEquals(i + 10, wheel.getWidth());
    }
    assertEquals(20, vehicle.getEngine().getLiters());
    assertTrue(vehicle.hasEngine());
  }",method,
"    for (int i = 0; i < 4; i++) {
      Wheel wheel = vehicle.getWheel(i);
      assertEquals(4, wheel.getRadius());
      assertEquals(i + 1, wheel.getWidth());
    }",method,
"    for (int i = 0; i < 4; i++) {
      vehicleBuilder.getWheelBuilder(i)
          .setRadius(5)
          .setWidth(i + 10);
    }",method,
"    for (int i = 0; i < 4; i++) {
      Wheel wheel = vehicle.getWheel(i);
      assertEquals(5, wheel.getRadius());
      assertEquals(i + 10, wheel.getWidth());
    }",method,
"  public void testMessagesAreCached() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheelBuilder()
        .setRadius(1)
        .setWidth(2);
    vehicleBuilder.addWheelBuilder()
        .setRadius(3)
        .setWidth(4);
    vehicleBuilder.addWheelBuilder()
        .setRadius(5)
        .setWidth(6);
    vehicleBuilder.addWheelBuilder()
        .setRadius(7)
        .setWidth(8);
    // Make sure messages are cached.
    List<Wheel> wheels = new ArrayList<Wheel>(vehicleBuilder.getWheelList());
    for (int i = 0; i < wheels.size(); i++) {
      assertSame(wheels.get(i), vehicleBuilder.getWheel(i));
    }
    // Now get builders and check they didn't change.
    for (int i = 0; i < wheels.size(); i++) {
      vehicleBuilder.getWheel(i);
    }
    for (int i = 0; i < wheels.size(); i++) {
      assertSame(wheels.get(i), vehicleBuilder.getWheel(i));
    }
    // Change just one
    vehicleBuilder.getWheelBuilder(3)
        .setRadius(20).setWidth(20);
    // Now get wheels and check that only that one changed
    for (int i = 0; i < wheels.size(); i++) {
      if (i < 3) {
        assertSame(wheels.get(i), vehicleBuilder.getWheel(i));
      } else {
        assertNotSame(wheels.get(i), vehicleBuilder.getWheel(i));
      }
    }
  }",method,
"      if (i < 3) {
        assertSame(wheels.get(i), vehicleBuilder.getWheel(i));
      }",method,
"  public void testRemove_WithNestedBuilders() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheelBuilder()
        .setRadius(1)
        .setWidth(1);
    vehicleBuilder.addWheelBuilder()
        .setRadius(2)
        .setWidth(2);
    vehicleBuilder.removeWheel(0);
    assertEquals(1, vehicleBuilder.getWheelCount());
    assertEquals(2, vehicleBuilder.getWheel(0).getRadius());
  }",method,
"  public void testRemove_WithNestedMessages() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.addWheel(Wheel.newBuilder()
        .setRadius(1)
        .setWidth(1));
    vehicleBuilder.addWheel(Wheel.newBuilder()
        .setRadius(2)
        .setWidth(2));
    vehicleBuilder.removeWheel(0);
    assertEquals(1, vehicleBuilder.getWheelCount());
    assertEquals(2, vehicleBuilder.getWheel(0).getRadius());
  }",method,
"  public void testMerge() {
    Vehicle vehicle1 = Vehicle.newBuilder()
        .addWheel(Wheel.newBuilder().setRadius(1).build())
        .addWheel(Wheel.newBuilder().setRadius(2).build())
        .build();
    Vehicle vehicle2 = Vehicle.newBuilder()
        .mergeFrom(vehicle1)
        .build();
    // List should be the same -- no allocation
    assertSame(vehicle1.getWheelList(), vehicle2.getWheelList());
    Vehicle vehicle3 = vehicle1.toBuilder().build();
    assertSame(vehicle1.getWheelList(), vehicle3.getWheelList());
  }",method,
"  public void testGettingBuilderMarksFieldAsHaving() {
    Vehicle.Builder vehicleBuilder = Vehicle.newBuilder();
    vehicleBuilder.getEngineBuilder();
    Vehicle vehicle = vehicleBuilder.buildPartial();
    assertTrue(vehicle.hasEngine());
  }",method,
"public class User {
  private Integer id;
  private String name;
  public Integer getId() {
    return id;
  }
  public void setId(Integer id) {
    this.id = id;
  }
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  @Override
  public String toString() {
    return ""User{"" +
            ""id="" + id +
            "", name='"" + name + '\'' +
            '}';
  }
}",class,
"public class Contact {
    private Integer id;
    private String address;
    private String phone;
    public String getAddress() {
        return address;
    }
    public void setAddress(String address) {
        this.address = address;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getPhone() {
        return phone;
    }
    public void setPhone(String phone) {
        this.phone = phone;
    }    
}",class,
"  public Integer getId() {
    return id;
  }",method,
"  public void setId(Integer id) {
    this.id = id;
  }",method,
"  public String getName() {
    return name;
  }",method,
"  public void setName(String name) {
    this.name = name;
  }",method,
"  @Override
  public String toString() {
    return ""User{"" +
            ""id="" + id +
            "", name='"" + name + '\'' +
            '}';
  }",method,
"    public String getAddress() {
        return address;
    }",method,
"    public void setAddress(String address) {
        this.address = address;
    }",method,
"    public Integer getId() {
        return id;
    }",method,
"    public void setId(Integer id) {
        this.id = id;
    }",method,
"    public String getPhone() {
        return phone;
    }",method,
"    public void setPhone(String phone) {
        this.phone = phone;
    }",method,
"public class PopupWindowCompat extends PopupWindow {
    private static final Field superListenerField;
    static {
        Field f = null;
        try {
            f = PopupWindow.class.getDeclaredField(""mOnScrollChangedListener"");
            f.setAccessible(true);
        } catch (NoSuchFieldException e) {
        }
        superListenerField = f;
    }
    private static final OnScrollChangedListener NOP = new OnScrollChangedListener() {
        @Override
        public void onScrollChanged() {
        }
    };
    private OnScrollChangedListener mSuperScrollListener;
    private ViewTreeObserver mViewTreeObserver;
    public PopupWindowCompat() {
        super();
        init();
    }
    public PopupWindowCompat(Context context) {
        super(context);
        init();
    }
    public PopupWindowCompat(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }
    public PopupWindowCompat(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init();
    }
    // @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public PopupWindowCompat(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        init();
    }
    public PopupWindowCompat(int width, int height) {
        super(width, height);
        init();
    }
    public PopupWindowCompat(View contentView) {
        super(contentView);
        init();
    }
    public PopupWindowCompat(View contentView, int width, int height, boolean focusable) {
        super(contentView, width, height, focusable);
        init();
    }
    public PopupWindowCompat(View contentView, int width, int height) {
        super(contentView, width, height);
        init();
    }
    private void init() {
        if (superListenerField != null) {
            try {
                mSuperScrollListener = (OnScrollChangedListener) superListenerField.get(this);
                superListenerField.set(this, NOP);
            } catch (Exception e) {
                mSuperScrollListener = null;
            }
        }
    }
    private void unregisterListener() {
        // Don't do anything if we haven't managed to patch the super listener
        if (mSuperScrollListener != null && mViewTreeObserver != null) {
            if (mViewTreeObserver.isAlive()) {
                mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
            }
            mViewTreeObserver = null;
        }
    }
    private void registerListener(View anchor) {
        // Don't do anything if we haven't managed to patch the super listener.
        // And don't bother attaching the listener if the anchor view isn't
        // attached. This means we'll only have to deal with the real VTO owned
        // by the ViewRoot.
        if (mSuperScrollListener != null) {
            ViewTreeObserver vto = (anchor.getWindowToken() != null) ? anchor.getViewTreeObserver()
                    : null;
            if (vto != mViewTreeObserver) {
                if (mViewTreeObserver != null && mViewTreeObserver.isAlive()) {
                    mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
                }
                if ((mViewTreeObserver = vto) != null) {
                    vto.addOnScrollChangedListener(mSuperScrollListener);
                }
            }
        }
    }
    @Override
    public void showAsDropDown(View anchor, int xoff, int yoff) {
        super.showAsDropDown(anchor, xoff, yoff);
        registerListener(anchor);
    }
    @Override
    public void update(View anchor, int xoff, int yoff, int width, int height) {
        super.update(anchor, xoff, yoff, width, height);
        registerListener(anchor);
    }
    @Override
    public void update(View anchor, int width, int height) {
        super.update(anchor, width, height);
        registerListener(anchor);
    }
    @Override
    public void showAtLocation(View parent, int gravity, int x, int y) {
        super.showAtLocation(parent, gravity, x, y);
        unregisterListener();
    }
    @Override
    public void dismiss() {
        super.dismiss();
        unregisterListener();
    }
}",class,
"        @Override
        public void onScrollChanged() {
        }",method,
"    public PopupWindowCompat() {
        super();
        init();
    }",method,
"    public PopupWindowCompat(Context context) {
        super(context);
        init();
    }",method,
"    public PopupWindowCompat(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }",method,
"    public PopupWindowCompat(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init();
    }",method,
"    public PopupWindowCompat(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        init();
    }",method,
"    public PopupWindowCompat(int width, int height) {
        super(width, height);
        init();
    }",method,
"    public PopupWindowCompat(View contentView) {
        super(contentView);
        init();
    }",method,
"    public PopupWindowCompat(View contentView, int width, int height, boolean focusable) {
        super(contentView, width, height, focusable);
        init();
    }",method,
"    public PopupWindowCompat(View contentView, int width, int height) {
        super(contentView, width, height);
        init();
    }",method,
"    private void init() {
        if (superListenerField != null) {
            try {
                mSuperScrollListener = (OnScrollChangedListener) superListenerField.get(this);
                superListenerField.set(this, NOP);
            } catch (Exception e) {
                mSuperScrollListener = null;
            }
        }
    }",method,
"        if (superListenerField != null) {
            try {
                mSuperScrollListener = (OnScrollChangedListener) superListenerField.get(this);
                superListenerField.set(this, NOP);
            } catch (Exception e) {
                mSuperScrollListener = null;
            }
        }",method,
"    private void unregisterListener() {
        // Don't do anything if we haven't managed to patch the super listener
        if (mSuperScrollListener != null && mViewTreeObserver != null) {
            if (mViewTreeObserver.isAlive()) {
                mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
            }
            mViewTreeObserver = null;
        }
    }",method,
"        if (mSuperScrollListener != null && mViewTreeObserver != null) {
            if (mViewTreeObserver.isAlive()) {
                mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
            }
            mViewTreeObserver = null;
        }",method,
"    private void registerListener(View anchor) {
        // Don't do anything if we haven't managed to patch the super listener.
        // And don't bother attaching the listener if the anchor view isn't
        // attached. This means we'll only have to deal with the real VTO owned
        // by the ViewRoot.
        if (mSuperScrollListener != null) {
            ViewTreeObserver vto = (anchor.getWindowToken() != null) ? anchor.getViewTreeObserver()
                    : null;
            if (vto != mViewTreeObserver) {
                if (mViewTreeObserver != null && mViewTreeObserver.isAlive()) {
                    mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
                }
                if ((mViewTreeObserver = vto) != null) {
                    vto.addOnScrollChangedListener(mSuperScrollListener);
                }
            }
        }
    }",method,
"        if (mSuperScrollListener != null) {
            ViewTreeObserver vto = (anchor.getWindowToken() != null) ? anchor.getViewTreeObserver()
                    : null;
            if (vto != mViewTreeObserver) {
                if (mViewTreeObserver != null && mViewTreeObserver.isAlive()) {
                    mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
                }
                if ((mViewTreeObserver = vto) != null) {
                    vto.addOnScrollChangedListener(mSuperScrollListener);
                }
            }
        }",method,
"            if (vto != mViewTreeObserver) {
                if (mViewTreeObserver != null && mViewTreeObserver.isAlive()) {
                    mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
                }
                if ((mViewTreeObserver = vto) != null) {
                    vto.addOnScrollChangedListener(mSuperScrollListener);
                }
            }",method,
"    @Override
    public void showAsDropDown(View anchor, int xoff, int yoff) {
        super.showAsDropDown(anchor, xoff, yoff);
        registerListener(anchor);
    }",method,
"    @Override
    public void update(View anchor, int xoff, int yoff, int width, int height) {
        super.update(anchor, xoff, yoff, width, height);
        registerListener(anchor);
    }",method,
"    @Override
    public void update(View anchor, int width, int height) {
        super.update(anchor, width, height);
        registerListener(anchor);
    }",method,

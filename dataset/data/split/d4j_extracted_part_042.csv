code_snippet,type,score
"    @Override
    public void showAtLocation(View parent, int gravity, int x, int y) {
        super.showAtLocation(parent, gravity, x, y);
        unregisterListener();
    }",method,
"    @Override
    public void dismiss() {
        super.dismiss();
        unregisterListener();
    }",method,
"public class LinkedBlockingStack<E> implements BlockingQueue<E> {
  private final LinkedBlockingDeque<E> delegate;
  public LinkedBlockingStack() {
    delegate = new LinkedBlockingDeque<>();
  }
  @Override
  public boolean add(E element) {
    delegate.addFirst(element);
    return true;
  }
  @Override
  public boolean offer(E element) {
    return delegate.offerFirst(element);
  }
  @Override
  public E remove() {
    return delegate.removeFirst();
  }
  @Override
  public E poll() {
    return delegate.pollFirst();
  }
  @Override
  public E element() {
    return delegate.getFirst();
  }
  @Override
  public E peek() {
    return delegate.peekFirst();
  }
  @Override
  public void put(E element) throws InterruptedException {
    delegate.putFirst(element);
  }
  @Override
  public boolean offer(E element, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate.offerFirst(element, timeout, unit);
  }
  @Override
  public E take() throws InterruptedException {
    return delegate.takeFirst();
  }
  @Override
  public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate.pollFirst(timeout, unit);
  }
  @Override
  public int remainingCapacity() {
    return delegate.remainingCapacity();
  }
  @Override
  public boolean remove(Object object) {
    return delegate.remove(object);
  }
  @Override
  public boolean addAll(Collection<? extends E> collection) {
    boolean modified = false;
    for (E element : collection) {
      if (add(element)) {
        modified = true;
      }
    }
    return modified;
  }
  @Override
  public void clear() {
    delegate.clear();
  }
  @Override
  public boolean retainAll(Collection<?> collection) {
    return delegate.retainAll(collection);
  }
  @Override
  public boolean removeAll(Collection<?> collection) {
    return delegate.removeAll(collection);
  }
  @Override
  public boolean containsAll(Collection<?> collection) {
    return delegate.containsAll(collection);
  }
  @Override
  public int size() {
    return delegate.size();
  }
  @Override
  public boolean isEmpty() {
    return delegate.isEmpty();
  }
  @Override
  public boolean contains(Object object) {
    return delegate.contains(object);
  }
  @Override
  public Iterator<E> iterator() {
    return delegate.iterator();
  }
  @Override
  public Object[] toArray() {
    return delegate.toArray();
  }
  @Override
  public <T> T[] toArray(T[] array) {
    return delegate.toArray(array);
  }
  @Override
  public int drainTo(Collection<? super E> collection) {
    return delegate.drainTo(collection);
  }
  @Override
  public int drainTo(Collection<? super E> collection, int maxElements) {
    return delegate.drainTo(collection, maxElements);
  }
}",class,
"  public LinkedBlockingStack() {
    delegate = new LinkedBlockingDeque<>();
  }",method,
"  @Override
  public boolean add(E element) {
    delegate.addFirst(element);
    return true;
  }",method,
"  @Override
  public boolean offer(E element) {
    return delegate.offerFirst(element);
  }",method,
"  @Override
  public E remove() {
    return delegate.removeFirst();
  }",method,
"  @Override
  public E poll() {
    return delegate.pollFirst();
  }",method,
"  @Override
  public E element() {
    return delegate.getFirst();
  }",method,
"  @Override
  public E peek() {
    return delegate.peekFirst();
  }",method,
"  @Override
  public void put(E element) throws InterruptedException {
    delegate.putFirst(element);
  }",method,
"  @Override
  public boolean offer(E element, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate.offerFirst(element, timeout, unit);
  }",method,
"  @Override
  public E take() throws InterruptedException {
    return delegate.takeFirst();
  }",method,
"  @Override
  public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate.pollFirst(timeout, unit);
  }",method,
"  @Override
  public int remainingCapacity() {
    return delegate.remainingCapacity();
  }",method,
"  @Override
  public boolean remove(Object object) {
    return delegate.remove(object);
  }",method,
"  @Override
  public boolean addAll(Collection<? extends E> collection) {
    boolean modified = false;
    for (E element : collection) {
      if (add(element)) {
        modified = true;
      }
    }
    return modified;
  }",method,
"    for (E element : collection) {
      if (add(element)) {
        modified = true;
      }
    }",method,
"  @Override
  public void clear() {
    delegate.clear();
  }",method,
"  @Override
  public boolean retainAll(Collection<?> collection) {
    return delegate.retainAll(collection);
  }",method,
"  @Override
  public boolean removeAll(Collection<?> collection) {
    return delegate.removeAll(collection);
  }",method,
"  @Override
  public boolean containsAll(Collection<?> collection) {
    return delegate.containsAll(collection);
  }",method,
"  @Override
  public int size() {
    return delegate.size();
  }",method,
"  @Override
  public boolean isEmpty() {
    return delegate.isEmpty();
  }",method,
"  @Override
  public boolean contains(Object object) {
    return delegate.contains(object);
  }",method,
"  @Override
  public Iterator<E> iterator() {
    return delegate.iterator();
  }",method,
"  @Override
  public Object[] toArray() {
    return delegate.toArray();
  }",method,
"  @Override
  public <T> T[] toArray(T[] array) {
    return delegate.toArray(array);
  }",method,
"  @Override
  public int drainTo(Collection<? super E> collection) {
    return delegate.drainTo(collection);
  }",method,
"  @Override
  public int drainTo(Collection<? super E> collection, int maxElements) {
    return delegate.drainTo(collection, maxElements);
  }",method,
"public class ProgressStripe extends JBPanel {
  @NotNull
  private final JBPanel myPanel;
  private final NotNullComputable<MyLoadingDecorator> myCreateLoadingDecorator;
  protected MyLoadingDecorator myDecorator;
  public ProgressStripe(@NotNull JComponent targetComponent, @NotNull Disposable parent, int startDelayMs) {
    super(new BorderLayout());
    myPanel = new JBPanel(new BorderLayout());
    myPanel.setOpaque(false);
    myPanel.add(targetComponent);
    myCreateLoadingDecorator = () -> {
      Disposable disposable = Disposer.newDisposable();
      Disposer.register(parent, disposable);
      return new MyLoadingDecorator(targetComponent, myPanel, disposable, startDelayMs);
    };
    createLoadingDecorator();
  }
  @Override
  public void updateUI() {
    super.updateUI();
    if (myCreateLoadingDecorator != null) {
      if (myDecorator != null) {
        remove(myDecorator.getComponent());
        myDecorator.dispose();
      }
      createLoadingDecorator();
    }
  }
  private void createLoadingDecorator() {
    myDecorator = myCreateLoadingDecorator.compute();
    add(myDecorator.getComponent(), BorderLayout.CENTER);
    myDecorator.setLoadingText("""");
  }
  public void startLoading() {
    myDecorator.startLoading(false);
  }
  public void startLoadingImmediately() {
    myDecorator.startLoadingImmediately();
  }
  public void stopLoading() {
    myDecorator.stopLoading();
  }
  private static class MyLoadingDecorator extends LoadingDecorator {
    @NotNull
    private final Disposable myDisposable;
    public MyLoadingDecorator(@NotNull JComponent component,
                              @NotNull JPanel contentPanel,
                              @NotNull Disposable disposable,
                              int startDelayMs) {
      super(contentPanel, disposable, startDelayMs, false, ProgressStripeIcon.generateIcon(component));
      myDisposable = disposable;
    }
    public void startLoadingImmediately() {
      _startLoading(false);
    }
    @Override
    protected NonOpaquePanel customizeLoadingLayer(JPanel parent, JLabel text, AsyncProcessIcon icon) {
      parent.setLayout(new BorderLayout());
      NonOpaquePanel result = new NonOpaquePanel();
      result.setLayout(new BoxLayout(result, BoxLayout.Y_AXIS));
      result.add(icon);
      parent.add(result, BorderLayout.NORTH);
      return result;
    }
    public void dispose() {
      Disposer.dispose(myDisposable);
    }
  }
}",class,
"  private static class MyLoadingDecorator extends LoadingDecorator {
    @NotNull
    private final Disposable myDisposable;
    public MyLoadingDecorator(@NotNull JComponent component,
                              @NotNull JPanel contentPanel,
                              @NotNull Disposable disposable,
                              int startDelayMs) {
      super(contentPanel, disposable, startDelayMs, false, ProgressStripeIcon.generateIcon(component));
      myDisposable = disposable;
    }
    public void startLoadingImmediately() {
      _startLoading(false);
    }
    @Override
    protected NonOpaquePanel customizeLoadingLayer(JPanel parent, JLabel text, AsyncProcessIcon icon) {
      parent.setLayout(new BorderLayout());
      NonOpaquePanel result = new NonOpaquePanel();
      result.setLayout(new BoxLayout(result, BoxLayout.Y_AXIS));
      result.add(icon);
      parent.add(result, BorderLayout.NORTH);
      return result;
    }
    public void dispose() {
      Disposer.dispose(myDisposable);
    }
  }",class,
"  public ProgressStripe(@NotNull JComponent targetComponent, @NotNull Disposable parent, int startDelayMs) {
    super(new BorderLayout());
    myPanel = new JBPanel(new BorderLayout());
    myPanel.setOpaque(false);
    myPanel.add(targetComponent);
    myCreateLoadingDecorator = () -> {
      Disposable disposable = Disposer.newDisposable();
      Disposer.register(parent, disposable);
      return new MyLoadingDecorator(targetComponent, myPanel, disposable, startDelayMs);
    };
    createLoadingDecorator();
  }",method,
"  @Override
  public void updateUI() {
    super.updateUI();
    if (myCreateLoadingDecorator != null) {
      if (myDecorator != null) {
        remove(myDecorator.getComponent());
        myDecorator.dispose();
      }
      createLoadingDecorator();
    }
  }",method,
"    if (myCreateLoadingDecorator != null) {
      if (myDecorator != null) {
        remove(myDecorator.getComponent());
        myDecorator.dispose();
      }
      createLoadingDecorator();
    }",method,
"      if (myDecorator != null) {
        remove(myDecorator.getComponent());
        myDecorator.dispose();
      }",method,
"  private void createLoadingDecorator() {
    myDecorator = myCreateLoadingDecorator.compute();
    add(myDecorator.getComponent(), BorderLayout.CENTER);
    myDecorator.setLoadingText("""");
  }",method,
"  public void startLoading() {
    myDecorator.startLoading(false);
  }",method,
"  public void startLoadingImmediately() {
    myDecorator.startLoadingImmediately();
  }",method,
"  public void stopLoading() {
    myDecorator.stopLoading();
  }",method,
"    public MyLoadingDecorator(@NotNull JComponent component,
                              @NotNull JPanel contentPanel,
                              @NotNull Disposable disposable,
                              int startDelayMs) {
      super(contentPanel, disposable, startDelayMs, false, ProgressStripeIcon.generateIcon(component));
      myDisposable = disposable;
    }",method,
"    public void startLoadingImmediately() {
      _startLoading(false);
    }",method,
"    @Override
    protected NonOpaquePanel customizeLoadingLayer(JPanel parent, JLabel text, AsyncProcessIcon icon) {
      parent.setLayout(new BorderLayout());
      NonOpaquePanel result = new NonOpaquePanel();
      result.setLayout(new BoxLayout(result, BoxLayout.Y_AXIS));
      result.add(icon);
      parent.add(result, BorderLayout.NORTH);
      return result;
    }",method,
"    public void dispose() {
      Disposer.dispose(myDisposable);
    }",method,
"public abstract class IndexableSetContributor {
  public static final ExtensionPointName<IndexableSetContributor> EP_NAME = new ExtensionPointName<>(""com.intellij.indexedRootsProvider"");
  private static final Logger LOG = Logger.getInstance(IndexableSetContributor.class);
  @NotNull
  public static Set<VirtualFile> getProjectRootsToIndex(@NotNull IndexableSetContributor contributor, @NotNull Project project) {
    Set<VirtualFile> roots = contributor.getAdditionalProjectRootsToIndex(project);
    return filterOutNulls(contributor, ""getAdditionalProjectRootsToIndex(Project)"", roots);
  }
  @NotNull
  public static Set<VirtualFile> getRootsToIndex(@NotNull IndexableSetContributor contributor) {
    Set<VirtualFile> roots = contributor.getAdditionalRootsToIndex();
    return filterOutNulls(contributor, ""getAdditionalRootsToIndex()"", roots);
  }
  @NotNull
  public Set<VirtualFile> getAdditionalProjectRootsToIndex(@NotNull Project project) {
    return Collections.emptySet();
  }
  @NotNull
  public abstract Set<VirtualFile> getAdditionalRootsToIndex();
  @NotNull
  private static Set<VirtualFile> filterOutNulls(@NotNull IndexableSetContributor contributor,
                                                 @NotNull String methodInfo,
                                                 @NotNull Set<VirtualFile> roots) {
    for (VirtualFile root : roots) {
      if (root == null || !root.isValid()) {
        LOG.error(""Please fix "" + contributor.getClass().getName() + ""#"" + methodInfo + "".\n"" +
                  (root == null ? ""The returned set is not expected to contain nulls, but it is "" + roots
                                : ""Invalid file returned: "" + root));
        return ContainerUtil.newLinkedHashSet(ContainerUtil.filter(roots, virtualFile -> virtualFile != null && virtualFile.isValid()));
      }
    }
    return roots;
  }
}",class,
"  @NotNull
  public static Set<VirtualFile> getProjectRootsToIndex(@NotNull IndexableSetContributor contributor, @NotNull Project project) {
    Set<VirtualFile> roots = contributor.getAdditionalProjectRootsToIndex(project);
    return filterOutNulls(contributor, ""getAdditionalProjectRootsToIndex(Project)"", roots);
  }",method,
"  @NotNull
  public static Set<VirtualFile> getRootsToIndex(@NotNull IndexableSetContributor contributor) {
    Set<VirtualFile> roots = contributor.getAdditionalRootsToIndex();
    return filterOutNulls(contributor, ""getAdditionalRootsToIndex()"", roots);
  }",method,
"  @NotNull
  public Set<VirtualFile> getAdditionalProjectRootsToIndex(@NotNull Project project) {
    return Collections.emptySet();
  }",method,
"  @NotNull
  private static Set<VirtualFile> filterOutNulls(@NotNull IndexableSetContributor contributor,
                                                 @NotNull String methodInfo,
                                                 @NotNull Set<VirtualFile> roots) {
    for (VirtualFile root : roots) {
      if (root == null || !root.isValid()) {
        LOG.error(""Please fix "" + contributor.getClass().getName() + ""#"" + methodInfo + "".\n"" +
                  (root == null ? ""The returned set is not expected to contain nulls, but it is "" + roots
                                : ""Invalid file returned: "" + root));
        return ContainerUtil.newLinkedHashSet(ContainerUtil.filter(roots, virtualFile -> virtualFile != null && virtualFile.isValid()));
      }
    }
    return roots;
  }",method,
"    for (VirtualFile root : roots) {
      if (root == null || !root.isValid()) {
        LOG.error(""Please fix "" + contributor.getClass().getName() + ""#"" + methodInfo + "".\n"" +
                  (root == null ? ""The returned set is not expected to contain nulls, but it is "" + roots
                                : ""Invalid file returned: "" + root));
        return ContainerUtil.newLinkedHashSet(ContainerUtil.filter(roots, virtualFile -> virtualFile != null && virtualFile.isValid()));
      }
    }",method,
"                                                 @NotNull String methodInfo,
                                                 @NotNull Set<VirtualFile> roots) {
    for (VirtualFile root : roots) {
      if (root == null || !root.isValid()) {
        LOG.error(""Please fix "" + contributor.getClass().getName() + ""#"" + methodInfo + "".\n"" +
                  (root == null ? ""The returned set is not expected to contain nulls, but it is "" + roots
                                : ""Invalid file returned: "" + root));
        return ContainerUtil.newLinkedHashSet(ContainerUtil.filter(roots, virtualFile -> virtualFile != null && virtualFile.isValid()));
      }
    }",method,
"public class BooleanTypeHandlerTest extends BaseTypeHandlerTest {
  private static final TypeHandler<Boolean> TYPE_HANDLER = new BooleanTypeHandler();
  @Override
  @Test
  public void shouldSetParameter() throws Exception {
    TYPE_HANDLER.setParameter(ps, 1, true, null);
    verify(ps).setBoolean(1, true);
  }
  @Override
  @Test
  public void shouldGetResultFromResultSetByName() throws Exception {
    when(rs.getBoolean(""column"")).thenReturn(true);
    when(rs.wasNull()).thenReturn(false);
    assertEquals(true, TYPE_HANDLER.getResult(rs, ""column""));
  }
  @Override
  public void shouldGetResultNullFromResultSetByName() throws Exception {
    // Unnecessary
  }
  @Override
  @Test
  public void shouldGetResultFromResultSetByPosition() throws Exception {
    when(rs.getBoolean(1)).thenReturn(true);
    when(rs.wasNull()).thenReturn(false);
    assertEquals(true, TYPE_HANDLER.getResult(rs, 1));
  }
  @Override
  public void shouldGetResultNullFromResultSetByPosition() throws Exception {
    // Unnecessary
  }
  @Override
  @Test
  public void shouldGetResultFromCallableStatement() throws Exception {
    when(cs.getBoolean(1)).thenReturn(true);
    when(cs.wasNull()).thenReturn(false);
    assertEquals(true, TYPE_HANDLER.getResult(cs, 1));
  }
  @Override
  public void shouldGetResultNullFromCallableStatement() throws Exception {
    // Unnecessary
  }
}",class,
"  @Override
  @Test
  public void shouldSetParameter() throws Exception {
    TYPE_HANDLER.setParameter(ps, 1, true, null);
    verify(ps).setBoolean(1, true);
  }",method,
"  @Override
  @Test
  public void shouldGetResultFromResultSetByName() throws Exception {
    when(rs.getBoolean(""column"")).thenReturn(true);
    when(rs.wasNull()).thenReturn(false);
    assertEquals(true, TYPE_HANDLER.getResult(rs, ""column""));
  }",method,
"  @Override
  public void shouldGetResultNullFromResultSetByName() throws Exception {
    // Unnecessary
  }",method,
"  @Override
  @Test
  public void shouldGetResultFromResultSetByPosition() throws Exception {
    when(rs.getBoolean(1)).thenReturn(true);
    when(rs.wasNull()).thenReturn(false);
    assertEquals(true, TYPE_HANDLER.getResult(rs, 1));
  }",method,
"  @Override
  public void shouldGetResultNullFromResultSetByPosition() throws Exception {
    // Unnecessary
  }",method,
"  @Override
  @Test
  public void shouldGetResultFromCallableStatement() throws Exception {
    when(cs.getBoolean(1)).thenReturn(true);
    when(cs.wasNull()).thenReturn(false);
    assertEquals(true, TYPE_HANDLER.getResult(cs, 1));
  }",method,
"  @Override
  public void shouldGetResultNullFromCallableStatement() throws Exception {
    // Unnecessary
  }",method,
"public class RuleDocumentationTest {
  private static final ImmutableSet<String> NO_FLAGS = ImmutableSet.<String>of();
  private static final ConfiguredRuleClassProvider provider =
      TestRuleClassProvider.getRuleClassProvider();
  private static void assertContains(String base, String value) {
    assertWithMessage(base + "" is expected to contain "" + value)
        .that(base.contains(value))
        .isTrue();
  }
  private void checkAttributeForRule(RuleDocumentation rule, RuleDocumentationAttribute attr,
      boolean isCommonAttribute) {
    rule.addAttribute(attr);
    String signature = rule.getAttributeSignature();
    StringBuilder sb = new StringBuilder();
    if (isCommonAttribute) {
      sb.append(""<a href=\""common-definitions.html#"");
    } else {
      sb.append(""<a href=\""#"");
    }
    sb.append(attr.getGeneratedInRule(rule.getRuleName())).append(""."");
    sb.append(attr.getAttributeName()).append(""\"">"").append(attr.getAttributeName()).append(""</a>"");
    assertContains(signature, sb.toString());
  }
  @Test
  public void testVariableSubstitution() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""rule"", ""OTHER"", ""FOO"", Joiner.on(""\n"").join(new String[] {
          ""x"",
          ""${VAR}"",
          ""z""}),
        0, """", ImmutableSet.<String>of(), provider);
    ruleDoc.addDocVariable(""VAR"", ""y"");
    assertThat(ruleDoc.getHtmlDocumentation()).isEqualTo(""x\ny\nz"");
  }
  @Test
  public void testSignatureContainsCommonAttribute() throws Exception {
    RuleDocumentationAttribute licensesAttr = RuleDocumentationAttribute.create(
        ""licenses"", ""common"", ""attribute doc"");
    checkAttributeForRule(
        new RuleDocumentation(
            ""java_binary"", ""BINARY"", ""JAVA"", """", 0, """", ImmutableSet.<String>of(), provider),
        licensesAttr, true);
  }
  @Test
  public void testInheritedAttributeGeneratesSignature() throws Exception {
    RuleDocumentationAttribute runtimeDepsAttr = RuleDocumentationAttribute.create(TestRule.class,
        ""runtime_deps"", ""attribute doc"", 0, """", NO_FLAGS);
    checkAttributeForRule(
        new RuleDocumentation(
            ""java_binary"", ""BINARY"", ""JAVA"", """", 0, """", ImmutableSet.<String>of(), provider),
        runtimeDepsAttr, false);
    checkAttributeForRule(
        new RuleDocumentation(
            ""java_library"", ""LIBRARY"", ""JAVA"", """", 0, """", ImmutableSet.<String>of(), provider),
        runtimeDepsAttr, false);
  }
  @Test
  public void testRuleDocFlagSubstitution() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""rule"", ""OTHER"", ""FOO"", ""x"", 0, """", ImmutableSet.<String>of(""DEPRECATED""), provider);
    ruleDoc.addDocVariable(""VAR"", ""y"");
    assertThat(ruleDoc.getHtmlDocumentation()).isEqualTo(""x"");
  }
  @Test
  public void testCommandLineDocumentation() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""foo_binary"", ""OTHER"", ""FOO"", Joiner.on(""\n"").join(new String[] {
            ""x"",
            ""y"",
            ""z"",
            ""${VAR}""}),
        0, """", ImmutableSet.<String>of(), provider);
    ruleDoc.addDocVariable(""VAR"", ""w"");
    RuleDocumentationAttribute attributeDoc = RuleDocumentationAttribute.create(TestRule.class,
        ""srcs"", ""attribute doc"", 0, """", NO_FLAGS);
    ruleDoc.addAttribute(attributeDoc);
    assertThat(ruleDoc.getCommandLineDocumentation()).isEqualTo(""\nx\ny\nz\n\n"");
  }
  @Test
  public void testExtractExamples() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""rule"", ""OTHER"", ""FOO"", Joiner.on(""\n"").join(new String[] {
            ""x"",
            ""<!-- #BLAZE_RULE.EXAMPLE -->"",
            ""a"",
            ""<!-- #BLAZE_RULE.END_EXAMPLE -->"",
            ""y"",
            ""<!-- #BLAZE_RULE.EXAMPLE -->"",
            ""b"",
            ""<!-- #BLAZE_RULE.END_EXAMPLE -->"",
            ""z""}),
        0, """", ImmutableSet.<String>of(), provider);
    assertThat(ruleDoc.extractExamples()).isEqualTo(ImmutableSet.<String>of(""a\n"", ""b\n""));
  }
  @Test
  public void testCreateExceptions() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""foo_binary"", ""OTHER"", ""FOO"", """", 10, ""foo.txt"", NO_FLAGS, provider);
    BuildEncyclopediaDocException e = ruleDoc.createException(""msg"");
    assertThat(e).hasMessageThat().isEqualTo(""Error in foo.txt:10: msg"");
  }
  @Test
  public void testEquals() throws BuildEncyclopediaDocException {
    assertThat(new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""y"", 0, """", NO_FLAGS, provider))
        .isEqualTo(new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider));
  }
  @Test
  public void testNotEquals() throws BuildEncyclopediaDocException {
    assertThat(
            new RuleDocumentation(""rule1"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)
                .equals(
                    new RuleDocumentation(""rule2"", ""OTHER"", ""FOO"", ""y"", 0, """", NO_FLAGS, provider)))
        .isFalse();
  }
  @Test
  public void testCompareTo() throws BuildEncyclopediaDocException {
    assertThat(
            new RuleDocumentation(""rule1"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)
                .compareTo(
                    new RuleDocumentation(""rule2"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)))
        .isEqualTo(-1);
  }
  @Test
  public void testHashCode() throws BuildEncyclopediaDocException {
    assertThat(
            new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""y"", 0, """", NO_FLAGS, provider)
                .hashCode())
        .isEqualTo(
            new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)
                .hashCode());
  }
}",class,
"  private static void assertContains(String base, String value) {
    assertWithMessage(base + "" is expected to contain "" + value)
        .that(base.contains(value))
        .isTrue();
  }",method,
"  private void checkAttributeForRule(RuleDocumentation rule, RuleDocumentationAttribute attr,
      boolean isCommonAttribute) {
    rule.addAttribute(attr);
    String signature = rule.getAttributeSignature();
    StringBuilder sb = new StringBuilder();
    if (isCommonAttribute) {
      sb.append(""<a href=\""common-definitions.html#"");
    } else {
      sb.append(""<a href=\""#"");
    }
    sb.append(attr.getGeneratedInRule(rule.getRuleName())).append(""."");
    sb.append(attr.getAttributeName()).append(""\"">"").append(attr.getAttributeName()).append(""</a>"");
    assertContains(signature, sb.toString());
  }",method,
"    if (isCommonAttribute) {
      sb.append(""<a href=\""common-definitions.html#"");
    }",method,
"  @Test
  public void testVariableSubstitution() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""rule"", ""OTHER"", ""FOO"", Joiner.on(""\n"").join(new String[] {
          ""x"",
          ""${VAR}"",
          ""z""}),
        0, """", ImmutableSet.<String>of(), provider);
    ruleDoc.addDocVariable(""VAR"", ""y"");
    assertThat(ruleDoc.getHtmlDocumentation()).isEqualTo(""x\ny\nz"");
  }",method,
"  @Test
  public void testSignatureContainsCommonAttribute() throws Exception {
    RuleDocumentationAttribute licensesAttr = RuleDocumentationAttribute.create(
        ""licenses"", ""common"", ""attribute doc"");
    checkAttributeForRule(
        new RuleDocumentation(
            ""java_binary"", ""BINARY"", ""JAVA"", """", 0, """", ImmutableSet.<String>of(), provider),
        licensesAttr, true);
  }",method,
"  @Test
  public void testInheritedAttributeGeneratesSignature() throws Exception {
    RuleDocumentationAttribute runtimeDepsAttr = RuleDocumentationAttribute.create(TestRule.class,
        ""runtime_deps"", ""attribute doc"", 0, """", NO_FLAGS);
    checkAttributeForRule(
        new RuleDocumentation(
            ""java_binary"", ""BINARY"", ""JAVA"", """", 0, """", ImmutableSet.<String>of(), provider),
        runtimeDepsAttr, false);
    checkAttributeForRule(
        new RuleDocumentation(
            ""java_library"", ""LIBRARY"", ""JAVA"", """", 0, """", ImmutableSet.<String>of(), provider),
        runtimeDepsAttr, false);
  }",method,
"  @Test
  public void testRuleDocFlagSubstitution() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""rule"", ""OTHER"", ""FOO"", ""x"", 0, """", ImmutableSet.<String>of(""DEPRECATED""), provider);
    ruleDoc.addDocVariable(""VAR"", ""y"");
    assertThat(ruleDoc.getHtmlDocumentation()).isEqualTo(""x"");
  }",method,
"  @Test
  public void testCommandLineDocumentation() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""foo_binary"", ""OTHER"", ""FOO"", Joiner.on(""\n"").join(new String[] {
            ""x"",
            ""y"",
            ""z"",
            ""${VAR}""}),
        0, """", ImmutableSet.<String>of(), provider);
    ruleDoc.addDocVariable(""VAR"", ""w"");
    RuleDocumentationAttribute attributeDoc = RuleDocumentationAttribute.create(TestRule.class,
        ""srcs"", ""attribute doc"", 0, """", NO_FLAGS);
    ruleDoc.addAttribute(attributeDoc);
    assertThat(ruleDoc.getCommandLineDocumentation()).isEqualTo(""\nx\ny\nz\n\n"");
  }",method,
"  @Test
  public void testExtractExamples() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""rule"", ""OTHER"", ""FOO"", Joiner.on(""\n"").join(new String[] {
            ""x"",
            ""<!-- #BLAZE_RULE.EXAMPLE -->"",
            ""a"",
            ""<!-- #BLAZE_RULE.END_EXAMPLE -->"",
            ""y"",
            ""<!-- #BLAZE_RULE.EXAMPLE -->"",
            ""b"",
            ""<!-- #BLAZE_RULE.END_EXAMPLE -->"",
            ""z""}),
        0, """", ImmutableSet.<String>of(), provider);
    assertThat(ruleDoc.extractExamples()).isEqualTo(ImmutableSet.<String>of(""a\n"", ""b\n""));
  }",method,
"  @Test
  public void testCreateExceptions() throws BuildEncyclopediaDocException {
    RuleDocumentation ruleDoc = new RuleDocumentation(
        ""foo_binary"", ""OTHER"", ""FOO"", """", 10, ""foo.txt"", NO_FLAGS, provider);
    BuildEncyclopediaDocException e = ruleDoc.createException(""msg"");
    assertThat(e).hasMessageThat().isEqualTo(""Error in foo.txt:10: msg"");
  }",method,
"  @Test
  public void testEquals() throws BuildEncyclopediaDocException {
    assertThat(new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""y"", 0, """", NO_FLAGS, provider))
        .isEqualTo(new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider));
  }",method,
"  @Test
  public void testNotEquals() throws BuildEncyclopediaDocException {
    assertThat(
            new RuleDocumentation(""rule1"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)
                .equals(
                    new RuleDocumentation(""rule2"", ""OTHER"", ""FOO"", ""y"", 0, """", NO_FLAGS, provider)))
        .isFalse();
  }",method,
"  @Test
  public void testCompareTo() throws BuildEncyclopediaDocException {
    assertThat(
            new RuleDocumentation(""rule1"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)
                .compareTo(
                    new RuleDocumentation(""rule2"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)))
        .isEqualTo(-1);
  }",method,
"  @Test
  public void testHashCode() throws BuildEncyclopediaDocException {
    assertThat(
            new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""y"", 0, """", NO_FLAGS, provider)
                .hashCode())
        .isEqualTo(
            new RuleDocumentation(""rule"", ""OTHER"", ""FOO"", ""x"", 0, """", NO_FLAGS, provider)
                .hashCode());
  }",method,
"public class JpsJavaDependenciesEnumeratorImpl extends JpsDependenciesEnumeratorBase<JpsJavaDependenciesEnumeratorImpl> implements JpsJavaDependenciesEnumerator {
  private boolean myProductionOnly;
  private boolean myRuntimeOnly;
  private boolean myCompileOnly;
  private boolean myExportedOnly;
  private boolean myRecursivelyExportedOnly;
  private JpsJavaClasspathKind myClasspathKind;
  private final List<JpsJavaDependenciesEnumerationHandler> myHandlers;
  public JpsJavaDependenciesEnumeratorImpl(Collection<JpsModule> rootModules) {
    super(rootModules);
    List<JpsJavaDependenciesEnumerationHandler> handlers = JpsJavaDependenciesEnumerationHandler.createHandlers(rootModules);
    myHandlers = handlers != null ? handlers : Collections.emptyList();
  }
  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator productionOnly() {
    myProductionOnly = true;
    return this;
  }
  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator compileOnly() {
    myCompileOnly = true;
    return this;
  }
  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator runtimeOnly() {
    myRuntimeOnly = true;
    return this;
  }
  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator exportedOnly() {
    if (myRecursively) {
      myRecursivelyExportedOnly = true;
    }
    else {
      myExportedOnly = true;
    }
    return this;
  }
  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator recursivelyExportedOnly() {
    return recursively().exportedOnly();
  }
  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator includedIn(@NotNull JpsJavaClasspathKind classpathKind) {
    myClasspathKind = classpathKind;
    return this;
  }
  @NotNull
  @Override
  public JpsJavaDependenciesRootsEnumerator classes() {
    return new JpsJavaDependenciesRootsEnumeratorImpl(this, JpsOrderRootType.COMPILED);
  }
  @NotNull
  @Override
  public JpsJavaDependenciesRootsEnumerator sources() {
    return new JpsJavaDependenciesRootsEnumeratorImpl(this, JpsOrderRootType.SOURCES);
  }
  @NotNull
  @Override
  public JpsJavaDependenciesRootsEnumerator annotations() {
    return new JpsJavaDependenciesRootsEnumeratorImpl(this, JpsAnnotationRootType.INSTANCE);
  }
  @Override
  protected JpsJavaDependenciesEnumeratorImpl self() {
    return this;
  }
  @Override
  protected boolean shouldProcessDependenciesRecursively() {
    return JpsJavaDependenciesEnumerationHandler.shouldProcessDependenciesRecursively(myHandlers);
  }
  @Override
  protected boolean shouldProcess(JpsModule module, JpsDependencyElement element) {
    boolean exported = !(element instanceof JpsSdkDependency);
    JpsJavaDependencyExtension extension = JpsJavaExtensionService.getInstance().getDependencyExtension(element);
    if (extension != null) {
      exported = extension.isExported();
      JpsJavaDependencyScope scope = extension.getScope();
      boolean forTestCompile = scope.isIncludedIn(JpsJavaClasspathKind.TEST_COMPILE) || scope == JpsJavaDependencyScope.RUNTIME &&
                                                                                        shouldAddRuntimeDependenciesToTestCompilationClasspath();
      if (myCompileOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE) && !forTestCompile
        || myRuntimeOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME) && !scope.isIncludedIn(JpsJavaClasspathKind.TEST_RUNTIME)
        || myClasspathKind != null && !scope.isIncludedIn(myClasspathKind) && !(myClasspathKind == JpsJavaClasspathKind.TEST_COMPILE && forTestCompile)) {
        return false;
      }
      if (myProductionOnly) {
        if (!scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE) && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)
            || myCompileOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE)
            || myRuntimeOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)) {
          return false;
        }
      }
    }
    if (!exported) {
      if (myExportedOnly) return false;
      if ((myRecursivelyExportedOnly || element instanceof JpsSdkDependency) && !isEnumerationRootModule(module)) return false;
    }
    return true;
  }
  public boolean isProductionOnly() {
    return myProductionOnly || myClasspathKind == JpsJavaClasspathKind.PRODUCTION_RUNTIME || myClasspathKind == JpsJavaClasspathKind.PRODUCTION_COMPILE;
  }
  public boolean isProductionOnTests(JpsDependencyElement element) {
    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (handler.isProductionOnTestsDependency(element)) {
        return true;
      }
    }
    return false;
  }
  public boolean shouldIncludeTestsFromDependentModulesToTestClasspath() {
    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (!handler.shouldIncludeTestsFromDependentModulesToTestClasspath()) {
        return false;
      }
    }
    return true;
  }
  public boolean shouldAddRuntimeDependenciesToTestCompilationClasspath() {
    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (handler.shouldAddRuntimeDependenciesToTestCompilationClasspath()) {
        return true;
      }
    }
    return false;
  }
}",class,
"  public JpsJavaDependenciesEnumeratorImpl(Collection<JpsModule> rootModules) {
    super(rootModules);
    List<JpsJavaDependenciesEnumerationHandler> handlers = JpsJavaDependenciesEnumerationHandler.createHandlers(rootModules);
    myHandlers = handlers != null ? handlers : Collections.emptyList();
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator productionOnly() {
    myProductionOnly = true;
    return this;
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator compileOnly() {
    myCompileOnly = true;
    return this;
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator runtimeOnly() {
    myRuntimeOnly = true;
    return this;
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator exportedOnly() {
    if (myRecursively) {
      myRecursivelyExportedOnly = true;
    }
    else {
      myExportedOnly = true;
    }
    return this;
  }",method,
"    if (myRecursively) {
      myRecursivelyExportedOnly = true;
    }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator recursivelyExportedOnly() {
    return recursively().exportedOnly();
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesEnumerator includedIn(@NotNull JpsJavaClasspathKind classpathKind) {
    myClasspathKind = classpathKind;
    return this;
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesRootsEnumerator classes() {
    return new JpsJavaDependenciesRootsEnumeratorImpl(this, JpsOrderRootType.COMPILED);
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesRootsEnumerator sources() {
    return new JpsJavaDependenciesRootsEnumeratorImpl(this, JpsOrderRootType.SOURCES);
  }",method,
"  @NotNull
  @Override
  public JpsJavaDependenciesRootsEnumerator annotations() {
    return new JpsJavaDependenciesRootsEnumeratorImpl(this, JpsAnnotationRootType.INSTANCE);
  }",method,
"  @Override
  protected JpsJavaDependenciesEnumeratorImpl self() {
    return this;
  }",method,
"  @Override
  protected boolean shouldProcessDependenciesRecursively() {
    return JpsJavaDependenciesEnumerationHandler.shouldProcessDependenciesRecursively(myHandlers);
  }",method,
"  @Override
  protected boolean shouldProcess(JpsModule module, JpsDependencyElement element) {
    boolean exported = !(element instanceof JpsSdkDependency);
    JpsJavaDependencyExtension extension = JpsJavaExtensionService.getInstance().getDependencyExtension(element);
    if (extension != null) {
      exported = extension.isExported();
      JpsJavaDependencyScope scope = extension.getScope();
      boolean forTestCompile = scope.isIncludedIn(JpsJavaClasspathKind.TEST_COMPILE) || scope == JpsJavaDependencyScope.RUNTIME &&
                                                                                        shouldAddRuntimeDependenciesToTestCompilationClasspath();
      if (myCompileOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE) && !forTestCompile
        || myRuntimeOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME) && !scope.isIncludedIn(JpsJavaClasspathKind.TEST_RUNTIME)
        || myClasspathKind != null && !scope.isIncludedIn(myClasspathKind) && !(myClasspathKind == JpsJavaClasspathKind.TEST_COMPILE && forTestCompile)) {
        return false;
      }
      if (myProductionOnly) {
        if (!scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE) && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)
            || myCompileOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE)
            || myRuntimeOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)) {
          return false;
        }
      }
    }
    if (!exported) {
      if (myExportedOnly) return false;
      if ((myRecursivelyExportedOnly || element instanceof JpsSdkDependency) && !isEnumerationRootModule(module)) return false;
    }
    return true;
  }",method,
"    if (extension != null) {
      exported = extension.isExported();
      JpsJavaDependencyScope scope = extension.getScope();
      boolean forTestCompile = scope.isIncludedIn(JpsJavaClasspathKind.TEST_COMPILE) || scope == JpsJavaDependencyScope.RUNTIME &&
                                                                                        shouldAddRuntimeDependenciesToTestCompilationClasspath();
      if (myCompileOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE) && !forTestCompile
        || myRuntimeOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME) && !scope.isIncludedIn(JpsJavaClasspathKind.TEST_RUNTIME)
        || myClasspathKind != null && !scope.isIncludedIn(myClasspathKind) && !(myClasspathKind == JpsJavaClasspathKind.TEST_COMPILE && forTestCompile)) {
        return false;
      }
      if (myProductionOnly) {
        if (!scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE) && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)
            || myCompileOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE)
            || myRuntimeOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)) {
          return false;
        }
      }
    }",method,
"      if (myProductionOnly) {
        if (!scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE) && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)
            || myCompileOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_COMPILE)
            || myRuntimeOnly && !scope.isIncludedIn(JpsJavaClasspathKind.PRODUCTION_RUNTIME)) {
          return false;
        }
      }",method,
"    if (!exported) {
      if (myExportedOnly) return false;
      if ((myRecursivelyExportedOnly || element instanceof JpsSdkDependency) && !isEnumerationRootModule(module)) return false;
    }",method,
"  public boolean isProductionOnly() {
    return myProductionOnly || myClasspathKind == JpsJavaClasspathKind.PRODUCTION_RUNTIME || myClasspathKind == JpsJavaClasspathKind.PRODUCTION_COMPILE;
  }",method,
"  public boolean isProductionOnTests(JpsDependencyElement element) {
    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (handler.isProductionOnTestsDependency(element)) {
        return true;
      }
    }
    return false;
  }",method,
"    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (handler.isProductionOnTestsDependency(element)) {
        return true;
      }
    }",method,
"  public boolean shouldIncludeTestsFromDependentModulesToTestClasspath() {
    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (!handler.shouldIncludeTestsFromDependentModulesToTestClasspath()) {
        return false;
      }
    }
    return true;
  }",method,
"    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (!handler.shouldIncludeTestsFromDependentModulesToTestClasspath()) {
        return false;
      }
    }",method,
"  public boolean shouldAddRuntimeDependenciesToTestCompilationClasspath() {
    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (handler.shouldAddRuntimeDependenciesToTestCompilationClasspath()) {
        return true;
      }
    }
    return false;
  }",method,
"    for (JpsJavaDependenciesEnumerationHandler handler : myHandlers) {
      if (handler.shouldAddRuntimeDependenciesToTestCompilationClasspath()) {
        return true;
      }
    }",method,
"public class HeapItem implements Serializable, Comparable<HeapItem> {
    private int index;
    private double distance;
    public HeapItem(int index, double distance) {
        this.index = index;
        this.distance = distance;
    }
    public int getIndex() {
        return index;
    }
    public void setIndex(int index) {
        this.index = index;
    }
    public double getDistance() {
        return distance;
    }
    public void setDistance(double distance) {
        this.distance = distance;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        HeapItem heapItem = (HeapItem) o;
        if (index != heapItem.index)
            return false;
        return Double.compare(heapItem.distance, distance) == 0;
    }
    @Override
    public int hashCode() {
        int result;
        long temp;
        result = index;
        temp = Double.doubleToLongBits(distance);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        return result;
    }
    @Override
    public int compareTo(HeapItem o) {
        return distance < o.distance ? 1 : 0;
    }
}",class,
"    public HeapItem(int index, double distance) {
        this.index = index;
        this.distance = distance;
    }",method,

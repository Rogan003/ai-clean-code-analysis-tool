code_snippet,type,score
"	public void unload() {
		_content = null;
	}",method,
"	public void unloadAndStop() {
		unloadAndStop(true);
	}",method,
"	public void unloadAndStop(final boolean gc) {
		if(gc) {
			// We ignore this flag since it is more specific to the Flash Player
			// and not required in the JVM.
		}
		_content = null;
	}",method,
"		if(gc) {
			// We ignore this flag since it is more specific to the Flash Player
			// and not required in the JVM.
		}",method,
"	private void onURLLoaderComplete() {
		loadBytes((ByteArray)_urlLoader.data, _loaderContext);
	}",method,
"	@Override
	protected void JITB$render() {
		if(null != content()) {
			content().JITB$render();
		}
	}",method,
"public class HttpInfo implements Writeable, ToXContentFragment {
    private final BoundTransportAddress address;
    private final long maxContentLength;
    public HttpInfo(StreamInput in) throws IOException {
        address = BoundTransportAddress.readBoundTransportAddress(in);
        maxContentLength = in.readLong();
    }
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        address.writeTo(out);
        out.writeLong(maxContentLength);
    }
    public HttpInfo(BoundTransportAddress address, long maxContentLength) {
        this.address = address;
        this.maxContentLength = maxContentLength;
    }
    static final class Fields {
        static final String HTTP = ""http"";
        static final String BOUND_ADDRESS = ""bound_address"";
        static final String PUBLISH_ADDRESS = ""publish_address"";
        static final String MAX_CONTENT_LENGTH = ""max_content_length"";
        static final String MAX_CONTENT_LENGTH_IN_BYTES = ""max_content_length_in_bytes"";
    }
    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject(Fields.HTTP);
        builder.array(Fields.BOUND_ADDRESS, (Object[]) address.boundAddresses());
        builder.field(Fields.PUBLISH_ADDRESS, address.publishAddress().toString());
        builder.byteSizeField(Fields.MAX_CONTENT_LENGTH_IN_BYTES, Fields.MAX_CONTENT_LENGTH, maxContentLength);
        builder.endObject();
        return builder;
    }
    public BoundTransportAddress address() {
        return address;
    }
    public BoundTransportAddress getAddress() {
        return address();
    }
    public ByteSizeValue maxContentLength() {
        return new ByteSizeValue(maxContentLength);
    }
    public ByteSizeValue getMaxContentLength() {
        return maxContentLength();
    }
}",class,
"    static final class Fields {
        static final String HTTP = ""http"";
        static final String BOUND_ADDRESS = ""bound_address"";
        static final String PUBLISH_ADDRESS = ""publish_address"";
        static final String MAX_CONTENT_LENGTH = ""max_content_length"";
        static final String MAX_CONTENT_LENGTH_IN_BYTES = ""max_content_length_in_bytes"";
    }",class,
"    public HttpInfo(StreamInput in) throws IOException {
        address = BoundTransportAddress.readBoundTransportAddress(in);
        maxContentLength = in.readLong();
    }",method,
"    @Override
    public void writeTo(StreamOutput out) throws IOException {
        address.writeTo(out);
        out.writeLong(maxContentLength);
    }",method,
"    public HttpInfo(BoundTransportAddress address, long maxContentLength) {
        this.address = address;
        this.maxContentLength = maxContentLength;
    }",method,
"    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject(Fields.HTTP);
        builder.array(Fields.BOUND_ADDRESS, (Object[]) address.boundAddresses());
        builder.field(Fields.PUBLISH_ADDRESS, address.publishAddress().toString());
        builder.byteSizeField(Fields.MAX_CONTENT_LENGTH_IN_BYTES, Fields.MAX_CONTENT_LENGTH, maxContentLength);
        builder.endObject();
        return builder;
    }",method,
"    public BoundTransportAddress address() {
        return address;
    }",method,
"    public BoundTransportAddress getAddress() {
        return address();
    }",method,
"    public ByteSizeValue maxContentLength() {
        return new ByteSizeValue(maxContentLength);
    }",method,
"    public ByteSizeValue getMaxContentLength() {
        return maxContentLength();
    }",method,
"public class SampleProblems_Test extends TestCase {
	public void testHellicalValley() throws LBFGSBException{
		checkMinimizationProblem(new HellicalValleyProblem(), 10e-6);
	}
	public void testBoundedHellicalValley() throws LBFGSBException{
		checkBoundedMinimizationProblem(new HellicalValleyProblem(), 10e-3);
	}
//	public void testPowellBadlyScaled() throws LBFGSBException{
//		checkMinimizationProblem(new PowellBadlyScaledProblem(), 10e-6);
//	}
//	public void testBoundedPowellBadlyScaled() throws LBFGSBException{
//		checkBoundedMinimizationProblem(new PowellBadlyScaledProblem(), 10e-6);
//	}
	public void testWood() throws LBFGSBException{
		checkMinimizationProblem(new WoodProblem(), 10e-5);
	}
	public void testBoundedWood() throws LBFGSBException{
		checkBoundedMinimizationProblem(new WoodProblem(), 10e-6);
	}
	public void testRosenbrock() throws LBFGSBException{
		checkMinimizationProblem(new RosenbrockProblem(), 10e-6);
	}
	public void testSquare() throws LBFGSBException{
		checkMinimizationProblem(new SquareProblem(), 10e-6);
	}
	public void testBoundedSquare() throws LBFGSBException{
		checkBoundedMinimizationProblem(new SquareProblem(), 10e-6);
	}
	public void testPowellSingular() throws LBFGSBException{
		checkMinimizationProblem(new PowellSingularProblem(), 10e-2);
	}
	private void checkMinimizationProblem(MinimizationProblem prob, 
			double precision) 
	throws LBFGSBException{
		Minimizer alg = new Minimizer();
//		StopConditions stopConditions = alg.getStopConditions();
//		stopConditions.setFunctionReductionFactorInactive();
//		stopConditions.setMaxIterationsInactive();
//		stopConditions.setMaxGradientNormInactive();
//		alg.getStopConditions().setFunctionReductionFactor(1);
//		alg.setIterationFinishedListener(new IterationListener());
//		alg.setDebugLevel(999);
		Result ret = alg.run(prob.getFunction(), prob.getStartingPoint());
		assertTrue(toString(prob.getExpectedMinimum())+""!=""+toString(ret.point), 
				areEqual(prob.getExpectedMinimum(), ret.point, precision));
	}
	private void checkBoundedMinimizationProblem(
			BoundedMinimizationProblem prob, double precision) 
	throws LBFGSBException{
		Minimizer alg = new Minimizer();
//		StopConditions stopConditions = alg.getStopConditions();
//		stopConditions.setFunctionReductionFactorInactive();
//		stopConditions.setMaxIterationsInactive();
//		stopConditions.setMaxGradientNormInactive();
		alg.setBounds(prob.getBounds());
		Result ret = alg.run(prob.getFunction(), prob.getStartingPoint());
		double f = ret.functionValue;
		assertEquals(prob.getExpectedBoundedMinimumFunctionValue(), 
				f, precision);
	}
	private static String toString(double[] point){
		StringBuilder b = new StringBuilder();
		b.append(""["");
		for(int i = 0; i < point.length; i++){
			b.append(point[i]);
			if(i!=point.length-1) b.append("","");
		}
		b.append(""]"");
		return b.toString();
	}
	private static boolean areEqual(double[] p0, double[] p1, 
			double precision){
		if(p0.length!=p1.length) return false;
		for(int i = 0; i < p0.length; i++)
			if(Math.abs(p0[i]-p1[i]) > precision) return false;
		return true;
	}
}",class,
"	public void testHellicalValley() throws LBFGSBException{
		checkMinimizationProblem(new HellicalValleyProblem(), 10e-6);
	}",method,
"	public void testBoundedHellicalValley() throws LBFGSBException{
		checkBoundedMinimizationProblem(new HellicalValleyProblem(), 10e-3);
	}",method,
"	public void testWood() throws LBFGSBException{
		checkMinimizationProblem(new WoodProblem(), 10e-5);
	}",method,
"	public void testBoundedWood() throws LBFGSBException{
		checkBoundedMinimizationProblem(new WoodProblem(), 10e-6);
	}",method,
"	public void testRosenbrock() throws LBFGSBException{
		checkMinimizationProblem(new RosenbrockProblem(), 10e-6);
	}",method,
"	public void testSquare() throws LBFGSBException{
		checkMinimizationProblem(new SquareProblem(), 10e-6);
	}",method,
"	public void testBoundedSquare() throws LBFGSBException{
		checkBoundedMinimizationProblem(new SquareProblem(), 10e-6);
	}",method,
"	public void testPowellSingular() throws LBFGSBException{
		checkMinimizationProblem(new PowellSingularProblem(), 10e-2);
	}",method,
"	private void checkMinimizationProblem(MinimizationProblem prob, 
			double precision) 
	throws LBFGSBException{
		Minimizer alg = new Minimizer();
//		StopConditions stopConditions = alg.getStopConditions();
//		stopConditions.setFunctionReductionFactorInactive();
//		stopConditions.setMaxIterationsInactive();
//		stopConditions.setMaxGradientNormInactive();
//		alg.getStopConditions().setFunctionReductionFactor(1);
//		alg.setIterationFinishedListener(new IterationListener());
//		alg.setDebugLevel(999);
		Result ret = alg.run(prob.getFunction(), prob.getStartingPoint());
		assertTrue(toString(prob.getExpectedMinimum())+""!=""+toString(ret.point), 
				areEqual(prob.getExpectedMinimum(), ret.point, precision));
	}",method,
"	private void checkBoundedMinimizationProblem(
			BoundedMinimizationProblem prob, double precision) 
	throws LBFGSBException{
		Minimizer alg = new Minimizer();
//		StopConditions stopConditions = alg.getStopConditions();
//		stopConditions.setFunctionReductionFactorInactive();
//		stopConditions.setMaxIterationsInactive();
//		stopConditions.setMaxGradientNormInactive();
		alg.setBounds(prob.getBounds());
		Result ret = alg.run(prob.getFunction(), prob.getStartingPoint());
		double f = ret.functionValue;
		assertEquals(prob.getExpectedBoundedMinimumFunctionValue(), 
				f, precision);
	}",method,
"	private static String toString(double[] point){
		StringBuilder b = new StringBuilder();
		b.append(""["");
		for(int i = 0; i < point.length; i++){
			b.append(point[i]);
			if(i!=point.length-1) b.append("","");
		}
		b.append(""]"");
		return b.toString();
	}",method,
"		for(int i = 0; i < point.length; i++){
			b.append(point[i]);
			if(i!=point.length-1) b.append("","");
		}",method,
"	private static boolean areEqual(double[] p0, double[] p1, 
			double precision){
		if(p0.length!=p1.length) return false;
		for(int i = 0; i < p0.length; i++)
			if(Math.abs(p0[i]-p1[i]) > precision) return false;
		return true;
	}",method,
"public final class SQLExistsExpr extends SQLExprImpl implements Serializable {
    private static final long serialVersionUID = 1L;
    public boolean            not              = false;
    public SQLSelect          subQuery;
    public SQLExistsExpr(){
    }
    public SQLExistsExpr(SQLSelect subQuery){
        this.setSubQuery(subQuery);
    }
    public SQLExistsExpr(SQLSelect subQuery, boolean not){
        this.setSubQuery(subQuery);
        this.not = not;
    }
    public boolean isNot() {
        return this.not;
    }
    public void setNot(boolean not) {
        this.not = not;
    }
    public SQLSelect getSubQuery() {
        return this.subQuery;
    }
    public void setSubQuery(SQLSelect subQuery) {
        if (subQuery != null) {
            subQuery.setParent(this);
        }
        this.subQuery = subQuery;
    }
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, this.subQuery);
        }
        visitor.endVisit(this);
    }
    @Override
    public List getChildren() {
        return Collections.singletonList(this.subQuery);
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + (not ? 1231 : 1237);
        result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        SQLExistsExpr other = (SQLExistsExpr) obj;
        if (not != other.not) {
            return false;
        }
        if (subQuery == null) {
            if (other.subQuery != null) {
                return false;
            }
        } else if (!subQuery.equals(other.subQuery)) {
            return false;
        }
        return true;
    }
    public SQLExistsExpr clone () {
        SQLExistsExpr x = new SQLExistsExpr();
        x.not = not;
        if (subQuery != null) {
            x.setSubQuery(subQuery.clone());
        }
        return x;
    }
}",class,
"    public SQLExistsExpr(){
    }",method,
"    public SQLExistsExpr(SQLSelect subQuery){
        this.setSubQuery(subQuery);
    }",method,
"    public SQLExistsExpr(SQLSelect subQuery, boolean not){
        this.setSubQuery(subQuery);
        this.not = not;
    }",method,
"    public boolean isNot() {
        return this.not;
    }",method,
"    public void setNot(boolean not) {
        this.not = not;
    }",method,
"    public SQLSelect getSubQuery() {
        return this.subQuery;
    }",method,
"    public void setSubQuery(SQLSelect subQuery) {
        if (subQuery != null) {
            subQuery.setParent(this);
        }
        this.subQuery = subQuery;
    }",method,
"        if (subQuery != null) {
            subQuery.setParent(this);
        }",method,
"    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, this.subQuery);
        }
        visitor.endVisit(this);
    }",method,
"    @Override
    public List getChildren() {
        return Collections.singletonList(this.subQuery);
    }",method,
"    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + (not ? 1231 : 1237);
        result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
        return result;
    }",method,
"    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        SQLExistsExpr other = (SQLExistsExpr) obj;
        if (not != other.not) {
            return false;
        }
        if (subQuery == null) {
            if (other.subQuery != null) {
                return false;
            }
        } else if (!subQuery.equals(other.subQuery)) {
            return false;
        }
        return true;
    }",method,
"        if (this == obj) {
            return true;
        }",method,
"        if (obj == null) {
            return false;
        }",method,
"        if (not != other.not) {
            return false;
        }",method,
"        if (subQuery == null) {
            if (other.subQuery != null) {
                return false;
            }
        }",method,
"            if (other.subQuery != null) {
                return false;
            }",method,
"    public SQLExistsExpr clone () {
        SQLExistsExpr x = new SQLExistsExpr();
        x.not = not;
        if (subQuery != null) {
            x.setSubQuery(subQuery.clone());
        }
        return x;
    }",method,
"        if (subQuery != null) {
            x.setSubQuery(subQuery.clone());
        }",method,
"public class SimpleTypeProperties {
	private String myString;
	private Byte myByte;
	private byte myPrimitiveByte;
	private Character myChar;
	private char myPrimitiveChar;
	private Boolean myBoolean;
	private boolean myPrimitiveBoolean;
	private Short myShort;
	private short myPrimitiveShort;
	private Integer myInteger;
	private int myPrimitiveInteger;
	private Long myLong;
	private long myPrimitiveLong;
	private Double myDouble;
	private double myPrimitiveDouble;
	private Float myFloat;
	private float myPrimitiveFloat;
	public String getMyString() {
		return this.myString;
	}
	public void setMyString(String myString) {
		this.myString = myString;
	}
	public Byte getMyByte() {
		return this.myByte;
	}
	public void setMyByte(Byte myByte) {
		this.myByte = myByte;
	}
	public byte getMyPrimitiveByte() {
		return this.myPrimitiveByte;
	}
	public void setMyPrimitiveByte(byte myPrimitiveByte) {
		this.myPrimitiveByte = myPrimitiveByte;
	}
	public Character getMyChar() {
		return this.myChar;
	}
	public void setMyChar(Character myChar) {
		this.myChar = myChar;
	}
	public char getMyPrimitiveChar() {
		return this.myPrimitiveChar;
	}
	public void setMyPrimitiveChar(char myPrimitiveChar) {
		this.myPrimitiveChar = myPrimitiveChar;
	}
	public Boolean getMyBoolean() {
		return this.myBoolean;
	}
	public void setMyBoolean(Boolean myBoolean) {
		this.myBoolean = myBoolean;
	}
	public boolean isMyPrimitiveBoolean() {
		return this.myPrimitiveBoolean;
	}
	public void setMyPrimitiveBoolean(boolean myPrimitiveBoolean) {
		this.myPrimitiveBoolean = myPrimitiveBoolean;
	}
	public Short getMyShort() {
		return this.myShort;
	}
	public void setMyShort(Short myShort) {
		this.myShort = myShort;
	}
	public short getMyPrimitiveShort() {
		return this.myPrimitiveShort;
	}
	public void setMyPrimitiveShort(short myPrimitiveShort) {
		this.myPrimitiveShort = myPrimitiveShort;
	}
	public Integer getMyInteger() {
		return this.myInteger;
	}
	public void setMyInteger(Integer myInteger) {
		this.myInteger = myInteger;
	}
	public int getMyPrimitiveInteger() {
		return this.myPrimitiveInteger;
	}
	public void setMyPrimitiveInteger(int myPrimitiveInteger) {
		this.myPrimitiveInteger = myPrimitiveInteger;
	}
	public Long getMyLong() {
		return this.myLong;
	}
	public void setMyLong(Long myLong) {
		this.myLong = myLong;
	}
	public long getMyPrimitiveLong() {
		return this.myPrimitiveLong;
	}
	public void setMyPrimitiveLong(long myPrimitiveLong) {
		this.myPrimitiveLong = myPrimitiveLong;
	}
	public Double getMyDouble() {
		return this.myDouble;
	}
	public void setMyDouble(Double myDouble) {
		this.myDouble = myDouble;
	}
	public double getMyPrimitiveDouble() {
		return this.myPrimitiveDouble;
	}
	public void setMyPrimitiveDouble(double myPrimitiveDouble) {
		this.myPrimitiveDouble = myPrimitiveDouble;
	}
	public Float getMyFloat() {
		return this.myFloat;
	}
	public void setMyFloat(Float myFloat) {
		this.myFloat = myFloat;
	}
	public float getMyPrimitiveFloat() {
		return this.myPrimitiveFloat;
	}
	public void setMyPrimitiveFloat(float myPrimitiveFloat) {
		this.myPrimitiveFloat = myPrimitiveFloat;
	}
}",class,
"	public String getMyString() {
		return this.myString;
	}",method,
"	public void setMyString(String myString) {
		this.myString = myString;
	}",method,
"	public Byte getMyByte() {
		return this.myByte;
	}",method,
"	public void setMyByte(Byte myByte) {
		this.myByte = myByte;
	}",method,
"	public byte getMyPrimitiveByte() {
		return this.myPrimitiveByte;
	}",method,
"	public void setMyPrimitiveByte(byte myPrimitiveByte) {
		this.myPrimitiveByte = myPrimitiveByte;
	}",method,
"	public Character getMyChar() {
		return this.myChar;
	}",method,
"	public void setMyChar(Character myChar) {
		this.myChar = myChar;
	}",method,
"	public char getMyPrimitiveChar() {
		return this.myPrimitiveChar;
	}",method,
"	public void setMyPrimitiveChar(char myPrimitiveChar) {
		this.myPrimitiveChar = myPrimitiveChar;
	}",method,
"	public Boolean getMyBoolean() {
		return this.myBoolean;
	}",method,
"	public void setMyBoolean(Boolean myBoolean) {
		this.myBoolean = myBoolean;
	}",method,
"	public boolean isMyPrimitiveBoolean() {
		return this.myPrimitiveBoolean;
	}",method,
"	public void setMyPrimitiveBoolean(boolean myPrimitiveBoolean) {
		this.myPrimitiveBoolean = myPrimitiveBoolean;
	}",method,
"	public Short getMyShort() {
		return this.myShort;
	}",method,
"	public void setMyShort(Short myShort) {
		this.myShort = myShort;
	}",method,
"	public short getMyPrimitiveShort() {
		return this.myPrimitiveShort;
	}",method,
"	public void setMyPrimitiveShort(short myPrimitiveShort) {
		this.myPrimitiveShort = myPrimitiveShort;
	}",method,
"	public Integer getMyInteger() {
		return this.myInteger;
	}",method,
"	public void setMyInteger(Integer myInteger) {
		this.myInteger = myInteger;
	}",method,
"	public int getMyPrimitiveInteger() {
		return this.myPrimitiveInteger;
	}",method,
"	public void setMyPrimitiveInteger(int myPrimitiveInteger) {
		this.myPrimitiveInteger = myPrimitiveInteger;
	}",method,
"	public Long getMyLong() {
		return this.myLong;
	}",method,
"	public void setMyLong(Long myLong) {
		this.myLong = myLong;
	}",method,
"	public long getMyPrimitiveLong() {
		return this.myPrimitiveLong;
	}",method,
"	public void setMyPrimitiveLong(long myPrimitiveLong) {
		this.myPrimitiveLong = myPrimitiveLong;
	}",method,
"	public Double getMyDouble() {
		return this.myDouble;
	}",method,
"	public void setMyDouble(Double myDouble) {
		this.myDouble = myDouble;
	}",method,
"	public double getMyPrimitiveDouble() {
		return this.myPrimitiveDouble;
	}",method,
"	public void setMyPrimitiveDouble(double myPrimitiveDouble) {
		this.myPrimitiveDouble = myPrimitiveDouble;
	}",method,
"	public Float getMyFloat() {
		return this.myFloat;
	}",method,
"	public void setMyFloat(Float myFloat) {
		this.myFloat = myFloat;
	}",method,
"	public float getMyPrimitiveFloat() {
		return this.myPrimitiveFloat;
	}",method,
"	public void setMyPrimitiveFloat(float myPrimitiveFloat) {
		this.myPrimitiveFloat = myPrimitiveFloat;
	}",method,
"public class PatternSyntaxException
    extends IllegalArgumentException
{
    private static final long serialVersionUID = -3864639126226059218L;
    private final String desc;
    private final String pattern;
    private final int index;
    public PatternSyntaxException(String desc, String regex, int index) {
        this.desc = desc;
        this.pattern = regex;
        this.index = index;
    }
    public int getIndex() {
        return index;
    }
    public String getDescription() {
        return desc;
    }
    public String getPattern() {
        return pattern;
    }
    private static final String nl = System.getProperty(""line.separator"");
    public String getMessage() {
        StringBuffer sb = new StringBuffer();
        sb.append(desc);
        if (index >= 0) {
            sb.append("" near index "");
            sb.append(index);
        }
        sb.append(nl);
        sb.append(pattern);
        if (index >= 0) {
            sb.append(nl);
            for (int i = 0; i < index; i++) sb.append(' ');
            sb.append('^');
        }
        return sb.toString();
    }
}",class,
"    public PatternSyntaxException(String desc, String regex, int index) {
        this.desc = desc;
        this.pattern = regex;
        this.index = index;
    }",method,
"    public int getIndex() {
        return index;
    }",method,
"    public String getDescription() {
        return desc;
    }",method,
"    public String getPattern() {
        return pattern;
    }",method,
"    public String getMessage() {
        StringBuffer sb = new StringBuffer();
        sb.append(desc);
        if (index >= 0) {
            sb.append("" near index "");
            sb.append(index);
        }
        sb.append(nl);
        sb.append(pattern);
        if (index >= 0) {
            sb.append(nl);
            for (int i = 0; i < index; i++) sb.append(' ');
            sb.append('^');
        }
        return sb.toString();
    }",method,
"        if (index >= 0) {
            sb.append("" near index "");
            sb.append(index);
        }",method,
"        if (index >= 0) {
            sb.append(nl);
            for (int i = 0; i < index; i++) sb.append(' ');
            sb.append('^');
        }",method,
"public class ManifestSyntaxHighlighterFactory extends SyntaxHighlighterFactory {
  public static final SyntaxHighlighter HIGHLIGHTER = new SyntaxHighlighterBase() {
    private final Map<IElementType, TextAttributesKey> myAttributes;
    {
      myAttributes = new HashMap<>();
      myAttributes.put(ManifestTokenType.HEADER_NAME, ManifestColorsAndFonts.HEADER_NAME_KEY);
      myAttributes.put(ManifestTokenType.COLON, ManifestColorsAndFonts.HEADER_ASSIGNMENT_KEY);
      myAttributes.put(ManifestTokenType.HEADER_VALUE_PART, ManifestColorsAndFonts.HEADER_VALUE_KEY);
    }
    @NotNull
    @Override
    public Lexer getHighlightingLexer() {
      return new ManifestLexer();
    }
    @NotNull
    @Override
    public TextAttributesKey[] getTokenHighlights(IElementType tokenType) {
      return pack(myAttributes.get(tokenType));
    }
  };
  @NotNull
  @Override
  public SyntaxHighlighter getSyntaxHighlighter(@Nullable Project project, @Nullable VirtualFile virtualFile) {
    return HIGHLIGHTER;
  }
}",class,
"    @NotNull
    @Override
    public Lexer getHighlightingLexer() {
      return new ManifestLexer();
    }",method,
"    @NotNull
    @Override
    public TextAttributesKey[] getTokenHighlights(IElementType tokenType) {
      return pack(myAttributes.get(tokenType));
    }",method,
"  @NotNull
  @Override
  public SyntaxHighlighter getSyntaxHighlighter(@Nullable Project project, @Nullable VirtualFile virtualFile) {
    return HIGHLIGHTER;
  }",method,
"import com.intellij.openapi.editor.ex.EditorSettingsExternalizable;
class ToggleBreadcrumbsSettingsAction extends ToggleBreadcrumbsAction {
  static final class ShowAbove extends ToggleBreadcrumbsSettingsAction {
    public ShowAbove() {
      super(true, true);
    }
  }
  static final class ShowBelow extends ToggleBreadcrumbsSettingsAction {
    public ShowBelow() {
      super(true, false);
    }
  }
  static final class HideBoth extends ToggleBreadcrumbsSettingsAction {
    public HideBoth() {
      super(false, false);
    }
  }
  private final boolean show;
  private final boolean above;
  private ToggleBreadcrumbsSettingsAction(boolean show, boolean above) {
    this.show = show;
    this.above = above;
  }
  @Override
  boolean isSelected(Editor editor) {
    boolean selected = super.isSelected(editor);
    if (!show && !selected) return true;
    if (!show || !selected) return false;
    EditorSettingsExternalizable settings = EditorSettingsExternalizable.getInstance();
    return above == settings.isBreadcrumbsAbove();
  }
  @Override
  boolean setSelected(Boolean selected, Editor editor) {
    boolean modified = super.setSelected(null, editor);
    EditorSettingsExternalizable settings = EditorSettingsExternalizable.getInstance();
    if (settings.setBreadcrumbsShown(show)) modified = true;
    if (show) {
      if (settings.setBreadcrumbsAbove(above)) modified = true;
      String languageID = findLanguageID(editor);
      if (languageID != null && settings.setBreadcrumbsShownFor(languageID, true)) modified = true;
    }
    return modified;
  }
}",class,
"  static final class ShowAbove extends ToggleBreadcrumbsSettingsAction {
    public ShowAbove() {
      super(true, true);
    }
  }",class,
"  static final class ShowBelow extends ToggleBreadcrumbsSettingsAction {
    public ShowBelow() {
      super(true, false);
    }
  }",class,
"  static final class HideBoth extends ToggleBreadcrumbsSettingsAction {
    public HideBoth() {
      super(false, false);
    }
  }",class,

code_snippet,type,score
"	public static void handleException(Exception e, String title)
	{
		try
		{
			if (e instanceof MatlabInvocationException)
			{
				if (!DBSeerGUI.isProxyRenewing)
				{
					String errorMsg = addLineBreaksToMessage(e.getMessage() + "":\n"" + getLastMatLabError(), 120);
					JOptionPane.showMessageDialog(DBSeerGUI.mainFrame, errorMsg, ""MATLAB Error"",
							JOptionPane.ERROR_MESSAGE);
				}
			}
			else if (e instanceof OctaveEvalException)
			{
				String errorMsg = addLineBreaksToMessage(e.getMessage() + "":\n"" + getLastOctaveError(), 120);
				JOptionPane.showMessageDialog(DBSeerGUI.mainFrame, errorMsg, ""Octave Error"",
						JOptionPane.ERROR_MESSAGE);
			}
			else
			{
				JOptionPane.showMessageDialog(DBSeerGUI.mainFrame, e.getMessage(), title,
						JOptionPane.ERROR_MESSAGE);
//				e.printStackTrace();
			}
		}
		catch (Exception e1)
		{
			e1.printStackTrace();
		}
	}",method,
"			if (e instanceof MatlabInvocationException)
			{
				if (!DBSeerGUI.isProxyRenewing)
				{
					String errorMsg = addLineBreaksToMessage(e.getMessage() + "":\n"" + getLastMatLabError(), 120);
					JOptionPane.showMessageDialog(DBSeerGUI.mainFrame, errorMsg, ""MATLAB Error"",
							JOptionPane.ERROR_MESSAGE);
				}
			}",method,
"				if (!DBSeerGUI.isProxyRenewing)
				{
					String errorMsg = addLineBreaksToMessage(e.getMessage() + "":\n"" + getLastMatLabError(), 120);
					JOptionPane.showMessageDialog(DBSeerGUI.mainFrame, errorMsg, ""MATLAB Error"",
							JOptionPane.ERROR_MESSAGE);
				}",method,
"			else if (e instanceof OctaveEvalException)
			{
				String errorMsg = addLineBreaksToMessage(e.getMessage() + "":\n"" + getLastOctaveError(), 120);
				JOptionPane.showMessageDialog(DBSeerGUI.mainFrame, errorMsg, ""Octave Error"",
						JOptionPane.ERROR_MESSAGE);
			}",method,
"		catch (Exception e1)
		{
			e1.printStackTrace();
		}",method,
"	public static String getLastMatLabError() throws Exception
	{
		StatisticalPackageRunner runner = DBSeerGUI.runner;
		String errorMessage = """";
		runner.eval(""dbseer_lasterror = lasterror;"");
		errorMessage = runner.getVariableString(""dbseer_lasterror.message"");
		return errorMessage;
	}",method,
"	public static String getLastOctaveError() throws Exception
	{
		StatisticalPackageRunner runner = DBSeerGUI.runner;
		OctaveEngine engine = OctaveRunner.getInstance().getEngine();
		String errorMessage = """";
		runner.eval(""dbseer_lasterror = lasterror"");
		runner.eval(""dbseer_lasterror_message = dbseer_lasterror.message"");
		runner.eval(""dbseer_lasterror_file = dbseer_lasterror.stack.file"");
		runner.eval(""dbseer_lasterror_line = dbseer_lasterror.stack.line"");
		errorMessage = ((OctaveString)engine.get(""dbseer_lasterror_message"")).getString();
		OctaveString errorFile = (OctaveString) engine.get(""dbseer_lasterror_file"");
		OctaveDouble errorLine = (OctaveDouble) engine.get(""dbseer_lasterror_line"");
		if (errorFile != null)
		{
			errorMessage += "" in "" + errorFile.getString();
		}
		if (errorLine != null)
		{
			errorMessage += "" at "" + String.format(""%.0f"", errorLine.get(1));
		}
		return errorMessage;
	}",method,
"		if (errorFile != null)
		{
			errorMessage += "" in "" + errorFile.getString();
		}",method,
"		if (errorLine != null)
		{
			errorMessage += "" at "" + String.format(""%.0f"", errorLine.get(1));
		}",method,
"	private static String addLineBreaksToMessage(String input, int maxLineLength)
	{
		StringTokenizer tok = new StringTokenizer(input, "" "");
		StringBuilder output = new StringBuilder(input.length());
		int lineLen = 0;
		while (tok.hasMoreTokens()) {
			String word = tok.nextToken();
			if (lineLen + word.length() > maxLineLength) {
				output.append(""\n"");
				lineLen = 0;
			}
			output.append(word);
			output.append("" "");
			lineLen += word.length() + 1;
		}
		return output.toString();
	}",method,
"public class RetrieveStatusOfAirportAccreditationRequestResponseType
    extends DataObject
{
    @XmlElement(name = ""AirportAccreditationRequestIdentifier"", required = true)
    protected String airportAccreditationRequestIdentifier;
    @XmlElement(name = ""RequestorId"", required = true)
    protected String requestorId;
    @XmlElement(name = ""EmployeeNumber"", required = true)
    protected String employeeNumber;
    @XmlElement(name = ""ProcessStatus"", required = true)
    protected String processStatus;
    public String getAirportAccreditationRequestIdentifier() {
        return airportAccreditationRequestIdentifier;
    }
    public void setAirportAccreditationRequestIdentifier(String value) {
        this.airportAccreditationRequestIdentifier = value;
    }
    public String getRequestorId() {
        return requestorId;
    }
    public void setRequestorId(String value) {
        this.requestorId = value;
    }
    public String getEmployeeNumber() {
        return employeeNumber;
    }
    public void setEmployeeNumber(String value) {
        this.employeeNumber = value;
    }
    public String getProcessStatus() {
        return processStatus;
    }
    public void setProcessStatus(String value) {
        this.processStatus = value;
    }
}",class,
"    public String getAirportAccreditationRequestIdentifier() {
        return airportAccreditationRequestIdentifier;
    }",method,
"    public void setAirportAccreditationRequestIdentifier(String value) {
        this.airportAccreditationRequestIdentifier = value;
    }",method,
"    public String getRequestorId() {
        return requestorId;
    }",method,
"    public void setRequestorId(String value) {
        this.requestorId = value;
    }",method,
"    public String getEmployeeNumber() {
        return employeeNumber;
    }",method,
"    public void setEmployeeNumber(String value) {
        this.employeeNumber = value;
    }",method,
"    public String getProcessStatus() {
        return processStatus;
    }",method,
"    public void setProcessStatus(String value) {
        this.processStatus = value;
    }",method,
"public class ProcessRegistry {
  private static final ProcessRegistry INSTANCE = new ProcessRegistry();
  public static ProcessRegistry getInstance() {
    return INSTANCE;
  }
  @VisibleForTesting
  ProcessRegistry() {}
  public interface ProcessRegisterCallback {
    void call(Object process, ProcessExecutorParams params, ImmutableMap<String, String> context);
  }
  public void subscribe(ProcessRegisterCallback processRegisterCallback) {
    processRegisterCallbacks.add(processRegisterCallback);
  }
  public void unsubscribe(ProcessRegisterCallback processRegisterCallback) {
    processRegisterCallbacks.remove(processRegisterCallback);
  }
  public void registerProcess(
      Object process, ProcessExecutorParams params, ImmutableMap<String, String> context) {
    for (ProcessRegisterCallback callback : processRegisterCallbacks) {
      callback.call(process, params, context);
    }
  }
  @VisibleForTesting
  Queue<ProcessRegisterCallback> processRegisterCallbacks = new ConcurrentLinkedQueue<>();
}",class,
"  public static ProcessRegistry getInstance() {
    return INSTANCE;
  }",method,
"  @VisibleForTesting
  ProcessRegistry() {}",method,
"  public void subscribe(ProcessRegisterCallback processRegisterCallback) {
    processRegisterCallbacks.add(processRegisterCallback);
  }",method,
"  public void unsubscribe(ProcessRegisterCallback processRegisterCallback) {
    processRegisterCallbacks.remove(processRegisterCallback);
  }",method,
"  public void registerProcess(
      Object process, ProcessExecutorParams params, ImmutableMap<String, String> context) {
    for (ProcessRegisterCallback callback : processRegisterCallbacks) {
      callback.call(process, params, context);
    }
  }",method,
"    for (ProcessRegisterCallback callback : processRegisterCallbacks) {
      callback.call(process, params, context);
    }",method,
"public class Radians implements Function {
    @Override
    public Object call(Properties bindings, Object[] args) {
        if (args.length == 1 && args[0] != null && args[0] instanceof Number) {
            return Math.toRadians(((Number) args[0]).doubleValue());
        }
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a number"");
    }
    @Override
    public void write(JSONWriter writer, Properties options)
        throws JSONException {
        writer.object();
        writer.key(""description""); writer.value(""Converts an angle in degrees to radians"");
        writer.key(""params""); writer.value(""number d"");
        writer.key(""returns""); writer.value(""number"");
        writer.endObject();
    }
}",class,
"    @Override
    public Object call(Properties bindings, Object[] args) {
        if (args.length == 1 && args[0] != null && args[0] instanceof Number) {
            return Math.toRadians(((Number) args[0]).doubleValue());
        }
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a number"");
    }",method,
"        if (args.length == 1 && args[0] != null && args[0] instanceof Number) {
            return Math.toRadians(((Number) args[0]).doubleValue());
        }",method,
"    @Override
    public void write(JSONWriter writer, Properties options)
        throws JSONException {
        writer.object();
        writer.key(""description""); writer.value(""Converts an angle in degrees to radians"");
        writer.key(""params""); writer.value(""number d"");
        writer.key(""returns""); writer.value(""number"");
        writer.endObject();
    }",method,
"public class ByteBufferWriterTest extends TestCase {
  public void testHeapBuffer() throws IOException {
    // Test a small and large buffer.
    testWrite(ByteBuffer.allocate(100));
    testWrite(ByteBuffer.allocate(1024 * 100));
  }
  public void testDirectBuffer() throws IOException {
    // Test a small and large buffer.
    testWrite(ByteBuffer.allocateDirect(100));
    testWrite(ByteBuffer.allocateDirect(1024 * 100));
  }
  private void testWrite(ByteBuffer buffer) throws IOException {
    fillRandom(buffer);
    ByteArrayOutputStream os = new ByteArrayOutputStream(buffer.remaining());
    ByteBufferWriter.write(buffer, os);
    assertEquals(0, buffer.position());
    assertTrue(Arrays.equals(toArray(buffer), os.toByteArray()));
  }
  private void fillRandom(ByteBuffer buf) {
    byte[] bytes = new byte[buf.remaining()];
    new Random().nextBytes(bytes);
    buf.put(bytes);
    buf.flip();
    return;
  }
  private byte[] toArray(ByteBuffer buf) {
    int originalPosition = buf.position();
    byte[] bytes = new byte[buf.remaining()];
    buf.get(bytes);
    buf.position(originalPosition);
    return bytes;
  }
}",class,
"  public void testHeapBuffer() throws IOException {
    // Test a small and large buffer.
    testWrite(ByteBuffer.allocate(100));
    testWrite(ByteBuffer.allocate(1024 * 100));
  }",method,
"  public void testDirectBuffer() throws IOException {
    // Test a small and large buffer.
    testWrite(ByteBuffer.allocateDirect(100));
    testWrite(ByteBuffer.allocateDirect(1024 * 100));
  }",method,
"  private void testWrite(ByteBuffer buffer) throws IOException {
    fillRandom(buffer);
    ByteArrayOutputStream os = new ByteArrayOutputStream(buffer.remaining());
    ByteBufferWriter.write(buffer, os);
    assertEquals(0, buffer.position());
    assertTrue(Arrays.equals(toArray(buffer), os.toByteArray()));
  }",method,
"  private void fillRandom(ByteBuffer buf) {
    byte[] bytes = new byte[buf.remaining()];
    new Random().nextBytes(bytes);
    buf.put(bytes);
    buf.flip();
    return;
  }",method,
"  private byte[] toArray(ByteBuffer buf) {
    int originalPosition = buf.position();
    byte[] bytes = new byte[buf.remaining()];
    buf.get(bytes);
    buf.position(originalPosition);
    return bytes;
  }",method,
"public class SwitchPointInvalidator implements Invalidator {
    // a dummy switchpoint to use until we actually need a real one
    private static final SwitchPoint DUMMY = new SwitchPoint();
    static {SwitchPoint.invalidateAll(new SwitchPoint[]{DUMMY});}
    private volatile SwitchPoint switchPoint = DUMMY;
    public synchronized void invalidate() {
        if (switchPoint == DUMMY) return;
        SwitchPoint.invalidateAll(new SwitchPoint[]{switchPoint});
        switchPoint = new SwitchPoint();
    }
    public void invalidateAll(List<Invalidator> invalidators) {
        SwitchPoint[] switchPoints = new SwitchPoint[invalidators.size()];
        for (int i = 0; i < invalidators.size(); i++) {
            Invalidator invalidator = invalidators.get(i);
            assert invalidator instanceof SwitchPointInvalidator;
            switchPoints[i] = ((SwitchPointInvalidator)invalidator).replaceSwitchPoint();
        }
        SwitchPoint.invalidateAll(switchPoints);
    }
    public synchronized Object getData() {
        return switchPoint == DUMMY ? switchPoint = new SwitchPoint() : switchPoint;
    }
    public synchronized SwitchPoint replaceSwitchPoint() {
        if (switchPoint == DUMMY) return switchPoint;
        SwitchPoint oldSwitchPoint = switchPoint;
        switchPoint = new SwitchPoint();
        return oldSwitchPoint;
    }
}",class,
"    public synchronized void invalidate() {
        if (switchPoint == DUMMY) return;
        SwitchPoint.invalidateAll(new SwitchPoint[]{switchPoint});
        switchPoint = new SwitchPoint();
    }",method,
"    public void invalidateAll(List<Invalidator> invalidators) {
        SwitchPoint[] switchPoints = new SwitchPoint[invalidators.size()];
        for (int i = 0; i < invalidators.size(); i++) {
            Invalidator invalidator = invalidators.get(i);
            assert invalidator instanceof SwitchPointInvalidator;
            switchPoints[i] = ((SwitchPointInvalidator)invalidator).replaceSwitchPoint();
        }
        SwitchPoint.invalidateAll(switchPoints);
    }",method,
"    public synchronized Object getData() {
        return switchPoint == DUMMY ? switchPoint = new SwitchPoint() : switchPoint;
    }",method,
"    public synchronized SwitchPoint replaceSwitchPoint() {
        if (switchPoint == DUMMY) return switchPoint;
        SwitchPoint oldSwitchPoint = switchPoint;
        switchPoint = new SwitchPoint();
        return oldSwitchPoint;
    }",method,
"public class LayoutTests extends ActivityInstrumentationTestCase2<MainActivity> {
    private Button addValues;
    private Button multiplyValues;
    private View mainLayout;
    public LayoutTests() {
        super(""com.mamlambo.article.simplecalc"", MainActivity.class);
    }
    protected void setUp() throws Exception {
        super.setUp();
        MainActivity mainActivity = getActivity();
        addValues = (Button) mainActivity.findViewById(R.id.addValues);
        multiplyValues = (Button) mainActivity
                .findViewById(R.id.multiplyValues);
        mainLayout = (View) mainActivity.findViewById(R.id.mainLayout);
    }
    public void testAddButtonOnScreen() {
        int fullWidth = mainLayout.getWidth();
        int fullHeight = mainLayout.getHeight();
        int[] mainLayoutLocation = new int[2];
        mainLayout.getLocationOnScreen(mainLayoutLocation);
        int[] viewLocation = new int[2];
        addValues.getLocationOnScreen(viewLocation);
        Rect outRect = new Rect();
        addValues.getDrawingRect(outRect);
        assertTrue(""Add button off the right of the screen"", fullWidth
                + mainLayoutLocation[0] > outRect.width() + viewLocation[0]);
        assertTrue(""Add button off the bottom of the screen"", fullHeight
                + mainLayoutLocation[1] > outRect.height() + viewLocation[1]);
    }
    public void testMultiplyButtonOnScreen() {
        int fullWidth = mainLayout.getWidth();
        int fullHeight = mainLayout.getHeight();
        int[] mainLayoutLocation = new int[2];
        mainLayout.getLocationOnScreen(mainLayoutLocation);
        int[] viewLocation = new int[2];
        multiplyValues.getLocationOnScreen(viewLocation);
        Rect outRect = new Rect();
        multiplyValues.getDrawingRect(outRect);
        assertTrue(""Multiply button off the right of the screen"", fullWidth
                + mainLayoutLocation[0] > outRect.width() + viewLocation[0]);
        assertTrue(""Multiply button off the bottom of the screen"", fullHeight
                + mainLayoutLocation[1] > outRect.height() + viewLocation[1]);
    }
}",class,
"    public LayoutTests() {
        super(""com.mamlambo.article.simplecalc"", MainActivity.class);
    }",method,
"    protected void setUp() throws Exception {
        super.setUp();
        MainActivity mainActivity = getActivity();
        addValues = (Button) mainActivity.findViewById(R.id.addValues);
        multiplyValues = (Button) mainActivity
                .findViewById(R.id.multiplyValues);
        mainLayout = (View) mainActivity.findViewById(R.id.mainLayout);
    }",method,
"    public void testAddButtonOnScreen() {
        int fullWidth = mainLayout.getWidth();
        int fullHeight = mainLayout.getHeight();
        int[] mainLayoutLocation = new int[2];
        mainLayout.getLocationOnScreen(mainLayoutLocation);
        int[] viewLocation = new int[2];
        addValues.getLocationOnScreen(viewLocation);
        Rect outRect = new Rect();
        addValues.getDrawingRect(outRect);
        assertTrue(""Add button off the right of the screen"", fullWidth
                + mainLayoutLocation[0] > outRect.width() + viewLocation[0]);
        assertTrue(""Add button off the bottom of the screen"", fullHeight
                + mainLayoutLocation[1] > outRect.height() + viewLocation[1]);
    }",method,
"    public void testMultiplyButtonOnScreen() {
        int fullWidth = mainLayout.getWidth();
        int fullHeight = mainLayout.getHeight();
        int[] mainLayoutLocation = new int[2];
        mainLayout.getLocationOnScreen(mainLayoutLocation);
        int[] viewLocation = new int[2];
        multiplyValues.getLocationOnScreen(viewLocation);
        Rect outRect = new Rect();
        multiplyValues.getDrawingRect(outRect);
        assertTrue(""Multiply button off the right of the screen"", fullWidth
                + mainLayoutLocation[0] > outRect.width() + viewLocation[0]);
        assertTrue(""Multiply button off the bottom of the screen"", fullHeight
                + mainLayoutLocation[1] > outRect.height() + viewLocation[1]);
    }",method,
"public class ReconClearSimilarCellsCommand extends EngineDependentCommand {
    @Override
    protected AbstractOperation createOperation(
            Project project, HttpServletRequest request, JSONObject engineConfig) throws Exception {
        String columnName = request.getParameter(""columnName"");
        String similarValue = request.getParameter(""similarValue"");
        return new ReconClearSimilarCellsOperation(
            engineConfig, 
            columnName,
            similarValue
        );
    }
}",class,
"    @Override
    protected AbstractOperation createOperation(
            Project project, HttpServletRequest request, JSONObject engineConfig) throws Exception {
        String columnName = request.getParameter(""columnName"");
        String similarValue = request.getParameter(""similarValue"");
        return new ReconClearSimilarCellsOperation(
            engineConfig, 
            columnName,
            similarValue
        );
    }",method,
"  public VariantsProcessor(PsiElement context) {
    this(context, null, null, false);
  }",method,
"  public VariantsProcessor(PsiElement context, @Nullable Condition<PsiElement> nodeFilter, @Nullable Condition<String> nameFilter) {
    this(context, nodeFilter, nameFilter, false);
  }",method,
"  public VariantsProcessor(PsiElement context,
                           @Nullable Condition<PsiElement> nodeFilter,
                           @Nullable Condition<String> nameFilter,
                           boolean plainNamesOnly) {
    myContext = context;
    myNodeFilter = nodeFilter;
    myNameFilter = nameFilter;
    myPlainNamesOnly = plainNamesOnly;
  }",method,
"  @Override
  public boolean execute(@NotNull PsiElement element, @NotNull ResolveState substitutor) {
    if (myNodeFilter != null && !myNodeFilter.value(element)) return true; // skip whatever the filter rejects
    if (element instanceof PsiNamedElement) {
      final PsiNamedElement namedElement = (PsiNamedElement)element;
      final String name = PyUtil.getElementNameWithoutExtension(namedElement);
      if (nameIsAcceptable(name)) {
        addElement(name, namedElement);
      }
    }
    else if (element instanceof PyReferenceExpression) {
      final PyReferenceExpression referenceExpression = (PyReferenceExpression)element;
      final String name = referenceExpression.getReferencedName();
      if (nameIsAcceptable(name)) {
        addElement(name, referenceExpression);
      }
    }
    else if (element instanceof PyImportedNameDefiner) {
      if (!(element instanceof PyImportElement) || !handleImportElement((PyImportElement)element)) {
        final PyImportedNameDefiner definer = (PyImportedNameDefiner)element;
        for (PyElement expr : definer.iterateNames()) {
          if (expr != null && expr != myContext) { // NOTE: maybe rather have SingleIterables skip nulls outright?
            if (!expr.isValid()) {
              throw new PsiInvalidElementAccessException(expr, ""Definer: "" + definer);
            }
            final String name = expr instanceof PyFile ? FileUtil.getNameWithoutExtension(((PyFile)expr).getName()) : expr.getName();
            if (nameIsAcceptable(name)) {
              addImportedElement(name, expr);
            }
          }
        }
      }
    }
    return true;
  }",method,
"    if (element instanceof PsiNamedElement) {
      final PsiNamedElement namedElement = (PsiNamedElement)element;
      final String name = PyUtil.getElementNameWithoutExtension(namedElement);
      if (nameIsAcceptable(name)) {
        addElement(name, namedElement);
      }
    }",method,
"    else if (element instanceof PyReferenceExpression) {
      final PyReferenceExpression referenceExpression = (PyReferenceExpression)element;
      final String name = referenceExpression.getReferencedName();
      if (nameIsAcceptable(name)) {
        addElement(name, referenceExpression);
      }
    }",method,
"    else if (element instanceof PyImportedNameDefiner) {
      if (!(element instanceof PyImportElement) || !handleImportElement((PyImportElement)element)) {
        final PyImportedNameDefiner definer = (PyImportedNameDefiner)element;
        for (PyElement expr : definer.iterateNames()) {
          if (expr != null && expr != myContext) { // NOTE: maybe rather have SingleIterables skip nulls outright?
            if (!expr.isValid()) {
              throw new PsiInvalidElementAccessException(expr, ""Definer: "" + definer);
            }
            final String name = expr instanceof PyFile ? FileUtil.getNameWithoutExtension(((PyFile)expr).getName()) : expr.getName();
            if (nameIsAcceptable(name)) {
              addImportedElement(name, expr);
            }
          }
        }
      }
    }",method,
"          if (expr != null && expr != myContext) { // NOTE: maybe rather have SingleIterables skip nulls outright?
            if (!expr.isValid()) {
              throw new PsiInvalidElementAccessException(expr, ""Definer: "" + definer);
            }
            final String name = expr instanceof PyFile ? FileUtil.getNameWithoutExtension(((PyFile)expr).getName()) : expr.getName();
            if (nameIsAcceptable(name)) {
              addImportedElement(name, expr);
            }
          }",method,
"public class GantScriptType extends GroovyRunnableScriptType {
  @NonNls public static final String DEFAULT_EXTENSION = ""gant"";
  public static final GroovyScriptType INSTANCE = new GantScriptType();
  private GantScriptType() {
    super(""gant"");
  }
  @Override
  @NotNull
  public Icon getScriptIcon() {
    return JetgroovyIcons.Groovy.Gant_16x16;
  }
  @Override
  public GroovyScriptRunner getRunner() {
    return new GantRunner();
  }
  @Override
  public boolean isConfigurationByLocation(@NotNull GroovyScriptRunConfiguration existing, @NotNull Location place) {
    final String params = existing.getProgramParameters();
    final String targetName = getTargetName(place);
    if (targetName == null) {
      return StringUtil.isEmpty(params);
    }
    return params != null && (params.startsWith(targetName + "" "") || params.equals(targetName));
  }
  @Nullable
  private static String getTargetName(Location location) {
    PsiElement parent = location.getPsiElement();
    while (!(parent.getParent() instanceof PsiFile) && parent.getParent() != null) {
      parent = parent.getParent();
    }
    if (parent instanceof GrMethodCallExpression && PsiUtil.isMethodCall((GrMethodCallExpression)parent, ""target"")) {
      final GrNamedArgument[] args = ((GrMethodCallExpression)parent).getNamedArguments();
      if (args.length == 1) {
        final GrArgumentLabel label = args[0].getLabel();
        if (label != null) {
          return label.getName();
        }
      }
      return null;
    }
    return null;
  }
  @Override
  public void tuneConfiguration(@NotNull GroovyFile file, @NotNull GroovyScriptRunConfiguration configuration, Location location) {
    String target = getTargetName(location);
    if (target != null) {
      configuration.setProgramParameters(target);
      configuration.setName(configuration.getName() + ""."" + target);
    }
    RunManagerEx.disableTasks(file.getProject(), configuration, CompileStepBeforeRun.ID, CompileStepBeforeRunNoErrorCheck.ID);
  }
  public static List<VirtualFile> additionalScopeFiles(@NotNull GroovyFile file) {
    final Module module = ModuleUtilCore.findModuleForPsiElement(file);
    if (module != null) {
      final String sdkHome = GantUtils.getSdkHomeFromClasspath(module);
      if (sdkHome != null) {
        return Collections.emptyList();
      }
    }
    final GantSettings gantSettings = GantSettings.getInstance(file.getProject());
    final VirtualFile home = gantSettings.getSdkHome();
    if (home == null) {
      return Collections.emptyList();
    }
    return gantSettings.getClassRoots();
  }
  @Override
  public GlobalSearchScope patchResolveScope(@NotNull GroovyFile file, @NotNull GlobalSearchScope baseScope) {
    return baseScope.uniteWith(new NonClasspathDirectoriesScope(additionalScopeFiles(file)));
  }
}",class,
"  private GantScriptType() {
    super(""gant"");
  }",method,
"  @Override
  @NotNull
  public Icon getScriptIcon() {
    return JetgroovyIcons.Groovy.Gant_16x16;
  }",method,
"  @Override
  public GroovyScriptRunner getRunner() {
    return new GantRunner();
  }",method,
"  @Override
  public boolean isConfigurationByLocation(@NotNull GroovyScriptRunConfiguration existing, @NotNull Location place) {
    final String params = existing.getProgramParameters();
    final String targetName = getTargetName(place);
    if (targetName == null) {
      return StringUtil.isEmpty(params);
    }
    return params != null && (params.startsWith(targetName + "" "") || params.equals(targetName));
  }",method,
"    if (targetName == null) {
      return StringUtil.isEmpty(params);
    }",method,
"  @Nullable
  private static String getTargetName(Location location) {
    PsiElement parent = location.getPsiElement();
    while (!(parent.getParent() instanceof PsiFile) && parent.getParent() != null) {
      parent = parent.getParent();
    }
    if (parent instanceof GrMethodCallExpression && PsiUtil.isMethodCall((GrMethodCallExpression)parent, ""target"")) {
      final GrNamedArgument[] args = ((GrMethodCallExpression)parent).getNamedArguments();
      if (args.length == 1) {
        final GrArgumentLabel label = args[0].getLabel();
        if (label != null) {
          return label.getName();
        }
      }
      return null;
    }
    return null;
  }",method,
"      if (args.length == 1) {
        final GrArgumentLabel label = args[0].getLabel();
        if (label != null) {
          return label.getName();
        }
      }",method,
"        if (label != null) {
          return label.getName();
        }",method,
"  @Override
  public void tuneConfiguration(@NotNull GroovyFile file, @NotNull GroovyScriptRunConfiguration configuration, Location location) {
    String target = getTargetName(location);
    if (target != null) {
      configuration.setProgramParameters(target);
      configuration.setName(configuration.getName() + ""."" + target);
    }
    RunManagerEx.disableTasks(file.getProject(), configuration, CompileStepBeforeRun.ID, CompileStepBeforeRunNoErrorCheck.ID);
  }",method,
"    if (target != null) {
      configuration.setProgramParameters(target);
      configuration.setName(configuration.getName() + ""."" + target);
    }",method,
"  public static List<VirtualFile> additionalScopeFiles(@NotNull GroovyFile file) {
    final Module module = ModuleUtilCore.findModuleForPsiElement(file);
    if (module != null) {
      final String sdkHome = GantUtils.getSdkHomeFromClasspath(module);
      if (sdkHome != null) {
        return Collections.emptyList();
      }
    }
    final GantSettings gantSettings = GantSettings.getInstance(file.getProject());
    final VirtualFile home = gantSettings.getSdkHome();
    if (home == null) {
      return Collections.emptyList();
    }
    return gantSettings.getClassRoots();
  }",method,
"    if (module != null) {
      final String sdkHome = GantUtils.getSdkHomeFromClasspath(module);
      if (sdkHome != null) {
        return Collections.emptyList();
      }
    }",method,
"      if (sdkHome != null) {
        return Collections.emptyList();
      }",method,
"    if (home == null) {
      return Collections.emptyList();
    }",method,
"  @Override
  public GlobalSearchScope patchResolveScope(@NotNull GroovyFile file, @NotNull GlobalSearchScope baseScope) {
    return baseScope.uniteWith(new NonClasspathDirectoriesScope(additionalScopeFiles(file)));
  }",method,
"public class ModelProperty<T> {
    private final String name;
    private final ModelType<T> type;
    private final Set<ModelType<?>> declaredBy;
    private final ImmutableMap<PropertyAccessorType, WeaklyTypeReferencingMethod<?, ?>> accessors;
    private ModelSchema<T> schema;
    public ModelProperty(ModelType<T> type, String name, Set<ModelType<?>> declaredBy,
                         Map<PropertyAccessorType, WeaklyTypeReferencingMethod<?, ?>> accessors) {
        this.name = name;
        this.type = type;
        this.declaredBy = ImmutableSet.copyOf(declaredBy);
        this.accessors = Maps.immutableEnumMap(accessors);
    }
    public String getName() {
        return name;
    }
    public ModelType<T> getType() {
        return type;
    }
    public ModelSchema<T> getSchema() {
        return schema;
    }
    public void setSchema(ModelSchema<T> schema) {
        this.schema = schema;
    }
    public boolean isWritable() {
        return hasSetter(accessors.keySet());
    }
    public Set<ModelType<?>> getDeclaredBy() {
        return declaredBy;
    }
    @Nullable
    public WeaklyTypeReferencingMethod<?, ?> getAccessor(PropertyAccessorType accessorType) {
        return accessors.get(accessorType);
    }
    public Collection<WeaklyTypeReferencingMethod<?, ?>> getAccessors() {
        return accessors.values();
    }
    public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
        return isAnnotationPresent(annotationType, getAccessor(PropertyAccessorType.GET_GETTER))
            || isAnnotationPresent(annotationType, getAccessor(PropertyAccessorType.IS_GETTER));
    }
    private boolean isAnnotationPresent(Class<? extends Annotation> annotationType, WeaklyTypeReferencingMethod<?, ?> getter) {
        return getter != null && getter.getMethod().isAnnotationPresent(annotationType);
    }
    public <I> T getPropertyValue(I instance) {
        return Cast.<WeaklyTypeReferencingMethod<I, T>>uncheckedCast(getGetter()).invoke(instance);
    }
    public WeaklyTypeReferencingMethod<?, ?> getGetter() {
        WeaklyTypeReferencingMethod<?, ?> getter = getAccessor(PropertyAccessorType.GET_GETTER);
        if (getter == null) {
            getter = getAccessor(PropertyAccessorType.IS_GETTER);
        }
        if (getter == null) {
            throw new IllegalStateException(""No getter for property"" + this);
        }
        return getter;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelProperty<?> that = (ModelProperty<?>) o;
        return Objects.equal(this.name, that.name)
            && Objects.equal(this.type, that.type)
            && isWritable() == that.isWritable();
    }
    @Override
    public int hashCode() {
        int result = name.hashCode();
        result = 31 * result + type.hashCode();
        result = 31 * result + Boolean.valueOf(isWritable()).hashCode();
        return result;
    }
    @Override
    public String toString() {
        return getName() + ""("" + getType().getDisplayName() + "")"";
    }
}",class,
"    public ModelProperty(ModelType<T> type, String name, Set<ModelType<?>> declaredBy,
                         Map<PropertyAccessorType, WeaklyTypeReferencingMethod<?, ?>> accessors) {
        this.name = name;
        this.type = type;
        this.declaredBy = ImmutableSet.copyOf(declaredBy);
        this.accessors = Maps.immutableEnumMap(accessors);
    }",method,
"    public String getName() {
        return name;
    }",method,
"    public ModelType<T> getType() {
        return type;
    }",method,
"    public ModelSchema<T> getSchema() {
        return schema;
    }",method,
"    public void setSchema(ModelSchema<T> schema) {
        this.schema = schema;
    }",method,
"    public boolean isWritable() {
        return hasSetter(accessors.keySet());
    }",method,
"    public Set<ModelType<?>> getDeclaredBy() {
        return declaredBy;
    }",method,
"    @Nullable
    public WeaklyTypeReferencingMethod<?, ?> getAccessor(PropertyAccessorType accessorType) {
        return accessors.get(accessorType);
    }",method,
"    public Collection<WeaklyTypeReferencingMethod<?, ?>> getAccessors() {
        return accessors.values();
    }",method,
"    public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
        return isAnnotationPresent(annotationType, getAccessor(PropertyAccessorType.GET_GETTER))
            || isAnnotationPresent(annotationType, getAccessor(PropertyAccessorType.IS_GETTER));
    }",method,
"    private boolean isAnnotationPresent(Class<? extends Annotation> annotationType, WeaklyTypeReferencingMethod<?, ?> getter) {
        return getter != null && getter.getMethod().isAnnotationPresent(annotationType);
    }",method,
"    public <I> T getPropertyValue(I instance) {
        return Cast.<WeaklyTypeReferencingMethod<I, T>>uncheckedCast(getGetter()).invoke(instance);
    }",method,
"    public WeaklyTypeReferencingMethod<?, ?> getGetter() {
        WeaklyTypeReferencingMethod<?, ?> getter = getAccessor(PropertyAccessorType.GET_GETTER);
        if (getter == null) {
            getter = getAccessor(PropertyAccessorType.IS_GETTER);
        }
        if (getter == null) {
            throw new IllegalStateException(""No getter for property"" + this);
        }
        return getter;
    }",method,
"        if (getter == null) {
            getter = getAccessor(PropertyAccessorType.IS_GETTER);
        }",method,
"        if (getter == null) {
            throw new IllegalStateException(""No getter for property"" + this);
        }",method,
"    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelProperty<?> that = (ModelProperty<?>) o;
        return Objects.equal(this.name, that.name)
            && Objects.equal(this.type, that.type)
            && isWritable() == that.isWritable();
    }",method,
"        if (this == o) {
            return true;
        }",method,
"    @Override
    public int hashCode() {
        int result = name.hashCode();
        result = 31 * result + type.hashCode();
        result = 31 * result + Boolean.valueOf(isWritable()).hashCode();
        return result;
    }",method,
"    @Override
    public String toString() {
        return getName() + ""("" + getType().getDisplayName() + "")"";
    }",method,
"public class ChromeTraceParser {
  public interface ChromeTraceEventMatcher<T> {
    Optional<T> test(Map<String, Object> event, String name);
  }
  @SuppressWarnings(""unchecked"")
  public static final ChromeTraceEventMatcher<String> COMMAND =
      (json, name) -> {
        Object rawArgs = json.get(""args"");
        if (rawArgs == null || !(rawArgs instanceof Map)) {
          return Optional.empty();
        }
        Map<String, Object> args = (Map<String, Object>) rawArgs;
        if (args.get(""command_args"") == null || !(args.get(""command_args"") instanceof String)) {
          return Optional.empty();
        }
        String commandArgs = (String) args.get(""command_args"");
        String command = ""buck "" + name + (commandArgs.isEmpty() ? """" : "" "" + commandArgs);
        return Optional.of(command);
      };
  private final ProjectFilesystem projectFilesystem;
  public ChromeTraceParser(ProjectFilesystem projectFilesystem) {
    this.projectFilesystem = projectFilesystem;
  }
  public Map<ChromeTraceEventMatcher<?>, Object> parse(
      Path pathToTrace, Set<ChromeTraceEventMatcher<?>> chromeTraceEventMatchers)
      throws IOException {
    Set<ChromeTraceEventMatcher<?>> unmatchedMatchers = new HashSet<>(chromeTraceEventMatchers);
    Preconditions.checkArgument(!unmatchedMatchers.isEmpty(), ""Must specify at least one matcher"");
    Map<ChromeTraceEventMatcher<?>, Object> results = new HashMap<>();
    try (InputStream input = projectFilesystem.newFileInputStream(pathToTrace);
        MappingIterator<ImmutableMap<String, Object>> it =
            ObjectMappers.READER
                .forType(new TypeReference<ImmutableMap<String, Object>>() {})
                .readValues(input)) {
      featureSearch:
      while (it.hasNext()) {
        // Verify and extract the name property before invoking any of the matchers.
        ImmutableMap<String, Object> event = it.next();
        Object nameEl = event.get(""name"");
        if (nameEl == null || !(nameEl instanceof String)) {
          continue;
        }
        String name = (String) nameEl;
        // Prefer Iterator to Iterable+foreach so we can use remove().
        for (Iterator<ChromeTraceEventMatcher<?>> iter = unmatchedMatchers.iterator();
            iter.hasNext();
            ) {
          ChromeTraceEventMatcher<?> chromeTraceEventMatcher = iter.next();
          Optional<?> result = chromeTraceEventMatcher.test(event, name);
          if (result.isPresent()) {
            iter.remove();
            results.put(chromeTraceEventMatcher, result.get());
            if (unmatchedMatchers.isEmpty()) {
              break featureSearch;
            }
          }
        }
      }
    }
    // We could throw if !unmatchedMatchers.isEmpty(), but that might be overbearing.
    return results;
  }
  @SuppressWarnings(""unchecked"")
  public static <T> Optional<T> getResultForMatcher(
      ChromeTraceEventMatcher<T> matcher, Map<ChromeTraceEventMatcher<?>, Object> results) {
    T result = (T) results.get(matcher);
    return Optional.ofNullable(result);
  }
}",class,
"  public ChromeTraceParser(ProjectFilesystem projectFilesystem) {
    this.projectFilesystem = projectFilesystem;
  }",method,
"  public Map<ChromeTraceEventMatcher<?>, Object> parse(
      Path pathToTrace, Set<ChromeTraceEventMatcher<?>> chromeTraceEventMatchers)
      throws IOException {
    Set<ChromeTraceEventMatcher<?>> unmatchedMatchers = new HashSet<>(chromeTraceEventMatchers);
    Preconditions.checkArgument(!unmatchedMatchers.isEmpty(), ""Must specify at least one matcher"");
    Map<ChromeTraceEventMatcher<?>, Object> results = new HashMap<>();
    try (InputStream input = projectFilesystem.newFileInputStream(pathToTrace);
        MappingIterator<ImmutableMap<String, Object>> it =
            ObjectMappers.READER
                .forType(new TypeReference<ImmutableMap<String, Object>>() {})
                .readValues(input)) {
      featureSearch:
      while (it.hasNext()) {
        // Verify and extract the name property before invoking any of the matchers.
        ImmutableMap<String, Object> event = it.next();
        Object nameEl = event.get(""name"");
        if (nameEl == null || !(nameEl instanceof String)) {
          continue;
        }
        String name = (String) nameEl;
        // Prefer Iterator to Iterable+foreach so we can use remove().
        for (Iterator<ChromeTraceEventMatcher<?>> iter = unmatchedMatchers.iterator();
            iter.hasNext();
            ) {
          ChromeTraceEventMatcher<?> chromeTraceEventMatcher = iter.next();
          Optional<?> result = chromeTraceEventMatcher.test(event, name);
          if (result.isPresent()) {
            iter.remove();
            results.put(chromeTraceEventMatcher, result.get());
            if (unmatchedMatchers.isEmpty()) {
              break featureSearch;
            }
          }
        }
      }
    }
    // We could throw if !unmatchedMatchers.isEmpty(), but that might be overbearing.
    return results;
  }",method,
"            ObjectMappers.READER
                .forType(new TypeReference<ImmutableMap<String, Object>>() {}",method,
"  @SuppressWarnings(""unchecked"")
  public static <T> Optional<T> getResultForMatcher(
      ChromeTraceEventMatcher<T> matcher, Map<ChromeTraceEventMatcher<?>, Object> results) {
    T result = (T) results.get(matcher);
    return Optional.ofNullable(result);
  }",method,
"  @Test
  public void testCompilationActionsWithIQuotesInCopts() throws Exception {
    useConfiguration(
        ""--cpu=ios_i386"",
        ""--ios_cpu=i386"");
    createLibraryTargetWriter(""//objc:lib"")
        .setAndCreateFiles(""srcs"", ""a.m"", ""b.m"", ""private.h"")
        .setAndCreateFiles(""hdrs"", ""c.h"")
        .setList(""copts"", ""-iquote foo/bar"", ""-iquote bam/baz"")
        .write();
    CommandAction compileActionA = compileAction(""//objc:lib"", ""a.o"");
    String action = String.join("" "", compileActionA.getArguments());
    assertThat(action).contains(""-iquote foo/bar"");
    assertThat(action).contains(""-iquote bam/baz"");
  }",method,
"  @Test
  public void testCollectCodeCoverageWithGCOVFlags() throws Exception {
    useConfiguration(
        ""--crosstool_top="" + MockObjcSupport.DEFAULT_OSX_CROSSTOOL, ""--collect_code_coverage"");
    createLibraryTargetWriter(""//objc:x"")
        .setAndCreateFiles(""srcs"", ""a.mm"", ""b.cc"", ""c.mm"", ""d.cxx"", ""e.c"", ""f.m"", ""g.C"")
        .write();
    List<String> copts = ImmutableList.of(""-fprofile-arcs"", ""-ftest-coverage"");
    assertThat(compileAction(""//objc:x"", ""a.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""b.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""c.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""d.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""e.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""f.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""g.o"").getArguments()).containsAllIn(copts);
  }",method,
"  @Test
  public void testCollectCodeCoverageWithLLVMCOVFlags() throws Exception {
    useConfiguration(
        ""--crosstool_top="" + MockObjcSupport.DEFAULT_OSX_CROSSTOOL,
        ""--collect_code_coverage"",
        ""--experimental_use_llvm_covmap"");
    createLibraryTargetWriter(""//objc:x"")
        .setAndCreateFiles(""srcs"", ""a.mm"", ""b.cc"", ""c.mm"", ""d.cxx"", ""e.c"", ""f.m"", ""g.C"")
        .write();
    List<String> copts = ImmutableList.of(""-fprofile-instr-generate"", ""-fcoverage-mapping"");
    assertThat(compileAction(""//objc:x"", ""a.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""b.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""c.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""d.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""e.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""f.o"").getArguments()).containsAllIn(copts);
    assertThat(compileAction(""//objc:x"", ""g.o"").getArguments()).containsAllIn(copts);
   }",method,
"  @Test
  public void testNoG0IfGeneratesDsym() throws Exception {
    useConfiguration(""--apple_generate_dsym"", ""-c"", ""opt"");
    createLibraryTargetWriter(""//x:x"").setList(""srcs"", ""a.m"").write();
    CommandAction compileAction = compileAction(""//x:x"", ""a.o"");
    assertThat(compileAction.getArguments()).doesNotContain(""-g0"");
  }",method,

code_snippet,type,score
"    public Base(int iX, int iY, int iAncho, int iAlto, Image imaImagen) {
        this.iX = iX;
        this.iY = iY;
        this.iAncho = iAncho;
        this.iAlto = iAlto;
        this.imaImagen = imaImagen;
    }",method,
"    public void setX(int iX) {
        this.iX = iX;
    }",method,
"    public int getX() {
        return iX;
    }",method,
"    public void setY(int iY) {
        this.iY = iY;
    }",method,
"    public int getY() {
        return iY;
    }",method,
"    public void setImagen(Image imaImagen) {
        this.imaImagen = imaImagen;
    }",method,
"    public Image getImagen() {
        return imaImagen;
    }",method,
"    public int getAncho() {
        return iAncho;
    }",method,
"    public int getAlto() {
        return iAlto;
    }",method,
"    public void paint(Graphics graGrafico, ImageObserver imoObserver) {
        graGrafico.drawImage(getImagen(), getX(), getY(), getAncho(), getAlto(), imoObserver);
    }",method,
"    public boolean equals(Object objObjeto) {
        // si el objeto parametro es una instancia de la clase Base
        if (objObjeto instanceof Base) {
            // se regresa la comparación entre este objeto que invoca y el
            // objeto recibido como parametro
            Base basParam = (Base) objObjeto;
            return this.getX() == basParam.getX()
                    && this.getY() == basParam.getY()
                    && this.getAncho() == basParam.getAncho()
                    && this.getAlto() == basParam.getAlto()
                    && this.getImagen() == basParam.getImagen();
        } else {
            // se regresa un falso porque el objeto recibido no es tipo Base
            return false;
        }
    }",method,
"        if (objObjeto instanceof Base) {
            // se regresa la comparación entre este objeto que invoca y el
            // objeto recibido como parametro
            Base basParam = (Base) objObjeto;
            return this.getX() == basParam.getX()
                    && this.getY() == basParam.getY()
                    && this.getAncho() == basParam.getAncho()
                    && this.getAlto() == basParam.getAlto()
                    && this.getImagen() == basParam.getImagen();
        }",method,
"    public boolean intersecta(Object objObjeto) {
        if (objObjeto instanceof Base) {
            Rectangle rctObjetoActual = new Rectangle(this.getX(), this.getY(), this.getAncho(), this.getAlto());
            Base basObjeto = (Base) objObjeto;
            Rectangle rctObjetoParametro = new Rectangle(basObjeto.getX(), basObjeto.getY(), basObjeto.getAncho(), basObjeto.getAlto());
            return rctObjetoActual.intersects(rctObjetoParametro);
        } else {
            return false;
        }
    }",method,
"        if (objObjeto instanceof Base) {
            Rectangle rctObjetoActual = new Rectangle(this.getX(), this.getY(), this.getAncho(), this.getAlto());
            Base basObjeto = (Base) objObjeto;
            Rectangle rctObjetoParametro = new Rectangle(basObjeto.getX(), basObjeto.getY(), basObjeto.getAncho(), basObjeto.getAlto());
            return rctObjetoActual.intersects(rctObjetoParametro);
        }",method,
"    public String toString() {
        return "" x: "" + this.getX() + "" y: "" + this.getY()
                + "" ancho: "" + this.getAncho() + "" alto: "" + this.getAlto();
    }",method,
"    void actualiza(long tiempoTranscurrido) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }",method,
"    @Override
    public void addHeader(Headers header, String value) {
      throw poison();
    }",method,
"    @Override
    public String getHeader(Headers header) {
      throw poison();
    }",method,
"    @Override
    public Map<Headers, String> getHeaders() {
      throw poison();
    }",method,
"    @Override
    public void setBody(String body) {
      throw poison();
    }",method,
"    @Override
    public String getBody() {
      throw poison();
    }",method,
"    private RuntimeException poison() {
      return new UnsupportedOperationException(""Poison"");
    }",method,
"public class MagnificationSpec implements Parcelable {
    private static final int MAX_POOL_SIZE = 20;
    private static final SynchronizedPool<MagnificationSpec> sPool =
            new SynchronizedPool<>(MAX_POOL_SIZE);
    public float scale = 1.0f;
    public float offsetX;
    public float offsetY;
    private MagnificationSpec() {
    }
    public void initialize(float scale, float offsetX, float offsetY) {
        if (scale < 1) {
            throw new IllegalArgumentException(""Scale must be greater than or equal to one!"");
        }
        this.scale = scale;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
    }
    public boolean isNop() {
        return scale == 1.0f && offsetX == 0 && offsetY == 0;
    }
    public static MagnificationSpec obtain(MagnificationSpec other) {
        MagnificationSpec info = obtain();
        info.scale = other.scale;
        info.offsetX = other.offsetX;
        info.offsetY = other.offsetY;
        return info;
    }
    public static MagnificationSpec obtain() {
        MagnificationSpec spec = sPool.acquire();
        return (spec != null) ? spec : new MagnificationSpec();
    }
    public void recycle() {
        clear();
        sPool.release(this);
    }
    public void clear() {
       scale = 1.0f;
       offsetX = 0.0f;
       offsetY = 0.0f;
    }
    public void setTo(MagnificationSpec other) {
        scale = other.scale;
        offsetX = other.offsetX;
        offsetY = other.offsetY;
    }
    @Override
    public int describeContents() {
        return 0;
    }
    @Override
    public void writeToParcel(Parcel parcel, int flags) {
        parcel.writeFloat(scale);
        parcel.writeFloat(offsetX);
        parcel.writeFloat(offsetY);
        recycle();
    }
    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || getClass() != other.getClass()) {
            return false;
        }
        final MagnificationSpec s = (MagnificationSpec) other;
        return scale == s.scale && offsetX == s.offsetX && offsetY == s.offsetY;
    }
    @Override
    public int hashCode() {
        int result = (scale != +0.0f ? Float.floatToIntBits(scale) : 0);
        result = 31 * result + (offsetX != +0.0f ? Float.floatToIntBits(offsetX) : 0);
        result = 31 * result + (offsetY != +0.0f ? Float.floatToIntBits(offsetY) : 0);
        return result;
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(""<scale:"");
        builder.append(Float.toString(scale));
        builder.append("",offsetX:"");
        builder.append(Float.toString(offsetX));
        builder.append("",offsetY:"");
        builder.append(Float.toString(offsetY));
        builder.append("">"");
        return builder.toString();
    }
    private void initFromParcel(Parcel parcel) {
        scale = parcel.readFloat();
        offsetX = parcel.readFloat();
        offsetY = parcel.readFloat();
    }
    public static final Creator<MagnificationSpec> CREATOR = new Creator<MagnificationSpec>() {
        @Override
        public MagnificationSpec[] newArray(int size) {
            return new MagnificationSpec[size];
        }
        @Override
        public MagnificationSpec createFromParcel(Parcel parcel) {
            MagnificationSpec spec = MagnificationSpec.obtain();
            spec.initFromParcel(parcel);
            return spec;
        }
    };
}",class,
"    private MagnificationSpec() {
    }",method,
"    public void initialize(float scale, float offsetX, float offsetY) {
        if (scale < 1) {
            throw new IllegalArgumentException(""Scale must be greater than or equal to one!"");
        }
        this.scale = scale;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
    }",method,
"        if (scale < 1) {
            throw new IllegalArgumentException(""Scale must be greater than or equal to one!"");
        }",method,
"    public boolean isNop() {
        return scale == 1.0f && offsetX == 0 && offsetY == 0;
    }",method,
"    public static MagnificationSpec obtain(MagnificationSpec other) {
        MagnificationSpec info = obtain();
        info.scale = other.scale;
        info.offsetX = other.offsetX;
        info.offsetY = other.offsetY;
        return info;
    }",method,
"    public static MagnificationSpec obtain() {
        MagnificationSpec spec = sPool.acquire();
        return (spec != null) ? spec : new MagnificationSpec();
    }",method,
"    public void recycle() {
        clear();
        sPool.release(this);
    }",method,
"    public void clear() {
       scale = 1.0f;
       offsetX = 0.0f;
       offsetY = 0.0f;
    }",method,
"    public void setTo(MagnificationSpec other) {
        scale = other.scale;
        offsetX = other.offsetX;
        offsetY = other.offsetY;
    }",method,
"    @Override
    public int describeContents() {
        return 0;
    }",method,
"    @Override
    public void writeToParcel(Parcel parcel, int flags) {
        parcel.writeFloat(scale);
        parcel.writeFloat(offsetX);
        parcel.writeFloat(offsetY);
        recycle();
    }",method,
"    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || getClass() != other.getClass()) {
            return false;
        }
        final MagnificationSpec s = (MagnificationSpec) other;
        return scale == s.scale && offsetX == s.offsetX && offsetY == s.offsetY;
    }",method,
"        if (this == other) {
            return true;
        }",method,
"    @Override
    public int hashCode() {
        int result = (scale != +0.0f ? Float.floatToIntBits(scale) : 0);
        result = 31 * result + (offsetX != +0.0f ? Float.floatToIntBits(offsetX) : 0);
        result = 31 * result + (offsetY != +0.0f ? Float.floatToIntBits(offsetY) : 0);
        return result;
    }",method,
"    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(""<scale:"");
        builder.append(Float.toString(scale));
        builder.append("",offsetX:"");
        builder.append(Float.toString(offsetX));
        builder.append("",offsetY:"");
        builder.append(Float.toString(offsetY));
        builder.append("">"");
        return builder.toString();
    }",method,
"    private void initFromParcel(Parcel parcel) {
        scale = parcel.readFloat();
        offsetX = parcel.readFloat();
        offsetY = parcel.readFloat();
    }",method,
"        @Override
        public MagnificationSpec[] newArray(int size) {
            return new MagnificationSpec[size];
        }",method,
"        @Override
        public MagnificationSpec createFromParcel(Parcel parcel) {
            MagnificationSpec spec = MagnificationSpec.obtain();
            spec.initFromParcel(parcel);
            return spec;
        }",method,
"public class TerminalSessionEditor extends UserDataHolderBase implements FileEditor {
  private Project myProject;
  private final TerminalSessionVirtualFileImpl myFile;
  private final TtyConnectorWaitFor myWaitFor;
  public TerminalSessionEditor(Project project, @NotNull TerminalSessionVirtualFileImpl terminalFile) {
    myProject = project;
    myFile = terminalFile;
    final TabbedSettingsProvider settings = myFile.getSettingsProvider();
    myFile.getTerminal().setNextProvider(new TerminalActionProviderBase() {
      @Override
      public List<TerminalAction> getActions() {
        return Lists.newArrayList(
          new TerminalAction(""Close Session"", settings.getCloseSessionKeyStrokes(), input -> {
            handleCloseSession();
            return true;
          }).withMnemonicKey(KeyEvent.VK_S)
        );
      }
    });
    myWaitFor = new TtyConnectorWaitFor(myFile.getTerminal().getTtyConnector(), ConcurrencyUtil.newSingleThreadExecutor(""Terminal session""));
    myWaitFor
      .setTerminationCallback(integer -> {
        ApplicationManager.getApplication().invokeLater(() -> FileEditorManagerEx.getInstanceEx(myProject).closeFile(myFile));
        return true;
      });
  }
  private void handleCloseSession() {
    myFile.getTerminal().close();
  }
  @NotNull
  @Override
  public JComponent getComponent() {
    return myFile.getTerminal();
  }
  @Nullable
  @Override
  public JComponent getPreferredFocusedComponent() {
    return myFile.getTerminal();
  }
  @NotNull
  @Override
  public String getName() {
    return myFile.getName();
  }
  @Override
  public void setState(@NotNull FileEditorState state) {
  }
  @Override
  public boolean isModified() {
    return false;
  }
  @Override
  public boolean isValid() {
    return true;
  }
  @Override
  public void selectNotify() {
  }
  @Override
  public void deselectNotify() {
  }
  @Override
  public void addPropertyChangeListener(@NotNull PropertyChangeListener listener) {
  }
  @Override
  public void removePropertyChangeListener(@NotNull PropertyChangeListener listener) {
  }
  @Nullable
  @Override
  public BackgroundEditorHighlighter getBackgroundHighlighter() {
    return null;
  }
  @Nullable
  @Override
  public FileEditorLocation getCurrentLocation() {
    return null;
  }
  @Nullable
  @Override
  public StructureViewBuilder getStructureViewBuilder() {
    return null;
  }
  @Override
  public void dispose() {
    Boolean closingToReopen = myFile.getUserData(FileEditorManagerImpl.CLOSING_TO_REOPEN);
    myWaitFor.detach();
    if (closingToReopen == null || !closingToReopen) {
      myFile.getTerminal().close();
    }
  }
}",class,
"  public TerminalSessionEditor(Project project, @NotNull TerminalSessionVirtualFileImpl terminalFile) {
    myProject = project;
    myFile = terminalFile;
    final TabbedSettingsProvider settings = myFile.getSettingsProvider();
    myFile.getTerminal().setNextProvider(new TerminalActionProviderBase() {
      @Override
      public List<TerminalAction> getActions() {
        return Lists.newArrayList(
          new TerminalAction(""Close Session"", settings.getCloseSessionKeyStrokes(), input -> {
            handleCloseSession();
            return true;
          }).withMnemonicKey(KeyEvent.VK_S)
        );
      }
    });
    myWaitFor = new TtyConnectorWaitFor(myFile.getTerminal().getTtyConnector(), ConcurrencyUtil.newSingleThreadExecutor(""Terminal session""));
    myWaitFor
      .setTerminationCallback(integer -> {
        ApplicationManager.getApplication().invokeLater(() -> FileEditorManagerEx.getInstanceEx(myProject).closeFile(myFile));
        return true;
      });
  }",method,
"      @Override
      public List<TerminalAction> getActions() {
        return Lists.newArrayList(
          new TerminalAction(""Close Session"", settings.getCloseSessionKeyStrokes(), input -> {
            handleCloseSession();
            return true;
          }).withMnemonicKey(KeyEvent.VK_S)
        );
      }",method,
"  private void handleCloseSession() {
    myFile.getTerminal().close();
  }",method,
"  @NotNull
  @Override
  public JComponent getComponent() {
    return myFile.getTerminal();
  }",method,
"  @Nullable
  @Override
  public JComponent getPreferredFocusedComponent() {
    return myFile.getTerminal();
  }",method,
"  @NotNull
  @Override
  public String getName() {
    return myFile.getName();
  }",method,
"  @Override
  public void setState(@NotNull FileEditorState state) {
  }",method,
"  @Override
  public boolean isModified() {
    return false;
  }",method,
"  @Override
  public boolean isValid() {
    return true;
  }",method,
"  @Override
  public void selectNotify() {
  }",method,
"  @Override
  public void deselectNotify() {
  }",method,
"  @Override
  public void addPropertyChangeListener(@NotNull PropertyChangeListener listener) {
  }",method,
"  @Override
  public void removePropertyChangeListener(@NotNull PropertyChangeListener listener) {
  }",method,
"  @Nullable
  @Override
  public BackgroundEditorHighlighter getBackgroundHighlighter() {
    return null;
  }",method,
"  @Nullable
  @Override
  public FileEditorLocation getCurrentLocation() {
    return null;
  }",method,
"  @Nullable
  @Override
  public StructureViewBuilder getStructureViewBuilder() {
    return null;
  }",method,
"  @Override
  public void dispose() {
    Boolean closingToReopen = myFile.getUserData(FileEditorManagerImpl.CLOSING_TO_REOPEN);
    myWaitFor.detach();
    if (closingToReopen == null || !closingToReopen) {
      myFile.getTerminal().close();
    }
  }",method,
"    if (closingToReopen == null || !closingToReopen) {
      myFile.getTerminal().close();
    }",method,
"public class Pager
        extends FilterOutputStream
{
    public static final String ENV_PAGER = ""PRESTO_PAGER"";
    public static final List<String> LESS = ImmutableList.of(""less"", ""-FXRSn"");
    private final Process process;
    private Pager(OutputStream out, @Nullable Process process)
    {
        super(out);
        this.process = process;
    }
    @Override
    public void close()
            throws IOException
    {
        try {
            super.close();
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
        finally {
            if (process != null) {
                try {
                    process.waitFor();
                }
                catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    process.destroy();
                }
            }
        }
    }
    public boolean isNullPager()
    {
        return process == null;
    }
    @Override
    public void write(int b)
            throws IOException
    {
        try {
            super.write(b);
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
    }
    @Override
    public void write(byte[] b, int off, int len)
            throws IOException
    {
        try {
            super.write(b, off, len);
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
    }
    @Override
    public void flush()
            throws IOException
    {
        try {
            super.flush();
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
    }
    public CompletableFuture<?> getFinishFuture()
    {
        checkState(process != null, ""getFinishFuture called on null pager"");
        CompletableFuture<?> result = new CompletableFuture<>();
        new Thread(() -> {
            try {
                process.waitFor();
            }
            catch (InterruptedException e) {
                // ignore exception because thread is exiting
            }
            finally {
                result.complete(null);
            }
        }).start();
        return unmodifiableFuture(result);
    }
    private static IOException propagateIOException(IOException e)
            throws IOException
    {
        // TODO: check if the pager exited and verify the exit status?
        if (""Broken pipe"".equals(e.getMessage()) || ""Stream closed"".equals(e.getMessage())) {
            throw new QueryAbortedException(e);
        }
        throw e;
    }
    public static Pager create()
    {
        String pager = System.getenv(ENV_PAGER);
        if (pager == null) {
            return create(LESS);
        }
        pager = pager.trim();
        if (pager.isEmpty()) {
            return createNullPager();
        }
        return create(ImmutableList.of(""/bin/sh"", ""-c"", pager));
    }
    public static Pager create(List<String> command)
    {
        try {
            Process process = new ProcessBuilder()
                    .command(command)
                    .redirectOutput(ProcessBuilder.Redirect.INHERIT)
                    .redirectError(ProcessBuilder.Redirect.INHERIT)
                    .start();
            return new Pager(process.getOutputStream(), process);
        }
        catch (IOException e) {
            System.err.println(""ERROR: failed to open pager: "" + e.getMessage());
            return createNullPager();
        }
    }
    private static Pager createNullPager()
    {
        return new Pager(uncloseableOutputStream(System.out), null);
    }
    private static OutputStream uncloseableOutputStream(OutputStream out)
    {
        return new FilterOutputStream(out)
        {
            @Override
            public void close()
                    throws IOException
            {
                flush();
            }
        };
    }
}",class,
"    private Pager(OutputStream out, @Nullable Process process)
    {
        super(out);
        this.process = process;
    }",method,
"    @Override
    public void close()
            throws IOException
    {
        try {
            super.close();
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
        finally {
            if (process != null) {
                try {
                    process.waitFor();
                }
                catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    process.destroy();
                }
            }
        }
    }",method,
"        catch (IOException e) {
            throw propagateIOException(e);
        }",method,
"            if (process != null) {
                try {
                    process.waitFor();
                }
                catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    process.destroy();
                }
            }",method,
"                catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    process.destroy();
                }",method,
"    public boolean isNullPager()
    {
        return process == null;
    }",method,
"    @Override
    public void write(int b)
            throws IOException
    {
        try {
            super.write(b);
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
    }",method,
"        catch (IOException e) {
            throw propagateIOException(e);
        }",method,
"    @Override
    public void write(byte[] b, int off, int len)
            throws IOException
    {
        try {
            super.write(b, off, len);
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
    }",method,
"        catch (IOException e) {
            throw propagateIOException(e);
        }",method,
"    @Override
    public void flush()
            throws IOException
    {
        try {
            super.flush();
        }
        catch (IOException e) {
            throw propagateIOException(e);
        }
    }",method,
"        catch (IOException e) {
            throw propagateIOException(e);
        }",method,
"    public CompletableFuture<?> getFinishFuture()
    {
        checkState(process != null, ""getFinishFuture called on null pager"");
        CompletableFuture<?> result = new CompletableFuture<>();
        new Thread(() -> {
            try {
                process.waitFor();
            }
            catch (InterruptedException e) {
                // ignore exception because thread is exiting
            }
            finally {
                result.complete(null);
            }
        }).start();
        return unmodifiableFuture(result);
    }",method,
"            catch (InterruptedException e) {
                // ignore exception because thread is exiting
            }",method,
"    private static IOException propagateIOException(IOException e)
            throws IOException
    {
        // TODO: check if the pager exited and verify the exit status?
        if (""Broken pipe"".equals(e.getMessage()) || ""Stream closed"".equals(e.getMessage())) {
            throw new QueryAbortedException(e);
        }
        throw e;
    }",method,
"    public static Pager create()
    {
        String pager = System.getenv(ENV_PAGER);
        if (pager == null) {
            return create(LESS);
        }
        pager = pager.trim();
        if (pager.isEmpty()) {
            return createNullPager();
        }
        return create(ImmutableList.of(""/bin/sh"", ""-c"", pager));
    }",method,
"        if (pager == null) {
            return create(LESS);
        }",method,
"    public static Pager create(List<String> command)
    {
        try {
            Process process = new ProcessBuilder()
                    .command(command)
                    .redirectOutput(ProcessBuilder.Redirect.INHERIT)
                    .redirectError(ProcessBuilder.Redirect.INHERIT)
                    .start();
            return new Pager(process.getOutputStream(), process);
        }
        catch (IOException e) {
            System.err.println(""ERROR: failed to open pager: "" + e.getMessage());
            return createNullPager();
        }
    }",method,
"        catch (IOException e) {
            System.err.println(""ERROR: failed to open pager: "" + e.getMessage());
            return createNullPager();
        }",method,
"    private static Pager createNullPager()
    {
        return new Pager(uncloseableOutputStream(System.out), null);
    }",method,
"    private static OutputStream uncloseableOutputStream(OutputStream out)
    {
        return new FilterOutputStream(out)
        {
            @Override
            public void close()
                    throws IOException
            {
                flush();
            }
        };
    }",method,
"        return new FilterOutputStream(out)
        {
            @Override
            public void close()
                    throws IOException
            {
                flush();
            }
        }",method,
"            @Override
            public void close()
                    throws IOException
            {
                flush();
            }",method,
"public class SystemProperties {
    private static final Set<String> STANDARD_PROPERTIES;
    static {
        Set<String> standardProperties = new HashSet<String>();
        standardProperties.add(""java.version"");
        standardProperties.add(""java.vendor"");
        standardProperties.add(""java.vendor.url"");
        standardProperties.add(""java.home"");
        standardProperties.add(""java.vm.specification.version"");
        standardProperties.add(""java.vm.specification.vendor"");
        standardProperties.add(""java.vm.specification.name"");
        standardProperties.add(""java.vm.version"");
        standardProperties.add(""java.vm.vendor"");
        standardProperties.add(""java.vm.name"");
        standardProperties.add(""java.specification.version"");
        standardProperties.add(""java.specification.vendor"");
        standardProperties.add(""java.specification.name"");
        standardProperties.add(""java.class.version"");
        standardProperties.add(""java.class.path"");
        standardProperties.add(""java.library.path"");
        standardProperties.add(""java.io.tmpdir"");
        standardProperties.add(""java.compiler"");
        standardProperties.add(""java.ext.dirs"");
        standardProperties.add(""os.name"");
        standardProperties.add(""os.arch"");
        standardProperties.add(""os.version"");
        standardProperties.add(""file.separator"");
        standardProperties.add(""path.separator"");
        standardProperties.add(""line.separator"");
        standardProperties.add(""user.name"");
        standardProperties.add(""user.home"");
        standardProperties.add(""user.dir"");
        STANDARD_PROPERTIES = Collections.unmodifiableSet(standardProperties);
    }
    private static final Set<String> IMPORTANT_NON_STANDARD_PROPERTIES = Collections.singleton(""java.runtime.version"");
    private static final SystemProperties INSTANCE = new SystemProperties();
    private final Lock lock = new ReentrantLock();
    public static SystemProperties getInstance() {
        return INSTANCE;
    }
    @SuppressWarnings(""unchecked"")
    public Map<String, String> asMap() {
        return (Map) System.getProperties();
    }
    public String getLineSeparator() {
        return System.getProperty(""line.separator"");
    }
    public String getJavaIoTmpDir() {
        return System.getProperty(""java.io.tmpdir"");
    }
    public String getUserHome() {
        return System.getProperty(""user.home"");
    }
    public String getUserName() {
        return System.getProperty(""user.name"");
    }
    public String getJavaVersion() {
        return System.getProperty(""java.version"");
    }
    public File getCurrentDir() {
        return new File(System.getProperty(""user.dir""));
    }
    public File getJavaHomeDir() {
        lock.lock();
        File javaHomeDir;
        try {
            javaHomeDir = new File(System.getProperty(""java.home""));
        } finally {
            lock.unlock();
        }
        return javaHomeDir;
    }
    public <T> T withJavaHome(File javaHomeDir, Factory<T> factory) {
        return withSystemProperty(""java.home"", javaHomeDir.getAbsolutePath(), factory);
    }
    public <T> T withSystemProperty(String propertyName, String value, Factory<T> factory) {
        lock.lock();
        String originalValue = System.getProperty(propertyName);
        System.setProperty(propertyName, value);
        try {
            return factory.create();
        } finally {
            if (originalValue != null) {
                System.setProperty(propertyName, originalValue);
            } else {
                System.clearProperty(propertyName);
            }
            lock.unlock();
        }
    }
    public Set<String> getStandardProperties() {
        return STANDARD_PROPERTIES;
    }
    public Set<String> getNonStandardImportantProperties() {
        return IMPORTANT_NON_STANDARD_PROPERTIES;
    }
}",class,
"    public static SystemProperties getInstance() {
        return INSTANCE;
    }",method,
"    @SuppressWarnings(""unchecked"")
    public Map<String, String> asMap() {
        return (Map) System.getProperties();
    }",method,
"    public String getLineSeparator() {
        return System.getProperty(""line.separator"");
    }",method,
"    public String getJavaIoTmpDir() {
        return System.getProperty(""java.io.tmpdir"");
    }",method,
"    public String getUserHome() {
        return System.getProperty(""user.home"");
    }",method,
"    public String getUserName() {
        return System.getProperty(""user.name"");
    }",method,
"    public String getJavaVersion() {
        return System.getProperty(""java.version"");
    }",method,
"    public File getCurrentDir() {
        return new File(System.getProperty(""user.dir""));
    }",method,
"    public File getJavaHomeDir() {
        lock.lock();
        File javaHomeDir;
        try {
            javaHomeDir = new File(System.getProperty(""java.home""));
        } finally {
            lock.unlock();
        }
        return javaHomeDir;
    }",method,
"    public <T> T withJavaHome(File javaHomeDir, Factory<T> factory) {
        return withSystemProperty(""java.home"", javaHomeDir.getAbsolutePath(), factory);
    }",method,
"    public <T> T withSystemProperty(String propertyName, String value, Factory<T> factory) {
        lock.lock();
        String originalValue = System.getProperty(propertyName);
        System.setProperty(propertyName, value);
        try {
            return factory.create();
        } finally {
            if (originalValue != null) {
                System.setProperty(propertyName, originalValue);
            } else {
                System.clearProperty(propertyName);
            }
            lock.unlock();
        }
    }",method,
"            if (originalValue != null) {
                System.setProperty(propertyName, originalValue);
            }",method,
"    public Set<String> getStandardProperties() {
        return STANDARD_PROPERTIES;
    }",method,
"    public Set<String> getNonStandardImportantProperties() {
        return IMPORTANT_NON_STANDARD_PROPERTIES;
    }",method,
"public class TypeHierarchyItem {
  public static final TypeHierarchyItem[] EMPTY_ARRAY = new TypeHierarchyItem[0];
  public static final List<TypeHierarchyItem> EMPTY_LIST = Lists.newArrayList();
  private final Element classElement;
  private final String displayName;
  private final Element memberElement;
  private final Integer superclass;
  private final int[] interfaces;
  private final int[] mixins;
  private final int[] subclasses;
  public TypeHierarchyItem(Element classElement, String displayName, Element memberElement, Integer superclass, int[] interfaces, int[] mixins, int[] subclasses) {
    this.classElement = classElement;
    this.displayName = displayName;
    this.memberElement = memberElement;
    this.superclass = superclass;
    this.interfaces = interfaces;
    this.mixins = mixins;
    this.subclasses = subclasses;
  }
  @Override
  public boolean equals(Object obj) {
    if (obj instanceof TypeHierarchyItem) {
      TypeHierarchyItem other = (TypeHierarchyItem) obj;
      return
        ObjectUtilities.equals(other.classElement, classElement) &&
        ObjectUtilities.equals(other.displayName, displayName) &&
        ObjectUtilities.equals(other.memberElement, memberElement) &&
        ObjectUtilities.equals(other.superclass, superclass) &&
        Arrays.equals(other.interfaces, interfaces) &&
        Arrays.equals(other.mixins, mixins) &&
        Arrays.equals(other.subclasses, subclasses);
    }
    return false;
  }
  public static TypeHierarchyItem fromJson(JsonObject jsonObject) {
    Element classElement = Element.fromJson(jsonObject.get(""classElement"").getAsJsonObject());
    String displayName = jsonObject.get(""displayName"") == null ? null : jsonObject.get(""displayName"").getAsString();
    Element memberElement = jsonObject.get(""memberElement"") == null ? null : Element.fromJson(jsonObject.get(""memberElement"").getAsJsonObject());
    Integer superclass = jsonObject.get(""superclass"") == null ? null : jsonObject.get(""superclass"").getAsInt();
    int[] interfaces = JsonUtilities.decodeIntArray(jsonObject.get(""interfaces"").getAsJsonArray());
    int[] mixins = JsonUtilities.decodeIntArray(jsonObject.get(""mixins"").getAsJsonArray());
    int[] subclasses = JsonUtilities.decodeIntArray(jsonObject.get(""subclasses"").getAsJsonArray());
    return new TypeHierarchyItem(classElement, displayName, memberElement, superclass, interfaces, mixins, subclasses);
  }
  public static List<TypeHierarchyItem> fromJsonArray(JsonArray jsonArray) {
    if (jsonArray == null) {
      return EMPTY_LIST;
    }
    ArrayList<TypeHierarchyItem> list = new ArrayList<TypeHierarchyItem>(jsonArray.size());
    Iterator<JsonElement> iterator = jsonArray.iterator();
    while (iterator.hasNext()) {
      list.add(fromJson(iterator.next().getAsJsonObject()));
    }
    return list;
  }
  public String getBestName() {
    if (displayName == null) {
      return classElement.getName();
    } else {
      return displayName;
    }
  }
  public Element getClassElement() {
    return classElement;
  }
  public String getDisplayName() {
    return displayName;
  }
  public int[] getInterfaces() {
    return interfaces;
  }
  public Element getMemberElement() {
    return memberElement;
  }
  public int[] getMixins() {
    return mixins;
  }
  public int[] getSubclasses() {
    return subclasses;
  }
  public Integer getSuperclass() {
    return superclass;
  }
  @Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    builder.append(classElement);
    builder.append(displayName);
    builder.append(memberElement);
    builder.append(superclass);
    builder.append(interfaces);
    builder.append(mixins);
    builder.append(subclasses);
    return builder.toHashCode();
  }
  public JsonObject toJson() {
    JsonObject jsonObject = new JsonObject();
    jsonObject.add(""classElement"", classElement.toJson());
    if (displayName != null) {
      jsonObject.addProperty(""displayName"", displayName);
    }
    if (memberElement != null) {
      jsonObject.add(""memberElement"", memberElement.toJson());
    }
    if (superclass != null) {
      jsonObject.addProperty(""superclass"", superclass);
    }
    JsonArray jsonArrayInterfaces = new JsonArray();
    for (int elt : interfaces) {
      jsonArrayInterfaces.add(new JsonPrimitive(elt));
    }
    jsonObject.add(""interfaces"", jsonArrayInterfaces);
    JsonArray jsonArrayMixins = new JsonArray();
    for (int elt : mixins) {
      jsonArrayMixins.add(new JsonPrimitive(elt));
    }
    jsonObject.add(""mixins"", jsonArrayMixins);
    JsonArray jsonArraySubclasses = new JsonArray();
    for (int elt : subclasses) {
      jsonArraySubclasses.add(new JsonPrimitive(elt));
    }
    jsonObject.add(""subclasses"", jsonArraySubclasses);
    return jsonObject;
  }
  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(""["");
    builder.append(""classElement="");
    builder.append(classElement + "", "");
    builder.append(""displayName="");
    builder.append(displayName + "", "");
    builder.append(""memberElement="");
    builder.append(memberElement + "", "");
    builder.append(""superclass="");
    builder.append(superclass + "", "");
    builder.append(""interfaces="");
    builder.append(StringUtils.join(interfaces, "", "") + "", "");
    builder.append(""mixins="");
    builder.append(StringUtils.join(mixins, "", "") + "", "");
    builder.append(""subclasses="");
    builder.append(StringUtils.join(subclasses, "", ""));
    builder.append(""]"");
    return builder.toString();
  }
}",class,
"  public TypeHierarchyItem(Element classElement, String displayName, Element memberElement, Integer superclass, int[] interfaces, int[] mixins, int[] subclasses) {
    this.classElement = classElement;
    this.displayName = displayName;
    this.memberElement = memberElement;
    this.superclass = superclass;
    this.interfaces = interfaces;
    this.mixins = mixins;
    this.subclasses = subclasses;
  }",method,

code_snippet,type,score
"    public DSymbolNode(ISourcePosition position) {
        super(position);
    }",method,
"    @Override
    public NodeType getNodeType() {
        return NodeType.DSYMBOLNODE;
    }",method,
"    @Override
    public Object accept(NodeVisitor visitor) {
        return visitor.visitDSymbolNode(this);
    }",method,
"  protected static class FetchResult {
    byte[] bytes;
    String contentType;
  }",class,
"              if (references.length > 0) {
                String extension = FileUtilRt.getExtension(new File(url).getName());
                final String namespace = tag.getAttributeValue(""namespace"");
                if (namespace != null &&
                    schemaLocation.indexOf('/') == -1 &&
                    !extension.equals(FileUtilRt.getExtension(schemaLocation))) {
                  result.add(namespace.substring(0, namespace.lastIndexOf('/') + 1) + schemaLocation);
                }
                else {
                  result.add(schemaLocation);
                }
              }",method,
"              if (schemaLocation != null) {
                final StringTokenizer tokenizer = new StringTokenizer(schemaLocation);
                while (tokenizer.hasMoreTokens()) {
                  tokenizer.nextToken();
                  if (!tokenizer.hasMoreTokens()) break;
                  String location = tokenizer.nextToken();
                  result.add(location);
                }
              }",method,
"  public static Set<String> extractEmbeddedFileReferences(final VirtualFile vFile,
                                                          @Nullable final VirtualFile contextVFile,
                                                          final PsiManager psiManager,
                                                          final String url) {
    return ReadAction.compute(() -> {
      PsiFile file = psiManager.findFile(vFile);
      if (file instanceof XmlFile) {
        PsiFile contextFile = contextVFile != null ? psiManager.findFile(contextVFile) : null;
        return extractEmbeddedFileReferences((XmlFile)file, contextFile instanceof XmlFile ? (XmlFile)contextFile : null, url);
      }
      return Collections.emptySet();
    });
  }",method,
"      if (file instanceof XmlFile) {
        PsiFile contextFile = contextVFile != null ? psiManager.findFile(contextVFile) : null;
        return extractEmbeddedFileReferences((XmlFile)file, contextFile instanceof XmlFile ? (XmlFile)contextFile : null, url);
      }",method,
"public class EnumValuesInlineTestsGenerated extends AbstractEnumValuesInlineTests {
    public void testAllFilesPresentInEnum() throws Exception {
        KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File(""compiler/testData/codegen/boxInline/enum""), Pattern.compile(""^(.+)\\.kt$""), TargetBackend.JS, true);
    }
    @TestMetadata(""kt10569.kt"")
    public void testKt10569() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/kt10569.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valueOf.kt"")
    public void testValueOf() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOf.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valueOfCapturedType.kt"")
    public void testValueOfCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfCapturedType.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valueOfChain.kt"")
    public void testValueOfChain() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfChain.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valueOfChainCapturedType.kt"")
    public void testValueOfChainCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfChainCapturedType.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valueOfNonReified.kt"")
    public void testValueOfNonReified() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfNonReified.kt"");
        doTest(fileName);
    }
    @TestMetadata(""values.kt"")
    public void testValues() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/values.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valuesAsArray.kt"")
    public void testValuesAsArray() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesAsArray.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valuesCapturedType.kt"")
    public void testValuesCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesCapturedType.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valuesChain.kt"")
    public void testValuesChain() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesChain.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valuesChainCapturedType.kt"")
    public void testValuesChainCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesChainCapturedType.kt"");
        doTest(fileName);
    }
    @TestMetadata(""valuesNonReified.kt"")
    public void testValuesNonReified() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesNonReified.kt"");
        doTest(fileName);
    }
}",class,
"    public void testAllFilesPresentInEnum() throws Exception {
        KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File(""compiler/testData/codegen/boxInline/enum""), Pattern.compile(""^(.+)\\.kt$""), TargetBackend.JS, true);
    }",method,
"    @TestMetadata(""kt10569.kt"")
    public void testKt10569() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/kt10569.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valueOf.kt"")
    public void testValueOf() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOf.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valueOfCapturedType.kt"")
    public void testValueOfCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfCapturedType.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valueOfChain.kt"")
    public void testValueOfChain() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfChain.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valueOfChainCapturedType.kt"")
    public void testValueOfChainCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfChainCapturedType.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valueOfNonReified.kt"")
    public void testValueOfNonReified() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valueOfNonReified.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""values.kt"")
    public void testValues() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/values.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valuesAsArray.kt"")
    public void testValuesAsArray() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesAsArray.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valuesCapturedType.kt"")
    public void testValuesCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesCapturedType.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valuesChain.kt"")
    public void testValuesChain() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesChain.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valuesChainCapturedType.kt"")
    public void testValuesChainCapturedType() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesChainCapturedType.kt"");
        doTest(fileName);
    }",method,
"    @TestMetadata(""valuesNonReified.kt"")
    public void testValuesNonReified() throws Exception {
        String fileName = KotlinTestUtils.navigationMetadata(""compiler/testData/codegen/boxInline/enum/valuesNonReified.kt"");
        doTest(fileName);
    }",method,
"public class HashBiMapTest extends TestCase {
  public static final class HashBiMapGenerator extends TestStringBiMapGenerator {
    @Override
    protected BiMap<String, String> create(Entry<String, String>[] entries) {
      BiMap<String, String> result = HashBiMap.create();
      for (Entry<String, String> entry : entries) {
        result.put(entry.getKey(), entry.getValue());
      }
      return result;
    }
  }
  @GwtIncompatible // suite
  public static Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(BiMapTestSuiteBuilder.using(new HashBiMapGenerator())
      .named(""HashBiMap"")
      .withFeatures(CollectionSize.ANY,
          CollectionFeature.SERIALIZABLE,
          CollectionFeature.SUPPORTS_ITERATOR_REMOVE,
          CollectionFeature.KNOWN_ORDER,
          MapFeature.ALLOWS_NULL_KEYS,
          MapFeature.ALLOWS_NULL_VALUES,
          MapFeature.ALLOWS_ANY_NULL_QUERIES,
          MapFeature.GENERAL_PURPOSE)
      .createTestSuite());
    suite.addTestSuite(HashBiMapTest.class);
    return suite;
  }
  public void testMapConstructor() {
    Map<String, String> map = ImmutableMap.of(
        ""canada"", ""dollar"",
        ""chile"", ""peso"",
        ""switzerland"", ""franc"");
    HashBiMap<String, String> bimap = HashBiMap.create(map);
    assertEquals(""dollar"", bimap.get(""canada""));
    assertEquals(""canada"", bimap.inverse().get(""dollar""));
  }
  private static final int N = 1000;
  public void testBashIt() throws Exception {
    BiMap<Integer, Integer> bimap = HashBiMap.create(N);
    BiMap<Integer, Integer> inverse = bimap.inverse();
    for (int i = 0; i < N; i++) {
      assertNull(bimap.put(2 * i, 2 * i + 1));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i + 1, (int) bimap.get(2 * i));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i, (int) inverse.get(2 * i + 1));
    }
    for (int i = 0; i < N; i++) {
      int oldValue = bimap.get(2 * i);
      assertEquals(2 * i + 1, (int) bimap.put(2 * i, oldValue - 2));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i - 1, (int) bimap.get(2 * i));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i, (int) inverse.get(2 * i - 1));
    }
    Set<Entry<Integer, Integer>> entries = bimap.entrySet();
    for (Entry<Integer, Integer> entry : entries) {
      entry.setValue(entry.getValue() + 2 * N);
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * N + 2 * i - 1, (int) bimap.get(2 * i));
    }
  }
  public void testBiMapEntrySetIteratorRemove() {
    BiMap<Integer, String> map = HashBiMap.create();
    map.put(1, ""one"");
    Set<Map.Entry<Integer, String>> entries = map.entrySet();
    Iterator<Map.Entry<Integer, String>> iterator = entries.iterator();
    Map.Entry<Integer, String> entry = iterator.next();
    entry.setValue(""two""); // changes the iterator's current entry value
    assertEquals(""two"", map.get(1));
    assertEquals(Integer.valueOf(1), map.inverse().get(""two""));
    iterator.remove(); // removes the updated entry
    assertTrue(map.isEmpty());
  }
  public void testInsertionOrder() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""foo"", 1),
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 3)).inOrder();
  }
  public void testInsertionOrderAfterRemoveFirst() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.remove(""foo"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 3)).inOrder();
  }
  public void testInsertionOrderAfterRemoveMiddle() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.remove(""bar"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""foo"", 1),
        Maps.immutableEntry(""quux"", 3)).inOrder();
  }
  public void testInsertionOrderAfterRemoveLast() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.remove(""quux"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""foo"", 1),
        Maps.immutableEntry(""bar"", 2)).inOrder();
  }
  public void testInsertionOrderAfterForcePut() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.forcePut(""quux"", 1);
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 1)).inOrder();
  }
  public void testInsertionOrderAfterInverseForcePut() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.inverse().forcePut(1, ""quux"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 1)).inOrder();
  }
  public void testInverseInsertionOrderAfterInverse() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""bar"", 2);
    map.put(""quux"", 1);
    assertThat(map.inverse().entrySet())
        .containsExactly(Maps.immutableEntry(2, ""bar""), Maps.immutableEntry(1, ""quux""))
        .inOrder();
  }
  public void testInverseInsertionOrderAfterInverseForcePut() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.inverse().forcePut(1, ""quux"");
    assertThat(map.inverse().entrySet()).containsExactly(
        Maps.immutableEntry(2, ""bar""),
        Maps.immutableEntry(1, ""quux"")).inOrder();
  }
  public void testInverseEntrySetValue() {
    BiMap<Integer, String> map = HashBiMap.create();
    map.put(1, ""one"");
    Entry<String, Integer> inverseEntry = Iterables.getOnlyElement(map.inverse().entrySet());
    inverseEntry.setValue(2);
    assertEquals(Integer.valueOf(2), inverseEntry.getValue());
  }
}",class,
"  public static final class HashBiMapGenerator extends TestStringBiMapGenerator {
    @Override
    protected BiMap<String, String> create(Entry<String, String>[] entries) {
      BiMap<String, String> result = HashBiMap.create();
      for (Entry<String, String> entry : entries) {
        result.put(entry.getKey(), entry.getValue());
      }
      return result;
    }
  }",class,
"    @Override
    protected BiMap<String, String> create(Entry<String, String>[] entries) {
      BiMap<String, String> result = HashBiMap.create();
      for (Entry<String, String> entry : entries) {
        result.put(entry.getKey(), entry.getValue());
      }
      return result;
    }",method,
"      for (Entry<String, String> entry : entries) {
        result.put(entry.getKey(), entry.getValue());
      }",method,
"  @GwtIncompatible // suite
  public static Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(BiMapTestSuiteBuilder.using(new HashBiMapGenerator())
      .named(""HashBiMap"")
      .withFeatures(CollectionSize.ANY,
          CollectionFeature.SERIALIZABLE,
          CollectionFeature.SUPPORTS_ITERATOR_REMOVE,
          CollectionFeature.KNOWN_ORDER,
          MapFeature.ALLOWS_NULL_KEYS,
          MapFeature.ALLOWS_NULL_VALUES,
          MapFeature.ALLOWS_ANY_NULL_QUERIES,
          MapFeature.GENERAL_PURPOSE)
      .createTestSuite());
    suite.addTestSuite(HashBiMapTest.class);
    return suite;
  }",method,
"  public void testMapConstructor() {
    Map<String, String> map = ImmutableMap.of(
        ""canada"", ""dollar"",
        ""chile"", ""peso"",
        ""switzerland"", ""franc"");
    HashBiMap<String, String> bimap = HashBiMap.create(map);
    assertEquals(""dollar"", bimap.get(""canada""));
    assertEquals(""canada"", bimap.inverse().get(""dollar""));
  }",method,
"  public void testBashIt() throws Exception {
    BiMap<Integer, Integer> bimap = HashBiMap.create(N);
    BiMap<Integer, Integer> inverse = bimap.inverse();
    for (int i = 0; i < N; i++) {
      assertNull(bimap.put(2 * i, 2 * i + 1));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i + 1, (int) bimap.get(2 * i));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i, (int) inverse.get(2 * i + 1));
    }
    for (int i = 0; i < N; i++) {
      int oldValue = bimap.get(2 * i);
      assertEquals(2 * i + 1, (int) bimap.put(2 * i, oldValue - 2));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i - 1, (int) bimap.get(2 * i));
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * i, (int) inverse.get(2 * i - 1));
    }
    Set<Entry<Integer, Integer>> entries = bimap.entrySet();
    for (Entry<Integer, Integer> entry : entries) {
      entry.setValue(entry.getValue() + 2 * N);
    }
    for (int i = 0; i < N; i++) {
      assertEquals(2 * N + 2 * i - 1, (int) bimap.get(2 * i));
    }
  }",method,
"    for (int i = 0; i < N; i++) {
      assertNull(bimap.put(2 * i, 2 * i + 1));
    }",method,
"    for (int i = 0; i < N; i++) {
      assertEquals(2 * i + 1, (int) bimap.get(2 * i));
    }",method,
"    for (int i = 0; i < N; i++) {
      assertEquals(2 * i, (int) inverse.get(2 * i + 1));
    }",method,
"    for (int i = 0; i < N; i++) {
      int oldValue = bimap.get(2 * i);
      assertEquals(2 * i + 1, (int) bimap.put(2 * i, oldValue - 2));
    }",method,
"    for (int i = 0; i < N; i++) {
      assertEquals(2 * i - 1, (int) bimap.get(2 * i));
    }",method,
"    for (int i = 0; i < N; i++) {
      assertEquals(2 * i, (int) inverse.get(2 * i - 1));
    }",method,
"    for (Entry<Integer, Integer> entry : entries) {
      entry.setValue(entry.getValue() + 2 * N);
    }",method,
"    for (int i = 0; i < N; i++) {
      assertEquals(2 * N + 2 * i - 1, (int) bimap.get(2 * i));
    }",method,
"  public void testBiMapEntrySetIteratorRemove() {
    BiMap<Integer, String> map = HashBiMap.create();
    map.put(1, ""one"");
    Set<Map.Entry<Integer, String>> entries = map.entrySet();
    Iterator<Map.Entry<Integer, String>> iterator = entries.iterator();
    Map.Entry<Integer, String> entry = iterator.next();
    entry.setValue(""two""); // changes the iterator's current entry value
    assertEquals(""two"", map.get(1));
    assertEquals(Integer.valueOf(1), map.inverse().get(""two""));
    iterator.remove(); // removes the updated entry
    assertTrue(map.isEmpty());
  }",method,
"  public void testInsertionOrder() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""foo"", 1),
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 3)).inOrder();
  }",method,
"  public void testInsertionOrderAfterRemoveFirst() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.remove(""foo"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 3)).inOrder();
  }",method,
"  public void testInsertionOrderAfterRemoveMiddle() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.remove(""bar"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""foo"", 1),
        Maps.immutableEntry(""quux"", 3)).inOrder();
  }",method,
"  public void testInsertionOrderAfterRemoveLast() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.remove(""quux"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""foo"", 1),
        Maps.immutableEntry(""bar"", 2)).inOrder();
  }",method,
"  public void testInsertionOrderAfterForcePut() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.forcePut(""quux"", 1);
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 1)).inOrder();
  }",method,
"  public void testInsertionOrderAfterInverseForcePut() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.inverse().forcePut(1, ""quux"");
    assertThat(map.entrySet()).containsExactly(
        Maps.immutableEntry(""bar"", 2),
        Maps.immutableEntry(""quux"", 1)).inOrder();
  }",method,
"  public void testInverseInsertionOrderAfterInverse() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""bar"", 2);
    map.put(""quux"", 1);
    assertThat(map.inverse().entrySet())
        .containsExactly(Maps.immutableEntry(2, ""bar""), Maps.immutableEntry(1, ""quux""))
        .inOrder();
  }",method,
"  public void testInverseInsertionOrderAfterInverseForcePut() {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put(""foo"", 1);
    map.put(""bar"", 2);
    map.put(""quux"", 3);
    map.inverse().forcePut(1, ""quux"");
    assertThat(map.inverse().entrySet()).containsExactly(
        Maps.immutableEntry(2, ""bar""),
        Maps.immutableEntry(1, ""quux"")).inOrder();
  }",method,
"  public void testInverseEntrySetValue() {
    BiMap<Integer, String> map = HashBiMap.create();
    map.put(1, ""one"");
    Entry<String, Integer> inverseEntry = Iterables.getOnlyElement(map.inverse().entrySet());
    inverseEntry.setValue(2);
    assertEquals(Integer.valueOf(2), inverseEntry.getValue());
  }",method,
"public class HmacDrbg {
  // ""V"" from the the spec.
  private byte[] value;
  // An instance of HMAC-SHA256 configured with ""Key"" from the spec.
  private HashFunction hmac;
  // The total number of bytes that have been generated from this DRBG so far.
  private int bytesGenerated;
  // Assume maximum security strength for HMAC-256, which is 256.
  // See: http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf D.2 #1.
  public static final int SECURITY_STRENGTH = 256;
  public static final int MAX_PERSONALIZATION_STRING_LENGTH_BYTES = 160 / 8;
  public static final int ENTROPY_INPUT_SIZE_BYTES = (SECURITY_STRENGTH / 8) * 3 / 2;
  public static final int MAX_BYTES_TOTAL = 10000;
  // See: http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf D.2 #2.
  private static final int DIGEST_NUM_BYTES = 256 / 8;
  // floor(7500/8); see: http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf D.2 #5.
  private static final int MAX_BYTES_PER_REQUEST = 937;
  private static final byte[] BYTE_ARRAY_0 = {0};
  private static final byte[] BYTE_ARRAY_1 = {1};
  public HmacDrbg(byte[] entropyInput, byte[] personalizationString) {
    // HMAC_DRBG Instantiate Process
    // See: http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf 10.1.1.2
    // 1. seed_material = entropy_input + nonce + personalization_string
    // Note: We are using the 8.6.7 interpretation, where the entropy_input and
    // nonce are acquired at the same time from the same source.
    byte[] seedMaterial = Bytes.concat(entropyInput, emptyIfNull(personalizationString));
    // 2. Key = 0x00 00...00
    setKey(new byte[256 / 8]);
    // 3. V = 0x01 01...01
    value = new byte[DIGEST_NUM_BYTES];
    Arrays.fill(value, (byte) 0x01);
    // 4. (Key, V) = HMAC_DRBG_Update(seed_material, Key, V)
    hmacDrbgUpdate(seedMaterial);
    bytesGenerated = 0;
  }
  private static byte[] emptyIfNull(byte[] b) {
    return b == null ? new byte[0] : b;
  }
  private void setKey(byte[] key) {
    hmac = Hashing.hmacSha256(key);
  }
  private byte[] hash(byte[] x) {
    return hmac.hashBytes(x).asBytes();
  }
  private void hmacDrbgUpdate(byte[] providedData) {
    // 1. K = HMAC(K, V || 0x00 || provided_data)
    setKey(hash(Bytes.concat(value, BYTE_ARRAY_0, emptyIfNull(providedData))));
    // 2. V = HMAC(K, V);
    value = hash(value);
    // 3. If (provided_data = Null), then return K and V.
    if (providedData == null) {
      return;
    }
    // 4. K = HMAC (K, V || 0x01 || provided_data).
    setKey(hash(Bytes.concat(value, BYTE_ARRAY_1, providedData)));
    // 5. V = HMAC (K, V).
    value = hash(value);
  }
  private void hmacDrbgGenerate(byte[] out, int start, int count) {
    // 3. temp = Null.
    int bytesWritten = 0;
    // 4. While (len (temp) < requested_number_of_bits) do:
    while (bytesWritten < count) {
      // 4.1 V = HMAC (Key, V).
      value = hash(value);
      // 4.2 temp = temp || V.
      // 5. returned_bits = Leftmost requested_number_of_bits of temp
      int bytesToWrite = Math.min(count - bytesWritten, DIGEST_NUM_BYTES);
      System.arraycopy(value, 0, out, start + bytesWritten, bytesToWrite);
      bytesWritten += bytesToWrite;
    }
    // 6. (Key, V) = HMAC_DRBG_Update (additional_input, Key, V).
    hmacDrbgUpdate(null);
  }
  public static byte[] generateEntropyInput() {
    byte result[] = new byte[ENTROPY_INPUT_SIZE_BYTES];
    new SecureRandom().nextBytes(result);
    return result;
  }
  public byte[] nextBytes(int length) {
    byte result[] = new byte[length];
    nextBytes(result);
    return result;
  }
  public void nextBytes(byte[] out) {
    nextBytes(out, 0, out.length);
  }
  public void nextBytes(byte[] out, int start, int count) {
    if (count == 0) {
      return;
    }
    if (bytesGenerated + count > MAX_BYTES_TOTAL) {
      throw new IllegalStateException(""Cannot generate more than a total of "" + count + "" bytes."");
    }
    try {
      int bytesWritten = 0;
      while (bytesWritten < count) {
        int bytesToWrite = Math.min(count - bytesWritten, MAX_BYTES_PER_REQUEST);
        hmacDrbgGenerate(out, start + bytesWritten, bytesToWrite);
        bytesWritten += bytesToWrite;
      }
    } finally {
      bytesGenerated += count;
    }
  }
}",class,
"  public HmacDrbg(byte[] entropyInput, byte[] personalizationString) {
    // HMAC_DRBG Instantiate Process
    // See: http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf 10.1.1.2
    // 1. seed_material = entropy_input + nonce + personalization_string
    // Note: We are using the 8.6.7 interpretation, where the entropy_input and
    // nonce are acquired at the same time from the same source.
    byte[] seedMaterial = Bytes.concat(entropyInput, emptyIfNull(personalizationString));
    // 2. Key = 0x00 00...00
    setKey(new byte[256 / 8]);
    // 3. V = 0x01 01...01
    value = new byte[DIGEST_NUM_BYTES];
    Arrays.fill(value, (byte) 0x01);
    // 4. (Key, V) = HMAC_DRBG_Update(seed_material, Key, V)
    hmacDrbgUpdate(seedMaterial);
    bytesGenerated = 0;
  }",method,
"  private static byte[] emptyIfNull(byte[] b) {
    return b == null ? new byte[0] : b;
  }",method,
"  private void setKey(byte[] key) {
    hmac = Hashing.hmacSha256(key);
  }",method,
"  private byte[] hash(byte[] x) {
    return hmac.hashBytes(x).asBytes();
  }",method,
"  private void hmacDrbgUpdate(byte[] providedData) {
    // 1. K = HMAC(K, V || 0x00 || provided_data)
    setKey(hash(Bytes.concat(value, BYTE_ARRAY_0, emptyIfNull(providedData))));
    // 2. V = HMAC(K, V);
    value = hash(value);
    // 3. If (provided_data = Null), then return K and V.
    if (providedData == null) {
      return;
    }
    // 4. K = HMAC (K, V || 0x01 || provided_data).
    setKey(hash(Bytes.concat(value, BYTE_ARRAY_1, providedData)));
    // 5. V = HMAC (K, V).
    value = hash(value);
  }",method,
"    if (providedData == null) {
      return;
    }",method,
"  private void hmacDrbgGenerate(byte[] out, int start, int count) {
    // 3. temp = Null.
    int bytesWritten = 0;
    // 4. While (len (temp) < requested_number_of_bits) do:
    while (bytesWritten < count) {
      // 4.1 V = HMAC (Key, V).
      value = hash(value);
      // 4.2 temp = temp || V.
      // 5. returned_bits = Leftmost requested_number_of_bits of temp
      int bytesToWrite = Math.min(count - bytesWritten, DIGEST_NUM_BYTES);
      System.arraycopy(value, 0, out, start + bytesWritten, bytesToWrite);
      bytesWritten += bytesToWrite;
    }
    // 6. (Key, V) = HMAC_DRBG_Update (additional_input, Key, V).
    hmacDrbgUpdate(null);
  }",method,
"    while (bytesWritten < count) {
      // 4.1 V = HMAC (Key, V).
      value = hash(value);
      // 4.2 temp = temp || V.
      // 5. returned_bits = Leftmost requested_number_of_bits of temp
      int bytesToWrite = Math.min(count - bytesWritten, DIGEST_NUM_BYTES);
      System.arraycopy(value, 0, out, start + bytesWritten, bytesToWrite);
      bytesWritten += bytesToWrite;
    }",method,
"  public static byte[] generateEntropyInput() {
    byte result[] = new byte[ENTROPY_INPUT_SIZE_BYTES];
    new SecureRandom().nextBytes(result);
    return result;
  }",method,
"  public byte[] nextBytes(int length) {
    byte result[] = new byte[length];
    nextBytes(result);
    return result;
  }",method,
"  public void nextBytes(byte[] out) {
    nextBytes(out, 0, out.length);
  }",method,
"  public void nextBytes(byte[] out, int start, int count) {
    if (count == 0) {
      return;
    }
    if (bytesGenerated + count > MAX_BYTES_TOTAL) {
      throw new IllegalStateException(""Cannot generate more than a total of "" + count + "" bytes."");
    }
    try {
      int bytesWritten = 0;
      while (bytesWritten < count) {
        int bytesToWrite = Math.min(count - bytesWritten, MAX_BYTES_PER_REQUEST);
        hmacDrbgGenerate(out, start + bytesWritten, bytesToWrite);
        bytesWritten += bytesToWrite;
      }
    } finally {
      bytesGenerated += count;
    }
  }",method,
"    if (count == 0) {
      return;
    }",method,
"    if (bytesGenerated + count > MAX_BYTES_TOTAL) {
      throw new IllegalStateException(""Cannot generate more than a total of "" + count + "" bytes."");
    }",method,
"      while (bytesWritten < count) {
        int bytesToWrite = Math.min(count - bytesWritten, MAX_BYTES_PER_REQUEST);
        hmacDrbgGenerate(out, start + bytesWritten, bytesToWrite);
        bytesWritten += bytesToWrite;
      }",method,
"public class GenericTypesTest {
  private SqlSessionFactory sqlSessionFactory;
  @Before
  public void setUp() throws Exception {
    Connection conn = null;
    try {
      Class.forName(""org.hsqldb.jdbcDriver"");
      conn = DriverManager.getConnection(""jdbc:hsqldb:mem:generictypes"", ""sa"", """");
      Reader reader = Resources.getResourceAsReader(""org/apache/ibatis/submitted/generictypes/CreateDB.sql"");
      ScriptRunner runner = new ScriptRunner(conn);
      runner.setLogWriter(null);
      runner.setErrorLogWriter(new PrintWriter(System.err));
      runner.runScript(reader);
      conn.commit();
      reader.close();
      reader = Resources.getResourceAsReader(""org/apache/ibatis/submitted/generictypes/Config.xml"");
      sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
      reader.close();
    } finally {
      if (conn != null) {
        conn.close();
      }
    }
  }
  @Test
  public void testShouldGetAListOfMaps() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
      Mapper mapper = sqlSession.getMapper(Mapper.class);
      Group group = mapper.getGroup();
      Assert.assertNotNull(group.getOwner());
    } finally {
      sqlSession.close();
    }
  }
}",class,
"  @Before
  public void setUp() throws Exception {
    Connection conn = null;
    try {
      Class.forName(""org.hsqldb.jdbcDriver"");
      conn = DriverManager.getConnection(""jdbc:hsqldb:mem:generictypes"", ""sa"", """");
      Reader reader = Resources.getResourceAsReader(""org/apache/ibatis/submitted/generictypes/CreateDB.sql"");
      ScriptRunner runner = new ScriptRunner(conn);
      runner.setLogWriter(null);
      runner.setErrorLogWriter(new PrintWriter(System.err));
      runner.runScript(reader);
      conn.commit();
      reader.close();
      reader = Resources.getResourceAsReader(""org/apache/ibatis/submitted/generictypes/Config.xml"");
      sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
      reader.close();
    } finally {
      if (conn != null) {
        conn.close();
      }
    }
  }",method,
"      if (conn != null) {
        conn.close();
      }",method,
"  @Test
  public void testShouldGetAListOfMaps() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
      Mapper mapper = sqlSession.getMapper(Mapper.class);
      Group group = mapper.getGroup();
      Assert.assertNotNull(group.getOwner());
    } finally {
      sqlSession.close();
    }
  }",method,
"public final class InputStreamSink {
  private static final byte[] DISCARD = new byte[4096];
  // Supresses default constructor; ensures non-instantiability
  private InputStreamSink() {
  }
  private static class NullSink implements Runnable {
    private final InputStream in;
    public NullSink(InputStream in) {
      this.in = in;
    }
    @Override
    public void run() {
      try {
        try {
          // Attempt to just skip all input
          do {
            in.skip(Integer.MAX_VALUE);
          } while (in.read() != -1); // Need to test for EOF
        } catch (IOException ioe) {
          // Some streams throw IOException when skip() is called;
          // resort to reading off all input with read():
          while (in.read(DISCARD) != -1) {
            // no loop body
          }
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
  private static class CopySink implements Runnable {
    private final InputStream in;
    private final OutputStream out;
    public CopySink(InputStream in, OutputStream out) {
      this.in = in;
      this.out = out;
    }
    @Override
    public void run() {
      try {
        byte[] buffer = new byte[2048];
        int bytesRead;
        while ((bytesRead = in.read(buffer)) >= 0) {
          out.write(buffer, 0, bytesRead);
          out.flush();
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
  public static Runnable newRunnableSink(InputStream in) {
    if (in == null) {
      throw new NullPointerException(""in"");
    }
    return new NullSink(in);
  }
  public static Runnable newRunnableSink(InputStream in, OutputStream out) {
    if (in == null) {
      throw new NullPointerException(""in"");
    }
    if (out == null) {
      throw new NullPointerException(""out"");
    }
    return new CopySink(in, out);
  }
}",class,
"  private static class NullSink implements Runnable {
    private final InputStream in;
    public NullSink(InputStream in) {
      this.in = in;
    }
    @Override
    public void run() {
      try {
        try {
          // Attempt to just skip all input
          do {
            in.skip(Integer.MAX_VALUE);
          } while (in.read() != -1); // Need to test for EOF
        } catch (IOException ioe) {
          // Some streams throw IOException when skip() is called;
          // resort to reading off all input with read():
          while (in.read(DISCARD) != -1) {
            // no loop body
          }
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }",class,
"  private static class CopySink implements Runnable {
    private final InputStream in;
    private final OutputStream out;
    public CopySink(InputStream in, OutputStream out) {
      this.in = in;
      this.out = out;
    }
    @Override
    public void run() {
      try {
        byte[] buffer = new byte[2048];
        int bytesRead;
        while ((bytesRead = in.read(buffer)) >= 0) {
          out.write(buffer, 0, bytesRead);
          out.flush();
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }",class,
"  private InputStreamSink() {
  }",method,
"    public NullSink(InputStream in) {
      this.in = in;
    }",method,
"    @Override
    public void run() {
      try {
        try {
          // Attempt to just skip all input
          do {
            in.skip(Integer.MAX_VALUE);
          } while (in.read() != -1); // Need to test for EOF
        } catch (IOException ioe) {
          // Some streams throw IOException when skip() is called;
          // resort to reading off all input with read():
          while (in.read(DISCARD) != -1) {
            // no loop body
          }
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }",method,
"    public CopySink(InputStream in, OutputStream out) {
      this.in = in;
      this.out = out;
    }",method,
"    @Override
    public void run() {
      try {
        byte[] buffer = new byte[2048];
        int bytesRead;
        while ((bytesRead = in.read(buffer)) >= 0) {
          out.write(buffer, 0, bytesRead);
          out.flush();
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }",method,
"  public static Runnable newRunnableSink(InputStream in) {
    if (in == null) {
      throw new NullPointerException(""in"");
    }
    return new NullSink(in);
  }",method,
"    if (in == null) {
      throw new NullPointerException(""in"");
    }",method,
"  public static Runnable newRunnableSink(InputStream in, OutputStream out) {
    if (in == null) {
      throw new NullPointerException(""in"");
    }
    if (out == null) {
      throw new NullPointerException(""out"");
    }
    return new CopySink(in, out);
  }",method,
"    if (in == null) {
      throw new NullPointerException(""in"");
    }",method,
"    if (out == null) {
      throw new NullPointerException(""out"");
    }",method,
"public class ModelReturn   {
  @JsonProperty(""return"")
  private Integer _return = null;
  public ModelReturn _return(Integer _return) {
    this._return = _return;
    return this;
  }
  @JsonProperty(""return"")
  @ApiModelProperty(value = """")
  public Integer getReturn() {
    return _return;
  }
  public void setReturn(Integer _return) {
    this._return = _return;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelReturn _return = (ModelReturn) o;
    return Objects.equals(this._return, _return._return);
  }
  @Override
  public int hashCode() {
    return Objects.hash(_return);
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class ModelReturn {\n"");
    sb.append(""    _return: "").append(toIndentedString(_return)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
}",class,
"    sb.append(""class ModelReturn {\n"");
    sb.append(""    _return: "").append(toIndentedString(_return)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"  public ModelReturn _return(Integer _return) {
    this._return = _return;
    return this;
  }",method,
"  @JsonProperty(""return"")
  @ApiModelProperty(value = """")
  public Integer getReturn() {
    return _return;
  }",method,
"  public void setReturn(Integer _return) {
    this._return = _return;
  }",method,
"  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelReturn _return = (ModelReturn) o;
    return Objects.equals(this._return, _return._return);
  }",method,
"    if (this == o) {
      return true;
    }",method,
"  @Override
  public int hashCode() {
    return Objects.hash(_return);
  }",method,
"  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class ModelReturn {\n"");
    sb.append(""    _return: "").append(toIndentedString(_return)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }",method,
"  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",method,
"    if (o == null) {
      return ""null"";
    }",method,
"public class DepthShader extends DefaultShader {
	public static class Config extends DefaultShader.Config {
		public boolean depthBufferOnly = false;
		public float defaultAlphaTest = 0.5f;
		public Config () {
			super();
			defaultCullFace = GL20.GL_FRONT;
		}
		public Config (String vertexShader, String fragmentShader) {
			super(vertexShader, fragmentShader);
		}
	}
	private static String defaultVertexShader = null;
	public final static String getDefaultVertexShader () {
		if (defaultVertexShader == null)
			defaultVertexShader = Gdx.files.classpath(""com/badlogic/gdx/graphics/g3d/shaders/depth.vertex.glsl"").readString();
		return defaultVertexShader;
	}
	private static String defaultFragmentShader = null;
	public final static String getDefaultFragmentShader () {
		if (defaultFragmentShader == null)
			defaultFragmentShader = Gdx.files.classpath(""com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl"").readString();
		return defaultFragmentShader;
	}
	public static String createPrefix (final Renderable renderable, final Config config) {
		String prefix = DefaultShader.createPrefix(renderable, config);
		if (!config.depthBufferOnly) prefix += ""#define PackedDepthFlag\n"";
		return prefix;
	}
	public final int numBones;
	public final int weights;
	private final FloatAttribute alphaTestAttribute;
	public DepthShader (final Renderable renderable) {
		this(renderable, new Config());
	}
	public DepthShader (final Renderable renderable, final Config config) {
		this(renderable, config, createPrefix(renderable, config));
	}
	public DepthShader (final Renderable renderable, final Config config, final String prefix) {
		this(renderable, config, prefix, config.vertexShader != null ? config.vertexShader : getDefaultVertexShader(),
			config.fragmentShader != null ? config.fragmentShader : getDefaultFragmentShader());
	}
	public DepthShader (final Renderable renderable, final Config config, final String prefix, final String vertexShader,
		final String fragmentShader) {
		this(renderable, config, new ShaderProgram(prefix + vertexShader, prefix + fragmentShader));
	}
	public DepthShader (final Renderable renderable, final Config config, final ShaderProgram shaderProgram) {
		super(renderable, config, shaderProgram);
		final Attributes attributes = combineAttributes(renderable);
		this.numBones = renderable.bones == null ? 0 : config.numBones;
		int w = 0;
		final int n = renderable.meshPart.mesh.getVertexAttributes().size();
		for (int i = 0; i < n; i++) {
			final VertexAttribute attr = renderable.meshPart.mesh.getVertexAttributes().get(i);
			if (attr.usage == Usage.BoneWeight) w |= (1 << attr.unit);
		}
		weights = w;
		alphaTestAttribute = new FloatAttribute(FloatAttribute.AlphaTest, config.defaultAlphaTest);
	}
	@Override
	public void begin (Camera camera, RenderContext context) {
		super.begin(camera, context);
		// Gdx.gl20.glEnable(GL20.GL_POLYGON_OFFSET_FILL);
		// Gdx.gl20.glPolygonOffset(2.f, 100.f);
	}
	@Override
	public void end () {
		super.end();
		// Gdx.gl20.glDisable(GL20.GL_POLYGON_OFFSET_FILL);
	}
	@Override
	public boolean canRender (Renderable renderable) {
		final Attributes attributes = combineAttributes(renderable);
		if (attributes.has(BlendingAttribute.Type)) {
			if ((attributesMask & BlendingAttribute.Type) != BlendingAttribute.Type)
				return false;
			if (attributes.has(TextureAttribute.Diffuse) != ((attributesMask & TextureAttribute.Diffuse) == TextureAttribute.Diffuse))
				return false;
		}
		final boolean skinned = ((renderable.meshPart.mesh.getVertexAttributes().getMask() & Usage.BoneWeight) == Usage.BoneWeight);
		if (skinned != (numBones > 0)) return false;
		if (!skinned) return true;
		int w = 0;
		final int n = renderable.meshPart.mesh.getVertexAttributes().size();
		for (int i = 0; i < n; i++) {
			final VertexAttribute attr = renderable.meshPart.mesh.getVertexAttributes().get(i);
			if (attr.usage == Usage.BoneWeight) w |= (1 << attr.unit);
		}
		return w == weights;
	}
	@Override
	public void render (Renderable renderable, Attributes combinedAttributes) {
		if (combinedAttributes.has(BlendingAttribute.Type)) {
			final BlendingAttribute blending = (BlendingAttribute)combinedAttributes.get(BlendingAttribute.Type);
			combinedAttributes.remove(BlendingAttribute.Type);
			final boolean hasAlphaTest = combinedAttributes.has(FloatAttribute.AlphaTest);
			if (!hasAlphaTest)
				combinedAttributes.set(alphaTestAttribute);
			if (blending.opacity >= ((FloatAttribute)combinedAttributes.get(FloatAttribute.AlphaTest)).value)
				super.render(renderable, combinedAttributes);
			if (!hasAlphaTest)
				combinedAttributes.remove(FloatAttribute.AlphaTest);
			combinedAttributes.set(blending);
		} else
			super.render(renderable, combinedAttributes);
	}
	private final static Attributes tmpAttributes = new Attributes();
	// TODO: Move responsibility for combining attributes to RenderableProvider
	private static final Attributes combineAttributes(final Renderable renderable) {
		tmpAttributes.clear();
		if (renderable.environment != null) tmpAttributes.set(renderable.environment);
		if (renderable.material != null) tmpAttributes.set(renderable.material);
		return tmpAttributes;
	}
}",class,
"	public static class Config extends DefaultShader.Config {
		public boolean depthBufferOnly = false;
		public float defaultAlphaTest = 0.5f;
		public Config () {
			super();
			defaultCullFace = GL20.GL_FRONT;
		}
		public Config (String vertexShader, String fragmentShader) {
			super(vertexShader, fragmentShader);
		}
	}",class,
"		public Config () {
			super();
			defaultCullFace = GL20.GL_FRONT;
		}",method,
"		public Config (String vertexShader, String fragmentShader) {
			super(vertexShader, fragmentShader);
		}",method,
"	public final static String getDefaultVertexShader () {
		if (defaultVertexShader == null)
			defaultVertexShader = Gdx.files.classpath(""com/badlogic/gdx/graphics/g3d/shaders/depth.vertex.glsl"").readString();
		return defaultVertexShader;
	}",method,
"	public final static String getDefaultFragmentShader () {
		if (defaultFragmentShader == null)
			defaultFragmentShader = Gdx.files.classpath(""com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl"").readString();
		return defaultFragmentShader;
	}",method,
"	public static String createPrefix (final Renderable renderable, final Config config) {
		String prefix = DefaultShader.createPrefix(renderable, config);
		if (!config.depthBufferOnly) prefix += ""#define PackedDepthFlag\n"";
		return prefix;
	}",method,
"	public DepthShader (final Renderable renderable) {
		this(renderable, new Config());
	}",method,
"	public DepthShader (final Renderable renderable, final Config config) {
		this(renderable, config, createPrefix(renderable, config));
	}",method,
"	public DepthShader (final Renderable renderable, final Config config, final String prefix) {
		this(renderable, config, prefix, config.vertexShader != null ? config.vertexShader : getDefaultVertexShader(),
			config.fragmentShader != null ? config.fragmentShader : getDefaultFragmentShader());
	}",method,

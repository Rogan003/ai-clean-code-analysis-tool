code_snippet,type,score
"	public void setMaximized(boolean maximized) {
		this.windowMaximized = maximized;
	}",method,
"	public void setWindowPosition(int x, int y) {
		windowX = x;
		windowY = y;
	}",method,
"	public void setWindowSizeLimits(int minWidth, int minHeight, int maxWidth, int maxHeight) {
		windowMinWidth = minWidth;
		windowMinHeight = minHeight;
		windowMaxWidth = maxWidth;
		windowMaxHeight = maxHeight;
	}",method,
"	public void setWindowIcon (String... filePaths) {
		setWindowIcon(FileType.Internal, filePaths);
	}",method,
"	public void setWindowIcon (FileType fileType, String... filePaths) {
		windowIconFileType = fileType;
		windowIconPaths = filePaths;
	}",method,
"	public void setWindowListener(Lwjgl3WindowListener windowListener) {
		this.windowListener = windowListener;
	}",method,
"	public void setFullscreenMode(DisplayMode mode) {
		this.fullscreenMode = (Lwjgl3DisplayMode)mode;
	}",method,
"	public void setTitle(String title) {
		this.title = title;
	}",method,
"	public void setInitialBackgroundColor(Color color) {
		initialBackgroundColor = color;
	}",method,
"public class DeleteRequest extends ReplicatedWriteRequest<DeleteRequest> implements DocWriteRequest<DeleteRequest>, CompositeIndicesRequest {
    private String type;
    private String id;
    @Nullable
    private String routing;
    @Nullable
    private String parent;
    private long version = Versions.MATCH_ANY;
    private VersionType versionType = VersionType.INTERNAL;
    public DeleteRequest() {
    }
    public DeleteRequest(String index) {
        this.index = index;
    }
    public DeleteRequest(String index, String type, String id) {
        this.index = index;
        this.type = type;
        this.id = id;
    }
    @Override
    public ActionRequestValidationException validate() {
        ActionRequestValidationException validationException = super.validate();
        if (type == null) {
            validationException = addValidationError(""type is missing"", validationException);
        }
        if (id == null) {
            validationException = addValidationError(""id is missing"", validationException);
        }
        if (!versionType.validateVersionForWrites(version)) {
            validationException = addValidationError(""illegal version value ["" + version + ""] for version type ["" + versionType.name() + ""]"", validationException);
        }
        if (versionType == VersionType.FORCE) {
            validationException = addValidationError(""version type [force] may no longer be used"", validationException);
        }
        return validationException;
    }
    @Override
    public String type() {
        return type;
    }
    public DeleteRequest type(String type) {
        this.type = type;
        return this;
    }
    @Override
    public String id() {
        return id;
    }
    public DeleteRequest id(String id) {
        this.id = id;
        return this;
    }
    @Override
    public String parent() {
        return parent;
    }
    public DeleteRequest parent(String parent) {
        this.parent = parent;
        return this;
    }
    @Override
    public DeleteRequest routing(String routing) {
        if (routing != null && routing.length() == 0) {
            this.routing = null;
        } else {
            this.routing = routing;
        }
        return this;
    }
    @Override
    public String routing() {
        return this.routing;
    }
    @Override
    public DeleteRequest version(long version) {
        this.version = version;
        return this;
    }
    @Override
    public long version() {
        return this.version;
    }
    @Override
    public DeleteRequest versionType(VersionType versionType) {
        this.versionType = versionType;
        return this;
    }
    @Override
    public VersionType versionType() {
        return this.versionType;
    }
    @Override
    public OpType opType() {
        return OpType.DELETE;
    }
    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        type = in.readString();
        id = in.readString();
        routing = in.readOptionalString();
        parent = in.readOptionalString();
        version = in.readLong();
        versionType = VersionType.fromValue(in.readByte());
    }
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeString(type);
        out.writeString(id);
        out.writeOptionalString(routing());
        out.writeOptionalString(parent());
        out.writeLong(version);
        out.writeByte(versionType.getValue());
    }
    @Override
    public String toString() {
        return ""delete {["" + index + ""]["" + type + ""]["" + id + ""]}"";
    }
    @Override
    public DeleteRequest setShardId(ShardId shardId) {
        throw new UnsupportedOperationException(""shard id should never be set on DeleteRequest"");
    }
}",class,
"    public DeleteRequest() {
    }",method,
"    public DeleteRequest(String index) {
        this.index = index;
    }",method,
"    public DeleteRequest(String index, String type, String id) {
        this.index = index;
        this.type = type;
        this.id = id;
    }",method,
"    @Override
    public ActionRequestValidationException validate() {
        ActionRequestValidationException validationException = super.validate();
        if (type == null) {
            validationException = addValidationError(""type is missing"", validationException);
        }
        if (id == null) {
            validationException = addValidationError(""id is missing"", validationException);
        }
        if (!versionType.validateVersionForWrites(version)) {
            validationException = addValidationError(""illegal version value ["" + version + ""] for version type ["" + versionType.name() + ""]"", validationException);
        }
        if (versionType == VersionType.FORCE) {
            validationException = addValidationError(""version type [force] may no longer be used"", validationException);
        }
        return validationException;
    }",method,
"        if (type == null) {
            validationException = addValidationError(""type is missing"", validationException);
        }",method,
"        if (id == null) {
            validationException = addValidationError(""id is missing"", validationException);
        }",method,
"        if (versionType == VersionType.FORCE) {
            validationException = addValidationError(""version type [force] may no longer be used"", validationException);
        }",method,
"    @Override
    public String type() {
        return type;
    }",method,
"    public DeleteRequest type(String type) {
        this.type = type;
        return this;
    }",method,
"    @Override
    public String id() {
        return id;
    }",method,
"    public DeleteRequest id(String id) {
        this.id = id;
        return this;
    }",method,
"    @Override
    public String parent() {
        return parent;
    }",method,
"    public DeleteRequest parent(String parent) {
        this.parent = parent;
        return this;
    }",method,
"    @Override
    public DeleteRequest routing(String routing) {
        if (routing != null && routing.length() == 0) {
            this.routing = null;
        } else {
            this.routing = routing;
        }
        return this;
    }",method,
"    @Override
    public String routing() {
        return this.routing;
    }",method,
"    @Override
    public DeleteRequest version(long version) {
        this.version = version;
        return this;
    }",method,
"    @Override
    public long version() {
        return this.version;
    }",method,
"    @Override
    public DeleteRequest versionType(VersionType versionType) {
        this.versionType = versionType;
        return this;
    }",method,
"    @Override
    public VersionType versionType() {
        return this.versionType;
    }",method,
"    @Override
    public OpType opType() {
        return OpType.DELETE;
    }",method,
"    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        type = in.readString();
        id = in.readString();
        routing = in.readOptionalString();
        parent = in.readOptionalString();
        version = in.readLong();
        versionType = VersionType.fromValue(in.readByte());
    }",method,
"    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeString(type);
        out.writeString(id);
        out.writeOptionalString(routing());
        out.writeOptionalString(parent());
        out.writeLong(version);
        out.writeByte(versionType.getValue());
    }",method,
"    @Override
    public String toString() {
        return ""delete {["" + index + ""]["" + type + ""]["" + id + ""]}"";
    }",method,
"    @Override
    public DeleteRequest setShardId(ShardId shardId) {
        throw new UnsupportedOperationException(""shard id should never be set on DeleteRequest"");
    }",method,
"     void prepareLayers(List<Object> layerConfigs)
            throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {
        this.layersOrdered = new ArrayList<>();
        this.layers = new HashMap<>();
        DimOrder dimOrder = DimOrder.NONE;
        for (Object layerConfig : layerConfigs) {
            Map<String, Object> layerConfigMap = (Map<String, Object>) layerConfig;
            // Append major keras version to each layer config.
            layerConfigMap.put(config.getFieldKerasVersion(), this.kerasMajorVersion);
            KerasLayerConfiguration kerasLayerConf = new KerasLayer(this.kerasMajorVersion).conf;
            KerasLayer layer = KerasLayerUtils.getKerasLayerFromConfig(layerConfigMap, this.enforceTrainingConfig,
                    kerasLayerConf, customLayers);
            if (dimOrder == DimOrder.NONE && layer.getDimOrder() != DimOrder.NONE)
                dimOrder = layer.getDimOrder();
            this.layersOrdered.add(layer);
            this.layers.put(layer.getLayerName(), layer);
            if (layer instanceof KerasLstm)
                this.useTruncatedBPTT = this.useTruncatedBPTT || ((KerasLstm) layer).getUnroll();
        }
        for (KerasLayer layer : this.layersOrdered) {
            if (layer.getDimOrder() == DimOrder.NONE)
                layer.setDimOrder(dimOrder);
            else if (layer.getDimOrder() != dimOrder)
                throw new UnsupportedKerasConfigurationException(""Keras layer "" + layer.getLayerName()
                        + "" has conflicting dim_ordering "" + layer.getDimOrder() + "" (vs. dimOrder)"");
        }
    }",method,
"        for (Object layerConfig : layerConfigs) {
            Map<String, Object> layerConfigMap = (Map<String, Object>) layerConfig;
            // Append major keras version to each layer config.
            layerConfigMap.put(config.getFieldKerasVersion(), this.kerasMajorVersion);
            KerasLayerConfiguration kerasLayerConf = new KerasLayer(this.kerasMajorVersion).conf;
            KerasLayer layer = KerasLayerUtils.getKerasLayerFromConfig(layerConfigMap, this.enforceTrainingConfig,
                    kerasLayerConf, customLayers);
            if (dimOrder == DimOrder.NONE && layer.getDimOrder() != DimOrder.NONE)
                dimOrder = layer.getDimOrder();
            this.layersOrdered.add(layer);
            this.layers.put(layer.getLayerName(), layer);
            if (layer instanceof KerasLstm)
                this.useTruncatedBPTT = this.useTruncatedBPTT || ((KerasLstm) layer).getUnroll();
        }",method,
"        for (KerasLayer layer : this.layersOrdered) {
            if (layer.getDimOrder() == DimOrder.NONE)
                layer.setDimOrder(dimOrder);
            else if (layer.getDimOrder() != dimOrder)
                throw new UnsupportedKerasConfigurationException(""Keras layer "" + layer.getLayerName()
                        + "" has conflicting dim_ordering "" + layer.getDimOrder() + "" (vs. dimOrder)"");
        }",method,
"public class DrawingSkylinesAlternative {
  // @include
  public static class Rectangle {
    public int left, right, height;
    public Rectangle(int left, int right, int height) {
      this.left = left;
      this.right = right;
      this.height = height;
    }
  }
  public static List<Rectangle> drawingSkylines(List<Rectangle> buildings) {
    int minLeft = Integer.MAX_VALUE, maxRight = Integer.MIN_VALUE;
    for (Rectangle building : buildings) {
      minLeft = Math.min(minLeft, building.left);
      maxRight = Math.max(maxRight, building.right);
    }
    List<Integer> heights
        = new ArrayList<>(Collections.nCopies(maxRight - minLeft + 1, 0));
    for (Rectangle building : buildings) {
      for (int i = building.left; i <= building.right; ++i) {
        heights.set(i - minLeft,
                    Math.max(heights.get(i - minLeft), building.height));
      }
    }
    List<Rectangle> result = new ArrayList<>();
    int left = 0;
    for (int i = 1; i < heights.size(); ++i) {
      if (heights.get(i) != heights.get(i - 1)) {
        result.add(
            new Rectangle(left + minLeft, i - 1 + minLeft, heights.get(i - 1)));
        left = i;
      }
    }
    result.add(new Rectangle(left + minLeft, maxRight,
                             heights.get(heights.size() - 1)));
    return result;
  }
  // @exclude
  private static void checkAnswer(List<Rectangle> ans) {
    // Just check there is no overlap.
    for (int i = 0; i < ans.size(); ++i) {
      assert(ans.get(i).left <= ans.get(i).right);
      if (i > 0) {
        assert(ans.get(i - 1).right <= ans.get(i).left);
        assert(ans.get(i - 1).right != ans.get(i).left
               || ans.get(i - 1).height != ans.get(i).height);
      }
    }
  }
  public static void main(String[] args) {
    Random r = new Random();
    for (int times = 0; times < 2000; ++times) {
      int n;
      if (args.length == 1) {
        n = Integer.parseInt(args[0]);
      } else {
        n = r.nextInt(5000) + 1;
      }
      List<Rectangle> A = new ArrayList<>();
      for (int i = 0; i < n; ++i) {
        int left = r.nextInt(1000);
        int right = r.nextInt(201) + left;
        int height = r.nextInt(100);
        A.add(new Rectangle(left, right, height));
      }
      List<Rectangle> ans = drawingSkylines(A);
      System.out.println(""n = "" + n);
      checkAnswer(ans);
    }
  }
}",class,
"  public static class Rectangle {
    public int left, right, height;
    public Rectangle(int left, int right, int height) {
      this.left = left;
      this.right = right;
      this.height = height;
    }
  }",class,
"    public Rectangle(int left, int right, int height) {
      this.left = left;
      this.right = right;
      this.height = height;
    }",method,
"  public static List<Rectangle> drawingSkylines(List<Rectangle> buildings) {
    int minLeft = Integer.MAX_VALUE, maxRight = Integer.MIN_VALUE;
    for (Rectangle building : buildings) {
      minLeft = Math.min(minLeft, building.left);
      maxRight = Math.max(maxRight, building.right);
    }
    List<Integer> heights
        = new ArrayList<>(Collections.nCopies(maxRight - minLeft + 1, 0));
    for (Rectangle building : buildings) {
      for (int i = building.left; i <= building.right; ++i) {
        heights.set(i - minLeft,
                    Math.max(heights.get(i - minLeft), building.height));
      }
    }
    List<Rectangle> result = new ArrayList<>();
    int left = 0;
    for (int i = 1; i < heights.size(); ++i) {
      if (heights.get(i) != heights.get(i - 1)) {
        result.add(
            new Rectangle(left + minLeft, i - 1 + minLeft, heights.get(i - 1)));
        left = i;
      }
    }
    result.add(new Rectangle(left + minLeft, maxRight,
                             heights.get(heights.size() - 1)));
    return result;
  }",method,
"    for (Rectangle building : buildings) {
      minLeft = Math.min(minLeft, building.left);
      maxRight = Math.max(maxRight, building.right);
    }",method,
"    for (Rectangle building : buildings) {
      for (int i = building.left; i <= building.right; ++i) {
        heights.set(i - minLeft,
                    Math.max(heights.get(i - minLeft), building.height));
      }
    }",method,
"      for (int i = building.left; i <= building.right; ++i) {
        heights.set(i - minLeft,
                    Math.max(heights.get(i - minLeft), building.height));
      }",method,
"  private static void checkAnswer(List<Rectangle> ans) {
    // Just check there is no overlap.
    for (int i = 0; i < ans.size(); ++i) {
      assert(ans.get(i).left <= ans.get(i).right);
      if (i > 0) {
        assert(ans.get(i - 1).right <= ans.get(i).left);
        assert(ans.get(i - 1).right != ans.get(i).left
               || ans.get(i - 1).height != ans.get(i).height);
      }
    }
  }",method,
"      if (i > 0) {
        assert(ans.get(i - 1).right <= ans.get(i).left);
        assert(ans.get(i - 1).right != ans.get(i).left
               || ans.get(i - 1).height != ans.get(i).height);
      }",method,
"  public static void main(String[] args) {
    Random r = new Random();
    for (int times = 0; times < 2000; ++times) {
      int n;
      if (args.length == 1) {
        n = Integer.parseInt(args[0]);
      } else {
        n = r.nextInt(5000) + 1;
      }
      List<Rectangle> A = new ArrayList<>();
      for (int i = 0; i < n; ++i) {
        int left = r.nextInt(1000);
        int right = r.nextInt(201) + left;
        int height = r.nextInt(100);
        A.add(new Rectangle(left, right, height));
      }
      List<Rectangle> ans = drawingSkylines(A);
      System.out.println(""n = "" + n);
      checkAnswer(ans);
    }
  }",method,
"    for (int times = 0; times < 2000; ++times) {
      int n;
      if (args.length == 1) {
        n = Integer.parseInt(args[0]);
      } else {
        n = r.nextInt(5000) + 1;
      }
      List<Rectangle> A = new ArrayList<>();
      for (int i = 0; i < n; ++i) {
        int left = r.nextInt(1000);
        int right = r.nextInt(201) + left;
        int height = r.nextInt(100);
        A.add(new Rectangle(left, right, height));
      }
      List<Rectangle> ans = drawingSkylines(A);
      System.out.println(""n = "" + n);
      checkAnswer(ans);
    }",method,
"      if (args.length == 1) {
        n = Integer.parseInt(args[0]);
      }",method,
"      for (int i = 0; i < n; ++i) {
        int left = r.nextInt(1000);
        int right = r.nextInt(201) + left;
        int height = r.nextInt(100);
        A.add(new Rectangle(left, right, height));
      }",method,
"public class UnnecessaryBlockStatementInspection extends BaseInspection implements CleanupLocalInspectionTool {
  @SuppressWarnings({""PublicField""})
  public boolean ignoreSwitchBranches = false;
  @Override
  @NotNull
  public String getID() {
    return ""UnnecessaryCodeBlock"";
  }
  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""unnecessary.code.block.display.name"");
  }
  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""unnecessary.block.statement.problem.descriptor"");
  }
  @Override
  public JComponent createOptionsPanel() {
    return new SingleCheckboxOptionsPanel(
      InspectionGadgetsBundle.message(""ignore.branches.of.switch.statements""),
      this, ""ignoreSwitchBranches"");
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new UnnecessaryBlockStatementVisitor();
  }
  @Override
  public InspectionGadgetsFix buildFix(Object... infos) {
    return new UnnecessaryBlockFix();
  }
  private static class UnnecessaryBlockFix extends InspectionGadgetsFix {
    @Override
    @NotNull
    public String getFamilyName() {
      return InspectionGadgetsBundle.message(
        ""unnecessary.code.block.unwrap.quickfix"");
    }
    @Override
    public void doFix(Project project, ProblemDescriptor descriptor) {
      final PsiElement leftBrace = descriptor.getPsiElement();
      final PsiElement parent = leftBrace.getParent();
      if (!(parent instanceof PsiCodeBlock)) {
        return;
      }
      final PsiCodeBlock block = (PsiCodeBlock)parent;
      final PsiElement firstBodyElement = block.getFirstBodyElement();
      final PsiElement lastBodyElement = block.getLastBodyElement();
      final PsiBlockStatement blockStatement = (PsiBlockStatement)block.getParent();
      if (firstBodyElement != null && lastBodyElement != null) {
        final PsiElement element = blockStatement.getParent();
        element.addRangeBefore(firstBodyElement, lastBodyElement, blockStatement);
      }
      blockStatement.delete();
    }
  }
  private class UnnecessaryBlockStatementVisitor extends BaseInspectionVisitor {
    @Override
    public void visitBlockStatement(PsiBlockStatement blockStatement) {
      super.visitBlockStatement(blockStatement);
      if (ignoreSwitchBranches) {
        final PsiElement prevStatement = PsiTreeUtil.skipWhitespacesBackward(blockStatement);
        if (prevStatement instanceof PsiSwitchLabelStatement) {
          return;
        }
      }
      final PsiElement parent = blockStatement.getParent();
      if (!(parent instanceof PsiCodeBlock)) {
        return;
      }
      final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();
      final PsiJavaToken brace = codeBlock.getLBrace();
      if (brace == null) {
        return;
      }
      final PsiCodeBlock parentBlock = (PsiCodeBlock)parent;
      if (parentBlock.getStatements().length > 1 &&
          DeclarationSearchUtils.containsConflictingDeclarations(codeBlock, parentBlock)) {
        return;
      }
      registerError(brace);
    }
  }
}",class,
"  private static class UnnecessaryBlockFix extends InspectionGadgetsFix {
    @Override
    @NotNull
    public String getFamilyName() {
      return InspectionGadgetsBundle.message(
        ""unnecessary.code.block.unwrap.quickfix"");
    }
    @Override
    public void doFix(Project project, ProblemDescriptor descriptor) {
      final PsiElement leftBrace = descriptor.getPsiElement();
      final PsiElement parent = leftBrace.getParent();
      if (!(parent instanceof PsiCodeBlock)) {
        return;
      }
      final PsiCodeBlock block = (PsiCodeBlock)parent;
      final PsiElement firstBodyElement = block.getFirstBodyElement();
      final PsiElement lastBodyElement = block.getLastBodyElement();
      final PsiBlockStatement blockStatement = (PsiBlockStatement)block.getParent();
      if (firstBodyElement != null && lastBodyElement != null) {
        final PsiElement element = blockStatement.getParent();
        element.addRangeBefore(firstBodyElement, lastBodyElement, blockStatement);
      }
      blockStatement.delete();
    }
  }",class,
"  private class UnnecessaryBlockStatementVisitor extends BaseInspectionVisitor {
    @Override
    public void visitBlockStatement(PsiBlockStatement blockStatement) {
      super.visitBlockStatement(blockStatement);
      if (ignoreSwitchBranches) {
        final PsiElement prevStatement = PsiTreeUtil.skipWhitespacesBackward(blockStatement);
        if (prevStatement instanceof PsiSwitchLabelStatement) {
          return;
        }
      }
      final PsiElement parent = blockStatement.getParent();
      if (!(parent instanceof PsiCodeBlock)) {
        return;
      }
      final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();
      final PsiJavaToken brace = codeBlock.getLBrace();
      if (brace == null) {
        return;
      }
      final PsiCodeBlock parentBlock = (PsiCodeBlock)parent;
      if (parentBlock.getStatements().length > 1 &&
          DeclarationSearchUtils.containsConflictingDeclarations(codeBlock, parentBlock)) {
        return;
      }
      registerError(brace);
    }
  }",class,
"  @Override
  @NotNull
  public String getID() {
    return ""UnnecessaryCodeBlock"";
  }",method,
"  @Override
  @NotNull
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(
      ""unnecessary.code.block.display.name"");
  }",method,
"  @Override
  @NotNull
  public String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""unnecessary.block.statement.problem.descriptor"");
  }",method,
"  @Override
  public JComponent createOptionsPanel() {
    return new SingleCheckboxOptionsPanel(
      InspectionGadgetsBundle.message(""ignore.branches.of.switch.statements""),
      this, ""ignoreSwitchBranches"");
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new UnnecessaryBlockStatementVisitor();
  }",method,
"  @Override
  public InspectionGadgetsFix buildFix(Object... infos) {
    return new UnnecessaryBlockFix();
  }",method,
"    @Override
    @NotNull
    public String getFamilyName() {
      return InspectionGadgetsBundle.message(
        ""unnecessary.code.block.unwrap.quickfix"");
    }",method,
"    @Override
    public void doFix(Project project, ProblemDescriptor descriptor) {
      final PsiElement leftBrace = descriptor.getPsiElement();
      final PsiElement parent = leftBrace.getParent();
      if (!(parent instanceof PsiCodeBlock)) {
        return;
      }
      final PsiCodeBlock block = (PsiCodeBlock)parent;
      final PsiElement firstBodyElement = block.getFirstBodyElement();
      final PsiElement lastBodyElement = block.getLastBodyElement();
      final PsiBlockStatement blockStatement = (PsiBlockStatement)block.getParent();
      if (firstBodyElement != null && lastBodyElement != null) {
        final PsiElement element = blockStatement.getParent();
        element.addRangeBefore(firstBodyElement, lastBodyElement, blockStatement);
      }
      blockStatement.delete();
    }",method,
"      if (firstBodyElement != null && lastBodyElement != null) {
        final PsiElement element = blockStatement.getParent();
        element.addRangeBefore(firstBodyElement, lastBodyElement, blockStatement);
      }",method,
"    @Override
    public void visitBlockStatement(PsiBlockStatement blockStatement) {
      super.visitBlockStatement(blockStatement);
      if (ignoreSwitchBranches) {
        final PsiElement prevStatement = PsiTreeUtil.skipWhitespacesBackward(blockStatement);
        if (prevStatement instanceof PsiSwitchLabelStatement) {
          return;
        }
      }
      final PsiElement parent = blockStatement.getParent();
      if (!(parent instanceof PsiCodeBlock)) {
        return;
      }
      final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();
      final PsiJavaToken brace = codeBlock.getLBrace();
      if (brace == null) {
        return;
      }
      final PsiCodeBlock parentBlock = (PsiCodeBlock)parent;
      if (parentBlock.getStatements().length > 1 &&
          DeclarationSearchUtils.containsConflictingDeclarations(codeBlock, parentBlock)) {
        return;
      }
      registerError(brace);
    }",method,
"      if (ignoreSwitchBranches) {
        final PsiElement prevStatement = PsiTreeUtil.skipWhitespacesBackward(blockStatement);
        if (prevStatement instanceof PsiSwitchLabelStatement) {
          return;
        }
      }",method,
"        if (prevStatement instanceof PsiSwitchLabelStatement) {
          return;
        }",method,
"      if (brace == null) {
        return;
      }",method,
"public class StatusBarShellCommand extends ShellCommand {
    private final IStatusBarService mInterface;
    public StatusBarShellCommand(StatusBarManagerService service) {
        mInterface = service;
    }
    @Override
    public int onCommand(String cmd) {
        if (cmd == null) {
            return handleDefaultCommands(cmd);
        }
        try {
            switch (cmd) {
                case ""expand-notifications"":
                    return runExpandNotifications();
                case ""expand-settings"":
                    return runExpandSettings();
                case ""collapse"":
                    return runCollapse();
                case ""add-tile"":
                    return runAddTile();
                case ""remove-tile"":
                    return runRemoveTile();
                case ""click-tile"":
                    return runClickTile();
                case ""check-support"":
                    final PrintWriter pw = getOutPrintWriter();
                    pw.println(String.valueOf(TileService.isQuickSettingsSupported()));
                    return 0;
                default:
                    return handleDefaultCommands(cmd);
            }
        } catch (RemoteException e) {
            final PrintWriter pw = getOutPrintWriter();
            pw.println(""Remote exception: "" + e);
        }
        return -1;
    }
    private int runAddTile() throws RemoteException {
        mInterface.addTile(ComponentName.unflattenFromString(getNextArgRequired()));
        return 0;
    }
    private int runRemoveTile() throws RemoteException {
        mInterface.remTile(ComponentName.unflattenFromString(getNextArgRequired()));
        return 0;
    }
    private int runClickTile() throws RemoteException {
        mInterface.clickTile(ComponentName.unflattenFromString(getNextArgRequired()));
        return 0;
    }
    private int runCollapse() throws RemoteException {
        mInterface.collapsePanels();
        return 0;
    }
    private int runExpandSettings() throws RemoteException {
        mInterface.expandSettingsPanel(null);
        return 0;
    }
    private int runExpandNotifications() throws RemoteException {
        mInterface.expandNotificationsPanel();
        return 0;
    }
    @Override
    public void onHelp() {
        final PrintWriter pw = getOutPrintWriter();
        pw.println(""Status bar commands:"");
        pw.println(""  help"");
        pw.println(""    Print this help text."");
        pw.println("""");
        pw.println(""  expand-notifications"");
        pw.println(""    Open the notifications panel."");
        pw.println("""");
        pw.println(""  expand-settings"");
        pw.println(""    Open the notifications panel and expand quick settings if present."");
        pw.println("""");
        pw.println(""  collapse"");
        pw.println(""    Collapse the notifications and settings panel."");
        pw.println("""");
        pw.println(""  add-tile COMPONENT"");
        pw.println(""    Add a TileService of the specified component"");
        pw.println("""");
        pw.println(""  remove-tile COMPONENT"");
        pw.println(""    Remove a TileService of the specified component"");
        pw.println("""");
        pw.println(""  click-tile COMPONENT"");
        pw.println(""    Click on a TileService of the specified component"");
        pw.println("""");
        pw.println(""  check-support"");
        pw.println(""    Check if this device supports QS + APIs"");
        pw.println("""");
    }
}",class,
"    public StatusBarShellCommand(StatusBarManagerService service) {
        mInterface = service;
    }",method,
"    @Override
    public int onCommand(String cmd) {
        if (cmd == null) {
            return handleDefaultCommands(cmd);
        }
        try {
            switch (cmd) {
                case ""expand-notifications"":
                    return runExpandNotifications();
                case ""expand-settings"":
                    return runExpandSettings();
                case ""collapse"":
                    return runCollapse();
                case ""add-tile"":
                    return runAddTile();
                case ""remove-tile"":
                    return runRemoveTile();
                case ""click-tile"":
                    return runClickTile();
                case ""check-support"":
                    final PrintWriter pw = getOutPrintWriter();
                    pw.println(String.valueOf(TileService.isQuickSettingsSupported()));
                    return 0;
                default:
                    return handleDefaultCommands(cmd);
            }
        } catch (RemoteException e) {
            final PrintWriter pw = getOutPrintWriter();
            pw.println(""Remote exception: "" + e);
        }
        return -1;
    }",method,
"        if (cmd == null) {
            return handleDefaultCommands(cmd);
        }",method,
"            switch (cmd) {
                case ""expand-notifications"":
                    return runExpandNotifications();
                case ""expand-settings"":
                    return runExpandSettings();
                case ""collapse"":
                    return runCollapse();
                case ""add-tile"":
                    return runAddTile();
                case ""remove-tile"":
                    return runRemoveTile();
                case ""click-tile"":
                    return runClickTile();
                case ""check-support"":
                    final PrintWriter pw = getOutPrintWriter();
                    pw.println(String.valueOf(TileService.isQuickSettingsSupported()));
                    return 0;
                default:
                    return handleDefaultCommands(cmd);
            }",method,
"    private int runAddTile() throws RemoteException {
        mInterface.addTile(ComponentName.unflattenFromString(getNextArgRequired()));
        return 0;
    }",method,
"    private int runRemoveTile() throws RemoteException {
        mInterface.remTile(ComponentName.unflattenFromString(getNextArgRequired()));
        return 0;
    }",method,
"    private int runClickTile() throws RemoteException {
        mInterface.clickTile(ComponentName.unflattenFromString(getNextArgRequired()));
        return 0;
    }",method,
"    private int runCollapse() throws RemoteException {
        mInterface.collapsePanels();
        return 0;
    }",method,
"    private int runExpandSettings() throws RemoteException {
        mInterface.expandSettingsPanel(null);
        return 0;
    }",method,
"    private int runExpandNotifications() throws RemoteException {
        mInterface.expandNotificationsPanel();
        return 0;
    }",method,
"    @Override
    public void onHelp() {
        final PrintWriter pw = getOutPrintWriter();
        pw.println(""Status bar commands:"");
        pw.println(""  help"");
        pw.println(""    Print this help text."");
        pw.println("""");
        pw.println(""  expand-notifications"");
        pw.println(""    Open the notifications panel."");
        pw.println("""");
        pw.println(""  expand-settings"");
        pw.println(""    Open the notifications panel and expand quick settings if present."");
        pw.println("""");
        pw.println(""  collapse"");
        pw.println(""    Collapse the notifications and settings panel."");
        pw.println("""");
        pw.println(""  add-tile COMPONENT"");
        pw.println(""    Add a TileService of the specified component"");
        pw.println("""");
        pw.println(""  remove-tile COMPONENT"");
        pw.println(""    Remove a TileService of the specified component"");
        pw.println("""");
        pw.println(""  click-tile COMPONENT"");
        pw.println(""    Click on a TileService of the specified component"");
        pw.println("""");
        pw.println(""  check-support"");
        pw.println(""    Check if this device supports QS + APIs"");
        pw.println("""");
    }",method,
"public class DeviceListLoader extends AsyncLoader<List<DeviceInfo>> {
  private static final String TAG = DeviceListLoader.class.getSimpleName();
  private final SignalServiceAccountManager accountManager;
  public DeviceListLoader(Context context, SignalServiceAccountManager accountManager) {
    super(context);
    this.accountManager = accountManager;
  }
  @Override
  public List<DeviceInfo> loadInBackground() {
    try {
      List<DeviceInfo>     devices  = accountManager.getDevices();
      Iterator<DeviceInfo> iterator = devices.iterator();
      while (iterator.hasNext()) {
        if ((iterator.next().getId() == SignalServiceAddress.DEFAULT_DEVICE_ID)) {
          iterator.remove();
        }
      }
      Collections.sort(devices, new DeviceInfoComparator());
      return devices;
    } catch (IOException e) {
      Log.w(TAG, e);
      return null;
    }
  }
  private static class DeviceInfoComparator implements Comparator<DeviceInfo> {
    @Override
    public int compare(DeviceInfo lhs, DeviceInfo rhs) {
      if      (lhs.getCreated() < rhs.getCreated())  return -1;
      else if (lhs.getCreated() != rhs.getCreated()) return 1;
      else                                           return 0;
    }
  }
}",class,
"  private static class DeviceInfoComparator implements Comparator<DeviceInfo> {
    @Override
    public int compare(DeviceInfo lhs, DeviceInfo rhs) {
      if      (lhs.getCreated() < rhs.getCreated())  return -1;
      else if (lhs.getCreated() != rhs.getCreated()) return 1;
      else                                           return 0;
    }
  }",class,
"  public DeviceListLoader(Context context, SignalServiceAccountManager accountManager) {
    super(context);
    this.accountManager = accountManager;
  }",method,
"  @Override
  public List<DeviceInfo> loadInBackground() {
    try {
      List<DeviceInfo>     devices  = accountManager.getDevices();
      Iterator<DeviceInfo> iterator = devices.iterator();
      while (iterator.hasNext()) {
        if ((iterator.next().getId() == SignalServiceAddress.DEFAULT_DEVICE_ID)) {
          iterator.remove();
        }
      }
      Collections.sort(devices, new DeviceInfoComparator());
      return devices;
    } catch (IOException e) {
      Log.w(TAG, e);
      return null;
    }
  }",method,
"    @Override
    public int compare(DeviceInfo lhs, DeviceInfo rhs) {
      if      (lhs.getCreated() < rhs.getCreated())  return -1;
      else if (lhs.getCreated() != rhs.getCreated()) return 1;
      else                                           return 0;
    }",method,
"public class PersistentDaemonRegistry implements DaemonRegistry {
    private final PersistentStateCache<DaemonRegistryContent> cache;
    private final Lock lock = new ReentrantLock();
    private final File registryFile;
    private static final Logger LOGGER = Logging.getLogger(PersistentDaemonRegistry.class);
    public PersistentDaemonRegistry(File registryFile, FileLockManager fileLockManager, Chmod chmod) {
        this.registryFile = registryFile;
        cache = new FileIntegrityViolationSuppressingPersistentStateCacheDecorator<DaemonRegistryContent>(
            new SimpleStateCache<DaemonRegistryContent>(
                registryFile,
                new OnDemandFileAccess(
                    registryFile,
                    ""daemon addresses registry"",
                    fileLockManager),
                DaemonRegistryContent.SERIALIZER,
                chmod
            ));
    }
    public List<DaemonInfo> getAll() {
        lock.lock();
        try {
            DaemonRegistryContent content = cache.get();
            if (content == null) {
                //when no daemon process has started yet
                return new LinkedList<DaemonInfo>();
            }
            return content.getInfos();
        } finally {
            lock.unlock();
        }
    }
    public List<DaemonInfo> getIdle() {
        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Idle;
            }
        });
    }
    public List<DaemonInfo> getNotIdle() {
        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() != Idle;
            }
        });
    }
    public List<DaemonInfo> getCanceled() {
        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Canceled;
            }
        });
    }
    private List<DaemonInfo> getDaemonsMatching(Spec<DaemonInfo> spec) {
        lock.lock();
        try {
            List<DaemonInfo> out = new LinkedList<DaemonInfo>();
            List<DaemonInfo> all = getAll();
            for (DaemonInfo d : all) {
                if (spec.isSatisfiedBy(d)) {
                    out.add(d);
                }
            }
            return out;
        } finally {
            lock.unlock();
        }
    }
    public void remove(final Address address) {
        lock.lock();
        LOGGER.debug(""Removing daemon address: {}"", address);
        try {
            cache.update(new PersistentStateCache.UpdateAction<DaemonRegistryContent>() {
                public DaemonRegistryContent update(DaemonRegistryContent oldValue) {
                    if (oldValue == null) {
                        return oldValue;
                    }
                    oldValue.removeInfo(address);
                    return oldValue;
                }
            });
        } finally {
            lock.unlock();
        }
    }
    public void markState(final Address address, final State state) {
        lock.lock();
        LOGGER.debug(""Marking busy by address: {}"", address);
        try {
            cache.update(new PersistentStateCache.UpdateAction<DaemonRegistryContent>() {
                public DaemonRegistryContent update(DaemonRegistryContent oldValue) {
                    DaemonInfo daemonInfo = oldValue != null ? oldValue.getInfo(address) : null;
                    if (daemonInfo != null) {
                        daemonInfo.setState(state);
                    }
                    // Else, has been removed by something else - ignore
                    return oldValue;
                }});
        } finally {
            lock.unlock();
        }
    }
    @Override
    public void storeStopEvent(final DaemonStopEvent stopEvent) {
        lock.lock();
        LOGGER.debug(""Storing daemon stop event with timestamp {}"", stopEvent.getTimestamp().getTime());
        try {
            cache.update(new PersistentStateCache.UpdateAction<DaemonRegistryContent>() {
                public DaemonRegistryContent update(DaemonRegistryContent content) {
                    if (content == null) { // registry doesn't exist yet
                        content = new DaemonRegistryContent();
                    }
                    content.addStopEvent(stopEvent);
                    return content;
                }
            });
        } finally {
            lock.unlock();
        }
    }
    @Override
    public List<DaemonStopEvent> getStopEvents() {
        lock.lock();
        LOGGER.debug(""Getting daemon stop events"");
        try {
            DaemonRegistryContent content = cache.get();
            if (content == null) { // no daemon process has started yet
                return new LinkedList<DaemonStopEvent>();
            }
            return content.getStopEvents();
        } finally {
            lock.unlock();
        }
    }
    @Override
    public void removeStopEvents(final Collection<DaemonStopEvent> events) {
        lock.lock();
        LOGGER.info(""Removing {} daemon stop events from registry"", events.size());
        try {
            cache.update(new PersistentStateCache.UpdateAction<DaemonRegistryContent>() {
                public DaemonRegistryContent update(DaemonRegistryContent content) {
                    if (content != null) { // no daemon process has started yet
                        content.removeStopEvents(events);
                    }
                    return content;
                }
            });
        } finally {
            lock.unlock();
        }
    }
    public void store(final DaemonInfo info) {
        final Address address = info.getAddress();
        final DaemonContext daemonContext = info.getContext();
        final byte[] token = info.getToken();
        final State state = info.getState();
        lock.lock();
        LOGGER.debug(""Storing daemon address: {}, context: {}"", address, daemonContext);
        try {
            cache.update(new PersistentStateCache.UpdateAction<DaemonRegistryContent>() {
                public DaemonRegistryContent update(DaemonRegistryContent oldValue) {
                    if (oldValue == null) {
                        //it means the registry didn't exist yet
                        oldValue = new DaemonRegistryContent();
                    }
                    DaemonInfo daemonInfo = new DaemonInfo(address, daemonContext, token, state);
                    oldValue.setStatus(address, daemonInfo);
                    return oldValue;
                }
            });
        } finally {
            lock.unlock();
        }
    }
    public String toString() {
        return String.format(""PersistentDaemonRegistry[file=%s]"", registryFile);
    }
}",class,
"public class BadlyFormedRequestException extends RuntimeException {
    public BadlyFormedRequestException(String message) {
        super(message);
    }
}",class,
"    public PersistentDaemonRegistry(File registryFile, FileLockManager fileLockManager, Chmod chmod) {
        this.registryFile = registryFile;
        cache = new FileIntegrityViolationSuppressingPersistentStateCacheDecorator<DaemonRegistryContent>(
            new SimpleStateCache<DaemonRegistryContent>(
                registryFile,
                new OnDemandFileAccess(
                    registryFile,
                    ""daemon addresses registry"",
                    fileLockManager),
                DaemonRegistryContent.SERIALIZER,
                chmod
            ));
    }",method,
"    public List<DaemonInfo> getAll() {
        lock.lock();
        try {
            DaemonRegistryContent content = cache.get();
            if (content == null) {
                //when no daemon process has started yet
                return new LinkedList<DaemonInfo>();
            }
            return content.getInfos();
        } finally {
            lock.unlock();
        }
    }",method,
"            if (content == null) {
                //when no daemon process has started yet
                return new LinkedList<DaemonInfo>();
            }",method,
"    public List<DaemonInfo> getIdle() {
        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Idle;
            }
        });
    }",method,
"        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Idle;
            }
        }",method,
"            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Idle;
            }",method,
"    public List<DaemonInfo> getNotIdle() {
        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() != Idle;
            }
        });
    }",method,
"        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() != Idle;
            }
        }",method,
"            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() != Idle;
            }",method,
"    public List<DaemonInfo> getCanceled() {
        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Canceled;
            }
        });
    }",method,
"        return getDaemonsMatching(new Spec<DaemonInfo>() {
            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Canceled;
            }
        }",method,
"            @Override
            public boolean isSatisfiedBy(DaemonInfo daemonInfo) {
                return daemonInfo.getState() == Canceled;
            }",method,
"    private List<DaemonInfo> getDaemonsMatching(Spec<DaemonInfo> spec) {
        lock.lock();
        try {
            List<DaemonInfo> out = new LinkedList<DaemonInfo>();
            List<DaemonInfo> all = getAll();
            for (DaemonInfo d : all) {
                if (spec.isSatisfiedBy(d)) {
                    out.add(d);
                }
            }
            return out;
        } finally {
            lock.unlock();
        }
    }",method,
"            for (DaemonInfo d : all) {
                if (spec.isSatisfiedBy(d)) {
                    out.add(d);
                }
            }",method,
"    public void remove(final Address address) {
        lock.lock();
        LOGGER.debug(""Removing daemon address: {}"", address);
        try {
            cache.update(new PersistentStateCache.UpdateAction<DaemonRegistryContent>() {
                public DaemonRegistryContent update(DaemonRegistryContent oldValue) {
                    if (oldValue == null) {
                        return oldValue;
                    }
                    oldValue.removeInfo(address);
                    return oldValue;
                }
            });
        } finally {
            lock.unlock();
        }
    }",method,
"            cache.update(new PersistentStateCache.UpdateAction<DaemonRegistryContent>() {
                public DaemonRegistryContent update(DaemonRegistryContent oldValue) {
                    if (oldValue == null) {
                        return oldValue;
                    }
                    oldValue.removeInfo(address);
                    return oldValue;
                }
            }",method,

code_snippet,type,score
"  private static void copy(File src, File dest) throws FileNotFoundException, IOException {
    FileOutputStream fos = null;
    FileInputStream fis = null;
    try {
      createParentDir(dest);
      fos = new FileOutputStream(dest);
      fis = new FileInputStream(src);
      fos.getChannel().transferFrom(fis.getChannel(), 0, Long.MAX_VALUE);
    } finally {
      if (fos != null)
        fos.close();
      if (fis != null)
        fis.close();
    }
  }",method,
"  private static File createParentDir(File file) throws IOException {
    File dir = file.getParentFile();
    if (!(dir.isDirectory() || dir.mkdirs()))
      throw new IOException(""Could not create dir: "" + dir.getAbsolutePath());
    else
      return file;
  }",method,
"  public static File getCacheFile(File baseDir, ArtifactHash hash, String filename) {
    assert (hash.value.length() == HASH_LENGTH); // we are slicing later and
                                                 // need at least 8 chars
    File artifactDir = new File(baseDir, ARTIFACT_CACHE_DIR);
    File level1 = new File(artifactDir, hash.value.subSequence(0, LEVEL_1_LENGTH).toString());
    File level2 = new File(level1, hash.value.subSequence(LEVEL_1_LENGTH, LEVEL_1_LENGTH + LEVEL_2_LENGTH).toString());
    File level3 = new File(level2, hash.value.subSequence(LEVEL_1_LENGTH + LEVEL_2_LENGTH, HASH_LENGTH).toString());
    return new File(level3, filename);
  }",method,
"  private static String hashFile(File file) throws IOException {
    FileInputStream fis = new FileInputStream(file);
    try {
      return Hasher.hash(fis);
    } finally {
      fis.close();
    }
  }",method,
"  public static File getOrCreateExistingCacheFile(File baseDir, ArtifactHash hash, String filename, boolean verify)
      throws IOException {
    File currentCacheFile = getCacheFile(baseDir, hash, filename);
    if (currentCacheFile.isFile()) {
      if (verify)
        assert (hashFile(currentCacheFile).equals(hash.value));
      return currentCacheFile;
    } else { // cache file is not there, but perhaps there is one with a
             // different name?
      File parentDir = currentCacheFile.getParentFile();
      if (parentDir != null && parentDir.listFiles() != null) {
        for (File file : parentDir.listFiles()) {
          if (!verify || hashFile(file).equals(hash.value)) {
            copy(file, currentCacheFile);
            return currentCacheFile;
          }
        }
        return null;
      } else {
        return null;
      }
    }
  }",method,
"  public static File cache(File baseDir, File srcFile, ArtifactHash expectedHash, String filename) throws AdeptCacheException,
      IOException {
    String actualHash = hashFile(srcFile);
    if (!actualHash.equals(expectedHash.value))
      throw new AdeptCacheException(""Expected file: "" + srcFile.getAbsolutePath() + "" (with new name: "" + filename
          + "") to have hash: "" + expectedHash.value + "" but it was: "" + actualHash);
    else {
      File existingCacheFile = getOrCreateExistingCacheFile(baseDir, expectedHash, filename, true);
      if (existingCacheFile == null) {
        File newCacheFile = getCacheFile(baseDir, expectedHash, filename);
        copy(srcFile, newCacheFile);
        return newCacheFile;
      } else
        return existingCacheFile;
    }
  }",method,
"      if (existingCacheFile == null) {
        File newCacheFile = getCacheFile(baseDir, expectedHash, filename);
        copy(srcFile, newCacheFile);
        return newCacheFile;
      }",method,
"public class MySqlIgnoreIndexHint extends MySqlIndexHintImpl {
    @Override
    public void accept0(MySqlASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, getIndexList());
        }
        visitor.endVisit(this);
    }
    public MySqlIgnoreIndexHint clone() {
        MySqlIgnoreIndexHint x = new MySqlIgnoreIndexHint();
        cloneTo(x);
        return x;
    }
}",class,
"    @Override
    public void accept0(MySqlASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, getIndexList());
        }
        visitor.endVisit(this);
    }",method,
"    public MySqlIgnoreIndexHint clone() {
        MySqlIgnoreIndexHint x = new MySqlIgnoreIndexHint();
        cloneTo(x);
        return x;
    }",method,
"        Option(String name) {
            this.name = name;
            this.name_lcase = name.toLowerCase();
        }",method,
"public class PruneCountAggregationOverScalar
        implements Rule<AggregationNode>
{
    private static final Pattern<AggregationNode> PATTERN = aggregation();
    @Override
    public Pattern<AggregationNode> getPattern()
    {
        return PATTERN;
    }
    @Override
    public Result apply(AggregationNode parent, Captures captures, Context context)
    {
        if (!parent.hasDefaultOutput() || parent.getOutputSymbols().size() != 1) {
            return Result.empty();
        }
        Map<Symbol, AggregationNode.Aggregation> assignments = parent.getAggregations();
        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : assignments.entrySet()) {
            AggregationNode.Aggregation aggregation = entry.getValue();
            requireNonNull(aggregation, ""aggregation is null"");
            Signature signature = aggregation.getSignature();
            FunctionCall functionCall = aggregation.getCall();
            if (!""count"".equals(signature.getName()) || !functionCall.getArguments().isEmpty()) {
                return Result.empty();
            }
        }
        if (!assignments.isEmpty() && isScalar(parent.getSource(), context.getLookup())) {
            return Result.ofPlanNode(new ValuesNode(parent.getId(), parent.getOutputSymbols(), ImmutableList.of(ImmutableList.of(new LongLiteral(""1"")))));
        }
        return Result.empty();
    }
}",class,
"    @Override
    public Pattern<AggregationNode> getPattern()
    {
        return PATTERN;
    }",method,
"    @Override
    public Result apply(AggregationNode parent, Captures captures, Context context)
    {
        if (!parent.hasDefaultOutput() || parent.getOutputSymbols().size() != 1) {
            return Result.empty();
        }
        Map<Symbol, AggregationNode.Aggregation> assignments = parent.getAggregations();
        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : assignments.entrySet()) {
            AggregationNode.Aggregation aggregation = entry.getValue();
            requireNonNull(aggregation, ""aggregation is null"");
            Signature signature = aggregation.getSignature();
            FunctionCall functionCall = aggregation.getCall();
            if (!""count"".equals(signature.getName()) || !functionCall.getArguments().isEmpty()) {
                return Result.empty();
            }
        }
        if (!assignments.isEmpty() && isScalar(parent.getSource(), context.getLookup())) {
            return Result.ofPlanNode(new ValuesNode(parent.getId(), parent.getOutputSymbols(), ImmutableList.of(ImmutableList.of(new LongLiteral(""1"")))));
        }
        return Result.empty();
    }",method,
"import java.util.concurrent.ConcurrentHashMap;
class JpsUtils {
    private static final Map<ModuleBuildTarget, Boolean> IS_KOTLIN_JS_MODULE_CACHE = new ConcurrentHashMap<ModuleBuildTarget, Boolean>();
    private static final Map<String, Boolean> IS_KOTLIN_JS_STDLIB_JAR_CACHE = new ConcurrentHashMap<String, Boolean>();
    private JpsUtils() {}
    @NotNull
    static JpsJavaDependenciesEnumerator getAllDependencies(@NotNull ModuleBuildTarget target) {
        return JpsJavaExtensionService.dependencies(target.getModule()).recursively().exportedOnly()
                .includedIn(JpsJavaClasspathKind.compile(target.isTests()));
    }
    static boolean isJsKotlinModule(@NotNull ModuleBuildTarget target) {
        Boolean cachedValue = IS_KOTLIN_JS_MODULE_CACHE.get(target);
        if (cachedValue != null) return cachedValue;
        boolean isKotlinJsModule = isJsKotlinModuleImpl(target);
        IS_KOTLIN_JS_MODULE_CACHE.put(target, isKotlinJsModule);
        return isKotlinJsModule;
    }
    private static boolean isJsKotlinModuleImpl(@NotNull ModuleBuildTarget target) {
        TargetPlatformKind<?> targetPlatform = JpsKotlinCompilerSettingsKt.getTargetPlatform(target.getModule());
        if (targetPlatform != null) return targetPlatform == TargetPlatformKind.JavaScript.INSTANCE;
        Set<JpsLibrary> libraries = getAllDependencies(target).getLibraries();
        for (JpsLibrary library : libraries) {
            for (JpsLibraryRoot root : library.getRoots(JpsOrderRootType.COMPILED)) {
                String url = root.getUrl();
                Boolean cachedValue = IS_KOTLIN_JS_STDLIB_JAR_CACHE.get(url);
                if (cachedValue != null) {
                    if (cachedValue.booleanValue()) return true;
                    else continue;
                }
                boolean isKotlinJavascriptStdLibrary = LibraryUtils.isKotlinJavascriptStdLibrary(JpsPathUtil.urlToFile(url));
                IS_KOTLIN_JS_STDLIB_JAR_CACHE.put(url, isKotlinJavascriptStdLibrary);
                if (isKotlinJavascriptStdLibrary) return true;
            }
        }
        return false;
    }
    @TestOnly
    static void resetCaches() {
        IS_KOTLIN_JS_MODULE_CACHE.clear();
        IS_KOTLIN_JS_STDLIB_JAR_CACHE.clear();
    }
}",class,
    private JpsUtils() {},method,
"    @NotNull
    static JpsJavaDependenciesEnumerator getAllDependencies(@NotNull ModuleBuildTarget target) {
        return JpsJavaExtensionService.dependencies(target.getModule()).recursively().exportedOnly()
                .includedIn(JpsJavaClasspathKind.compile(target.isTests()));
    }",method,
"    static boolean isJsKotlinModule(@NotNull ModuleBuildTarget target) {
        Boolean cachedValue = IS_KOTLIN_JS_MODULE_CACHE.get(target);
        if (cachedValue != null) return cachedValue;
        boolean isKotlinJsModule = isJsKotlinModuleImpl(target);
        IS_KOTLIN_JS_MODULE_CACHE.put(target, isKotlinJsModule);
        return isKotlinJsModule;
    }",method,
"    private static boolean isJsKotlinModuleImpl(@NotNull ModuleBuildTarget target) {
        TargetPlatformKind<?> targetPlatform = JpsKotlinCompilerSettingsKt.getTargetPlatform(target.getModule());
        if (targetPlatform != null) return targetPlatform == TargetPlatformKind.JavaScript.INSTANCE;
        Set<JpsLibrary> libraries = getAllDependencies(target).getLibraries();
        for (JpsLibrary library : libraries) {
            for (JpsLibraryRoot root : library.getRoots(JpsOrderRootType.COMPILED)) {
                String url = root.getUrl();
                Boolean cachedValue = IS_KOTLIN_JS_STDLIB_JAR_CACHE.get(url);
                if (cachedValue != null) {
                    if (cachedValue.booleanValue()) return true;
                    else continue;
                }
                boolean isKotlinJavascriptStdLibrary = LibraryUtils.isKotlinJavascriptStdLibrary(JpsPathUtil.urlToFile(url));
                IS_KOTLIN_JS_STDLIB_JAR_CACHE.put(url, isKotlinJavascriptStdLibrary);
                if (isKotlinJavascriptStdLibrary) return true;
            }
        }
        return false;
    }",method,
"        for (JpsLibrary library : libraries) {
            for (JpsLibraryRoot root : library.getRoots(JpsOrderRootType.COMPILED)) {
                String url = root.getUrl();
                Boolean cachedValue = IS_KOTLIN_JS_STDLIB_JAR_CACHE.get(url);
                if (cachedValue != null) {
                    if (cachedValue.booleanValue()) return true;
                    else continue;
                }
                boolean isKotlinJavascriptStdLibrary = LibraryUtils.isKotlinJavascriptStdLibrary(JpsPathUtil.urlToFile(url));
                IS_KOTLIN_JS_STDLIB_JAR_CACHE.put(url, isKotlinJavascriptStdLibrary);
                if (isKotlinJavascriptStdLibrary) return true;
            }
        }",method,
"                if (cachedValue != null) {
                    if (cachedValue.booleanValue()) return true;
                    else continue;
                }",method,
"    @TestOnly
    static void resetCaches() {
        IS_KOTLIN_JS_MODULE_CACHE.clear();
        IS_KOTLIN_JS_STDLIB_JAR_CACHE.clear();
    }",method,
"  public DFAMap<ScopeVariable> fun(final DFAMap<ScopeVariable> map, final Instruction instruction) {
    final PsiElement element = instruction.getElement();
    if (element == null || ((PyFile) element.getContainingFile()).getLanguageLevel().isPython2()){
      return processReducedMap(map, instruction, element);
    }
    // Scope reduction
    final DFAMap<ScopeVariable> reducedMap = new DFAMap<>();
    for (Map.Entry<String, ScopeVariable> entry : map.entrySet()) {
      final ScopeVariable value = entry.getValue();
      // Support PEP-3110. (PY-1408)
      if (value.isParameter()){
        final PsiElement declaration = value.getDeclarations().iterator().next();
        final PyExceptPart exceptPart = PyExceptPartNavigator.getPyExceptPartByTarget(declaration);
        if (exceptPart != null){
          if (!PsiTreeUtil.isAncestor(exceptPart, element, false)){
            continue;
          }
        }
      } 
      reducedMap.put(entry.getKey(), value);
    }
    return processReducedMap(reducedMap, instruction, element);
  }",method,
"        if (exceptPart != null){
          if (!PsiTreeUtil.isAncestor(exceptPart, element, false)){
            continue;
          }
        }",method,
"  private DFAMap<ScopeVariable> processReducedMap(DFAMap<ScopeVariable> map,
                                                  final Instruction instruction,
                                                  final PsiElement element) {
    String name = null;
    // Process readwrite instruction
    if (instruction instanceof ReadWriteInstruction && ((ReadWriteInstruction)instruction).getAccess().isWriteAccess()) {
      name = ((ReadWriteInstruction)instruction).getName();
    }
    // Processing PyFunction
    else if (element instanceof PyFunction){
      name = ((PyFunction)element).getName();
    }
    if (name == null){
      return map;
    }
    final ScopeVariable variable = map.get(name);
    // Parameter case
    final PsiElement parameterScope = ScopeUtil.getParameterScope(element);
    if (parameterScope != null) {
      final ScopeVariable scopeVariable = new ScopeVariableImpl(name, true, element);
      map = map.asWritable();
      map.put(name, scopeVariable);
    }
    // Local variable case
    else {
      final ScopeVariableImpl scopeVariable;
      final boolean isParameter = variable != null && variable.isParameter();
      if (variable == null) {
        scopeVariable = new ScopeVariableImpl(name, isParameter, element);
      } else {
        scopeVariable = new ScopeVariableImpl(name, isParameter, variable.getDeclarations());
      }
      map = map.asWritable();
      map.put(name, scopeVariable);
    }
    return map;
  }",method,
"    else if (element instanceof PyFunction){
      name = ((PyFunction)element).getName();
    }",method,
"    if (name == null){
      return map;
    }",method,
"    if (parameterScope != null) {
      final ScopeVariable scopeVariable = new ScopeVariableImpl(name, true, element);
      map = map.asWritable();
      map.put(name, scopeVariable);
    }",method,
"      if (variable == null) {
        scopeVariable = new ScopeVariableImpl(name, isParameter, element);
      }",method,
"  @NotNull
  public DFAMap<ScopeVariable> initial() {
    return INITIAL_MAP;
  }",method,
"  public boolean isForward() {
    return true;
  }",method,
"public class MultisetsImmutableEntryTest extends TestCase {
  private static final String NE = null;
  private static <E> Entry<E> entry(final E element, final int count) {
    return Multisets.immutableEntry(element, count);
  }
  private static <E> Entry<E> control(E element, int count) {
    return HashMultiset.create(Collections.nCopies(count, element))
        .entrySet().iterator().next();
  }
  public void testToString() {
    assertEquals(""foo"", entry(""foo"", 1).toString());
    assertEquals(""bar x 2"", entry(""bar"", 2).toString());
  }
  public void testToStringNull() {
    assertEquals(""null"", entry(NE, 1).toString());
    assertEquals(""null x 2"", entry(NE, 2).toString());
  }
  public void testEquals() {
    assertEquals(control(""foo"", 1), entry(""foo"", 1));
    assertEquals(control(""bar"", 2), entry(""bar"", 2));
    assertFalse(control(""foo"", 1).equals(entry(""foo"", 2)));
    assertFalse(entry(""foo"", 1).equals(control(""bar"", 1)));
    assertFalse(entry(""foo"", 1).equals(new Object()));
    assertFalse(entry(""foo"", 1).equals(null));
  }
  public void testEqualsNull() {
    assertEquals(control(NE, 1), entry(NE, 1));
    assertFalse(control(NE, 1).equals(entry(NE, 2)));
    assertFalse(entry(NE, 1).equals(control(""bar"", 1)));
    assertFalse(entry(NE, 1).equals(new Object()));
    assertFalse(entry(NE, 1).equals(null));
  }
  public void testHashCode() {
    assertEquals(control(""foo"", 1).hashCode(), entry(""foo"", 1).hashCode());
    assertEquals(control(""bar"", 2).hashCode(), entry(""bar"", 2).hashCode());
  }
  public void testHashCodeNull() {
    assertEquals(control(NE, 1).hashCode(), entry(NE, 1).hashCode());
  }
  public void testNegativeCount() {
    try {
      entry(""foo"", -1);
      fail();
    } catch (IllegalArgumentException expected) {}
  }
}",class,
"  private static <E> Entry<E> entry(final E element, final int count) {
    return Multisets.immutableEntry(element, count);
  }",method,
"  private static <E> Entry<E> control(E element, int count) {
    return HashMultiset.create(Collections.nCopies(count, element))
        .entrySet().iterator().next();
  }",method,
"  public void testToString() {
    assertEquals(""foo"", entry(""foo"", 1).toString());
    assertEquals(""bar x 2"", entry(""bar"", 2).toString());
  }",method,
"  public void testToStringNull() {
    assertEquals(""null"", entry(NE, 1).toString());
    assertEquals(""null x 2"", entry(NE, 2).toString());
  }",method,
"  public void testEquals() {
    assertEquals(control(""foo"", 1), entry(""foo"", 1));
    assertEquals(control(""bar"", 2), entry(""bar"", 2));
    assertFalse(control(""foo"", 1).equals(entry(""foo"", 2)));
    assertFalse(entry(""foo"", 1).equals(control(""bar"", 1)));
    assertFalse(entry(""foo"", 1).equals(new Object()));
    assertFalse(entry(""foo"", 1).equals(null));
  }",method,
"  public void testEqualsNull() {
    assertEquals(control(NE, 1), entry(NE, 1));
    assertFalse(control(NE, 1).equals(entry(NE, 2)));
    assertFalse(entry(NE, 1).equals(control(""bar"", 1)));
    assertFalse(entry(NE, 1).equals(new Object()));
    assertFalse(entry(NE, 1).equals(null));
  }",method,
"  public void testHashCode() {
    assertEquals(control(""foo"", 1).hashCode(), entry(""foo"", 1).hashCode());
    assertEquals(control(""bar"", 2).hashCode(), entry(""bar"", 2).hashCode());
  }",method,
"  public void testHashCodeNull() {
    assertEquals(control(NE, 1).hashCode(), entry(NE, 1).hashCode());
  }",method,
"  public void testNegativeCount() {
    try {
      entry(""foo"", -1);
      fail();
    } catch (IllegalArgumentException expected) {}
  }",method,
"public class Neo4jDataAutoConfigurationTests {
	private WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
			.withUserConfiguration(TestConfiguration.class)
			.withConfiguration(AutoConfigurations.of(Neo4jDataAutoConfiguration.class,
					TransactionAutoConfiguration.class));
	@Test
	public void defaultConfiguration() {
		this.contextRunner
				.withPropertyValues(""spring.data.neo4j.uri=http://localhost:8989"")
				.run((context) -> {
					assertThat(context)
							.hasSingleBean(org.neo4j.ogm.config.Configuration.class);
					assertThat(context).hasSingleBean(SessionFactory.class);
					assertThat(context).hasSingleBean(Neo4jTransactionManager.class);
					assertThat(context).hasSingleBean(OpenSessionInViewInterceptor.class);
				});
	}
	@Test
	public void customNeo4jTransactionManagerUsingProperties() {
		this.contextRunner
				.withPropertyValues(""spring.transaction.default-timeout=30"",
						""spring.transaction.rollback-on-commit-failure:true"")
				.run((context) -> {
					Neo4jTransactionManager transactionManager = context
							.getBean(Neo4jTransactionManager.class);
					assertThat(transactionManager.getDefaultTimeout()).isEqualTo(30);
					assertThat(transactionManager.isRollbackOnCommitFailure()).isTrue();
				});
	}
	@Test
	public void customSessionFactory() {
		this.contextRunner.withUserConfiguration(CustomSessionFactory.class)
				.run((context) -> {
					assertThat(context)
							.doesNotHaveBean(org.neo4j.ogm.config.Configuration.class);
					assertThat(context).hasSingleBean(SessionFactory.class);
				});
	}
	@Test
	public void customConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class)
				.run((context) -> {
					assertThat(context.getBean(org.neo4j.ogm.config.Configuration.class))
							.isSameAs(context.getBean(""myConfiguration""));
					assertThat(context).hasSingleBean(SessionFactory.class);
					assertThat(context)
							.hasSingleBean(org.neo4j.ogm.config.Configuration.class);
				});
	}
	@Test
	public void usesAutoConfigurationPackageToPickUpDomainTypes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		String cityPackage = City.class.getPackage().getName();
		AutoConfigurationPackages.register(context, cityPackage);
		context.register(Neo4jDataAutoConfiguration.class,
				Neo4jRepositoriesAutoConfiguration.class);
		try {
			context.refresh();
			assertDomainTypesDiscovered(context.getBean(Neo4jMappingContext.class),
					City.class);
		}
		finally {
			context.close();
		}
	}
	@Test
	public void openSessionInViewInterceptorCanBeDisabled() {
		this.contextRunner.withPropertyValues(""spring.data.neo4j.open-in-view:false"")
				.run((context) -> assertThat(context)
						.doesNotHaveBean(OpenSessionInViewInterceptor.class));
	}
	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}",class,
"	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",class,
"	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",class,
"	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",class,
"	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",class,
"	@Test
	public void defaultConfiguration() {
		this.contextRunner
				.withPropertyValues(""spring.data.neo4j.uri=http://localhost:8989"")
				.run((context) -> {
					assertThat(context)
							.hasSingleBean(org.neo4j.ogm.config.Configuration.class);
					assertThat(context).hasSingleBean(SessionFactory.class);
					assertThat(context).hasSingleBean(Neo4jTransactionManager.class);
					assertThat(context).hasSingleBean(OpenSessionInViewInterceptor.class);
				});
	}
	@Test
	public void customNeo4jTransactionManagerUsingProperties() {
		this.contextRunner
				.withPropertyValues(""spring.transaction.default-timeout=30"",
						""spring.transaction.rollback-on-commit-failure:true"")
				.run((context) -> {
					Neo4jTransactionManager transactionManager = context
							.getBean(Neo4jTransactionManager.class);
					assertThat(transactionManager.getDefaultTimeout()).isEqualTo(30);
					assertThat(transactionManager.isRollbackOnCommitFailure()).isTrue();
				});
	}
	@Test
	public void customSessionFactory() {
		this.contextRunner.withUserConfiguration(CustomSessionFactory.class)
				.run((context) -> {
					assertThat(context)
							.doesNotHaveBean(org.neo4j.ogm.config.Configuration.class);
					assertThat(context).hasSingleBean(SessionFactory.class);
				});
	}
	@Test
	public void customConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class)
				.run((context) -> {
					assertThat(context.getBean(org.neo4j.ogm.config.Configuration.class))
							.isSameAs(context.getBean(""myConfiguration""));
					assertThat(context).hasSingleBean(SessionFactory.class);
					assertThat(context)
							.hasSingleBean(org.neo4j.ogm.config.Configuration.class);
				});
	}
	@Test
	public void usesAutoConfigurationPackageToPickUpDomainTypes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		String cityPackage = City.class.getPackage().getName();
		AutoConfigurationPackages.register(context, cityPackage);
		context.register(Neo4jDataAutoConfiguration.class,
				Neo4jRepositoriesAutoConfiguration.class);
		try {
			context.refresh();
			assertDomainTypesDiscovered(context.getBean(Neo4jMappingContext.class),
					City.class);
		}
		finally {
			context.close();
		}
	}
	@Test
	public void openSessionInViewInterceptorCanBeDisabled() {
		this.contextRunner.withPropertyValues(""spring.data.neo4j.open-in-view:false"")
				.run((context) -> assertThat(context)
						.doesNotHaveBean(OpenSessionInViewInterceptor.class));
	}
	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}",method,
"	@Test
	public void customNeo4jTransactionManagerUsingProperties() {
		this.contextRunner
				.withPropertyValues(""spring.transaction.default-timeout=30"",
						""spring.transaction.rollback-on-commit-failure:true"")
				.run((context) -> {
					Neo4jTransactionManager transactionManager = context
							.getBean(Neo4jTransactionManager.class);
					assertThat(transactionManager.getDefaultTimeout()).isEqualTo(30);
					assertThat(transactionManager.isRollbackOnCommitFailure()).isTrue();
				});
	}
	@Test
	public void customSessionFactory() {
		this.contextRunner.withUserConfiguration(CustomSessionFactory.class)
				.run((context) -> {
					assertThat(context)
							.doesNotHaveBean(org.neo4j.ogm.config.Configuration.class);
					assertThat(context).hasSingleBean(SessionFactory.class);
				});
	}
	@Test
	public void customConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class)
				.run((context) -> {
					assertThat(context.getBean(org.neo4j.ogm.config.Configuration.class))
							.isSameAs(context.getBean(""myConfiguration""));
					assertThat(context).hasSingleBean(SessionFactory.class);
					assertThat(context)
							.hasSingleBean(org.neo4j.ogm.config.Configuration.class);
				});
	}
	@Test
	public void usesAutoConfigurationPackageToPickUpDomainTypes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		String cityPackage = City.class.getPackage().getName();
		AutoConfigurationPackages.register(context, cityPackage);
		context.register(Neo4jDataAutoConfiguration.class,
				Neo4jRepositoriesAutoConfiguration.class);
		try {
			context.refresh();
			assertDomainTypesDiscovered(context.getBean(Neo4jMappingContext.class),
					City.class);
		}
		finally {
			context.close();
		}
	}
	@Test
	public void openSessionInViewInterceptorCanBeDisabled() {
		this.contextRunner.withPropertyValues(""spring.data.neo4j.open-in-view:false"")
				.run((context) -> assertThat(context)
						.doesNotHaveBean(OpenSessionInViewInterceptor.class));
	}
	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"	@Test
	public void customSessionFactory() {
		this.contextRunner.withUserConfiguration(CustomSessionFactory.class)
				.run((context) -> {
					assertThat(context)
							.doesNotHaveBean(org.neo4j.ogm.config.Configuration.class);
					assertThat(context).hasSingleBean(SessionFactory.class);
				});
	}
	@Test
	public void customConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class)
				.run((context) -> {
					assertThat(context.getBean(org.neo4j.ogm.config.Configuration.class))
							.isSameAs(context.getBean(""myConfiguration""));
					assertThat(context).hasSingleBean(SessionFactory.class);
					assertThat(context)
							.hasSingleBean(org.neo4j.ogm.config.Configuration.class);
				});
	}
	@Test
	public void usesAutoConfigurationPackageToPickUpDomainTypes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		String cityPackage = City.class.getPackage().getName();
		AutoConfigurationPackages.register(context, cityPackage);
		context.register(Neo4jDataAutoConfiguration.class,
				Neo4jRepositoriesAutoConfiguration.class);
		try {
			context.refresh();
			assertDomainTypesDiscovered(context.getBean(Neo4jMappingContext.class),
					City.class);
		}
		finally {
			context.close();
		}
	}
	@Test
	public void openSessionInViewInterceptorCanBeDisabled() {
		this.contextRunner.withPropertyValues(""spring.data.neo4j.open-in-view:false"")
				.run((context) -> assertThat(context)
						.doesNotHaveBean(OpenSessionInViewInterceptor.class));
	}
	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"	@Test
	public void customConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class)
				.run((context) -> {
					assertThat(context.getBean(org.neo4j.ogm.config.Configuration.class))
							.isSameAs(context.getBean(""myConfiguration""));
					assertThat(context).hasSingleBean(SessionFactory.class);
					assertThat(context)
							.hasSingleBean(org.neo4j.ogm.config.Configuration.class);
				});
	}
	@Test
	public void usesAutoConfigurationPackageToPickUpDomainTypes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		String cityPackage = City.class.getPackage().getName();
		AutoConfigurationPackages.register(context, cityPackage);
		context.register(Neo4jDataAutoConfiguration.class,
				Neo4jRepositoriesAutoConfiguration.class);
		try {
			context.refresh();
			assertDomainTypesDiscovered(context.getBean(Neo4jMappingContext.class),
					City.class);
		}
		finally {
			context.close();
		}
	}
	@Test
	public void openSessionInViewInterceptorCanBeDisabled() {
		this.contextRunner.withPropertyValues(""spring.data.neo4j.open-in-view:false"")
				.run((context) -> assertThat(context)
						.doesNotHaveBean(OpenSessionInViewInterceptor.class));
	}
	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"	@Test
	public void usesAutoConfigurationPackageToPickUpDomainTypes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		String cityPackage = City.class.getPackage().getName();
		AutoConfigurationPackages.register(context, cityPackage);
		context.register(Neo4jDataAutoConfiguration.class,
				Neo4jRepositoriesAutoConfiguration.class);
		try {
			context.refresh();
			assertDomainTypesDiscovered(context.getBean(Neo4jMappingContext.class),
					City.class);
		}
		finally {
			context.close();
		}
	}
	@Test
	public void openSessionInViewInterceptorCanBeDisabled() {
		this.contextRunner.withPropertyValues(""spring.data.neo4j.open-in-view:false"")
				.run((context) -> assertThat(context)
						.doesNotHaveBean(OpenSessionInViewInterceptor.class));
	}
	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"	@Test
	public void openSessionInViewInterceptorCanBeDisabled() {
		this.contextRunner.withPropertyValues(""spring.data.neo4j.open-in-view:false"")
				.run((context) -> assertThat(context)
						.doesNotHaveBean(OpenSessionInViewInterceptor.class));
	}
	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"	@Test
	public void eventListenersAreAutoRegistered() {
		this.contextRunner.withUserConfiguration(EventListenerConfiguration.class)
				.run((context) -> {
					Session session = context.getBean(SessionFactory.class).openSession();
					session.notifyListeners(
							new PersistenceEvent(null, Event.TYPE.PRE_SAVE));
					verify(context.getBean(""eventListenerOne"", EventListener.class))
							.onPreSave(any(Event.class));
					verify(context.getBean(""eventListenerTwo"", EventListener.class))
							.onPreSave(any(Event.class));
				});
	}
	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"	private static void assertDomainTypesDiscovered(Neo4jMappingContext mappingContext,
			Class<?>... types) {
		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"		for (Class<?> type : types) {
			assertThat(mappingContext.getPersistentEntity(type)).isNotNull();
		}
	}
	@Configuration
	@EntityScan(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration
	static class CustomSessionFactory {
		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"		@Bean
		public SessionFactory customSessionFactory() {
			return mock(SessionFactory.class);
		}
	}
	@Configuration
	static class CustomConfiguration {
		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"		@Bean
		public org.neo4j.ogm.config.Configuration myConfiguration() {
			return new org.neo4j.ogm.config.Configuration.Builder()
					.uri(""http://localhost:12345"").build();
		}
	}
	@Configuration
	static class EventListenerConfiguration {
		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}
		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}
	}",method,
"		@Bean
		public EventListener eventListenerOne() {
			return mock(EventListener.class);
		}",method,
"		@Bean
		public EventListener eventListenerTwo() {
			return mock(EventListener.class);
		}",method,
"public class GeneratorsFileUtil {
    @SuppressWarnings(""UseOfSystemOutOrSystemErr"")
    public static void writeFileIfContentChanged(File file, String newText) throws IOException {
        writeFileIfContentChanged(file, newText, true);
    }
    @SuppressWarnings(""UseOfSystemOutOrSystemErr"")
    public static void writeFileIfContentChanged(File file, String newText, boolean logNotChanged) throws IOException {
        File parentFile = file.getParentFile();
        if (!parentFile.exists()) {
            if (parentFile.mkdirs()) {
                System.out.println(""Directory created: "" + parentFile.getAbsolutePath());
            }
            else {
                throw new IllegalStateException(""Cannot create directory: "" + parentFile);
            }
        }
        if (checkFileIgnoringLineSeparators(file, newText)) {
            if (logNotChanged) {
                System.out.println(""Not changed: "" + file.getAbsolutePath());
            }
            return;
        }
        boolean useTempFile = !SystemInfo.isWindows;
        File tempFile = useTempFile ? new File(KotlinTestUtils.tmpDir(file.getName()), file.getName() + "".tmp"") : file;
        FileUtil.writeToFile(tempFile, newText);
        System.out.println(""File written: "" + tempFile.getAbsolutePath());
        if (useTempFile) {
            Files.move(tempFile.toPath(), file.toPath(), REPLACE_EXISTING);
            System.out.println(""Renamed "" + tempFile + "" to "" + file);
        }
        System.out.println();
    }
    private static boolean checkFileIgnoringLineSeparators(File file, String content) {
        String currentContent;
        try {
            currentContent = FileUtil.loadFile(file, true);
        }
        catch (Throwable ignored) {
            return false;
        }
        return StringUtil.convertLineSeparators(content).equals(currentContent);
    }
}",class,
"    @SuppressWarnings(""UseOfSystemOutOrSystemErr"")
    public static void writeFileIfContentChanged(File file, String newText) throws IOException {
        writeFileIfContentChanged(file, newText, true);
    }",method,
"    @SuppressWarnings(""UseOfSystemOutOrSystemErr"")
    public static void writeFileIfContentChanged(File file, String newText, boolean logNotChanged) throws IOException {
        File parentFile = file.getParentFile();
        if (!parentFile.exists()) {
            if (parentFile.mkdirs()) {
                System.out.println(""Directory created: "" + parentFile.getAbsolutePath());
            }
            else {
                throw new IllegalStateException(""Cannot create directory: "" + parentFile);
            }
        }
        if (checkFileIgnoringLineSeparators(file, newText)) {
            if (logNotChanged) {
                System.out.println(""Not changed: "" + file.getAbsolutePath());
            }
            return;
        }
        boolean useTempFile = !SystemInfo.isWindows;
        File tempFile = useTempFile ? new File(KotlinTestUtils.tmpDir(file.getName()), file.getName() + "".tmp"") : file;
        FileUtil.writeToFile(tempFile, newText);
        System.out.println(""File written: "" + tempFile.getAbsolutePath());
        if (useTempFile) {
            Files.move(tempFile.toPath(), file.toPath(), REPLACE_EXISTING);
            System.out.println(""Renamed "" + tempFile + "" to "" + file);
        }
        System.out.println();
    }",method,
"            if (logNotChanged) {
                System.out.println(""Not changed: "" + file.getAbsolutePath());
            }",method,
"        if (useTempFile) {
            Files.move(tempFile.toPath(), file.toPath(), REPLACE_EXISTING);
            System.out.println(""Renamed "" + tempFile + "" to "" + file);
        }",method,
"    private static boolean checkFileIgnoringLineSeparators(File file, String content) {
        String currentContent;
        try {
            currentContent = FileUtil.loadFile(file, true);
        }
        catch (Throwable ignored) {
            return false;
        }
        return StringUtil.convertLineSeparators(content).equals(currentContent);
    }",method,
"        catch (Throwable ignored) {
            return false;
        }",method,
"public class RequestOptions {
  public static final String DEFAULT_HOST = ""localhost"";
  public static final int DEFAULT_PORT = 80;
  public static final boolean DEFAULT_SSL = false;
  public static final String DEFAULT_URI = """";
  private String host;
  private int port;
  private boolean ssl;
  private String uri;
  public RequestOptions() {
    host = DEFAULT_HOST;
    port = DEFAULT_PORT;
    ssl = DEFAULT_SSL;
    uri = DEFAULT_URI;
  }
  public RequestOptions(RequestOptions other) {
    setHost(other.host);
    setPort(other.port);
    setSsl(other.ssl);
    setURI(other.uri);
  }
  public RequestOptions(JsonObject json) {
    setHost(json.getString(""host"", DEFAULT_HOST));
    setPort(json.getInteger(""port"", DEFAULT_PORT));
    setSsl(json.getBoolean(""ssl"", DEFAULT_SSL));
    setURI(json.getString(""uri"", DEFAULT_URI));
  }
  public String getHost() {
    return host;
  }
  public RequestOptions setHost(String host) {
    this.host = host;
    return this;
  }
  public int getPort() {
    return port;
  }
  public RequestOptions setPort(int port) {
    this.port = port;
    return this;
  }
  public boolean isSsl() {
    return ssl;
  }
  public RequestOptions setSsl(boolean ssl) {
    this.ssl = ssl;
    return this;
  }
  public String getURI() {
    return uri;
  }
  public RequestOptions setURI(String uri) {
    this.uri = uri;
    return this;
  }
}",class,
"  public RequestOptions() {
    host = DEFAULT_HOST;
    port = DEFAULT_PORT;
    ssl = DEFAULT_SSL;
    uri = DEFAULT_URI;
  }",method,
"  public RequestOptions(RequestOptions other) {
    setHost(other.host);
    setPort(other.port);
    setSsl(other.ssl);
    setURI(other.uri);
  }",method,
"  public RequestOptions(JsonObject json) {
    setHost(json.getString(""host"", DEFAULT_HOST));
    setPort(json.getInteger(""port"", DEFAULT_PORT));
    setSsl(json.getBoolean(""ssl"", DEFAULT_SSL));
    setURI(json.getString(""uri"", DEFAULT_URI));
  }",method,
"  public String getHost() {
    return host;
  }",method,
"  public RequestOptions setHost(String host) {
    this.host = host;
    return this;
  }",method,
"  public int getPort() {
    return port;
  }",method,
"  public RequestOptions setPort(int port) {
    this.port = port;
    return this;
  }",method,
"  public boolean isSsl() {
    return ssl;
  }",method,
"  public RequestOptions setSsl(boolean ssl) {
    this.ssl = ssl;
    return this;
  }",method,
"  public String getURI() {
    return uri;
  }",method,
"  public RequestOptions setURI(String uri) {
    this.uri = uri;
    return this;
  }",method,
"public class ExpectedExceptionNeverThrownInspection extends BaseInspection {
  @Nls
  @NotNull
  @Override
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""expected.exception.never.thrown.display.name"");
  }
  @NotNull
  @Override
  protected String buildErrorString(Object... infos) {
    final PsiMethod method = (PsiMethod)infos[0];
    return InspectionGadgetsBundle.message(""expected.exception.never.thrown.problem.descriptor"", method.getName());
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new ExpectedExceptionNeverThrownVisitor();
  }
  private static class ExpectedExceptionNeverThrownVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethod(PsiMethod method) {
      super.visitMethod(method);
      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(method, ""org.junit.Test"");
      if (annotation == null) {
        return;
      }
      final PsiAnnotationParameterList parameterList = annotation.getParameterList();
      final PsiNameValuePair[] attributes = parameterList.getAttributes();
      PsiAnnotationMemberValue value = null;
      for (PsiNameValuePair attribute : attributes) {
        if (""expected"".equals(attribute.getName())) {
          value = attribute.getValue();
          break;
        }
      }
      if (!(value instanceof PsiClassObjectAccessExpression)) {
        return;
      }
      final PsiCodeBlock body = method.getBody();
      if (body == null) {
        return;
      }
      final PsiClassObjectAccessExpression classObjectAccessExpression = (PsiClassObjectAccessExpression)value;
      final PsiTypeElement operand = classObjectAccessExpression.getOperand();
      final PsiType type = operand.getType();
      final PsiClass aClass = PsiUtil.resolveClassInClassTypeOnly(type);
      if (InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_RUNTIME_EXCEPTION) ||
        InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_ERROR)) {
        return;
      }
      final List<PsiClassType> exceptionsThrown = ExceptionUtil.getThrownExceptions(body);
      for (PsiClassType psiClassType : exceptionsThrown) {
        if (psiClassType.isAssignableFrom(type)) {
          return;
        }
      }
      registerError(operand, method);
    }
  }
}",class,
"  private static class ExpectedExceptionNeverThrownVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethod(PsiMethod method) {
      super.visitMethod(method);
      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(method, ""org.junit.Test"");
      if (annotation == null) {
        return;
      }
      final PsiAnnotationParameterList parameterList = annotation.getParameterList();
      final PsiNameValuePair[] attributes = parameterList.getAttributes();
      PsiAnnotationMemberValue value = null;
      for (PsiNameValuePair attribute : attributes) {
        if (""expected"".equals(attribute.getName())) {
          value = attribute.getValue();
          break;
        }
      }
      if (!(value instanceof PsiClassObjectAccessExpression)) {
        return;
      }
      final PsiCodeBlock body = method.getBody();
      if (body == null) {
        return;
      }
      final PsiClassObjectAccessExpression classObjectAccessExpression = (PsiClassObjectAccessExpression)value;
      final PsiTypeElement operand = classObjectAccessExpression.getOperand();
      final PsiType type = operand.getType();
      final PsiClass aClass = PsiUtil.resolveClassInClassTypeOnly(type);
      if (InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_RUNTIME_EXCEPTION) ||
        InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_ERROR)) {
        return;
      }
      final List<PsiClassType> exceptionsThrown = ExceptionUtil.getThrownExceptions(body);
      for (PsiClassType psiClassType : exceptionsThrown) {
        if (psiClassType.isAssignableFrom(type)) {
          return;
        }
      }
      registerError(operand, method);
    }
  }",class,
"  @Nls
  @NotNull
  @Override
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""expected.exception.never.thrown.display.name"");
  }",method,
"  @NotNull
  @Override
  protected String buildErrorString(Object... infos) {
    final PsiMethod method = (PsiMethod)infos[0];
    return InspectionGadgetsBundle.message(""expected.exception.never.thrown.problem.descriptor"", method.getName());
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new ExpectedExceptionNeverThrownVisitor();
  }",method,
"    @Override
    public void visitMethod(PsiMethod method) {
      super.visitMethod(method);
      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(method, ""org.junit.Test"");
      if (annotation == null) {
        return;
      }
      final PsiAnnotationParameterList parameterList = annotation.getParameterList();
      final PsiNameValuePair[] attributes = parameterList.getAttributes();
      PsiAnnotationMemberValue value = null;
      for (PsiNameValuePair attribute : attributes) {
        if (""expected"".equals(attribute.getName())) {
          value = attribute.getValue();
          break;
        }
      }
      if (!(value instanceof PsiClassObjectAccessExpression)) {
        return;
      }
      final PsiCodeBlock body = method.getBody();
      if (body == null) {
        return;
      }
      final PsiClassObjectAccessExpression classObjectAccessExpression = (PsiClassObjectAccessExpression)value;
      final PsiTypeElement operand = classObjectAccessExpression.getOperand();
      final PsiType type = operand.getType();
      final PsiClass aClass = PsiUtil.resolveClassInClassTypeOnly(type);
      if (InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_RUNTIME_EXCEPTION) ||
        InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_ERROR)) {
        return;
      }
      final List<PsiClassType> exceptionsThrown = ExceptionUtil.getThrownExceptions(body);
      for (PsiClassType psiClassType : exceptionsThrown) {
        if (psiClassType.isAssignableFrom(type)) {
          return;
        }
      }
      registerError(operand, method);
    }",method,
"      if (annotation == null) {
        return;
      }",method,
"      for (PsiNameValuePair attribute : attributes) {
        if (""expected"".equals(attribute.getName())) {
          value = attribute.getValue();
          break;
        }
      }",method,
"      if (body == null) {
        return;
      }",method,
"      for (PsiClassType psiClassType : exceptionsThrown) {
        if (psiClassType.isAssignableFrom(type)) {
          return;
        }
      }",method,
"public class UnknownFeaturesCollector implements PersistentStateComponent<Element> {
  @NonNls private static final String FEATURE_ID = ""featureType"";
  @NonNls private static final String IMPLEMENTATION_NAME = ""implementationName"";
  private final Set<UnknownFeature> myUnknownFeatures = new HashSet<>();
  private final Set<UnknownFeature> myIgnoredUnknownFeatures = new HashSet<>();
  public static UnknownFeaturesCollector getInstance(Project project) {
    return ServiceManager.getService(project, UnknownFeaturesCollector.class);
  }
  public void registerUnknownRunConfiguration(String configurationId) {
    registerUnknownFeature(""com.intellij.configurationType"", configurationId, ""Run Configuration"");
  }
  public void registerUnknownFeature(String featureType, String implementationName, String featureDisplayName) {
    final UnknownFeature feature = new UnknownFeature(featureType, featureDisplayName, implementationName);
    if (!isIgnored(feature)) {
      myUnknownFeatures.add(feature);
    }
  }
  public boolean isIgnored(UnknownFeature feature) {
    return myIgnoredUnknownFeatures.contains(feature);
  }
  public void ignoreFeature(UnknownFeature feature) {
    myIgnoredUnknownFeatures.add(feature);
  }
  public Set<UnknownFeature> getUnknownFeatures() {
    return myUnknownFeatures;
  }
  @Nullable
  @Override
  public Element getState() {
    if (myIgnoredUnknownFeatures.isEmpty()) return null;
    final Element ignored = new Element(""ignored"");
    for (UnknownFeature feature : myIgnoredUnknownFeatures) {
      final Element option = new Element(""option"");
      option.setAttribute(FEATURE_ID, feature.getFeatureType());
      option.setAttribute(IMPLEMENTATION_NAME, feature.getImplementationName());
      ignored.addContent(option);
    }
    return ignored;
  }
  @Override
  public void loadState(Element state) {
    myIgnoredUnknownFeatures.clear();
    for (Element element : state.getChildren()) {
      myIgnoredUnknownFeatures.add(
        new UnknownFeature(element.getAttributeValue(FEATURE_ID), null, element.getAttributeValue(IMPLEMENTATION_NAME)));
    }
  }
}",class,
"  public static UnknownFeaturesCollector getInstance(Project project) {
    return ServiceManager.getService(project, UnknownFeaturesCollector.class);
  }",method,
"  public void registerUnknownRunConfiguration(String configurationId) {
    registerUnknownFeature(""com.intellij.configurationType"", configurationId, ""Run Configuration"");
  }",method,
"  public void registerUnknownFeature(String featureType, String implementationName, String featureDisplayName) {
    final UnknownFeature feature = new UnknownFeature(featureType, featureDisplayName, implementationName);
    if (!isIgnored(feature)) {
      myUnknownFeatures.add(feature);
    }
  }",method,
"  public boolean isIgnored(UnknownFeature feature) {
    return myIgnoredUnknownFeatures.contains(feature);
  }",method,
"  public void ignoreFeature(UnknownFeature feature) {
    myIgnoredUnknownFeatures.add(feature);
  }",method,
"  public Set<UnknownFeature> getUnknownFeatures() {
    return myUnknownFeatures;
  }",method,
"  @Nullable
  @Override
  public Element getState() {
    if (myIgnoredUnknownFeatures.isEmpty()) return null;
    final Element ignored = new Element(""ignored"");
    for (UnknownFeature feature : myIgnoredUnknownFeatures) {
      final Element option = new Element(""option"");
      option.setAttribute(FEATURE_ID, feature.getFeatureType());
      option.setAttribute(IMPLEMENTATION_NAME, feature.getImplementationName());
      ignored.addContent(option);
    }
    return ignored;
  }",method,
"    for (UnknownFeature feature : myIgnoredUnknownFeatures) {
      final Element option = new Element(""option"");
      option.setAttribute(FEATURE_ID, feature.getFeatureType());
      option.setAttribute(IMPLEMENTATION_NAME, feature.getImplementationName());
      ignored.addContent(option);
    }",method,
"  @Override
  public void loadState(Element state) {
    myIgnoredUnknownFeatures.clear();
    for (Element element : state.getChildren()) {
      myIgnoredUnknownFeatures.add(
        new UnknownFeature(element.getAttributeValue(FEATURE_ID), null, element.getAttributeValue(IMPLEMENTATION_NAME)));
    }
  }",method,
"public class TranslationException extends Exception
{
    private static final long serialVersionUID = 1863414006518097804L;
    public TranslationException(String str)
    {
        super(str);
    }
    public TranslationException(Exception e)
    {
        super(e);
    }
}",class,
"			public Set getEmeds()
			{
				return new HashSet<AtEmbed>(p.atEmbeds.values());
			}",method,
"			public Set getTranslationSet()
			{
				return p.entrySet();
			}",method,

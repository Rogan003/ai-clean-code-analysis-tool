code_snippet,type,score
"	@Override
	public void shutdown(boolean waitForJobsToComplete) {
	}",method,
"	@Override
	public int getPoolSize() {
		return -1;
	}",method,
"	@Override
	public boolean runInThread(Runnable runnable) {
		Assert.state(this.taskExecutor != null, ""No TaskExecutor available"");
		try {
			this.taskExecutor.execute(runnable);
			return true;
		}
		catch (RejectedExecutionException ex) {
			logger.error(""Task has been rejected by TaskExecutor"", ex);
			return false;
		}
	}",method,
"		catch (RejectedExecutionException ex) {
			logger.error(""Task has been rejected by TaskExecutor"", ex);
			return false;
		}",method,
"	@Override
	public int blockForAvailableThreads() {
		// The present implementation always returns 1, making Quartz
		// always schedule any tasks that it feels like scheduling.
		// This could be made smarter for specific TaskExecutors,
		// for example calling {@code getMaximumPoolSize() - getActiveCount()}
		// on a {@code java.util.concurrent.ThreadPoolExecutor}.
		return 1;
	}",method,
"public final class OldXMLFormatterTest extends TestCase {
    XMLFormatter formatter = null;
    MockHandler handler = null;
    LogRecord lr = null;
    @Override protected void setUp() throws Exception {
        super.setUp();
        formatter = new XMLFormatter();
        handler = new MockHandler();
        lr = new LogRecord(Level.SEVERE, ""pattern"");
    }
    public void testXMLFormatter() throws SecurityException, UnsupportedEncodingException {
        handler.setEncoding(""UTF-8"");
        String result = formatter.getHead(handler);
        int headPos = result
                .indexOf(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""no\""?>"");
        int dtdPos = result.indexOf(""<!DOCTYPE log SYSTEM \""logger.dtd\"">"");
        int rootPos = result.indexOf(""<log>"");
        assertTrue(""head string position should be more or equal zero"",
                headPos >= 0);
        assertTrue(""dtd string position should be more head string position"",
                dtdPos > headPos);
        assertTrue(""root string position should be more dtd string position"",
                rootPos > dtdPos);
        assertTrue(""Tail string position should be more zero"", formatter
                .getTail(handler).indexOf(""/log>"") > 0);
    }
    public void testGetTail() {
        assertEquals(""Tail string with null handler should be equal expected value"",
                ""</log>"", formatter.getTail(null).trim());
        assertEquals(""Tail string should be equal expected value"", ""</log>"",
                formatter.getTail(handler).trim());
        handler.publish(lr);
        assertEquals(""Tail string after publish() should be equal expected value"",
                ""</log>"", formatter.getTail(handler).trim());
    }
    public static class MockHandler extends Handler {
        public void close() {}
        public void flush() {}
        public void publish(LogRecord record) {}
    }
}",class,
"    public static class MockHandler extends Handler {
        public void close() {}
        public void flush() {}
        public void publish(LogRecord record) {}
    }",class,
"    public void testXMLFormatter() throws SecurityException, UnsupportedEncodingException {
        handler.setEncoding(""UTF-8"");
        String result = formatter.getHead(handler);
        int headPos = result
                .indexOf(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""no\""?>"");
        int dtdPos = result.indexOf(""<!DOCTYPE log SYSTEM \""logger.dtd\"">"");
        int rootPos = result.indexOf(""<log>"");
        assertTrue(""head string position should be more or equal zero"",
                headPos >= 0);
        assertTrue(""dtd string position should be more head string position"",
                dtdPos > headPos);
        assertTrue(""root string position should be more dtd string position"",
                rootPos > dtdPos);
        assertTrue(""Tail string position should be more zero"", formatter
                .getTail(handler).indexOf(""/log>"") > 0);
    }",method,
"    public void testGetTail() {
        assertEquals(""Tail string with null handler should be equal expected value"",
                ""</log>"", formatter.getTail(null).trim());
        assertEquals(""Tail string should be equal expected value"", ""</log>"",
                formatter.getTail(handler).trim());
        handler.publish(lr);
        assertEquals(""Tail string after publish() should be equal expected value"",
                ""</log>"", formatter.getTail(handler).trim());
    }",method,
        public void close() {},method,
        public void flush() {},method,
        public void publish(LogRecord record) {},method,
"public class ResourceRegion {
	private final Resource resource;
	private final long position;
	private final long count;
	public ResourceRegion(Resource resource, long position, long count) {
		Assert.notNull(resource, ""Resource must not be null"");
		Assert.isTrue(position >= 0, ""'position' must be larger than or equal to 0"");
		Assert.isTrue(count >= 0, ""'count' must be larger than or equal to 0"");
		this.resource = resource;
		this.position = position;
		this.count = count;
	}
	public Resource getResource() {
		return this.resource;
	}
	public long getPosition() {
		return this.position;
	}
	public long getCount() {
		return this.count;
	}
}",class,
"	public ResourceRegion(Resource resource, long position, long count) {
		Assert.notNull(resource, ""Resource must not be null"");
		Assert.isTrue(position >= 0, ""'position' must be larger than or equal to 0"");
		Assert.isTrue(count >= 0, ""'count' must be larger than or equal to 0"");
		this.resource = resource;
		this.position = position;
		this.count = count;
	}",method,
"	public Resource getResource() {
		return this.resource;
	}",method,
"	public long getPosition() {
		return this.position;
	}",method,
"	public long getCount() {
		return this.count;
	}",method,
"public class CaseKylin_mysql_idle_1 extends TestCase {
    private String  jdbcUrl;
    private String  user;
    private String  password;
    private String  driverClass;
    private int     initialSize                   = 1;
    private int     minIdle                       = 1;
    private int     maxIdle                       = 20;
    private int     maxActive                     = 20;
    private int     maxWait                       = 60000;
    private String  validationQuery               = null;     // ""SELECT 1"";
    private int     threadCount                   = 15;
    private int     TEST_COUNT                    = 3;
    final int       LOOP_COUNT                    = 1000 * 10;
    private boolean testWhileIdle                 = true;
    private boolean testOnBorrow                  = false;
    private boolean testOnReturn                  = false;
    private boolean removeAbandoned               = true;
    private int     removeAbandonedTimeout        = 180;
    private long    timeBetweenEvictionRunsMillis = 60000;
    private long    minEvictableIdleTimeMillis    = 1800000;
    private int     numTestsPerEvictionRun        = 20;
    protected void setUp() throws Exception {
        // jdbcUrl = ""jdbc:fake:dragoon_v25masterdb"";
        // user = ""dragoon25"";
        // password = ""dragoon25"";
        // driverClass = ""com.alibaba.druid.mock.MockDriver"";
        jdbcUrl = ""jdbc:mysql://a.b.c.d:8066/amoeba"";
        user = ""root"";
        password = ""12345"";
        driverClass = ""com.mysql.jdbc.Driver"";
        // jdbcUrl = ""jdbc:oracle:thin:@a.b.c.d:1521:ocnauto"";
        // user = ""alibaba"";
        // password = ""ccbuauto"";
        // driverClass = ""oracle.jdbc.driver.OracleDriver"";
    }
    public void test_perf() throws Exception {
        druid();
    }
    public void druid() throws Exception {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setInitialSize(initialSize);
        dataSource.setMaxActive(maxActive);
        dataSource.setMaxIdle(maxIdle);
        dataSource.setMinIdle(minIdle);
        dataSource.setMaxWait(maxWait);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setDriverClassName(driverClass);
        dataSource.setUrl(jdbcUrl);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setUsername(user);
        dataSource.setPassword(password);
        dataSource.setValidationQuery(validationQuery);
        dataSource.setTestOnBorrow(testOnBorrow);
        dataSource.setTestOnBorrow(testWhileIdle);
        dataSource.setTestOnBorrow(testOnReturn);
        dataSource.setRemoveAbandoned(removeAbandoned);
        dataSource.setRemoveAbandonedTimeout(removeAbandonedTimeout);
        dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        dataSource.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
        p0(dataSource, ""druid"", threadCount);
        long startMillis = System.currentTimeMillis();
        for (int i = 0; i < 1000; ++i) {
            p0(dataSource, ""druid"", threadCount);
            long seconds = (System.currentTimeMillis() - startMillis) / 1000L;
            System.out.println(""seconds : "" + seconds);
        }
        System.out.println();
    }
    private void p0(final DataSource dataSource, String name, int threadCount) throws Exception {
        final CountDownLatch startLatch = new CountDownLatch(1);
        final CountDownLatch endLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; ++i) {
            Thread thread = new Thread() {
                public void run() {
                    try {
                        startLatch.await();
                        for (int i = 0; i < LOOP_COUNT; ++i) {
                            Connection conn = dataSource.getConnection();
                            PreparedStatement stmt = conn.prepareStatement(""SELECT 1 FROM DUAL"");
                            ResultSet rs = stmt.executeQuery();
                            rs.next();
                            rs.getInt(1);
                            rs.close();
                            stmt.close();
                            conn.close();
                        }
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                    endLatch.countDown();
                }
            };
            thread.start();
        }
        long startMillis = System.currentTimeMillis();
        long startYGC = TestUtil.getYoungGC();
        long startFullGC = TestUtil.getFullGC();
        startLatch.countDown();
        endLatch.await();
        long millis = System.currentTimeMillis() - startMillis;
        long ygc = TestUtil.getYoungGC() - startYGC;
        long fullGC = TestUtil.getFullGC() - startFullGC;
        System.out.println(""thread "" + threadCount + "" "" + name + "" millis : ""
                           + NumberFormat.getInstance().format(millis) + "", YGC "" + ygc + "" FGC "" + fullGC);
    }
}",class,
"    protected void setUp() throws Exception {
        // jdbcUrl = ""jdbc:fake:dragoon_v25masterdb"";
        // user = ""dragoon25"";
        // password = ""dragoon25"";
        // driverClass = ""com.alibaba.druid.mock.MockDriver"";
        jdbcUrl = ""jdbc:mysql://a.b.c.d:8066/amoeba"";
        user = ""root"";
        password = ""12345"";
        driverClass = ""com.mysql.jdbc.Driver"";
        // jdbcUrl = ""jdbc:oracle:thin:@a.b.c.d:1521:ocnauto"";
        // user = ""alibaba"";
        // password = ""ccbuauto"";
        // driverClass = ""oracle.jdbc.driver.OracleDriver"";
    }
    public void test_perf() throws Exception {
        druid();
    }
    public void druid() throws Exception {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setInitialSize(initialSize);
        dataSource.setMaxActive(maxActive);
        dataSource.setMaxIdle(maxIdle);
        dataSource.setMinIdle(minIdle);
        dataSource.setMaxWait(maxWait);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setDriverClassName(driverClass);
        dataSource.setUrl(jdbcUrl);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setUsername(user);
        dataSource.setPassword(password);
        dataSource.setValidationQuery(validationQuery);
        dataSource.setTestOnBorrow(testOnBorrow);
        dataSource.setTestOnBorrow(testWhileIdle);
        dataSource.setTestOnBorrow(testOnReturn);
        dataSource.setRemoveAbandoned(removeAbandoned);
        dataSource.setRemoveAbandonedTimeout(removeAbandonedTimeout);
        dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        dataSource.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
        p0(dataSource, ""druid"", threadCount);
        long startMillis = System.currentTimeMillis();
        for (int i = 0; i < 1000; ++i) {
            p0(dataSource, ""druid"", threadCount);
            long seconds = (System.currentTimeMillis() - startMillis) / 1000L;
            System.out.println(""seconds : "" + seconds);
        }
        System.out.println();
    }
    private void p0(final DataSource dataSource, String name, int threadCount) throws Exception {
        final CountDownLatch startLatch = new CountDownLatch(1);
        final CountDownLatch endLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; ++i) {
            Thread thread = new Thread() {
                public void run() {
                    try {
                        startLatch.await();
                        for (int i = 0; i < LOOP_COUNT; ++i) {
                            Connection conn = dataSource.getConnection();
                            PreparedStatement stmt = conn.prepareStatement(""SELECT 1 FROM DUAL"");
                            ResultSet rs = stmt.executeQuery();
                            rs.next();
                            rs.getInt(1);
                            rs.close();
                            stmt.close();
                            conn.close();
                        }
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                    endLatch.countDown();
                }
            };
            thread.start();
        }
        long startMillis = System.currentTimeMillis();
        long startYGC = TestUtil.getYoungGC();
        long startFullGC = TestUtil.getFullGC();
        startLatch.countDown();
        endLatch.await();
        long millis = System.currentTimeMillis() - startMillis;
        long ygc = TestUtil.getYoungGC() - startYGC;
        long fullGC = TestUtil.getFullGC() - startFullGC;
        System.out.println(""thread "" + threadCount + "" "" + name + "" millis : ""
                           + NumberFormat.getInstance().format(millis) + "", YGC "" + ygc + "" FGC "" + fullGC);
    }",method,
"import org.opencv.imgproc.Imgproc;
class Filter2D_DemoRun {
    public void run(String[] args) {
        // Declare variables
        Mat src, dst = new Mat();
        Mat kernel = new Mat();
        Point anchor;
        double delta;
        int ddepth;
        int kernel_size;
        String window_name = ""filter2D Demo"";
        //! [load]
        String imageName = ((args.length > 0) ? args[0] : ""../data/lena.jpg"");
        // Load an image
        src = Imgcodecs.imread(imageName, Imgcodecs.IMREAD_COLOR);
        // Check if image is loaded fine
        if( src.empty() ) {
            System.out.println(""Error opening image!"");
            System.out.println(""Program Arguments: [image_name -- default ../data/lena.jpg] \n"");
            System.exit(-1);
        }
        //! [load]
        //! [init_arguments]
        // Initialize arguments for the filter
        anchor = new Point( -1, -1);
        delta = 0.0;
        ddepth = -1;
        //! [init_arguments]
        // Loop - Will filter the image with different kernel sizes each 0.5 seconds
        int ind = 0;
        while( true )
        {
            //! [update_kernel]
            // Update kernel size for a normalized box filter
            kernel_size = 3 + 2*( ind%5 );
            Mat ones = Mat.ones( kernel_size, kernel_size, CvType.CV_32F );
            Core.multiply(ones, new Scalar(1/(double)(kernel_size*kernel_size)), kernel);
            //! [update_kernel]
            //! [apply_filter]
            // Apply filter
            Imgproc.filter2D(src, dst, ddepth , kernel, anchor, delta, Core.BORDER_DEFAULT );
            //! [apply_filter]
            HighGui.imshow( window_name, dst );
            int c = HighGui.waitKey(500);
            // Press 'ESC' to exit the program
            if( c == 27 )
            { break; }
            ind++;
        }
        System.exit(0);
    }
}",class,
"public class Filter2D_Demo {
    public static void main(String[] args) {
        // Load the native library.
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        new Filter2D_DemoRun().run(args);
    }
}",class,
"    public void run(String[] args) {
        // Declare variables
        Mat src, dst = new Mat();
        Mat kernel = new Mat();
        Point anchor;
        double delta;
        int ddepth;
        int kernel_size;
        String window_name = ""filter2D Demo"";
        //! [load]
        String imageName = ((args.length > 0) ? args[0] : ""../data/lena.jpg"");
        // Load an image
        src = Imgcodecs.imread(imageName, Imgcodecs.IMREAD_COLOR);
        // Check if image is loaded fine
        if( src.empty() ) {
            System.out.println(""Error opening image!"");
            System.out.println(""Program Arguments: [image_name -- default ../data/lena.jpg] \n"");
            System.exit(-1);
        }
        //! [load]
        //! [init_arguments]
        // Initialize arguments for the filter
        anchor = new Point( -1, -1);
        delta = 0.0;
        ddepth = -1;
        //! [init_arguments]
        // Loop - Will filter the image with different kernel sizes each 0.5 seconds
        int ind = 0;
        while( true )
        {
            //! [update_kernel]
            // Update kernel size for a normalized box filter
            kernel_size = 3 + 2*( ind%5 );
            Mat ones = Mat.ones( kernel_size, kernel_size, CvType.CV_32F );
            Core.multiply(ones, new Scalar(1/(double)(kernel_size*kernel_size)), kernel);
            //! [update_kernel]
            //! [apply_filter]
            // Apply filter
            Imgproc.filter2D(src, dst, ddepth , kernel, anchor, delta, Core.BORDER_DEFAULT );
            //! [apply_filter]
            HighGui.imshow( window_name, dst );
            int c = HighGui.waitKey(500);
            // Press 'ESC' to exit the program
            if( c == 27 )
            { break; }
            ind++;
        }
        System.exit(0);
    }",method,
"        while( true )
        {
            //! [update_kernel]
            // Update kernel size for a normalized box filter
            kernel_size = 3 + 2*( ind%5 );
            Mat ones = Mat.ones( kernel_size, kernel_size, CvType.CV_32F );
            Core.multiply(ones, new Scalar(1/(double)(kernel_size*kernel_size)), kernel);
            //! [update_kernel]
            //! [apply_filter]
            // Apply filter
            Imgproc.filter2D(src, dst, ddepth , kernel, anchor, delta, Core.BORDER_DEFAULT );
            //! [apply_filter]
            HighGui.imshow( window_name, dst );
            int c = HighGui.waitKey(500);
            // Press 'ESC' to exit the program
            if( c == 27 )
            { break; }
            ind++;
        }",method,
"            if( c == 27 )
            { break; }",method,
"    public static void main(String[] args) {
        // Load the native library.
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        new Filter2D_DemoRun().run(args);
    }",method,
"public class StructureViewUpdatingTest extends TestSourceBasedTestCase {
  @Override
  protected String getTestPath() {
    return ""structureView"";
  }
  @Override
  protected String getTestDataPath() {
    return JavaTestUtil.getJavaTestDataPath();
  }
  public void testJavaClassStructure() {
    PsiClass psiClass = JavaDirectoryService.getInstance().getClasses(getPackageDirectory(""com/package1""))[0];
    VirtualFile virtualFile = psiClass.getContainingFile().getVirtualFile();
    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);
    FileEditor[] fileEditors = fileEditorManager.openFile(virtualFile, false);
    FileEditor fileEditor = fileEditors[0];
    StructureViewComponent svc = (StructureViewComponent)fileEditor.getStructureViewBuilder()
      .createStructureView(fileEditor, myProject);
    Disposer.register(getTestRootDisposable(), svc);
    fileEditorManager.closeFile(virtualFile);
    Document document = PsiDocumentManager.getInstance(myProject).getDocument(psiClass.getContainingFile());
    svc.setActionActive(InheritedMembersNodeProvider.ID, true);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class1.java\n"" +
      "" -Class1\n"" +
      ""  getValue(): int\n"" +
      ""  getClass(): Class<?>\n"" +
      ""  hashCode(): int\n"" +
      ""  equals(Object): boolean\n"" +
      ""  clone(): Object\n"" +
      ""  toString(): String\n"" +
      ""  notify(): void\n"" +
      ""  notifyAll(): void\n"" +
      ""  wait(long): void\n"" +
      ""  wait(long, int): void\n"" +
      ""  wait(): void\n"" +
      ""  finalize(): void\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"");
    new WriteCommandAction.Simple(getProject()) {
      @Override
      protected void run() {
        int offset = document.getLineStartOffset(5);
        document.insertString(offset, ""    boolean myNewField = false;\n"");
      }
    }.execute().throwException();
    PsiDocumentManager.getInstance(myProject).commitDocument(document);
    PlatformTestUtil.waitForAlarm(600);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class1.java\n"" +
      "" -Class1\n"" + ""  getValue(): int\n"" +
      ""  getClass(): Class<?>\n"" +
      ""  hashCode(): int\n"" +
      ""  equals(Object): boolean\n"" +
      ""  clone(): Object\n"" +
      ""  toString(): String\n"" +
      ""  notify(): void\n"" +
      ""  notifyAll(): void\n"" +
      ""  wait(long): void\n"" +
      ""  wait(long, int): void\n"" +
      ""  wait(): void\n"" +
      ""  finalize(): void\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myNewField: boolean = false\n"");
  }
  public void testShowClassMembers() {
    PsiClass psiClass = JavaDirectoryService.getInstance().getClasses(getPackageDirectory(""com/package1""))[0];
    VirtualFile virtualFile = psiClass.getContainingFile().getVirtualFile();
    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);
    FileEditor[] fileEditors = fileEditorManager.openFile(virtualFile, false);
    FileEditor fileEditor = fileEditors[0];
    StructureViewComponent svc = (StructureViewComponent)fileEditor.getStructureViewBuilder()
      .createStructureView(fileEditor, myProject);
    Disposer.register(getTestRootDisposable(), svc);
    fileEditorManager.closeFile(virtualFile);
    PlatformTestUtil.waitForPromise(svc.rebuildAndUpdate());
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class2.java\n"" +
      "" -Class2\n"" +
      ""  +InnerClass1\n"" +
      ""  +InnerClass2\n"" +
      ""  getValue(): int\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myField3: boolean\n"" +
      ""  myField4: boolean\n"");
    PsiField innerClassField = psiClass.getInnerClasses()[0].getFields()[0];
    svc.select(innerClassField, true);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class2.java\n"" +
      "" -Class2\n"" +
      ""  -InnerClass1\n"" +
      ""   +InnerClass12\n"" +
      ""   myInnerClassField: int\n"" +
      ""  +InnerClass2\n"" +
      ""  getValue(): int\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myField3: boolean\n"" +
      ""  myField4: boolean\n"");
    CommandProcessor.getInstance().executeCommand(myProject, () -> WriteCommandAction.runWriteCommandAction(null, () -> {
      try {
        innerClassField.delete();
      }
      catch (IncorrectOperationException e) {
        fail(e.getLocalizedMessage());
      }
    }), null, null);
    PlatformTestUtil.waitForAlarm(1000);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class2.java\n"" +
      "" -Class2\n"" +
      ""  -InnerClass1\n"" +
      ""   +InnerClass12\n"" +
      ""  +InnerClass2\n"" +
      ""  getValue(): int\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myField3: boolean\n"" +
      ""  myField4: boolean\n"");
  }
  public void testExpandElementWithExitingName() {
    VirtualFile xmlVirtualFile = getContentRoot().findFileByRelativePath(""test.xml"");
    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);
    FileEditor[] fileEditors = fileEditorManager.openFile(xmlVirtualFile, false);
    FileEditor fileEditor = fileEditors[0];
    StructureViewComponent svc = (StructureViewComponent)fileEditor.getStructureViewBuilder()
      .createStructureView(fileEditor, myProject);
    Disposer.register(getTestRootDisposable(), svc);
    fileEditorManager.closeFile(xmlVirtualFile);
    PlatformTestUtil.waitForPromise(svc.rebuildAndUpdate());
    JTree tree = svc.getTree();
    PlatformTestUtil.assertTreeEqual(
      tree,
      ""-test.xml\n"" +
      "" -test\n"" +
      ""  +level1\n"" +
      ""  +level1\n"" +
      ""  +level1\n"" +
      ""  +level1\n"");
    tree.expandPath(tree.getPathForRow(3));
    PlatformTestUtil.assertTreeEqual(
      tree,
      ""-test.xml\n"" +
      "" -test\n"" +
      ""  +level1\n"" +
      ""  -level1\n"" +
      ""   +level2\n"" +
      ""  +level1\n"" +
      ""  +level1\n"");
  }
}",class,
"  @Override
  protected String getTestPath() {
    return ""structureView"";
  }",method,
"  @Override
  protected String getTestDataPath() {
    return JavaTestUtil.getJavaTestDataPath();
  }",method,
"  public void testJavaClassStructure() {
    PsiClass psiClass = JavaDirectoryService.getInstance().getClasses(getPackageDirectory(""com/package1""))[0];
    VirtualFile virtualFile = psiClass.getContainingFile().getVirtualFile();
    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);
    FileEditor[] fileEditors = fileEditorManager.openFile(virtualFile, false);
    FileEditor fileEditor = fileEditors[0];
    StructureViewComponent svc = (StructureViewComponent)fileEditor.getStructureViewBuilder()
      .createStructureView(fileEditor, myProject);
    Disposer.register(getTestRootDisposable(), svc);
    fileEditorManager.closeFile(virtualFile);
    Document document = PsiDocumentManager.getInstance(myProject).getDocument(psiClass.getContainingFile());
    svc.setActionActive(InheritedMembersNodeProvider.ID, true);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class1.java\n"" +
      "" -Class1\n"" +
      ""  getValue(): int\n"" +
      ""  getClass(): Class<?>\n"" +
      ""  hashCode(): int\n"" +
      ""  equals(Object): boolean\n"" +
      ""  clone(): Object\n"" +
      ""  toString(): String\n"" +
      ""  notify(): void\n"" +
      ""  notifyAll(): void\n"" +
      ""  wait(long): void\n"" +
      ""  wait(long, int): void\n"" +
      ""  wait(): void\n"" +
      ""  finalize(): void\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"");
    new WriteCommandAction.Simple(getProject()) {
      @Override
      protected void run() {
        int offset = document.getLineStartOffset(5);
        document.insertString(offset, ""    boolean myNewField = false;\n"");
      }
    }.execute().throwException();
    PsiDocumentManager.getInstance(myProject).commitDocument(document);
    PlatformTestUtil.waitForAlarm(600);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class1.java\n"" +
      "" -Class1\n"" + ""  getValue(): int\n"" +
      ""  getClass(): Class<?>\n"" +
      ""  hashCode(): int\n"" +
      ""  equals(Object): boolean\n"" +
      ""  clone(): Object\n"" +
      ""  toString(): String\n"" +
      ""  notify(): void\n"" +
      ""  notifyAll(): void\n"" +
      ""  wait(long): void\n"" +
      ""  wait(long, int): void\n"" +
      ""  wait(): void\n"" +
      ""  finalize(): void\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myNewField: boolean = false\n"");
  }",method,
"      @Override
      protected void run() {
        int offset = document.getLineStartOffset(5);
        document.insertString(offset, ""    boolean myNewField = false;\n"");
      }",method,
"  public void testShowClassMembers() {
    PsiClass psiClass = JavaDirectoryService.getInstance().getClasses(getPackageDirectory(""com/package1""))[0];
    VirtualFile virtualFile = psiClass.getContainingFile().getVirtualFile();
    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);
    FileEditor[] fileEditors = fileEditorManager.openFile(virtualFile, false);
    FileEditor fileEditor = fileEditors[0];
    StructureViewComponent svc = (StructureViewComponent)fileEditor.getStructureViewBuilder()
      .createStructureView(fileEditor, myProject);
    Disposer.register(getTestRootDisposable(), svc);
    fileEditorManager.closeFile(virtualFile);
    PlatformTestUtil.waitForPromise(svc.rebuildAndUpdate());
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class2.java\n"" +
      "" -Class2\n"" +
      ""  +InnerClass1\n"" +
      ""  +InnerClass2\n"" +
      ""  getValue(): int\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myField3: boolean\n"" +
      ""  myField4: boolean\n"");
    PsiField innerClassField = psiClass.getInnerClasses()[0].getFields()[0];
    svc.select(innerClassField, true);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class2.java\n"" +
      "" -Class2\n"" +
      ""  -InnerClass1\n"" +
      ""   +InnerClass12\n"" +
      ""   myInnerClassField: int\n"" +
      ""  +InnerClass2\n"" +
      ""  getValue(): int\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myField3: boolean\n"" +
      ""  myField4: boolean\n"");
    CommandProcessor.getInstance().executeCommand(myProject, () -> WriteCommandAction.runWriteCommandAction(null, () -> {
      try {
        innerClassField.delete();
      }
      catch (IncorrectOperationException e) {
        fail(e.getLocalizedMessage());
      }
    }), null, null);
    PlatformTestUtil.waitForAlarm(1000);
    PlatformTestUtil.assertTreeEqual(
      svc.getTree(),
      ""-Class2.java\n"" +
      "" -Class2\n"" +
      ""  -InnerClass1\n"" +
      ""   +InnerClass12\n"" +
      ""  +InnerClass2\n"" +
      ""  getValue(): int\n"" +
      ""  myField1: boolean\n"" +
      ""  myField2: boolean\n"" +
      ""  myField3: boolean\n"" +
      ""  myField4: boolean\n"");
  }",method,
"      catch (IncorrectOperationException e) {
        fail(e.getLocalizedMessage());
      }",method,
"  public void testExpandElementWithExitingName() {
    VirtualFile xmlVirtualFile = getContentRoot().findFileByRelativePath(""test.xml"");
    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);
    FileEditor[] fileEditors = fileEditorManager.openFile(xmlVirtualFile, false);
    FileEditor fileEditor = fileEditors[0];
    StructureViewComponent svc = (StructureViewComponent)fileEditor.getStructureViewBuilder()
      .createStructureView(fileEditor, myProject);
    Disposer.register(getTestRootDisposable(), svc);
    fileEditorManager.closeFile(xmlVirtualFile);
    PlatformTestUtil.waitForPromise(svc.rebuildAndUpdate());
    JTree tree = svc.getTree();
    PlatformTestUtil.assertTreeEqual(
      tree,
      ""-test.xml\n"" +
      "" -test\n"" +
      ""  +level1\n"" +
      ""  +level1\n"" +
      ""  +level1\n"" +
      ""  +level1\n"");
    tree.expandPath(tree.getPathForRow(3));
    PlatformTestUtil.assertTreeEqual(
      tree,
      ""-test.xml\n"" +
      "" -test\n"" +
      ""  +level1\n"" +
      ""  -level1\n"" +
      ""   +level2\n"" +
      ""  +level1\n"" +
      ""  +level1\n"");
  }",method,
"public final class CompletableMergeArray extends Completable {
    final CompletableSource[] sources;
    public CompletableMergeArray(CompletableSource[] sources) {
        this.sources = sources;
    }
    @Override
    public void subscribeActual(final CompletableObserver s) {
        final CompositeDisposable set = new CompositeDisposable();
        final AtomicBoolean once = new AtomicBoolean();
        InnerCompletableObserver shared = new InnerCompletableObserver(s, once, set, sources.length + 1);
        s.onSubscribe(set);
        for (CompletableSource c : sources) {
            if (set.isDisposed()) {
                return;
            }
            if (c == null) {
                set.dispose();
                NullPointerException npe = new NullPointerException(""A completable source is null"");
                shared.onError(npe);
                return;
            }
            c.subscribe(shared);
        }
        shared.onComplete();
    }
    static final class InnerCompletableObserver extends AtomicInteger implements CompletableObserver {
        private static final long serialVersionUID = -8360547806504310570L;
        final CompletableObserver actual;
        final AtomicBoolean once;
        final CompositeDisposable set;
        InnerCompletableObserver(CompletableObserver actual, AtomicBoolean once, CompositeDisposable set, int n) {
            this.actual = actual;
            this.once = once;
            this.set = set;
            this.lazySet(n);
        }
        @Override
        public void onSubscribe(Disposable d) {
            set.add(d);
        }
        @Override
        public void onError(Throwable e) {
            set.dispose();
            if (once.compareAndSet(false, true)) {
                actual.onError(e);
            } else {
                RxJavaPlugins.onError(e);
            }
        }
        @Override
        public void onComplete() {
            if (decrementAndGet() == 0) {
                if (once.compareAndSet(false, true)) {
                    actual.onComplete();
                }
            }
        }
    }
}",class,
"    static final class InnerCompletableObserver extends AtomicInteger implements CompletableObserver {
        private static final long serialVersionUID = -8360547806504310570L;
        final CompletableObserver actual;
        final AtomicBoolean once;
        final CompositeDisposable set;
        InnerCompletableObserver(CompletableObserver actual, AtomicBoolean once, CompositeDisposable set, int n) {
            this.actual = actual;
            this.once = once;
            this.set = set;
            this.lazySet(n);
        }
        @Override
        public void onSubscribe(Disposable d) {
            set.add(d);
        }
        @Override
        public void onError(Throwable e) {
            set.dispose();
            if (once.compareAndSet(false, true)) {
                actual.onError(e);
            } else {
                RxJavaPlugins.onError(e);
            }
        }
        @Override
        public void onComplete() {
            if (decrementAndGet() == 0) {
                if (once.compareAndSet(false, true)) {
                    actual.onComplete();
                }
            }
        }
    }",class,
"    public CompletableMergeArray(CompletableSource[] sources) {
        this.sources = sources;
    }",method,
"    @Override
    public void subscribeActual(final CompletableObserver s) {
        final CompositeDisposable set = new CompositeDisposable();
        final AtomicBoolean once = new AtomicBoolean();
        InnerCompletableObserver shared = new InnerCompletableObserver(s, once, set, sources.length + 1);
        s.onSubscribe(set);
        for (CompletableSource c : sources) {
            if (set.isDisposed()) {
                return;
            }
            if (c == null) {
                set.dispose();
                NullPointerException npe = new NullPointerException(""A completable source is null"");
                shared.onError(npe);
                return;
            }
            c.subscribe(shared);
        }
        shared.onComplete();
    }",method,
"        for (CompletableSource c : sources) {
            if (set.isDisposed()) {
                return;
            }
            if (c == null) {
                set.dispose();
                NullPointerException npe = new NullPointerException(""A completable source is null"");
                shared.onError(npe);
                return;
            }
            c.subscribe(shared);
        }",method,
"            if (c == null) {
                set.dispose();
                NullPointerException npe = new NullPointerException(""A completable source is null"");
                shared.onError(npe);
                return;
            }",method,
"        InnerCompletableObserver(CompletableObserver actual, AtomicBoolean once, CompositeDisposable set, int n) {
            this.actual = actual;
            this.once = once;
            this.set = set;
            this.lazySet(n);
        }",method,
"        @Override
        public void onSubscribe(Disposable d) {
            set.add(d);
        }",method,
"        @Override
        public void onError(Throwable e) {
            set.dispose();
            if (once.compareAndSet(false, true)) {
                actual.onError(e);
            } else {
                RxJavaPlugins.onError(e);
            }
        }",method,
"        @Override
        public void onComplete() {
            if (decrementAndGet() == 0) {
                if (once.compareAndSet(false, true)) {
                    actual.onComplete();
                }
            }
        }",method,
"public class NamedArgumentInsertHandler implements InsertHandler<LookupElement> {
  public static final NamedArgumentInsertHandler INSTANCE = new NamedArgumentInsertHandler();
  private NamedArgumentInsertHandler() {}
  @Override
  public void handleInsert(InsertionContext context, LookupElement item) {
    int tailOffset = context.getTailOffset();
    PsiElement argumentList = context.getFile().findElementAt(tailOffset - 1);
    while (argumentList != null && !(argumentList instanceof GrArgumentList) && !(argumentList instanceof GrListOrMap)) {
      argumentList = argumentList.getParent();
    }
    final Editor editor = context.getEditor();
    if (argumentList != null) {
      CodeStyleSettings settings = CodeStyleSettingsManager.getInstance(context.getProject()).getCurrentSettings();
      GroovyCodeStyleSettings codeStyleSettings = settings.getCustomSettings(GroovyCodeStyleSettings.class);
      CommonCodeStyleSettings commonCodeStyleSettings = settings.getCommonSettings(GroovyLanguage.INSTANCE);
      boolean insertSpace = codeStyleSettings.SPACE_IN_NAMED_ARGUMENT;
      if (context.getCompletionChar() == ':' || (insertSpace && context.getCompletionChar() == ' ')) {
        context.setAddCompletionChar(false);
      }
      String argumentListText = argumentList.getText();
      String s = argumentListText.substring(tailOffset - argumentList.getTextOffset());
      s = StringUtil.trimEnd(s, "")"");
      if (s.trim().isEmpty()) {
        String toInsert = insertSpace ? "": "" : "":"";
        editor.getDocument().insertString(tailOffset, toInsert);
        editor.getCaretModel().moveToOffset(tailOffset + toInsert.length());
      }
      else {
        if (context.getCompletionChar() == Lookup.REPLACE_SELECT_CHAR) {
          char a = s.charAt(0);
          if (Character.isLetterOrDigit(a)) {
            return;
          }
        }
        Matcher m = Pattern.compile(""([ \\t]*):([ \\t]*)(.*)"", Pattern.DOTALL).matcher(s);
        if (m.matches()) {
          int caret = tailOffset + m.end(2);
          if (m.group(2).isEmpty()) {
            editor.getDocument().insertString(caret, "" "");
            caret++;
          }
          editor.getCaretModel().moveToOffset(caret);
        }
        else {
          m = Pattern.compile(""([ \\t]*)([\\n \\t]*)[\\],](.*)"", Pattern.DOTALL).matcher(s);
          if (m.matches()) {
            String toInsert = insertSpace ? "": "" : "":"";
            editor.getDocument().replaceString(tailOffset, tailOffset + m.start(2), toInsert);
            editor.getCaretModel().moveToOffset(tailOffset + toInsert.length());
          }
          else {
            m = Pattern.compile(""([ \\t]*)(.*)"", Pattern.DOTALL).matcher(s);
            if (!m.matches()) throw new RuntimeException(""This pattern must match any non-empty string! ("" + s + "")"");
            StringBuilder sb = new StringBuilder(3);
            sb.append(':');
            int shiftCaret = 1;
            if (insertSpace) {
              sb.append(' ');
              shiftCaret++;
            }
            if (!m.group(2).startsWith(""\n"") && commonCodeStyleSettings.SPACE_AFTER_COMMA) {
              sb.append(' ');
            }
            editor.getDocument().replaceString(tailOffset, tailOffset + m.start(2), sb);
            editor.getCaretModel().moveToOffset(tailOffset + shiftCaret);
          }
        }
      }
      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
      editor.getSelectionModel().removeSelection();
    }
  }
}",class,
  private NamedArgumentInsertHandler() {},method,
"  @Override
  public void handleInsert(InsertionContext context, LookupElement item) {
    int tailOffset = context.getTailOffset();
    PsiElement argumentList = context.getFile().findElementAt(tailOffset - 1);
    while (argumentList != null && !(argumentList instanceof GrArgumentList) && !(argumentList instanceof GrListOrMap)) {
      argumentList = argumentList.getParent();
    }
    final Editor editor = context.getEditor();
    if (argumentList != null) {
      CodeStyleSettings settings = CodeStyleSettingsManager.getInstance(context.getProject()).getCurrentSettings();
      GroovyCodeStyleSettings codeStyleSettings = settings.getCustomSettings(GroovyCodeStyleSettings.class);
      CommonCodeStyleSettings commonCodeStyleSettings = settings.getCommonSettings(GroovyLanguage.INSTANCE);
      boolean insertSpace = codeStyleSettings.SPACE_IN_NAMED_ARGUMENT;
      if (context.getCompletionChar() == ':' || (insertSpace && context.getCompletionChar() == ' ')) {
        context.setAddCompletionChar(false);
      }
      String argumentListText = argumentList.getText();
      String s = argumentListText.substring(tailOffset - argumentList.getTextOffset());
      s = StringUtil.trimEnd(s, "")"");
      if (s.trim().isEmpty()) {
        String toInsert = insertSpace ? "": "" : "":"";
        editor.getDocument().insertString(tailOffset, toInsert);
        editor.getCaretModel().moveToOffset(tailOffset + toInsert.length());
      }
      else {
        if (context.getCompletionChar() == Lookup.REPLACE_SELECT_CHAR) {
          char a = s.charAt(0);
          if (Character.isLetterOrDigit(a)) {
            return;
          }
        }
        Matcher m = Pattern.compile(""([ \\t]*):([ \\t]*)(.*)"", Pattern.DOTALL).matcher(s);
        if (m.matches()) {
          int caret = tailOffset + m.end(2);
          if (m.group(2).isEmpty()) {
            editor.getDocument().insertString(caret, "" "");
            caret++;
          }
          editor.getCaretModel().moveToOffset(caret);
        }
        else {
          m = Pattern.compile(""([ \\t]*)([\\n \\t]*)[\\],](.*)"", Pattern.DOTALL).matcher(s);
          if (m.matches()) {
            String toInsert = insertSpace ? "": "" : "":"";
            editor.getDocument().replaceString(tailOffset, tailOffset + m.start(2), toInsert);
            editor.getCaretModel().moveToOffset(tailOffset + toInsert.length());
          }
          else {
            m = Pattern.compile(""([ \\t]*)(.*)"", Pattern.DOTALL).matcher(s);
            if (!m.matches()) throw new RuntimeException(""This pattern must match any non-empty string! ("" + s + "")"");
            StringBuilder sb = new StringBuilder(3);
            sb.append(':');
            int shiftCaret = 1;
            if (insertSpace) {
              sb.append(' ');
              shiftCaret++;
            }
            if (!m.group(2).startsWith(""\n"") && commonCodeStyleSettings.SPACE_AFTER_COMMA) {
              sb.append(' ');
            }
            editor.getDocument().replaceString(tailOffset, tailOffset + m.start(2), sb);
            editor.getCaretModel().moveToOffset(tailOffset + shiftCaret);
          }
        }
      }
      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
      editor.getSelectionModel().removeSelection();
    }
  }",method,
"    if (argumentList != null) {
      CodeStyleSettings settings = CodeStyleSettingsManager.getInstance(context.getProject()).getCurrentSettings();
      GroovyCodeStyleSettings codeStyleSettings = settings.getCustomSettings(GroovyCodeStyleSettings.class);
      CommonCodeStyleSettings commonCodeStyleSettings = settings.getCommonSettings(GroovyLanguage.INSTANCE);
      boolean insertSpace = codeStyleSettings.SPACE_IN_NAMED_ARGUMENT;
      if (context.getCompletionChar() == ':' || (insertSpace && context.getCompletionChar() == ' ')) {
        context.setAddCompletionChar(false);
      }
      String argumentListText = argumentList.getText();
      String s = argumentListText.substring(tailOffset - argumentList.getTextOffset());
      s = StringUtil.trimEnd(s, "")"");
      if (s.trim().isEmpty()) {
        String toInsert = insertSpace ? "": "" : "":"";
        editor.getDocument().insertString(tailOffset, toInsert);
        editor.getCaretModel().moveToOffset(tailOffset + toInsert.length());
      }
      else {
        if (context.getCompletionChar() == Lookup.REPLACE_SELECT_CHAR) {
          char a = s.charAt(0);
          if (Character.isLetterOrDigit(a)) {
            return;
          }
        }
        Matcher m = Pattern.compile(""([ \\t]*):([ \\t]*)(.*)"", Pattern.DOTALL).matcher(s);
        if (m.matches()) {
          int caret = tailOffset + m.end(2);
          if (m.group(2).isEmpty()) {
            editor.getDocument().insertString(caret, "" "");
            caret++;
          }
          editor.getCaretModel().moveToOffset(caret);
        }
        else {
          m = Pattern.compile(""([ \\t]*)([\\n \\t]*)[\\],](.*)"", Pattern.DOTALL).matcher(s);
          if (m.matches()) {
            String toInsert = insertSpace ? "": "" : "":"";
            editor.getDocument().replaceString(tailOffset, tailOffset + m.start(2), toInsert);
            editor.getCaretModel().moveToOffset(tailOffset + toInsert.length());
          }
          else {
            m = Pattern.compile(""([ \\t]*)(.*)"", Pattern.DOTALL).matcher(s);
            if (!m.matches()) throw new RuntimeException(""This pattern must match any non-empty string! ("" + s + "")"");
            StringBuilder sb = new StringBuilder(3);
            sb.append(':');
            int shiftCaret = 1;
            if (insertSpace) {
              sb.append(' ');
              shiftCaret++;
            }
            if (!m.group(2).startsWith(""\n"") && commonCodeStyleSettings.SPACE_AFTER_COMMA) {
              sb.append(' ');
            }
            editor.getDocument().replaceString(tailOffset, tailOffset + m.start(2), sb);
            editor.getCaretModel().moveToOffset(tailOffset + shiftCaret);
          }
        }
      }
      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
      editor.getSelectionModel().removeSelection();
    }",method,
"            if (insertSpace) {
              sb.append(' ');
              shiftCaret++;
            }",method,
"public class StubbingWithCustomAnswerTest extends TestBase {
    @Mock
    private IMethods mock;
    @Test
    public void shouldAnswer() throws Exception {
        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {
            public String answer(InvocationOnMock invocation) throws Throwable {
                String arg =  invocation.getArgument(0);
                return invocation.getMethod().getName() + ""-"" + arg;
            }
        });
        assertEquals(""simpleMethod-test"", mock.simpleMethod(""test""));
    }
    @Test
    public void shouldAnswerWithThenAnswerAlias() throws Exception {
        RecordCall recordCall = new RecordCall();
        Set<?> mockedSet = (Set<?>) when(mock(Set.class).isEmpty()).then(recordCall).getMock();
        mockedSet.isEmpty();
        assertTrue(recordCall.isCalled());
    }
    @Test
    public void shouldAnswerConsecutively() throws Exception {
        when(mock.simpleMethod())
                .thenAnswer(new Answer<String>() {
                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName();
                    }
                })
                .thenReturn(""Hello"")
                .thenAnswer(new Answer<String>() {
                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName() + ""-1"";
                    }
                });
        assertEquals(""simpleMethod"", mock.simpleMethod());
        assertEquals(""Hello"", mock.simpleMethod());
        assertEquals(""simpleMethod-1"", mock.simpleMethod());
        assertEquals(""simpleMethod-1"", mock.simpleMethod());
    }
    @Test
    public void shouldAnswerVoidMethod() throws Exception {
        RecordCall recordCall = new RecordCall();
        doAnswer(recordCall).when(mock).voidMethod();
        mock.voidMethod();
        assertTrue(recordCall.isCalled());
    }
    @Test
    public void shouldAnswerVoidMethodConsecutively() throws Exception {
        RecordCall call1 = new RecordCall();
        RecordCall call2 = new RecordCall();
        doAnswer(call1)
        .doThrow(new UnsupportedOperationException())
        .doAnswer(call2)
        .when(mock).voidMethod();
        mock.voidMethod();
        assertTrue(call1.isCalled());
        assertFalse(call2.isCalled());
        try {
            mock.voidMethod();
            fail();
        } catch (UnsupportedOperationException e) {
        }
        mock.voidMethod();
        assertTrue(call2.isCalled());
    }
    @Test
    public void shouldMakeSureTheInterfaceDoesNotChange() throws Exception {
        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {
            public String answer(InvocationOnMock invocation) throws Throwable {
                assertTrue(invocation.getArguments().getClass().isArray());
                assertEquals(Method.class, invocation.getMethod().getClass());
                return ""assertions passed"";
            }
        });
        assertEquals(""assertions passed"", mock.simpleMethod(""test""));
    }
    private static class RecordCall implements Answer<Object> {
        private boolean called = false;
        public boolean isCalled() {
            return called;
        }
        public Object answer(InvocationOnMock invocation) throws Throwable {
            called = true;
            return null;
        }
    }
}",class,
"    private static class RecordCall implements Answer<Object> {
        private boolean called = false;
        public boolean isCalled() {
            return called;
        }
        public Object answer(InvocationOnMock invocation) throws Throwable {
            called = true;
            return null;
        }
    }",class,
"    @Test
    public void shouldAnswer() throws Exception {
        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {
            public String answer(InvocationOnMock invocation) throws Throwable {
                String arg =  invocation.getArgument(0);
                return invocation.getMethod().getName() + ""-"" + arg;
            }
        });
        assertEquals(""simpleMethod-test"", mock.simpleMethod(""test""));
    }",method,
"            public String answer(InvocationOnMock invocation) throws Throwable {
                String arg =  invocation.getArgument(0);
                return invocation.getMethod().getName() + ""-"" + arg;
            }",method,
"    @Test
    public void shouldAnswerWithThenAnswerAlias() throws Exception {
        RecordCall recordCall = new RecordCall();
        Set<?> mockedSet = (Set<?>) when(mock(Set.class).isEmpty()).then(recordCall).getMock();
        mockedSet.isEmpty();
        assertTrue(recordCall.isCalled());
    }",method,
"    @Test
    public void shouldAnswerConsecutively() throws Exception {
        when(mock.simpleMethod())
                .thenAnswer(new Answer<String>() {
                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName();
                    }
                })
                .thenReturn(""Hello"")
                .thenAnswer(new Answer<String>() {
                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName() + ""-1"";
                    }
                });
        assertEquals(""simpleMethod"", mock.simpleMethod());
        assertEquals(""Hello"", mock.simpleMethod());
        assertEquals(""simpleMethod-1"", mock.simpleMethod());
        assertEquals(""simpleMethod-1"", mock.simpleMethod());
    }",method,
"                .thenAnswer(new Answer<String>() {
                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName();
                    }
                }",method,
"                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName();
                    }",method,
"                .thenAnswer(new Answer<String>() {
                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName() + ""-1"";
                    }
                }",method,
"                    public String answer(InvocationOnMock invocation) throws Throwable {
                        return invocation.getMethod().getName() + ""-1"";
                    }",method,
"    @Test
    public void shouldAnswerVoidMethod() throws Exception {
        RecordCall recordCall = new RecordCall();
        doAnswer(recordCall).when(mock).voidMethod();
        mock.voidMethod();
        assertTrue(recordCall.isCalled());
    }",method,
"    @Test
    public void shouldAnswerVoidMethodConsecutively() throws Exception {
        RecordCall call1 = new RecordCall();
        RecordCall call2 = new RecordCall();
        doAnswer(call1)
        .doThrow(new UnsupportedOperationException())
        .doAnswer(call2)
        .when(mock).voidMethod();
        mock.voidMethod();
        assertTrue(call1.isCalled());
        assertFalse(call2.isCalled());
        try {
            mock.voidMethod();
            fail();
        } catch (UnsupportedOperationException e) {
        }
        mock.voidMethod();
        assertTrue(call2.isCalled());
    }",method,
"    @Test
    public void shouldMakeSureTheInterfaceDoesNotChange() throws Exception {
        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {
            public String answer(InvocationOnMock invocation) throws Throwable {
                assertTrue(invocation.getArguments().getClass().isArray());
                assertEquals(Method.class, invocation.getMethod().getClass());
                return ""assertions passed"";
            }
        });
        assertEquals(""assertions passed"", mock.simpleMethod(""test""));
    }",method,
"            public String answer(InvocationOnMock invocation) throws Throwable {
                assertTrue(invocation.getArguments().getClass().isArray());
                assertEquals(Method.class, invocation.getMethod().getClass());
                return ""assertions passed"";
            }",method,
"        public boolean isCalled() {
            return called;
        }",method,
"        public Object answer(InvocationOnMock invocation) throws Throwable {
            called = true;
            return null;
        }",method,
"import java.util.function.Function;
class PhraseSuggestionContext extends SuggestionContext {
    static final boolean DEFAULT_COLLATE_PRUNE = false;
    static final boolean DEFAULT_REQUIRE_UNIGRAM = true;
    static final float DEFAULT_CONFIDENCE = 1.0f;
    static final int DEFAULT_GRAM_SIZE = 1;
    static final float DEFAULT_RWE_ERRORLIKELIHOOD = 0.95f;
    static final float DEFAULT_MAX_ERRORS = 0.5f;
    static final String DEFAULT_SEPARATOR = "" "";
    static final WordScorer.WordScorerFactory DEFAULT_SCORER = (IndexReader reader, Terms terms, String field, double realWordLikelyhood,
            BytesRef separator) -> new StupidBackoffScorer(reader, terms, field, realWordLikelyhood, separator, 0.4f);
    private float maxErrors = DEFAULT_MAX_ERRORS;
    private BytesRef separator = new BytesRef(DEFAULT_SEPARATOR);
    private float realworldErrorLikelihood = DEFAULT_RWE_ERRORLIKELIHOOD;
    private int gramSize = DEFAULT_GRAM_SIZE;
    private float confidence = DEFAULT_CONFIDENCE;
    private int tokenLimit = NoisyChannelSpellChecker.DEFAULT_TOKEN_LIMIT;
    private boolean requireUnigram = DEFAULT_REQUIRE_UNIGRAM;
    private BytesRef preTag;
    private BytesRef postTag;
    private TemplateScript.Factory scriptFactory;
    private boolean prune = DEFAULT_COLLATE_PRUNE;
    private List<DirectCandidateGenerator> generators = new ArrayList<>();
    private Map<String, Object> collateScriptParams = new HashMap<>(1);
    private WordScorer.WordScorerFactory scorer = DEFAULT_SCORER;
    PhraseSuggestionContext(QueryShardContext shardContext) {
        super(PhraseSuggester.INSTANCE, shardContext);
    }
    public float maxErrors() {
        return maxErrors;
    }
    public void setMaxErrors(Float maxErrors) {
        this.maxErrors = maxErrors;
    }
    public BytesRef separator() {
        return separator;
    }
    public void setSeparator(BytesRef separator) {
        this.separator = separator;
    }
    public Float realworldErrorLikelyhood() {
        return realworldErrorLikelihood;
    }
    public void setRealWordErrorLikelihood(Float realworldErrorLikelihood) {
        this.realworldErrorLikelihood = realworldErrorLikelihood;
    }
    public void addGenerator(DirectCandidateGenerator generator) {
        this.generators.add(generator);
    }
    public List<DirectCandidateGenerator> generators() {
        return this.generators ;
    }
    public void setGramSize(int gramSize) {
        this.gramSize = gramSize;
    }
    public int gramSize() {
        return gramSize;
    }
    public float confidence() {
        return confidence;
    }
    public void setConfidence(float confidence) {
        this.confidence = confidence;
    }
    public void setModel(WordScorer.WordScorerFactory scorer) {
        this.scorer = scorer;
    }
    public WordScorer.WordScorerFactory model() {
        return scorer;
    }
    static class DirectCandidateGenerator extends DirectSpellcheckerSettings {
        private Analyzer preFilter;
        private Analyzer postFilter;
        private String field;
        private int size = 5;
        public String field() {
            return field;
        }
        public void setField(String field) {
            this.field = field;
        }
        public int size() {
            return size;
        }
        public void size(int size) {
            if (size <= 0) {
                throw new IllegalArgumentException(""Size must be positive"");
            }
            this.size = size;
        }
        public Analyzer preFilter() {
            return preFilter;
        }
        public void preFilter(Analyzer preFilter) {
            this.preFilter = preFilter;
        }
        public Analyzer postFilter() {
            return postFilter;
        }
        public void postFilter(Analyzer postFilter) {
            this.postFilter = postFilter;
        }
    }
    public void setRequireUnigram(boolean requireUnigram) {
        this.requireUnigram  = requireUnigram;
    }
    public boolean getRequireUnigram() {
        return requireUnigram;
    }
    public void setTokenLimit(int tokenLimit) {
        this.tokenLimit = tokenLimit;
    }
    public int getTokenLimit() {
        return tokenLimit;
    }
    public void setPreTag(BytesRef preTag) {
        this.preTag = preTag;
    }
    public BytesRef getPreTag() {
        return preTag;
    }
    public void setPostTag(BytesRef postTag) {
        this.postTag = postTag;
    }
    public BytesRef getPostTag() {
        return postTag;
    }
    TemplateScript.Factory getCollateQueryScript() {
        return scriptFactory;
    }
    void setCollateQueryScript(TemplateScript.Factory scriptFactory) {
        this.scriptFactory = scriptFactory;
    }
    Map<String, Object> getCollateScriptParams() {
        return collateScriptParams;
    }
    void setCollateScriptParams(Map<String, Object> collateScriptParams) {
        this.collateScriptParams = new HashMap<>(collateScriptParams);
    }
    void setCollatePrune(boolean prune) {
        this.prune = prune;
    }
    boolean collatePrune() {
        return prune;
    }
}",class,
"    static class DirectCandidateGenerator extends DirectSpellcheckerSettings {
        private Analyzer preFilter;
        private Analyzer postFilter;
        private String field;
        private int size = 5;
        public String field() {
            return field;
        }
        public void setField(String field) {
            this.field = field;
        }
        public int size() {
            return size;
        }
        public void size(int size) {
            if (size <= 0) {
                throw new IllegalArgumentException(""Size must be positive"");
            }
            this.size = size;
        }
        public Analyzer preFilter() {
            return preFilter;
        }
        public void preFilter(Analyzer preFilter) {
            this.preFilter = preFilter;
        }
        public Analyzer postFilter() {
            return postFilter;
        }
        public void postFilter(Analyzer postFilter) {
            this.postFilter = postFilter;
        }
    }",class,
"    PhraseSuggestionContext(QueryShardContext shardContext) {
        super(PhraseSuggester.INSTANCE, shardContext);
    }",method,
"    public float maxErrors() {
        return maxErrors;
    }",method,
"    public void setMaxErrors(Float maxErrors) {
        this.maxErrors = maxErrors;
    }",method,
"    public BytesRef separator() {
        return separator;
    }",method,
"    public void setSeparator(BytesRef separator) {
        this.separator = separator;
    }",method,
"    public Float realworldErrorLikelyhood() {
        return realworldErrorLikelihood;
    }",method,
"    public void setRealWordErrorLikelihood(Float realworldErrorLikelihood) {
        this.realworldErrorLikelihood = realworldErrorLikelihood;
    }",method,
"    public void addGenerator(DirectCandidateGenerator generator) {
        this.generators.add(generator);
    }",method,
"    public List<DirectCandidateGenerator> generators() {
        return this.generators ;
    }",method,
"    public void setGramSize(int gramSize) {
        this.gramSize = gramSize;
    }",method,
"    public int gramSize() {
        return gramSize;
    }",method,
"    public float confidence() {
        return confidence;
    }",method,
"    public void setConfidence(float confidence) {
        this.confidence = confidence;
    }",method,
"    public void setModel(WordScorer.WordScorerFactory scorer) {
        this.scorer = scorer;
    }",method,
"    public WordScorer.WordScorerFactory model() {
        return scorer;
    }",method,
"        public String field() {
            return field;
        }",method,
"        public void setField(String field) {
            this.field = field;
        }",method,
"        public int size() {
            return size;
        }",method,
"        public void size(int size) {
            if (size <= 0) {
                throw new IllegalArgumentException(""Size must be positive"");
            }
            this.size = size;
        }",method,
"            if (size <= 0) {
                throw new IllegalArgumentException(""Size must be positive"");
            }",method,
"        public Analyzer preFilter() {
            return preFilter;
        }",method,
"        public void preFilter(Analyzer preFilter) {
            this.preFilter = preFilter;
        }",method,
"        public Analyzer postFilter() {
            return postFilter;
        }",method,
"        public void postFilter(Analyzer postFilter) {
            this.postFilter = postFilter;
        }",method,
"    public void setRequireUnigram(boolean requireUnigram) {
        this.requireUnigram  = requireUnigram;
    }",method,
"    public boolean getRequireUnigram() {
        return requireUnigram;
    }",method,
"    public void setTokenLimit(int tokenLimit) {
        this.tokenLimit = tokenLimit;
    }",method,
"    public int getTokenLimit() {
        return tokenLimit;
    }",method,
"    public void setPreTag(BytesRef preTag) {
        this.preTag = preTag;
    }",method,
"    public BytesRef getPreTag() {
        return preTag;
    }",method,
"    public void setPostTag(BytesRef postTag) {
        this.postTag = postTag;
    }",method,
"    public BytesRef getPostTag() {
        return postTag;
    }",method,
"    TemplateScript.Factory getCollateQueryScript() {
        return scriptFactory;
    }",method,
"    void setCollateQueryScript(TemplateScript.Factory scriptFactory) {
        this.scriptFactory = scriptFactory;
    }",method,
"    Map<String, Object> getCollateScriptParams() {
        return collateScriptParams;
    }",method,

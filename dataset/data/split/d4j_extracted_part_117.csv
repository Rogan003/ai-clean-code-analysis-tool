code_snippet,type,score
"    if (instance == null) {
      instance = findByComponent(KeyboardFocusManager.getCurrentKeyboardFocusManager().getActiveWindow());
    }",method,
"    if (instance == null) {
      instance = getGlobalInstance();
    }",method,
"  @NotNull
  public static IdeFocusManager findInstanceByComponent(@NotNull Component c) {
    final IdeFocusManager instance = findByComponent(c);
    return instance != null ? instance : findInstanceByContext(null);
  }",method,
"  @Nullable
  private static IdeFocusManager findByComponent(Component c) {
    final Component parent = UIUtil.findUltimateParent(c);
    if (parent instanceof IdeFrame) {
      return getInstanceSafe(((IdeFrame)parent).getProject());
    }
    return null;
  }",method,
"    if (parent instanceof IdeFrame) {
      return getInstanceSafe(((IdeFrame)parent).getProject());
    }",method,
"  @Nullable
  private static IdeFocusManager getInstanceSafe(@Nullable Project project) {
    if (project != null && !project.isDisposed() && project.isInitialized()) {
      return getInstance(project);
    }
    return null;
  }",method,
"  @NotNull
  public static IdeFocusManager findInstance() {
    final Component owner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
    return owner != null ? findInstanceByComponent(owner) : findInstanceByContext(null);
  }",method,
"  @NotNull
  public static IdeFocusManager getGlobalInstance() {
    IdeFocusManager fm = null;
    Application app = ApplicationManager.getApplication();
    if (app != null && app.hasComponent(IdeFocusManager.class)) {
      fm = app.getComponent(IdeFocusManager.class);
    }
    if (fm == null) {
      // happens when app is semi-initialized (e.g. when IDEA server dialog is shown)
      fm = PassThroughIdeFocusManager.getInstance();
    }
    return fm;
  }",method,
"    if (fm == null) {
      // happens when app is semi-initialized (e.g. when IDEA server dialog is shown)
      fm = PassThroughIdeFocusManager.getInstance();
    }",method,
"public class KerasZeroPadding2D extends KerasLayer {
    public KerasZeroPadding2D(Map<String, Object> layerConfig)
                    throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {
        this(layerConfig, true);
    }
    public KerasZeroPadding2D(Map<String, Object> layerConfig, boolean enforceTrainingConfig)
                    throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {
        super(layerConfig, enforceTrainingConfig);
        ZeroPaddingLayer.Builder builder = new ZeroPaddingLayer.Builder(
                getZeroPaddingFromConfig(layerConfig, conf, 2))
                .name(this.layerName).dropOut(this.dropout);
        this.layer = builder.build();
        this.vertex = null;
    }
    public ZeroPaddingLayer getZeroPadding2DLayer() {
        return (ZeroPaddingLayer) this.layer;
    }
    @Override
    public InputType getOutputType(InputType... inputType) throws InvalidKerasConfigurationException {
        if (inputType.length > 1)
            throw new InvalidKerasConfigurationException(
                            ""Keras ZeroPadding layer accepts only one input (received "" + inputType.length + "")"");
        return this.getZeroPadding2DLayer().getOutputType(-1, inputType[0]);
    }
}",class,
"    public KerasZeroPadding2D(Map<String, Object> layerConfig)
                    throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {
        this(layerConfig, true);
    }",method,
"    public KerasZeroPadding2D(Map<String, Object> layerConfig, boolean enforceTrainingConfig)
                    throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {
        super(layerConfig, enforceTrainingConfig);
        ZeroPaddingLayer.Builder builder = new ZeroPaddingLayer.Builder(
                getZeroPaddingFromConfig(layerConfig, conf, 2))
                .name(this.layerName).dropOut(this.dropout);
        this.layer = builder.build();
        this.vertex = null;
    }",method,
"    public ZeroPaddingLayer getZeroPadding2DLayer() {
        return (ZeroPaddingLayer) this.layer;
    }",method,
"    @Override
    public InputType getOutputType(InputType... inputType) throws InvalidKerasConfigurationException {
        if (inputType.length > 1)
            throw new InvalidKerasConfigurationException(
                            ""Keras ZeroPadding layer accepts only one input (received "" + inputType.length + "")"");
        return this.getZeroPadding2DLayer().getOutputType(-1, inputType[0]);
    }",method,
"public class StubSessionDetailModel extends SessionDetailModel {
    private HashMap<SessionDetailQueryEnum, Cursor> mFakeData = new HashMap<>();
    public StubSessionDetailModel(Uri sessionUri, Context context, Cursor sessionCursor,
            Cursor speakersCursor, Cursor tagMetadataCursor) {
        super(sessionUri, context, null, null);
        mFakeData.put(SessionDetailQueryEnum.SESSIONS, sessionCursor);
        mFakeData.put(SessionDetailQueryEnum.SPEAKERS, speakersCursor);
        mFakeData.put(SessionDetailQueryEnum.TAG_METADATA, tagMetadataCursor);
    }
    @Override
    public void requestData(final @NonNull SessionDetailQueryEnum query,
            final @NonNull DataQueryCallback<SessionDetailQueryEnum> callback) {
        new StubModelHelper<SessionDetailModel.SessionDetailQueryEnum>()
                .overrideLoaderManager(query, callback, mFakeData, mDataQueryCallbacks, this);
    }
}",class,
"    public StubSessionDetailModel(Uri sessionUri, Context context, Cursor sessionCursor,
            Cursor speakersCursor, Cursor tagMetadataCursor) {
        super(sessionUri, context, null, null);
        mFakeData.put(SessionDetailQueryEnum.SESSIONS, sessionCursor);
        mFakeData.put(SessionDetailQueryEnum.SPEAKERS, speakersCursor);
        mFakeData.put(SessionDetailQueryEnum.TAG_METADATA, tagMetadataCursor);
    }",method,
"    @Override
    public void requestData(final @NonNull SessionDetailQueryEnum query,
            final @NonNull DataQueryCallback<SessionDetailQueryEnum> callback) {
        new StubModelHelper<SessionDetailModel.SessionDetailQueryEnum>()
                .overrideLoaderManager(query, callback, mFakeData, mDataQueryCallbacks, this);
    }",method,
"public final class ScriptFieldsFetchSubPhase implements FetchSubPhase {
    @Override
    public void hitsExecute(SearchContext context, SearchHit[] hits) throws IOException {
        if (context.hasScriptFields() == false) {
            return;
        }
        hits = hits.clone(); // don't modify the incoming hits
        Arrays.sort(hits, Comparator.comparingInt(SearchHit::docId));
        int lastReaderId = -1;
        SearchScript[] leafScripts = null;
        List<ScriptFieldsContext.ScriptField> scriptFields = context.scriptFields().fields();
        final IndexReader reader = context.searcher().getIndexReader();
        for (SearchHit hit : hits) {
            int readerId = ReaderUtil.subIndex(hit.docId(), reader.leaves());
            LeafReaderContext leafReaderContext = reader.leaves().get(readerId);
            if (readerId != lastReaderId) {
                leafScripts = createLeafScripts(leafReaderContext, scriptFields);
                lastReaderId = readerId;
            }
            int docId = hit.docId() - leafReaderContext.docBase;
            for (int i = 0; i < leafScripts.length; i++) {
                leafScripts[i].setDocument(docId);
                final Object value;
                try {
                    value = leafScripts[i].run();
                } catch (RuntimeException e) {
                    if (scriptFields.get(i).ignoreException()) {
                        continue;
                    }
                    throw e;
                }
                if (hit.fieldsOrNull() == null) {
                    hit.fields(new HashMap<>(2));
                }
                String scriptFieldName = scriptFields.get(i).name();
                DocumentField hitField = hit.getFields().get(scriptFieldName);
                if (hitField == null) {
                    final List<Object> values;
                    if (value instanceof Collection) {
                        values = new ArrayList<>((Collection<?>) value);
                    } else {
                        values = Collections.singletonList(value);
                    }
                    hitField = new DocumentField(scriptFieldName, values);
                    hit.getFields().put(scriptFieldName, hitField);
                }
            }
        }
    }
    private SearchScript[] createLeafScripts(LeafReaderContext context,
                                             List<ScriptFieldsContext.ScriptField> scriptFields) {
        SearchScript[] scripts = new SearchScript[scriptFields.size()];
        for (int i = 0; i < scripts.length; i++) {
            try {
                scripts[i] = scriptFields.get(i).script().newInstance(context);
            } catch (IOException e1) {
                throw new IllegalStateException(""Failed to load script "" + scriptFields.get(i).name(), e1);
            }
        }
        return scripts;
    }
}",class,
"    @Override
    public void hitsExecute(SearchContext context, SearchHit[] hits) throws IOException {
        if (context.hasScriptFields() == false) {
            return;
        }
        hits = hits.clone(); // don't modify the incoming hits
        Arrays.sort(hits, Comparator.comparingInt(SearchHit::docId));
        int lastReaderId = -1;
        SearchScript[] leafScripts = null;
        List<ScriptFieldsContext.ScriptField> scriptFields = context.scriptFields().fields();
        final IndexReader reader = context.searcher().getIndexReader();
        for (SearchHit hit : hits) {
            int readerId = ReaderUtil.subIndex(hit.docId(), reader.leaves());
            LeafReaderContext leafReaderContext = reader.leaves().get(readerId);
            if (readerId != lastReaderId) {
                leafScripts = createLeafScripts(leafReaderContext, scriptFields);
                lastReaderId = readerId;
            }
            int docId = hit.docId() - leafReaderContext.docBase;
            for (int i = 0; i < leafScripts.length; i++) {
                leafScripts[i].setDocument(docId);
                final Object value;
                try {
                    value = leafScripts[i].run();
                } catch (RuntimeException e) {
                    if (scriptFields.get(i).ignoreException()) {
                        continue;
                    }
                    throw e;
                }
                if (hit.fieldsOrNull() == null) {
                    hit.fields(new HashMap<>(2));
                }
                String scriptFieldName = scriptFields.get(i).name();
                DocumentField hitField = hit.getFields().get(scriptFieldName);
                if (hitField == null) {
                    final List<Object> values;
                    if (value instanceof Collection) {
                        values = new ArrayList<>((Collection<?>) value);
                    } else {
                        values = Collections.singletonList(value);
                    }
                    hitField = new DocumentField(scriptFieldName, values);
                    hit.getFields().put(scriptFieldName, hitField);
                }
            }
        }
    }",method,
"        for (SearchHit hit : hits) {
            int readerId = ReaderUtil.subIndex(hit.docId(), reader.leaves());
            LeafReaderContext leafReaderContext = reader.leaves().get(readerId);
            if (readerId != lastReaderId) {
                leafScripts = createLeafScripts(leafReaderContext, scriptFields);
                lastReaderId = readerId;
            }
            int docId = hit.docId() - leafReaderContext.docBase;
            for (int i = 0; i < leafScripts.length; i++) {
                leafScripts[i].setDocument(docId);
                final Object value;
                try {
                    value = leafScripts[i].run();
                } catch (RuntimeException e) {
                    if (scriptFields.get(i).ignoreException()) {
                        continue;
                    }
                    throw e;
                }
                if (hit.fieldsOrNull() == null) {
                    hit.fields(new HashMap<>(2));
                }
                String scriptFieldName = scriptFields.get(i).name();
                DocumentField hitField = hit.getFields().get(scriptFieldName);
                if (hitField == null) {
                    final List<Object> values;
                    if (value instanceof Collection) {
                        values = new ArrayList<>((Collection<?>) value);
                    } else {
                        values = Collections.singletonList(value);
                    }
                    hitField = new DocumentField(scriptFieldName, values);
                    hit.getFields().put(scriptFieldName, hitField);
                }
            }
        }",method,
"            if (readerId != lastReaderId) {
                leafScripts = createLeafScripts(leafReaderContext, scriptFields);
                lastReaderId = readerId;
            }",method,
"            for (int i = 0; i < leafScripts.length; i++) {
                leafScripts[i].setDocument(docId);
                final Object value;
                try {
                    value = leafScripts[i].run();
                } catch (RuntimeException e) {
                    if (scriptFields.get(i).ignoreException()) {
                        continue;
                    }
                    throw e;
                }
                if (hit.fieldsOrNull() == null) {
                    hit.fields(new HashMap<>(2));
                }
                String scriptFieldName = scriptFields.get(i).name();
                DocumentField hitField = hit.getFields().get(scriptFieldName);
                if (hitField == null) {
                    final List<Object> values;
                    if (value instanceof Collection) {
                        values = new ArrayList<>((Collection<?>) value);
                    } else {
                        values = Collections.singletonList(value);
                    }
                    hitField = new DocumentField(scriptFieldName, values);
                    hit.getFields().put(scriptFieldName, hitField);
                }
            }",method,
"                if (hitField == null) {
                    final List<Object> values;
                    if (value instanceof Collection) {
                        values = new ArrayList<>((Collection<?>) value);
                    } else {
                        values = Collections.singletonList(value);
                    }
                    hitField = new DocumentField(scriptFieldName, values);
                    hit.getFields().put(scriptFieldName, hitField);
                }",method,
"                    if (value instanceof Collection) {
                        values = new ArrayList<>((Collection<?>) value);
                    }",method,
"    private SearchScript[] createLeafScripts(LeafReaderContext context,
                                             List<ScriptFieldsContext.ScriptField> scriptFields) {
        SearchScript[] scripts = new SearchScript[scriptFields.size()];
        for (int i = 0; i < scripts.length; i++) {
            try {
                scripts[i] = scriptFields.get(i).script().newInstance(context);
            } catch (IOException e1) {
                throw new IllegalStateException(""Failed to load script "" + scriptFields.get(i).name(), e1);
            }
        }
        return scripts;
    }",method,
"        for (int i = 0; i < scripts.length; i++) {
            try {
                scripts[i] = scriptFields.get(i).script().newInstance(context);
            } catch (IOException e1) {
                throw new IllegalStateException(""Failed to load script "" + scriptFields.get(i).name(), e1);
            }
        }",method,
"public class ReactDrawerLayoutManager extends ViewGroupManager<ReactDrawerLayout> {
  protected static final String REACT_CLASS = ""AndroidDrawerLayout"";
  public static final int OPEN_DRAWER = 1;
  public static final int CLOSE_DRAWER = 2;
  @Override
  public String getName() {
    return REACT_CLASS;
  }
  @Override
  protected void addEventEmitters(ThemedReactContext reactContext, ReactDrawerLayout view) {
    view.setDrawerListener(
        new DrawerEventEmitter(
            view,
            reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher()));
  }
  @Override
  protected ReactDrawerLayout createViewInstance(ThemedReactContext context) {
    return new ReactDrawerLayout(context);
  }
  @ReactProp(name = ""drawerPosition"", defaultInt = Gravity.START)
  public void setDrawerPosition(ReactDrawerLayout view, int drawerPosition) {
    if (Gravity.START == drawerPosition || Gravity.END == drawerPosition) {
      view.setDrawerPosition(drawerPosition);
    } else {
      throw new JSApplicationIllegalArgumentException(""Unknown drawerPosition "" + drawerPosition);
    }
  }
  @ReactProp(name = ""drawerWidth"", defaultFloat = Float.NaN)
  public void getDrawerWidth(ReactDrawerLayout view, float width) {
    int widthInPx = Float.isNaN(width) ?
        ReactDrawerLayout.DEFAULT_DRAWER_WIDTH : Math.round(PixelUtil.toPixelFromDIP(width));
    view.setDrawerWidth(widthInPx);
  }
  @ReactProp(name = ""drawerLockMode"")
  public void setDrawerLockMode(ReactDrawerLayout view, @Nullable String drawerLockMode) {
    if (drawerLockMode == null || ""unlocked"".equals(drawerLockMode)) {
      view.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED);
    } else if (""locked-closed"".equals(drawerLockMode)) {
      view.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED);
    } else if (""locked-open"".equals(drawerLockMode)) {
      view.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_OPEN);
    } else {
      throw new JSApplicationIllegalArgumentException(""Unknown drawerLockMode "" + drawerLockMode);
    }
  }
  @Override
  public void setElevation(ReactDrawerLayout view, float elevation) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      // Facebook is using an older version of the support lib internally that doesn't support
      // setDrawerElevation so we invoke it using reflection.
      // TODO: Call the method directly when this is no longer needed.
      try {
        Method method = ReactDrawerLayout.class.getMethod(""setDrawerElevation"", float.class);
        method.invoke(view, PixelUtil.toPixelFromDIP(elevation));
      } catch (Exception ex) {
        FLog.w(
            ReactConstants.TAG,
            ""setDrawerElevation is not available in this version of the support lib."",
            ex);
      }
    }
  }
  @Override
  public boolean needsCustomLayoutForChildren() {
    // Return true, since DrawerLayout will lay out it's own children.
    return true;
  }
  @Override
  public @Nullable Map<String, Integer> getCommandsMap() {
    return MapBuilder.of(""openDrawer"", OPEN_DRAWER, ""closeDrawer"", CLOSE_DRAWER);
  }
  @Override
  public void receiveCommand(
      ReactDrawerLayout root,
      int commandId,
      @Nullable ReadableArray args) {
    switch (commandId) {
      case OPEN_DRAWER:
        root.openDrawer();
        break;
      case CLOSE_DRAWER:
        root.closeDrawer();
        break;
    }
  }
  @Override
  public @Nullable Map getExportedViewConstants() {
    return MapBuilder.of(
        ""DrawerPosition"",
        MapBuilder.of(""Left"", Gravity.START, ""Right"", Gravity.END));
  }
  @Override
  public @Nullable Map getExportedCustomDirectEventTypeConstants() {
    return MapBuilder.of(
        DrawerSlideEvent.EVENT_NAME, MapBuilder.of(""registrationName"", ""onDrawerSlide""),
        DrawerOpenedEvent.EVENT_NAME, MapBuilder.of(""registrationName"", ""onDrawerOpen""),
        DrawerClosedEvent.EVENT_NAME, MapBuilder.of(""registrationName"", ""onDrawerClose""),
        DrawerStateChangedEvent.EVENT_NAME, MapBuilder.of(
            ""registrationName"", ""onDrawerStateChanged""));
  }
  @Override
  public void addView(ReactDrawerLayout parent, View child, int index) {
    if (getChildCount(parent) >= 2) {
      throw new
          JSApplicationIllegalArgumentException(""The Drawer cannot have more than two children"");
    }
    if (index != 0 && index != 1) {
      throw new JSApplicationIllegalArgumentException(
          ""The only valid indices for drawer's child are 0 or 1. Got "" + index + "" instead."");
    }
    parent.addView(child, index);
    parent.setDrawerProperties();
  }
  public static class DrawerEventEmitter implements DrawerLayout.DrawerListener {
    private final DrawerLayout mDrawerLayout;
    private final EventDispatcher mEventDispatcher;
    public DrawerEventEmitter(DrawerLayout drawerLayout, EventDispatcher eventDispatcher) {
      mDrawerLayout = drawerLayout;
      mEventDispatcher = eventDispatcher;
    }
    @Override
    public void onDrawerSlide(View view, float v) {
      mEventDispatcher.dispatchEvent(
          new DrawerSlideEvent(mDrawerLayout.getId(), v));
    }
    @Override
    public void onDrawerOpened(View view) {
      mEventDispatcher.dispatchEvent(
        new DrawerOpenedEvent(mDrawerLayout.getId()));
    }
    @Override
    public void onDrawerClosed(View view) {
      mEventDispatcher.dispatchEvent(
          new DrawerClosedEvent(mDrawerLayout.getId()));
    }
    @Override
    public void onDrawerStateChanged(int i) {
      mEventDispatcher.dispatchEvent(
          new DrawerStateChangedEvent(mDrawerLayout.getId(), i));
    }
  }
}",class,
"  public static class DrawerEventEmitter implements DrawerLayout.DrawerListener {
    private final DrawerLayout mDrawerLayout;
    private final EventDispatcher mEventDispatcher;
    public DrawerEventEmitter(DrawerLayout drawerLayout, EventDispatcher eventDispatcher) {
      mDrawerLayout = drawerLayout;
      mEventDispatcher = eventDispatcher;
    }
    @Override
    public void onDrawerSlide(View view, float v) {
      mEventDispatcher.dispatchEvent(
          new DrawerSlideEvent(mDrawerLayout.getId(), v));
    }
    @Override
    public void onDrawerOpened(View view) {
      mEventDispatcher.dispatchEvent(
        new DrawerOpenedEvent(mDrawerLayout.getId()));
    }
    @Override
    public void onDrawerClosed(View view) {
      mEventDispatcher.dispatchEvent(
          new DrawerClosedEvent(mDrawerLayout.getId()));
    }
    @Override
    public void onDrawerStateChanged(int i) {
      mEventDispatcher.dispatchEvent(
          new DrawerStateChangedEvent(mDrawerLayout.getId(), i));
    }
  }",class,
"  @Override
  public String getName() {
    return REACT_CLASS;
  }",method,
"  @Override
  protected void addEventEmitters(ThemedReactContext reactContext, ReactDrawerLayout view) {
    view.setDrawerListener(
        new DrawerEventEmitter(
            view,
            reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher()));
  }",method,
"  @Override
  protected ReactDrawerLayout createViewInstance(ThemedReactContext context) {
    return new ReactDrawerLayout(context);
  }",method,
"  @ReactProp(name = ""drawerPosition"", defaultInt = Gravity.START)
  public void setDrawerPosition(ReactDrawerLayout view, int drawerPosition) {
    if (Gravity.START == drawerPosition || Gravity.END == drawerPosition) {
      view.setDrawerPosition(drawerPosition);
    } else {
      throw new JSApplicationIllegalArgumentException(""Unknown drawerPosition "" + drawerPosition);
    }
  }",method,
"    if (Gravity.START == drawerPosition || Gravity.END == drawerPosition) {
      view.setDrawerPosition(drawerPosition);
    }",method,
"  @ReactProp(name = ""drawerWidth"", defaultFloat = Float.NaN)
  public void getDrawerWidth(ReactDrawerLayout view, float width) {
    int widthInPx = Float.isNaN(width) ?
        ReactDrawerLayout.DEFAULT_DRAWER_WIDTH : Math.round(PixelUtil.toPixelFromDIP(width));
    view.setDrawerWidth(widthInPx);
  }",method,
"  @ReactProp(name = ""drawerLockMode"")
  public void setDrawerLockMode(ReactDrawerLayout view, @Nullable String drawerLockMode) {
    if (drawerLockMode == null || ""unlocked"".equals(drawerLockMode)) {
      view.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED);
    } else if (""locked-closed"".equals(drawerLockMode)) {
      view.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED);
    } else if (""locked-open"".equals(drawerLockMode)) {
      view.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_OPEN);
    } else {
      throw new JSApplicationIllegalArgumentException(""Unknown drawerLockMode "" + drawerLockMode);
    }
  }",method,
"  @Override
  public void setElevation(ReactDrawerLayout view, float elevation) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      // Facebook is using an older version of the support lib internally that doesn't support
      // setDrawerElevation so we invoke it using reflection.
      // TODO: Call the method directly when this is no longer needed.
      try {
        Method method = ReactDrawerLayout.class.getMethod(""setDrawerElevation"", float.class);
        method.invoke(view, PixelUtil.toPixelFromDIP(elevation));
      } catch (Exception ex) {
        FLog.w(
            ReactConstants.TAG,
            ""setDrawerElevation is not available in this version of the support lib."",
            ex);
      }
    }
  }",method,
"    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      // Facebook is using an older version of the support lib internally that doesn't support
      // setDrawerElevation so we invoke it using reflection.
      // TODO: Call the method directly when this is no longer needed.
      try {
        Method method = ReactDrawerLayout.class.getMethod(""setDrawerElevation"", float.class);
        method.invoke(view, PixelUtil.toPixelFromDIP(elevation));
      } catch (Exception ex) {
        FLog.w(
            ReactConstants.TAG,
            ""setDrawerElevation is not available in this version of the support lib."",
            ex);
      }
    }",method,
"  @Override
  public boolean needsCustomLayoutForChildren() {
    // Return true, since DrawerLayout will lay out it's own children.
    return true;
  }",method,
"  @Override
  public void receiveCommand(
      ReactDrawerLayout root,
      int commandId,
      @Nullable ReadableArray args) {
    switch (commandId) {
      case OPEN_DRAWER:
        root.openDrawer();
        break;
      case CLOSE_DRAWER:
        root.closeDrawer();
        break;
    }
  }",method,
"    switch (commandId) {
      case OPEN_DRAWER:
        root.openDrawer();
        break;
      case CLOSE_DRAWER:
        root.closeDrawer();
        break;
    }",method,
"  @Override
  public void addView(ReactDrawerLayout parent, View child, int index) {
    if (getChildCount(parent) >= 2) {
      throw new
          JSApplicationIllegalArgumentException(""The Drawer cannot have more than two children"");
    }
    if (index != 0 && index != 1) {
      throw new JSApplicationIllegalArgumentException(
          ""The only valid indices for drawer's child are 0 or 1. Got "" + index + "" instead."");
    }
    parent.addView(child, index);
    parent.setDrawerProperties();
  }",method,
"    if (index != 0 && index != 1) {
      throw new JSApplicationIllegalArgumentException(
          ""The only valid indices for drawer's child are 0 or 1. Got "" + index + "" instead."");
    }",method,
"    public DrawerEventEmitter(DrawerLayout drawerLayout, EventDispatcher eventDispatcher) {
      mDrawerLayout = drawerLayout;
      mEventDispatcher = eventDispatcher;
    }",method,
"    @Override
    public void onDrawerSlide(View view, float v) {
      mEventDispatcher.dispatchEvent(
          new DrawerSlideEvent(mDrawerLayout.getId(), v));
    }",method,
"    @Override
    public void onDrawerOpened(View view) {
      mEventDispatcher.dispatchEvent(
        new DrawerOpenedEvent(mDrawerLayout.getId()));
    }",method,
"    @Override
    public void onDrawerClosed(View view) {
      mEventDispatcher.dispatchEvent(
          new DrawerClosedEvent(mDrawerLayout.getId()));
    }",method,
"    @Override
    public void onDrawerStateChanged(int i) {
      mEventDispatcher.dispatchEvent(
          new DrawerStateChangedEvent(mDrawerLayout.getId(), i));
    }",method,
"      @Nullable ReadableArray args) {
    switch (commandId) {
      case OPEN_DRAWER:
        root.openDrawer();
        break;
      case CLOSE_DRAWER:
        root.closeDrawer();
        break;
    }",method,
"public class SimplePropertyNamespaceHandler implements NamespaceHandler {
	private static final String REF_SUFFIX = ""-ref"";
	@Override
	public void init() {
	}
	@Override
	@Nullable
	public BeanDefinition parse(Element element, ParserContext parserContext) {
		parserContext.getReaderContext().error(
				""Class ["" + getClass().getName() + ""] does not support custom elements."", element);
		return null;
	}
	@Override
	public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
		if (node instanceof Attr) {
			Attr attr = (Attr) node;
			String propertyName = parserContext.getDelegate().getLocalName(attr);
			String propertyValue = attr.getValue();
			MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();
			if (pvs.contains(propertyName)) {
				parserContext.getReaderContext().error(""Property '"" + propertyName + ""' is already defined using "" +
						""both <property> and inline syntax. Only one approach may be used per property."", attr);
			}
			if (propertyName.endsWith(REF_SUFFIX)) {
				propertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());
				pvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));
			}
			else {
				pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);
			}
		}
		return definition;
	}
}",class,
"	@Override
	public void init() {
	}",method,
"	@Override
	@Nullable
	public BeanDefinition parse(Element element, ParserContext parserContext) {
		parserContext.getReaderContext().error(
				""Class ["" + getClass().getName() + ""] does not support custom elements."", element);
		return null;
	}",method,
"	@Override
	public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
		if (node instanceof Attr) {
			Attr attr = (Attr) node;
			String propertyName = parserContext.getDelegate().getLocalName(attr);
			String propertyValue = attr.getValue();
			MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();
			if (pvs.contains(propertyName)) {
				parserContext.getReaderContext().error(""Property '"" + propertyName + ""' is already defined using "" +
						""both <property> and inline syntax. Only one approach may be used per property."", attr);
			}
			if (propertyName.endsWith(REF_SUFFIX)) {
				propertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());
				pvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));
			}
			else {
				pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);
			}
		}
		return definition;
	}",method,
"		if (node instanceof Attr) {
			Attr attr = (Attr) node;
			String propertyName = parserContext.getDelegate().getLocalName(attr);
			String propertyValue = attr.getValue();
			MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();
			if (pvs.contains(propertyName)) {
				parserContext.getReaderContext().error(""Property '"" + propertyName + ""' is already defined using "" +
						""both <property> and inline syntax. Only one approach may be used per property."", attr);
			}
			if (propertyName.endsWith(REF_SUFFIX)) {
				propertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());
				pvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));
			}
			else {
				pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);
			}
		}",method,
"public class OutputDirectoryCreatingTaskExecuter implements TaskExecuter {
    private static final Logger LOGGER = Logging.getLogger(OutputDirectoryCreatingTaskExecuter.class);
    private final TaskExecuter executer;
    public OutputDirectoryCreatingTaskExecuter(TaskExecuter executer) {
        this.executer = executer;
    }
    public void execute(TaskInternal task, TaskStateInternal state, TaskExecutionContext context) {
        for (TaskOutputFilePropertySpec outputProperty : task.getOutputs().getFileProperties()) {
            OutputType type = outputProperty.getOutputType();
            for (File output : outputProperty.getPropertyFiles()) {
                ensureOutput(outputProperty, output, type);
            }
        }
        executer.execute(task, state, context);
    }
    private static void ensureOutput(TaskOutputFilePropertySpec outputProperty, File output, OutputType type) {
        if (output == null) {
            LOGGER.debug(""Not ensuring directory exists for property {}, because value is null"", outputProperty);
            return;
        }
        switch (type) {
            case DIRECTORY:
                LOGGER.debug(""Ensuring directory exists for property {} at {}"", outputProperty, output);
                mkdirs(output);
                break;
            case FILE:
                LOGGER.debug(""Ensuring parent directory exists for property {} at {}"", outputProperty, output);
                mkdirs(output.getParentFile());
                break;
            default:
                throw new AssertionError();
        }
    }
}",class,
"    public OutputDirectoryCreatingTaskExecuter(TaskExecuter executer) {
        this.executer = executer;
    }",method,
"    public void execute(TaskInternal task, TaskStateInternal state, TaskExecutionContext context) {
        for (TaskOutputFilePropertySpec outputProperty : task.getOutputs().getFileProperties()) {
            OutputType type = outputProperty.getOutputType();
            for (File output : outputProperty.getPropertyFiles()) {
                ensureOutput(outputProperty, output, type);
            }
        }
        executer.execute(task, state, context);
    }",method,
"    private static void ensureOutput(TaskOutputFilePropertySpec outputProperty, File output, OutputType type) {
        if (output == null) {
            LOGGER.debug(""Not ensuring directory exists for property {}, because value is null"", outputProperty);
            return;
        }
        switch (type) {
            case DIRECTORY:
                LOGGER.debug(""Ensuring directory exists for property {} at {}"", outputProperty, output);
                mkdirs(output);
                break;
            case FILE:
                LOGGER.debug(""Ensuring parent directory exists for property {} at {}"", outputProperty, output);
                mkdirs(output.getParentFile());
                break;
            default:
                throw new AssertionError();
        }
    }",method,
"        if (output == null) {
            LOGGER.debug(""Not ensuring directory exists for property {}, because value is null"", outputProperty);
            return;
        }",method,
"        switch (type) {
            case DIRECTORY:
                LOGGER.debug(""Ensuring directory exists for property {} at {}"", outputProperty, output);
                mkdirs(output);
                break;
            case FILE:
                LOGGER.debug(""Ensuring parent directory exists for property {} at {}"", outputProperty, output);
                mkdirs(output.getParentFile());
                break;
            default:
                throw new AssertionError();
        }",method,
"public class AssistDisclosure {
    private final Context mContext;
    private final WindowManager mWm;
    private final Handler mHandler;
    private AssistDisclosureView mView;
    private boolean mViewAdded;
    public AssistDisclosure(Context context, Handler handler) {
        mContext = context;
        mHandler = handler;
        mWm = mContext.getSystemService(WindowManager.class);
    }
    public void postShow() {
        mHandler.removeCallbacks(mShowRunnable);
        mHandler.post(mShowRunnable);
    }
    private void show() {
        if (mView == null) {
            mView = new AssistDisclosureView(mContext);
        }
        if (!mViewAdded) {
            WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                    WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,
                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                            | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
                            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
                            | WindowManager.LayoutParams.FLAG_FULLSCREEN
                            | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,
                    PixelFormat.TRANSLUCENT);
            lp.setTitle(""AssistDisclosure"");
            mWm.addView(mView, lp);
            mViewAdded = true;
        }
    }
    private void hide() {
        if (mViewAdded) {
            mWm.removeView(mView);
            mViewAdded = false;
        }
    }
    private Runnable mShowRunnable = new Runnable() {
        @Override
        public void run() {
            show();
        }
    };
    private class AssistDisclosureView extends View
            implements ValueAnimator.AnimatorUpdateListener {
        static final int FULL_ALPHA = 222; // 87%
        static final int ALPHA_IN_ANIMATION_DURATION = 400;
        static final int ALPHA_OUT_ANIMATION_DURATION = 300;
        private float mThickness;
        private float mShadowThickness;
        private final Paint mPaint = new Paint();
        private final Paint mShadowPaint = new Paint();
        private final ValueAnimator mAlphaOutAnimator;
        private final ValueAnimator mAlphaInAnimator;
        private final AnimatorSet mAnimator;
        private int mAlpha = 0;
        public AssistDisclosureView(Context context) {
            super(context);
            mAlphaInAnimator = ValueAnimator.ofInt(0, FULL_ALPHA)
                    .setDuration(ALPHA_IN_ANIMATION_DURATION);
            mAlphaInAnimator.addUpdateListener(this);
            mAlphaInAnimator.setInterpolator(Interpolators.CUSTOM_40_40);
            mAlphaOutAnimator = ValueAnimator.ofInt(FULL_ALPHA, 0).setDuration(
                    ALPHA_OUT_ANIMATION_DURATION);
            mAlphaOutAnimator.addUpdateListener(this);
            mAlphaOutAnimator.setInterpolator(Interpolators.CUSTOM_40_40);
            mAnimator = new AnimatorSet();
            mAnimator.play(mAlphaInAnimator).before(mAlphaOutAnimator);
            mAnimator.addListener(new AnimatorListenerAdapter() {
                boolean mCancelled;
                @Override
                public void onAnimationStart(Animator animation) {
                    mCancelled = false;
                }
                @Override
                public void onAnimationCancel(Animator animation) {
                    mCancelled = true;
                }
                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCancelled) {
                        hide();
                    }
                }
            });
            PorterDuffXfermode srcMode = new PorterDuffXfermode(PorterDuff.Mode.SRC);
            mPaint.setColor(Color.WHITE);
            mPaint.setXfermode(srcMode);
            mShadowPaint.setColor(Color.DKGRAY);
            mShadowPaint.setXfermode(srcMode);
            mThickness = getResources().getDimension(R.dimen.assist_disclosure_thickness);
            mShadowThickness = getResources().getDimension(
                    R.dimen.assist_disclosure_shadow_thickness);
        }
        @Override
        protected void onAttachedToWindow() {
            super.onAttachedToWindow();
            startAnimation();
            sendAccessibilityEvent(AccessibilityEvent.TYPE_ASSIST_READING_CONTEXT);
        }
        @Override
        protected void onDetachedFromWindow() {
            super.onDetachedFromWindow();
            mAnimator.cancel();
            mAlpha = 0;
        }
        private void startAnimation() {
            mAnimator.cancel();
            mAnimator.start();
        }
        @Override
        protected void onDraw(Canvas canvas) {
            mPaint.setAlpha(mAlpha);
            mShadowPaint.setAlpha(mAlpha / 4);
            drawGeometry(canvas, mShadowPaint, mShadowThickness);
            drawGeometry(canvas, mPaint, 0);
        }
        private void drawGeometry(Canvas canvas, Paint paint, float padding) {
            final int width = getWidth();
            final int height = getHeight();
            float thickness = mThickness;
            // bottom
            drawBeam(canvas,
                    0,
                    height - thickness,
                    width,
                    height, paint, padding);
            // sides
            drawBeam(canvas,
                    0,
                    0,
                    thickness,
                    height - thickness, paint, padding);
            drawBeam(canvas,
                    width - thickness,
                    0,
                    width,
                    height - thickness, paint, padding);
            // top
            drawBeam(canvas,
                    thickness,
                    0,
                    width - thickness,
                    thickness, paint, padding);
        }
        private void drawBeam(Canvas canvas, float left, float top, float right, float bottom,
                Paint paint, float padding) {
            canvas.drawRect(left - padding,
                    top - padding,
                    right + padding,
                    bottom + padding,
                    paint);
        }
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            if (animation == mAlphaOutAnimator) {
                mAlpha = (int) mAlphaOutAnimator.getAnimatedValue();
            } else if (animation == mAlphaInAnimator) {
                mAlpha = (int) mAlphaInAnimator.getAnimatedValue();
            }
            invalidate();
        }
    }
}",class,
"    private class AssistDisclosureView extends View
            implements ValueAnimator.AnimatorUpdateListener {
        static final int FULL_ALPHA = 222; // 87%
        static final int ALPHA_IN_ANIMATION_DURATION = 400;
        static final int ALPHA_OUT_ANIMATION_DURATION = 300;
        private float mThickness;
        private float mShadowThickness;
        private final Paint mPaint = new Paint();
        private final Paint mShadowPaint = new Paint();
        private final ValueAnimator mAlphaOutAnimator;
        private final ValueAnimator mAlphaInAnimator;
        private final AnimatorSet mAnimator;
        private int mAlpha = 0;
        public AssistDisclosureView(Context context) {
            super(context);
            mAlphaInAnimator = ValueAnimator.ofInt(0, FULL_ALPHA)
                    .setDuration(ALPHA_IN_ANIMATION_DURATION);
            mAlphaInAnimator.addUpdateListener(this);
            mAlphaInAnimator.setInterpolator(Interpolators.CUSTOM_40_40);
            mAlphaOutAnimator = ValueAnimator.ofInt(FULL_ALPHA, 0).setDuration(
                    ALPHA_OUT_ANIMATION_DURATION);
            mAlphaOutAnimator.addUpdateListener(this);
            mAlphaOutAnimator.setInterpolator(Interpolators.CUSTOM_40_40);
            mAnimator = new AnimatorSet();
            mAnimator.play(mAlphaInAnimator).before(mAlphaOutAnimator);
            mAnimator.addListener(new AnimatorListenerAdapter() {
                boolean mCancelled;
                @Override
                public void onAnimationStart(Animator animation) {
                    mCancelled = false;
                }
                @Override
                public void onAnimationCancel(Animator animation) {
                    mCancelled = true;
                }
                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCancelled) {
                        hide();
                    }
                }
            });
            PorterDuffXfermode srcMode = new PorterDuffXfermode(PorterDuff.Mode.SRC);
            mPaint.setColor(Color.WHITE);
            mPaint.setXfermode(srcMode);
            mShadowPaint.setColor(Color.DKGRAY);
            mShadowPaint.setXfermode(srcMode);
            mThickness = getResources().getDimension(R.dimen.assist_disclosure_thickness);
            mShadowThickness = getResources().getDimension(
                    R.dimen.assist_disclosure_shadow_thickness);
        }
        @Override
        protected void onAttachedToWindow() {
            super.onAttachedToWindow();
            startAnimation();
            sendAccessibilityEvent(AccessibilityEvent.TYPE_ASSIST_READING_CONTEXT);
        }
        @Override
        protected void onDetachedFromWindow() {
            super.onDetachedFromWindow();
            mAnimator.cancel();
            mAlpha = 0;
        }
        private void startAnimation() {
            mAnimator.cancel();
            mAnimator.start();
        }
        @Override
        protected void onDraw(Canvas canvas) {
            mPaint.setAlpha(mAlpha);
            mShadowPaint.setAlpha(mAlpha / 4);
            drawGeometry(canvas, mShadowPaint, mShadowThickness);
            drawGeometry(canvas, mPaint, 0);
        }
        private void drawGeometry(Canvas canvas, Paint paint, float padding) {
            final int width = getWidth();
            final int height = getHeight();
            float thickness = mThickness;
            // bottom
            drawBeam(canvas,
                    0,
                    height - thickness,
                    width,
                    height, paint, padding);
            // sides
            drawBeam(canvas,
                    0,
                    0,
                    thickness,
                    height - thickness, paint, padding);
            drawBeam(canvas,
                    width - thickness,
                    0,
                    width,
                    height - thickness, paint, padding);
            // top
            drawBeam(canvas,
                    thickness,
                    0,
                    width - thickness,
                    thickness, paint, padding);
        }
        private void drawBeam(Canvas canvas, float left, float top, float right, float bottom,
                Paint paint, float padding) {
            canvas.drawRect(left - padding,
                    top - padding,
                    right + padding,
                    bottom + padding,
                    paint);
        }
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            if (animation == mAlphaOutAnimator) {
                mAlpha = (int) mAlphaOutAnimator.getAnimatedValue();
            } else if (animation == mAlphaInAnimator) {
                mAlpha = (int) mAlphaInAnimator.getAnimatedValue();
            }
            invalidate();
        }
    }",class,
"    public AssistDisclosure(Context context, Handler handler) {
        mContext = context;
        mHandler = handler;
        mWm = mContext.getSystemService(WindowManager.class);
    }",method,
"    public void postShow() {
        mHandler.removeCallbacks(mShowRunnable);
        mHandler.post(mShowRunnable);
    }",method,
"    private void show() {
        if (mView == null) {
            mView = new AssistDisclosureView(mContext);
        }
        if (!mViewAdded) {
            WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                    WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,
                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                            | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
                            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
                            | WindowManager.LayoutParams.FLAG_FULLSCREEN
                            | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,
                    PixelFormat.TRANSLUCENT);
            lp.setTitle(""AssistDisclosure"");
            mWm.addView(mView, lp);
            mViewAdded = true;
        }
    }",method,
"        if (mView == null) {
            mView = new AssistDisclosureView(mContext);
        }",method,
"        if (!mViewAdded) {
            WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                    WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,
                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                            | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
                            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
                            | WindowManager.LayoutParams.FLAG_FULLSCREEN
                            | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,
                    PixelFormat.TRANSLUCENT);
            lp.setTitle(""AssistDisclosure"");
            mWm.addView(mView, lp);
            mViewAdded = true;
        }",method,
"    private void hide() {
        if (mViewAdded) {
            mWm.removeView(mView);
            mViewAdded = false;
        }
    }",method,
"        if (mViewAdded) {
            mWm.removeView(mView);
            mViewAdded = false;
        }",method,
"        @Override
        public void run() {
            show();
        }",method,
"        public AssistDisclosureView(Context context) {
            super(context);
            mAlphaInAnimator = ValueAnimator.ofInt(0, FULL_ALPHA)
                    .setDuration(ALPHA_IN_ANIMATION_DURATION);
            mAlphaInAnimator.addUpdateListener(this);
            mAlphaInAnimator.setInterpolator(Interpolators.CUSTOM_40_40);
            mAlphaOutAnimator = ValueAnimator.ofInt(FULL_ALPHA, 0).setDuration(
                    ALPHA_OUT_ANIMATION_DURATION);
            mAlphaOutAnimator.addUpdateListener(this);
            mAlphaOutAnimator.setInterpolator(Interpolators.CUSTOM_40_40);
            mAnimator = new AnimatorSet();
            mAnimator.play(mAlphaInAnimator).before(mAlphaOutAnimator);
            mAnimator.addListener(new AnimatorListenerAdapter() {
                boolean mCancelled;
                @Override
                public void onAnimationStart(Animator animation) {
                    mCancelled = false;
                }
                @Override
                public void onAnimationCancel(Animator animation) {
                    mCancelled = true;
                }
                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCancelled) {
                        hide();
                    }
                }
            });
            PorterDuffXfermode srcMode = new PorterDuffXfermode(PorterDuff.Mode.SRC);
            mPaint.setColor(Color.WHITE);
            mPaint.setXfermode(srcMode);
            mShadowPaint.setColor(Color.DKGRAY);
            mShadowPaint.setXfermode(srcMode);
            mThickness = getResources().getDimension(R.dimen.assist_disclosure_thickness);
            mShadowThickness = getResources().getDimension(
                    R.dimen.assist_disclosure_shadow_thickness);
        }",method,
"            mAnimator.addListener(new AnimatorListenerAdapter() {
                boolean mCancelled;
                @Override
                public void onAnimationStart(Animator animation) {
                    mCancelled = false;
                }
                @Override
                public void onAnimationCancel(Animator animation) {
                    mCancelled = true;
                }
                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCancelled) {
                        hide();
                    }
                }
            }",method,
"                @Override
                public void onAnimationStart(Animator animation) {
                    mCancelled = false;
                }",method,
"                @Override
                public void onAnimationCancel(Animator animation) {
                    mCancelled = true;
                }",method,
"                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCancelled) {
                        hide();
                    }
                }",method,
"                    if (!mCancelled) {
                        hide();
                    }",method,
"        @Override
        protected void onAttachedToWindow() {
            super.onAttachedToWindow();
            startAnimation();
            sendAccessibilityEvent(AccessibilityEvent.TYPE_ASSIST_READING_CONTEXT);
        }",method,
"        @Override
        protected void onDetachedFromWindow() {
            super.onDetachedFromWindow();
            mAnimator.cancel();
            mAlpha = 0;
        }",method,
"        private void startAnimation() {
            mAnimator.cancel();
            mAnimator.start();
        }",method,
"        @Override
        protected void onDraw(Canvas canvas) {
            mPaint.setAlpha(mAlpha);
            mShadowPaint.setAlpha(mAlpha / 4);
            drawGeometry(canvas, mShadowPaint, mShadowThickness);
            drawGeometry(canvas, mPaint, 0);
        }",method,
"        private void drawGeometry(Canvas canvas, Paint paint, float padding) {
            final int width = getWidth();
            final int height = getHeight();
            float thickness = mThickness;
            // bottom
            drawBeam(canvas,
                    0,
                    height - thickness,
                    width,
                    height, paint, padding);
            // sides
            drawBeam(canvas,
                    0,
                    0,
                    thickness,
                    height - thickness, paint, padding);
            drawBeam(canvas,
                    width - thickness,
                    0,
                    width,
                    height - thickness, paint, padding);
            // top
            drawBeam(canvas,
                    thickness,
                    0,
                    width - thickness,
                    thickness, paint, padding);
        }",method,
"        private void drawBeam(Canvas canvas, float left, float top, float right, float bottom,
                Paint paint, float padding) {
            canvas.drawRect(left - padding,
                    top - padding,
                    right + padding,
                    bottom + padding,
                    paint);
        }",method,
"        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            if (animation == mAlphaOutAnimator) {
                mAlpha = (int) mAlphaOutAnimator.getAnimatedValue();
            } else if (animation == mAlphaInAnimator) {
                mAlpha = (int) mAlphaInAnimator.getAnimatedValue();
            }
            invalidate();
        }",method,
"            if (animation == mAlphaOutAnimator) {
                mAlpha = (int) mAlphaOutAnimator.getAnimatedValue();
            }",method,
"public class ConcatRope extends ManagedRope {
    private final Rope left;
    private final Rope right;
    private final boolean balanced;
    public ConcatRope(Rope left, Rope right, Encoding encoding, CodeRange codeRange, boolean singleByteOptimizable, int depth, boolean balanced) {
        this(left, right, encoding, codeRange, singleByteOptimizable, depth, null, balanced);
    }
    private ConcatRope(Rope left, Rope right, Encoding encoding, CodeRange codeRange, boolean singleByteOptimizable, int depth, byte[] bytes, boolean balanced) {
        super(encoding,
                codeRange,
                singleByteOptimizable,
                left.byteLength() + right.byteLength(),
                left.characterLength() + right.characterLength(),
                depth,
                bytes);
        assert !(left instanceof NativeRope);
        assert !(right instanceof NativeRope);
        this.left = left;
        this.right = right;
        this.balanced = balanced;
    }
    @Override
    public Rope withEncoding(Encoding newEncoding, CodeRange newCodeRange) {
        if (newCodeRange != getCodeRange()) {
            throw new UnsupportedOperationException(""Cannot fast-path updating encoding with different code range."");
        }
        return new ConcatRope(getLeft(), getRight(), newEncoding, newCodeRange, isSingleByteOptimizable(), depth(), getRawBytes(), balanced);
    }
    @Override
    @TruffleBoundary
    public byte getByteSlow(int index) {
        if (index < left.byteLength()) {
            return left.getByteSlow(index);
        }
        return right.getByteSlow(index - left.byteLength());
    }
    public Rope getLeft() {
        return left;
    }
    public Rope getRight() {
        return right;
    }
    public boolean isBalanced() {
        return balanced;
    }
    @Override
    public String toString() {
        // This should be used for debugging only.
        return left.toString() + right.toString();
    }
}",class,
"    public ConcatRope(Rope left, Rope right, Encoding encoding, CodeRange codeRange, boolean singleByteOptimizable, int depth, boolean balanced) {
        this(left, right, encoding, codeRange, singleByteOptimizable, depth, null, balanced);
    }",method,
"    private ConcatRope(Rope left, Rope right, Encoding encoding, CodeRange codeRange, boolean singleByteOptimizable, int depth, byte[] bytes, boolean balanced) {
        super(encoding,
                codeRange,
                singleByteOptimizable,
                left.byteLength() + right.byteLength(),
                left.characterLength() + right.characterLength(),
                depth,
                bytes);
        assert !(left instanceof NativeRope);
        assert !(right instanceof NativeRope);
        this.left = left;
        this.right = right;
        this.balanced = balanced;
    }",method,
"    @Override
    public Rope withEncoding(Encoding newEncoding, CodeRange newCodeRange) {
        if (newCodeRange != getCodeRange()) {
            throw new UnsupportedOperationException(""Cannot fast-path updating encoding with different code range."");
        }
        return new ConcatRope(getLeft(), getRight(), newEncoding, newCodeRange, isSingleByteOptimizable(), depth(), getRawBytes(), balanced);
    }",method,
"    @Override
    @TruffleBoundary
    public byte getByteSlow(int index) {
        if (index < left.byteLength()) {
            return left.getByteSlow(index);
        }
        return right.getByteSlow(index - left.byteLength());
    }",method,
"    public Rope getLeft() {
        return left;
    }",method,
"    public Rope getRight() {
        return right;
    }",method,
"    public boolean isBalanced() {
        return balanced;
    }",method,
"    @Override
    public String toString() {
        // This should be used for debugging only.
        return left.toString() + right.toString();
    }",method,
"public class PyTreeStructureProvider implements SelectableTreeStructureProvider, DumbAware {
  @NotNull
  @Override
  public Collection<AbstractTreeNode> modify(@NotNull AbstractTreeNode parent,
                                             @NotNull Collection<AbstractTreeNode> children,
                                             ViewSettings settings) {
    final Project project = parent.getProject();
    final Sdk sdk = getPythonSdk(parent);
    if (sdk != null && project != null) {
      final Collection<AbstractTreeNode> newChildren = hideSkeletons(children);
      final PySkeletonsNode skeletonsNode = PySkeletonsNode.create(project, sdk, settings);
      if (skeletonsNode != null) {
        newChildren.add(skeletonsNode);
      }
      final PyUserSkeletonsNode userSkeletonsNode = PyUserSkeletonsNode.create(project, settings);
      if (userSkeletonsNode != null) {
        newChildren.add(userSkeletonsNode);
      }
      final PyRemoteLibrariesNode remoteLibrariesNode = PyRemoteLibrariesNode.create(project, sdk, settings);
      if (remoteLibrariesNode != null) {
        newChildren.add(remoteLibrariesNode);
      }
      final PyTypeShedNode typeShedNode = PyTypeShedNode.Companion.create(project, sdk, settings);
      if (typeShedNode != null) {
        newChildren.add(typeShedNode);
      }
      return newChildren;
    }
    if (settings.isShowMembers()) {
      List<AbstractTreeNode> newChildren = new ArrayList<>();
      for (AbstractTreeNode child : children) {
        if (child instanceof PsiFileNode && ((PsiFileNode)child).getValue() instanceof PyFile) {
          newChildren.add(new PyFileNode(project, ((PsiFileNode)child).getValue(), settings));
        }
        else {
          newChildren.add(child);
        }
      }
      return newChildren;
    }
    return children;
  }
  @Nullable
  private static Sdk getPythonSdk(@NotNull AbstractTreeNode node) {
    if (node instanceof NamedLibraryElementNode) {
      final NamedLibraryElement value = ((NamedLibraryElementNode)node).getValue();
      if (value != null) {
        final LibraryOrSdkOrderEntry entry = value.getOrderEntry();
        if (entry instanceof JdkOrderEntry) {
          final Sdk sdk = ((JdkOrderEntry)entry).getJdk();
          final SdkTypeId type = sdk.getSdkType();
          if (type instanceof PythonSdkType) {
            return sdk;
          }
        }
      }
    }
    return null;
  }
  @NotNull
  private static Collection<AbstractTreeNode> hideSkeletons(@NotNull Collection<AbstractTreeNode> children) {
    List<AbstractTreeNode> newChildren = new ArrayList<>();
    for (AbstractTreeNode child : children) {
      if (child instanceof PsiDirectoryNode) {
        PsiDirectory directory = ((PsiDirectoryNode)child).getValue();
        if (directory == null) {
          continue;
        }
        VirtualFile dir = directory.getVirtualFile();
        if (dir.equals(PyUserSkeletonsUtil.getUserSkeletonsDirectory())) {
          continue;
        }
        if (dir.getFileSystem() instanceof JarFileSystem) {
          dir = ((JarFileSystem)dir.getFileSystem()).getLocalByEntry(dir);
        }
        if (dir == null) {
          continue;
        }
        if (PyTypeShed.INSTANCE.isInside(dir)) {
          continue;
        }
        VirtualFile dirParent = dir.getParent();
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.SKELETON_DIR_NAME)) {
          continue;
        }
        if (dirParent != null && dirParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
          continue;
        }
        if (dirParent != null) {
          VirtualFile grandParent = dirParent.getParent();
          if (grandParent != null && grandParent.getName().equals(PythonSdkType.REMOTE_SOURCES_DIR_NAME)) {
            continue;
          }
        }
      }
      newChildren.add(child);
    }
    return newChildren;
  }
  @Override
  public PsiElement getTopLevelElement(PsiElement element) {
    PyPsiUtils.assertValid(element);
    final Ref<PsiFile> containingFileRef = Ref.create();
    ApplicationManager.getApplication().runReadAction(() -> containingFileRef.set(element.getContainingFile()));
    final PsiFile containingFile = containingFileRef.get();
    if (!(containingFile instanceof PyFile)) {
      return null;
    }
    List<PsiElement> parents = new ArrayList<>();
    PyDocStringOwner container = PsiTreeUtil.getParentOfType(element, PyDocStringOwner.class);
    while (container != null) {
      if (container instanceof PyFile) {
        break;
      }
      parents.add(0, container);
      container = PsiTreeUtil.getParentOfType(container, PyDocStringOwner.class);
    }
    for (PsiElement parent : parents) {
      if (parent instanceof PyFunction) {
        return parent;     // we don't display any nodes under functions
      }
    }
    if (parents.size() > 0) {
      return parents.get(parents.size() - 1);
    }
    return element.getContainingFile();
  }
}",class,
"  @NotNull
  @Override
  public Collection<AbstractTreeNode> modify(@NotNull AbstractTreeNode parent,
                                             @NotNull Collection<AbstractTreeNode> children,
                                             ViewSettings settings) {
    final Project project = parent.getProject();
    final Sdk sdk = getPythonSdk(parent);
    if (sdk != null && project != null) {
      final Collection<AbstractTreeNode> newChildren = hideSkeletons(children);
      final PySkeletonsNode skeletonsNode = PySkeletonsNode.create(project, sdk, settings);
      if (skeletonsNode != null) {
        newChildren.add(skeletonsNode);
      }
      final PyUserSkeletonsNode userSkeletonsNode = PyUserSkeletonsNode.create(project, settings);
      if (userSkeletonsNode != null) {
        newChildren.add(userSkeletonsNode);
      }
      final PyRemoteLibrariesNode remoteLibrariesNode = PyRemoteLibrariesNode.create(project, sdk, settings);
      if (remoteLibrariesNode != null) {
        newChildren.add(remoteLibrariesNode);
      }
      final PyTypeShedNode typeShedNode = PyTypeShedNode.Companion.create(project, sdk, settings);
      if (typeShedNode != null) {
        newChildren.add(typeShedNode);
      }
      return newChildren;
    }
    if (settings.isShowMembers()) {
      List<AbstractTreeNode> newChildren = new ArrayList<>();
      for (AbstractTreeNode child : children) {
        if (child instanceof PsiFileNode && ((PsiFileNode)child).getValue() instanceof PyFile) {
          newChildren.add(new PyFileNode(project, ((PsiFileNode)child).getValue(), settings));
        }
        else {
          newChildren.add(child);
        }
      }
      return newChildren;
    }
    return children;
  }",method,
"    if (sdk != null && project != null) {
      final Collection<AbstractTreeNode> newChildren = hideSkeletons(children);
      final PySkeletonsNode skeletonsNode = PySkeletonsNode.create(project, sdk, settings);
      if (skeletonsNode != null) {
        newChildren.add(skeletonsNode);
      }
      final PyUserSkeletonsNode userSkeletonsNode = PyUserSkeletonsNode.create(project, settings);
      if (userSkeletonsNode != null) {
        newChildren.add(userSkeletonsNode);
      }
      final PyRemoteLibrariesNode remoteLibrariesNode = PyRemoteLibrariesNode.create(project, sdk, settings);
      if (remoteLibrariesNode != null) {
        newChildren.add(remoteLibrariesNode);
      }
      final PyTypeShedNode typeShedNode = PyTypeShedNode.Companion.create(project, sdk, settings);
      if (typeShedNode != null) {
        newChildren.add(typeShedNode);
      }
      return newChildren;
    }",method,
"      if (skeletonsNode != null) {
        newChildren.add(skeletonsNode);
      }",method,
"      if (userSkeletonsNode != null) {
        newChildren.add(userSkeletonsNode);
      }",method,
"      if (remoteLibrariesNode != null) {
        newChildren.add(remoteLibrariesNode);
      }",method,
"      if (typeShedNode != null) {
        newChildren.add(typeShedNode);
      }",method,
"      for (AbstractTreeNode child : children) {
        if (child instanceof PsiFileNode && ((PsiFileNode)child).getValue() instanceof PyFile) {
          newChildren.add(new PyFileNode(project, ((PsiFileNode)child).getValue(), settings));
        }
        else {
          newChildren.add(child);
        }
      }",method,
"  @Nullable
  private static Sdk getPythonSdk(@NotNull AbstractTreeNode node) {
    if (node instanceof NamedLibraryElementNode) {
      final NamedLibraryElement value = ((NamedLibraryElementNode)node).getValue();
      if (value != null) {
        final LibraryOrSdkOrderEntry entry = value.getOrderEntry();
        if (entry instanceof JdkOrderEntry) {
          final Sdk sdk = ((JdkOrderEntry)entry).getJdk();
          final SdkTypeId type = sdk.getSdkType();
          if (type instanceof PythonSdkType) {
            return sdk;
          }
        }
      }
    }
    return null;
  }",method,

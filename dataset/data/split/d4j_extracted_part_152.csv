code_snippet,type,score
"public class ArrayAccessInstrumentor extends MethodInstrumentor {
    public ArrayAccessInstrumentor(MethodVisitor mv, String parentClz, String superClz,
        int access, String name, String desc) {
        super(mv, parentClz, superClz, access, name, desc);
    }
    public void visitInsn(int opcode) {
        boolean arrayload = false;
        boolean arraystore = false;
        switch (opcode) {
            case IALOAD: case LALOAD:
            case FALOAD: case DALOAD:
            case AALOAD: case BALOAD:
            case CALOAD: case SALOAD:
                arrayload = true;
                break;
            case IASTORE: case LASTORE:
            case FASTORE: case DASTORE:
            case AASTORE: case BASTORE:
            case CASTORE: case SASTORE:
                arraystore = true;
                break;
        }
        if (arrayload) {
            onBeforeArrayLoad(opcode);
        } else if (arraystore) {
            onBeforeArrayStore(opcode);
        }
        super.visitInsn(opcode);
        if (arrayload) {
            onAfterArrayLoad(opcode);
        } else if (arraystore) {
            onAfterArrayStore(opcode);
        }
    }
    protected void onBeforeArrayLoad(int opcode) {}
    protected void onAfterArrayLoad(int opcode) {}
    protected void onBeforeArrayStore(int opcode) {}
    protected void onAfterArrayStore(int opcode) {}
    public static void main(final String[] args) throws Exception {
        if (args.length != 1) {
            System.err.println(""Usage: java com.sun.btrace.runtime.ArrayAccessInstrumentor <class>"");
            System.exit(1);
        }
        args[0] = args[0].replace('.', '/');
        FileInputStream fis = new FileInputStream(args[0] + "".class"");
        ClassReader reader = new ClassReader(new BufferedInputStream(fis));
        FileOutputStream fos = new FileOutputStream(args[0] + "".class"");
        ClassWriter writer = InstrumentUtils.newClassWriter();
        InstrumentUtils.accept(reader, 
            new ClassVisitor(Opcodes.ASM4, writer) {
                 public MethodVisitor visitMethod(int access, String name, String desc, 
                     String signature, String[] exceptions) {
                     MethodVisitor mv = super.visitMethod(access, name, desc, 
                             signature, exceptions);
                     return new ArrayAccessInstrumentor(mv, args[0], args[0], access, name, desc) {
                    @Override
                    protected void onAfterArrayLoad(int opcode) {
                        println(""after array load"");
                    }
                    @Override
                    protected void onAfterArrayStore(int opcode) {
                        println(""after array store"");
                    }
                    @Override
                    protected void onBeforeArrayLoad(int opcode) {
                        println(""before array load"");
                    }
                    @Override
                    protected void onBeforeArrayStore(int opcode) {
                        println(""before array store"");
                    }
                     };
                 }
            });
        fos.write(writer.toByteArray());
    }
}",class,
"    public ArrayAccessInstrumentor(MethodVisitor mv, String parentClz, String superClz,
        int access, String name, String desc) {
        super(mv, parentClz, superClz, access, name, desc);
    }",method,
"    public void visitInsn(int opcode) {
        boolean arrayload = false;
        boolean arraystore = false;
        switch (opcode) {
            case IALOAD: case LALOAD:
            case FALOAD: case DALOAD:
            case AALOAD: case BALOAD:
            case CALOAD: case SALOAD:
                arrayload = true;
                break;
            case IASTORE: case LASTORE:
            case FASTORE: case DASTORE:
            case AASTORE: case BASTORE:
            case CASTORE: case SASTORE:
                arraystore = true;
                break;
        }
        if (arrayload) {
            onBeforeArrayLoad(opcode);
        } else if (arraystore) {
            onBeforeArrayStore(opcode);
        }
        super.visitInsn(opcode);
        if (arrayload) {
            onAfterArrayLoad(opcode);
        } else if (arraystore) {
            onAfterArrayStore(opcode);
        }
    }",method,
"        switch (opcode) {
            case IALOAD: case LALOAD:
            case FALOAD: case DALOAD:
            case AALOAD: case BALOAD:
            case CALOAD: case SALOAD:
                arrayload = true;
                break;
            case IASTORE: case LASTORE:
            case FASTORE: case DASTORE:
            case AASTORE: case BASTORE:
            case CASTORE: case SASTORE:
                arraystore = true;
                break;
        }",method,
"        if (arrayload) {
            onBeforeArrayLoad(opcode);
        }",method,
"        if (arrayload) {
            onAfterArrayLoad(opcode);
        }",method,
    protected void onBeforeArrayLoad(int opcode) {},method,
    protected void onAfterArrayLoad(int opcode) {},method,
    protected void onBeforeArrayStore(int opcode) {},method,
    protected void onAfterArrayStore(int opcode) {},method,
"    public static void main(final String[] args) throws Exception {
        if (args.length != 1) {
            System.err.println(""Usage: java com.sun.btrace.runtime.ArrayAccessInstrumentor <class>"");
            System.exit(1);
        }
        args[0] = args[0].replace('.', '/');
        FileInputStream fis = new FileInputStream(args[0] + "".class"");
        ClassReader reader = new ClassReader(new BufferedInputStream(fis));
        FileOutputStream fos = new FileOutputStream(args[0] + "".class"");
        ClassWriter writer = InstrumentUtils.newClassWriter();
        InstrumentUtils.accept(reader, 
            new ClassVisitor(Opcodes.ASM4, writer) {
                 public MethodVisitor visitMethod(int access, String name, String desc, 
                     String signature, String[] exceptions) {
                     MethodVisitor mv = super.visitMethod(access, name, desc, 
                             signature, exceptions);
                     return new ArrayAccessInstrumentor(mv, args[0], args[0], access, name, desc) {
                    @Override
                    protected void onAfterArrayLoad(int opcode) {
                        println(""after array load"");
                    }
                    @Override
                    protected void onAfterArrayStore(int opcode) {
                        println(""after array store"");
                    }
                    @Override
                    protected void onBeforeArrayLoad(int opcode) {
                        println(""before array load"");
                    }
                    @Override
                    protected void onBeforeArrayStore(int opcode) {
                        println(""before array store"");
                    }
                     };
                 }
            });
        fos.write(writer.toByteArray());
    }",method,
"        if (args.length != 1) {
            System.err.println(""Usage: java com.sun.btrace.runtime.ArrayAccessInstrumentor <class>"");
            System.exit(1);
        }",method,
"        InstrumentUtils.accept(reader, 
            new ClassVisitor(Opcodes.ASM4, writer) {
                 public MethodVisitor visitMethod(int access, String name, String desc, 
                     String signature, String[] exceptions) {
                     MethodVisitor mv = super.visitMethod(access, name, desc, 
                             signature, exceptions);
                     return new ArrayAccessInstrumentor(mv, args[0], args[0], access, name, desc) {
                    @Override
                    protected void onAfterArrayLoad(int opcode) {
                        println(""after array load"");
                    }
                    @Override
                    protected void onAfterArrayStore(int opcode) {
                        println(""after array store"");
                    }
                    @Override
                    protected void onBeforeArrayLoad(int opcode) {
                        println(""before array load"");
                    }
                    @Override
                    protected void onBeforeArrayStore(int opcode) {
                        println(""before array store"");
                    }
                     };
                 }
            }",method,
"                 public MethodVisitor visitMethod(int access, String name, String desc, 
                     String signature, String[] exceptions) {
                     MethodVisitor mv = super.visitMethod(access, name, desc, 
                             signature, exceptions);
                     return new ArrayAccessInstrumentor(mv, args[0], args[0], access, name, desc) {
                    @Override
                    protected void onAfterArrayLoad(int opcode) {
                        println(""after array load"");
                    }
                    @Override
                    protected void onAfterArrayStore(int opcode) {
                        println(""after array store"");
                    }
                    @Override
                    protected void onBeforeArrayLoad(int opcode) {
                        println(""before array load"");
                    }
                    @Override
                    protected void onBeforeArrayStore(int opcode) {
                        println(""before array store"");
                    }
                     };
                 }",method,
"                     return new ArrayAccessInstrumentor(mv, args[0], args[0], access, name, desc) {
                    @Override
                    protected void onAfterArrayLoad(int opcode) {
                        println(""after array load"");
                    }
                    @Override
                    protected void onAfterArrayStore(int opcode) {
                        println(""after array store"");
                    }
                    @Override
                    protected void onBeforeArrayLoad(int opcode) {
                        println(""before array load"");
                    }
                    @Override
                    protected void onBeforeArrayStore(int opcode) {
                        println(""before array store"");
                    }
                     }",method,
"                    @Override
                    protected void onAfterArrayLoad(int opcode) {
                        println(""after array load"");
                    }",method,
"                    @Override
                    protected void onAfterArrayStore(int opcode) {
                        println(""after array store"");
                    }",method,
"                    @Override
                    protected void onBeforeArrayLoad(int opcode) {
                        println(""before array load"");
                    }",method,
"                    @Override
                    protected void onBeforeArrayStore(int opcode) {
                        println(""before array store"");
                    }",method,
"public class NoActivityJUnit4Test extends NoActivityJUnit3Test {
  @org.junit.Test
  public void multidexedTestJUnit4() {
    super.testMultidexedTest();
  }
}",class,
"public class NoActivitySubTest {
  public static int get() {
    return 7;
  }
}",class,
"  @org.junit.Test
  public void multidexedTestJUnit4() {
    super.testMultidexedTest();
  }",method,
"  public static int get() {
    return 7;
  }",method,
"public class ViewDumpParser {
    private Map<String, Short> mIds;
    private List<Map<Short,Object>> mViews;
    public void parse(byte[] data) {
        Decoder d = new Decoder(ByteBuffer.wrap(data));
        mViews = new ArrayList<>(100);
        boolean dataIncludesWindowPosition = (data[0] == 'S');
        Short windowLeftKey = null, windowTopKey = null;
        Integer windowLeftValue = null, windowTopValue = null;
        if (dataIncludesWindowPosition) {
            windowLeftKey = (Short) d.readObject();
            windowLeftValue = (Integer) d.readObject();
            windowTopKey = (Short) d.readObject();
            windowTopValue = (Integer) d.readObject();
        }
        while (d.hasRemaining()) {
            Object o = d.readObject();
            if (o instanceof Map) {
                //noinspection unchecked
                mViews.add((Map<Short, Object>) o);
            }
        }
        if (mViews.isEmpty()) {
            return;
        }
        if (dataIncludesWindowPosition) {
          mViews.get(0).put(windowLeftKey, windowLeftValue);
          mViews.get(0).put(windowTopKey, windowTopValue);
        }
        // the last one is the property map
        Map<Short,Object> idMap = mViews.remove(mViews.size() - 1);
        mIds = reverse(idMap);
    }
    public String getFirstView() {
        if (mViews.isEmpty()) {
            return null;
        }
        Map<Short, Object> props = mViews.get(0);
        Object name = getProperty(props, ""__name__"");
        Object hash = getProperty(props, ""__hash__"");
        if (name instanceof String && hash instanceof Integer) {
            return String.format(Locale.US, ""%s@%x"", name, hash);
        } else {
            return null;
        }
    }
    private Object getProperty(Map<Short, Object> props, String key) {
        return props.get(mIds.get(key));
    }
    private static Map<String, Short> reverse(Map<Short, Object> m) {
        Map<String, Short> r = new HashMap<String, Short>(m.size());
        for (Map.Entry<Short, Object> e : m.entrySet()) {
            r.put((String)e.getValue(), e.getKey());
        }
        return r;
    }
    public List<Map<Short, Object>> getViews() {
        return mViews;
    }
    public Map<String, Short> getIds() {
        return mIds;
    }
}",class,
"    public void parse(byte[] data) {
        Decoder d = new Decoder(ByteBuffer.wrap(data));
        mViews = new ArrayList<>(100);
        boolean dataIncludesWindowPosition = (data[0] == 'S');
        Short windowLeftKey = null, windowTopKey = null;
        Integer windowLeftValue = null, windowTopValue = null;
        if (dataIncludesWindowPosition) {
            windowLeftKey = (Short) d.readObject();
            windowLeftValue = (Integer) d.readObject();
            windowTopKey = (Short) d.readObject();
            windowTopValue = (Integer) d.readObject();
        }
        while (d.hasRemaining()) {
            Object o = d.readObject();
            if (o instanceof Map) {
                //noinspection unchecked
                mViews.add((Map<Short, Object>) o);
            }
        }
        if (mViews.isEmpty()) {
            return;
        }
        if (dataIncludesWindowPosition) {
          mViews.get(0).put(windowLeftKey, windowLeftValue);
          mViews.get(0).put(windowTopKey, windowTopValue);
        }
        // the last one is the property map
        Map<Short,Object> idMap = mViews.remove(mViews.size() - 1);
        mIds = reverse(idMap);
    }",method,
"        if (dataIncludesWindowPosition) {
            windowLeftKey = (Short) d.readObject();
            windowLeftValue = (Integer) d.readObject();
            windowTopKey = (Short) d.readObject();
            windowTopValue = (Integer) d.readObject();
        }",method,
"            if (o instanceof Map) {
                //noinspection unchecked
                mViews.add((Map<Short, Object>) o);
            }",method,
"        if (dataIncludesWindowPosition) {
          mViews.get(0).put(windowLeftKey, windowLeftValue);
          mViews.get(0).put(windowTopKey, windowTopValue);
        }",method,
"    public String getFirstView() {
        if (mViews.isEmpty()) {
            return null;
        }
        Map<Short, Object> props = mViews.get(0);
        Object name = getProperty(props, ""__name__"");
        Object hash = getProperty(props, ""__hash__"");
        if (name instanceof String && hash instanceof Integer) {
            return String.format(Locale.US, ""%s@%x"", name, hash);
        } else {
            return null;
        }
    }",method,
"        if (name instanceof String && hash instanceof Integer) {
            return String.format(Locale.US, ""%s@%x"", name, hash);
        }",method,
"    private Object getProperty(Map<Short, Object> props, String key) {
        return props.get(mIds.get(key));
    }",method,
"    private static Map<String, Short> reverse(Map<Short, Object> m) {
        Map<String, Short> r = new HashMap<String, Short>(m.size());
        for (Map.Entry<Short, Object> e : m.entrySet()) {
            r.put((String)e.getValue(), e.getKey());
        }
        return r;
    }",method,
"    public List<Map<Short, Object>> getViews() {
        return mViews;
    }",method,
"    public Map<String, Short> getIds() {
        return mIds;
    }",method,
"public class RefactoringMessageDialog extends DialogWrapper {
  private final String myMessage;
  private final String myHelpTopic;
  private final Icon myIcon;
  private final boolean myIsCancelButtonVisible;
  public RefactoringMessageDialog(String title, String message, String helpTopic, @NonNls String iconId, boolean showCancelButton, Project project) {
    super(project, false);
    setTitle(title);
    myMessage = message;
    myHelpTopic = helpTopic;
    myIsCancelButtonVisible = showCancelButton;
    myIcon = UIManager.getIcon(iconId);
    init();
  }
  @NotNull
  @Override
  protected Action[] createActions() {
    List<Action> actions = new ArrayList<>();
    actions.add(getOKAction());
    if (myIsCancelButtonVisible) {
      actions.add(getCancelAction());
    }
    if (myHelpTopic != null) {
      actions.add(getHelpAction());
    }
    return actions.toArray(new Action[actions.size()]);
  }
  @Override
  protected JComponent createNorthPanel() {
    JLabel label = new JLabel(myMessage);
    label.setUI(new MultiLineLabelUI());
    JPanel panel = new JPanel(new BorderLayout(10, 0));
    if (myIcon != null) {
      panel.add(new JLabel(myIcon), BorderLayout.WEST);
      panel.add(label, BorderLayout.CENTER);
    }
    else {
      panel.add(label, BorderLayout.WEST);
    }
    return panel;
  }
  @Override
  protected JComponent createCenterPanel() {
    return null;
  }
  @Override
  protected void doHelpAction() {
    HelpManager.getInstance().invokeHelp(myHelpTopic);
  }
}",class,
"  public RefactoringMessageDialog(String title, String message, String helpTopic, @NonNls String iconId, boolean showCancelButton, Project project) {
    super(project, false);
    setTitle(title);
    myMessage = message;
    myHelpTopic = helpTopic;
    myIsCancelButtonVisible = showCancelButton;
    myIcon = UIManager.getIcon(iconId);
    init();
  }",method,
"  @NotNull
  @Override
  protected Action[] createActions() {
    List<Action> actions = new ArrayList<>();
    actions.add(getOKAction());
    if (myIsCancelButtonVisible) {
      actions.add(getCancelAction());
    }
    if (myHelpTopic != null) {
      actions.add(getHelpAction());
    }
    return actions.toArray(new Action[actions.size()]);
  }",method,
"    if (myIsCancelButtonVisible) {
      actions.add(getCancelAction());
    }",method,
"    if (myHelpTopic != null) {
      actions.add(getHelpAction());
    }",method,
"  @Override
  protected JComponent createNorthPanel() {
    JLabel label = new JLabel(myMessage);
    label.setUI(new MultiLineLabelUI());
    JPanel panel = new JPanel(new BorderLayout(10, 0));
    if (myIcon != null) {
      panel.add(new JLabel(myIcon), BorderLayout.WEST);
      panel.add(label, BorderLayout.CENTER);
    }
    else {
      panel.add(label, BorderLayout.WEST);
    }
    return panel;
  }",method,
"    if (myIcon != null) {
      panel.add(new JLabel(myIcon), BorderLayout.WEST);
      panel.add(label, BorderLayout.CENTER);
    }",method,
"  @Override
  protected JComponent createCenterPanel() {
    return null;
  }",method,
"  @Override
  protected void doHelpAction() {
    HelpManager.getInstance().invokeHelp(myHelpTopic);
  }",method,
"public class DialogWrapperPeerFactoryImpl extends DialogWrapperPeerFactory {
  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, @Nullable Project project, boolean canBeParent) {
    return new DialogWrapperPeerImpl(wrapper, project, canBeParent);
  }
  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, @Nullable Project project, boolean canBeParent, @NotNull DialogWrapper.IdeModalityType ideModalityType) {
    return new DialogWrapperPeerImpl(wrapper, project, canBeParent, ideModalityType);
  }
  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, boolean canBeParent) {
    return new DialogWrapperPeerImpl(wrapper, canBeParent);
  }
  @NotNull
  @Deprecated
  @Override
  public DialogWrapperPeer createPeer(@NotNull final DialogWrapper wrapper, final boolean canBeParent, final boolean applicationModalIfPossible) {
    return new DialogWrapperPeerImpl(wrapper, null, canBeParent, applicationModalIfPossible);
  }
  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull final DialogWrapper wrapper, final Window owner, final boolean canBeParent, final boolean applicationModalIfPossible) {
    return new DialogWrapperPeerImpl(wrapper, owner, canBeParent, applicationModalIfPossible);
  }
  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, @NotNull Component parent, boolean canBeParent) {
    return new DialogWrapperPeerImpl(wrapper, parent, canBeParent);
  }
  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, boolean canBeParent, DialogWrapper.IdeModalityType ideModalityType) {
    return new DialogWrapperPeerImpl(wrapper, (Window)null, canBeParent, ideModalityType);
  }
  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper,
                                      Window owner,
                                      boolean canBeParent,
                                      DialogWrapper.IdeModalityType ideModalityType) {
    return new DialogWrapperPeerImpl(wrapper, owner, canBeParent, ideModalityType);
  }
}",class,
"  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, @Nullable Project project, boolean canBeParent) {
    return new DialogWrapperPeerImpl(wrapper, project, canBeParent);
  }",method,
"  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, @Nullable Project project, boolean canBeParent, @NotNull DialogWrapper.IdeModalityType ideModalityType) {
    return new DialogWrapperPeerImpl(wrapper, project, canBeParent, ideModalityType);
  }",method,
"  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, boolean canBeParent) {
    return new DialogWrapperPeerImpl(wrapper, canBeParent);
  }",method,
"  @NotNull
  @Deprecated
  @Override
  public DialogWrapperPeer createPeer(@NotNull final DialogWrapper wrapper, final boolean canBeParent, final boolean applicationModalIfPossible) {
    return new DialogWrapperPeerImpl(wrapper, null, canBeParent, applicationModalIfPossible);
  }",method,
"  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull final DialogWrapper wrapper, final Window owner, final boolean canBeParent, final boolean applicationModalIfPossible) {
    return new DialogWrapperPeerImpl(wrapper, owner, canBeParent, applicationModalIfPossible);
  }",method,
"  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, @NotNull Component parent, boolean canBeParent) {
    return new DialogWrapperPeerImpl(wrapper, parent, canBeParent);
  }",method,
"  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper, boolean canBeParent, DialogWrapper.IdeModalityType ideModalityType) {
    return new DialogWrapperPeerImpl(wrapper, (Window)null, canBeParent, ideModalityType);
  }",method,
"  @NotNull
  @Override
  public DialogWrapperPeer createPeer(@NotNull DialogWrapper wrapper,
                                      Window owner,
                                      boolean canBeParent,
                                      DialogWrapper.IdeModalityType ideModalityType) {
    return new DialogWrapperPeerImpl(wrapper, owner, canBeParent, ideModalityType);
  }",method,
"public class ModelReturn {
  @JsonProperty(""return"")
  private Integer _return = null;
  public ModelReturn _return(Integer _return) {
    this._return = _return;
    return this;
  }
  @ApiModelProperty(value = """")
  public Integer getReturn() {
    return _return;
  }
  public void setReturn(Integer _return) {
    this._return = _return;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelReturn _return = (ModelReturn) o;
    return Objects.equals(this._return, _return._return);
  }
  @Override
  public int hashCode() {
    return Objects.hash(_return);
  }
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class ModelReturn {\n"");
    sb.append(""    _return: "").append(toIndentedString(_return)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }
}",class,
"    sb.append(""class ModelReturn {\n"");
    sb.append(""    _return: "").append(toIndentedString(_return)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",class,
"  public ModelReturn _return(Integer _return) {
    this._return = _return;
    return this;
  }",method,
"  @ApiModelProperty(value = """")
  public Integer getReturn() {
    return _return;
  }",method,
"  public void setReturn(Integer _return) {
    this._return = _return;
  }",method,
"  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelReturn _return = (ModelReturn) o;
    return Objects.equals(this._return, _return._return);
  }",method,
"    if (this == o) {
      return true;
    }",method,
"  @Override
  public int hashCode() {
    return Objects.hash(_return);
  }",method,
"  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(""class ModelReturn {\n"");
    sb.append(""    _return: "").append(toIndentedString(_return)).append(""\n"");
    sb.append(""}"");
    return sb.toString();
  }",method,
"  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return ""null"";
    }
    return o.toString().replace(""\n"", ""\n    "");
  }",method,
"    if (o == null) {
      return ""null"";
    }",method,
"public class DoublePtr extends AbstractPtr implements Ptr {
  public static final DoublePtr NULL = new DoublePtr();
  public static final int BYTES = Double.SIZE / BITS_PER_BYTE;
  public final double[] array;
  public final int offset;
  private DoublePtr() {
    this.array = null;
    this.offset = 0;
  }
  public DoublePtr(double[] array, int offset) {
    this.array = array;
    this.offset = offset;
  }
  public DoublePtr(double... values) {
    this.array = values;
    this.offset = 0;
  }
  public static DoublePtr malloc(int bytes) {
    return new DoublePtr(new double[AbstractPtr.mallocSize(bytes, BYTES)]);
  }
  @Override
  public double[] getArray() {
    return array;
  }
  @Override
  public int getOffset() {
    return offset;
  }
  @Override
  public int getOffsetInBytes() {
    return offset * BYTES;
  }
  @Override
  public DoublePtr realloc(int newSizeInBytes) {
    return new DoublePtr(Realloc.realloc(array, offset, newSizeInBytes / 8));
  }
  @Override
  public String toString() {
    return offset + ""+"" + Arrays.toString(array);
  }
  public double unwrap() {
    return array[offset];
  }
  public double get() {
    return array[offset];
  }
  public double get(int i) {
    return array[offset+i];
  }
  public void set(double x) {
    array[offset] = x;
  }
  public void set(int index, double value) {
    array[offset+index] = value;
  }
  public static int memcmp(DoublePtr x, DoublePtr y, int numBytes) {
    return memcmp(x.array, x.offset, y.array, y.offset, numBytes);
  }
  public static int memcmp(double[] x, int xi, double[] y, int yi, int n) {
    while(n > 0) {
      long xb = Double.doubleToRawLongBits(xi);
      long yb = Double.doubleToRawLongBits(yi);
      if(xb != yb || n < 8) {
        LongPtr.memcmp(xb, yb, n);
      }
      xi++;
      yi++;
      n -= 8;
    }
    return 0;
  }
  public static void memset(double[] str, int strOffset, int c, int n) {
    assert n % BYTES == 0;
    double doubleValue = memset(c);
    Arrays.fill(str, strOffset, strOffset + (n / BYTES), doubleValue);
  }
  public static double memset(int c) {
    return Double.longBitsToDouble(LongPtr.memset(c));
  }
  public static DoublePtr cast(Object voidPointer) {
    if(voidPointer instanceof MallocThunk) {
      return ((MallocThunk) voidPointer).doublePtr();
    }
    if(voidPointer == null) {
      return NULL;
    }
    return (DoublePtr) voidPointer;
  }
  @Override
  public double getDouble() {
    return array[offset];
  }
  @Override
  public double getDouble(int offset) {
    if(offset % 8 == 0) {
      return this.array[this.offset + (offset / 8)];
    }
    return super.getDouble(offset);
  }
  @Override
  public double getAlignedDouble(int index) {
    return array[this.offset + index];
  }
  @Override
  public void setDouble(double value) {
    this.array[offset] = value;
  }
  @Override
  public void setAlignedDouble(int index, double value) {
    this.array[this.offset + index] = value;
  }
  @Override
  public byte getByte(int offset) {
    int bytes = (this.offset * BYTES) + offset;
    int index = bytes / BYTES;
    double element = array[index];
    long elementBits = Double.doubleToRawLongBits(element);
    int shift = (bytes % BYTES) * BITS_PER_BYTE;
    return (byte)(elementBits >>> shift);
  }
  @Override
  public void setByte(int offset, byte value) {
    int bytes = (this.offset * BYTES) + offset;
    int index = bytes / BYTES;
    int shift = (bytes % BYTES) * BITS_PER_BYTE;
    long element = Double.doubleToRawLongBits(array[index]);
    long updateMask = 0xffL << shift;
    // Zero out the bits in the byte we are going to update
    element = element & ~updateMask;
    // Shift our byte into position
    long update = (((long)value) << shift) & updateMask;
    // Merge the original long and updated bits together
    array[index] = Double.longBitsToDouble(element | update);
  }
  @Override
  public int toInt() {
    return offset * BYTES;
  }
  @Override
  public boolean isNull() {
    return array == null && offset == 0;
  }
  @Override
  public Ptr pointerPlus(int byteCount) {
    if(byteCount % BYTES == 0) {
      return new DoublePtr(this.array, this.offset + (byteCount / BYTES));
    } else {
      return new OffsetPtr(this, byteCount);
    }
  }
  public static void memcpy(DoublePtr x, DoublePtr y, int numBytes) {
    double[] arrayS = y.getArray();
    int offsetS = y.getOffset();
    int restY = arrayS.length - offsetS;
    if(restY > 0) {
      double[] carray = new double[numBytes];
      for(int i = 0, j = offsetS; j < arrayS.length && i < numBytes; j++, i++) {
        carray[i] = arrayS[j];
      }
      x = new DoublePtr(carray);
    }
  }
}",class,
"  private DoublePtr() {
    this.array = null;
    this.offset = 0;
  }",method,
"  public DoublePtr(double[] array, int offset) {
    this.array = array;
    this.offset = offset;
  }",method,
"  public DoublePtr(double... values) {
    this.array = values;
    this.offset = 0;
  }",method,
"  public static DoublePtr malloc(int bytes) {
    return new DoublePtr(new double[AbstractPtr.mallocSize(bytes, BYTES)]);
  }",method,
"  @Override
  public double[] getArray() {
    return array;
  }",method,
"  @Override
  public int getOffset() {
    return offset;
  }",method,
"  @Override
  public int getOffsetInBytes() {
    return offset * BYTES;
  }",method,
"  @Override
  public DoublePtr realloc(int newSizeInBytes) {
    return new DoublePtr(Realloc.realloc(array, offset, newSizeInBytes / 8));
  }",method,
"  @Override
  public String toString() {
    return offset + ""+"" + Arrays.toString(array);
  }",method,
"  public double unwrap() {
    return array[offset];
  }",method,
"  public double get() {
    return array[offset];
  }",method,
"  public double get(int i) {
    return array[offset+i];
  }",method,
"  public void set(double x) {
    array[offset] = x;
  }",method,
"  public void set(int index, double value) {
    array[offset+index] = value;
  }",method,
"  public static int memcmp(DoublePtr x, DoublePtr y, int numBytes) {
    return memcmp(x.array, x.offset, y.array, y.offset, numBytes);
  }",method,
"  public static int memcmp(double[] x, int xi, double[] y, int yi, int n) {
    while(n > 0) {
      long xb = Double.doubleToRawLongBits(xi);
      long yb = Double.doubleToRawLongBits(yi);
      if(xb != yb || n < 8) {
        LongPtr.memcmp(xb, yb, n);
      }
      xi++;
      yi++;
      n -= 8;
    }
    return 0;
  }",method,
"    while(n > 0) {
      long xb = Double.doubleToRawLongBits(xi);
      long yb = Double.doubleToRawLongBits(yi);
      if(xb != yb || n < 8) {
        LongPtr.memcmp(xb, yb, n);
      }
      xi++;
      yi++;
      n -= 8;
    }",method,
"      if(xb != yb || n < 8) {
        LongPtr.memcmp(xb, yb, n);
      }",method,
"  public static void memset(double[] str, int strOffset, int c, int n) {
    assert n % BYTES == 0;
    double doubleValue = memset(c);
    Arrays.fill(str, strOffset, strOffset + (n / BYTES), doubleValue);
  }",method,
"  public static double memset(int c) {
    return Double.longBitsToDouble(LongPtr.memset(c));
  }",method,
"  public static DoublePtr cast(Object voidPointer) {
    if(voidPointer instanceof MallocThunk) {
      return ((MallocThunk) voidPointer).doublePtr();
    }
    if(voidPointer == null) {
      return NULL;
    }
    return (DoublePtr) voidPointer;
  }",method,
"    if(voidPointer instanceof MallocThunk) {
      return ((MallocThunk) voidPointer).doublePtr();
    }",method,
"    if(voidPointer == null) {
      return NULL;
    }",method,
"  @Override
  public double getDouble() {
    return array[offset];
  }",method,
"  @Override
  public double getDouble(int offset) {
    if(offset % 8 == 0) {
      return this.array[this.offset + (offset / 8)];
    }
    return super.getDouble(offset);
  }",method,
"    if(offset % 8 == 0) {
      return this.array[this.offset + (offset / 8)];
    }",method,
"  @Override
  public double getAlignedDouble(int index) {
    return array[this.offset + index];
  }",method,
"  @Override
  public void setDouble(double value) {
    this.array[offset] = value;
  }",method,
"  @Override
  public void setAlignedDouble(int index, double value) {
    this.array[this.offset + index] = value;
  }",method,
"  @Override
  public byte getByte(int offset) {
    int bytes = (this.offset * BYTES) + offset;
    int index = bytes / BYTES;
    double element = array[index];
    long elementBits = Double.doubleToRawLongBits(element);
    int shift = (bytes % BYTES) * BITS_PER_BYTE;
    return (byte)(elementBits >>> shift);
  }",method,
"  @Override
  public void setByte(int offset, byte value) {
    int bytes = (this.offset * BYTES) + offset;
    int index = bytes / BYTES;
    int shift = (bytes % BYTES) * BITS_PER_BYTE;
    long element = Double.doubleToRawLongBits(array[index]);
    long updateMask = 0xffL << shift;
    // Zero out the bits in the byte we are going to update
    element = element & ~updateMask;
    // Shift our byte into position
    long update = (((long)value) << shift) & updateMask;
    // Merge the original long and updated bits together
    array[index] = Double.longBitsToDouble(element | update);
  }",method,
"  @Override
  public int toInt() {
    return offset * BYTES;
  }",method,
"  @Override
  public boolean isNull() {
    return array == null && offset == 0;
  }",method,
"  @Override
  public Ptr pointerPlus(int byteCount) {
    if(byteCount % BYTES == 0) {
      return new DoublePtr(this.array, this.offset + (byteCount / BYTES));
    } else {
      return new OffsetPtr(this, byteCount);
    }
  }",method,
"    if(byteCount % BYTES == 0) {
      return new DoublePtr(this.array, this.offset + (byteCount / BYTES));
    }",method,
"  public static void memcpy(DoublePtr x, DoublePtr y, int numBytes) {
    double[] arrayS = y.getArray();
    int offsetS = y.getOffset();
    int restY = arrayS.length - offsetS;
    if(restY > 0) {
      double[] carray = new double[numBytes];
      for(int i = 0, j = offsetS; j < arrayS.length && i < numBytes; j++, i++) {
        carray[i] = arrayS[j];
      }
      x = new DoublePtr(carray);
    }
  }",method,
"    if(restY > 0) {
      double[] carray = new double[numBytes];
      for(int i = 0, j = offsetS; j < arrayS.length && i < numBytes; j++, i++) {
        carray[i] = arrayS[j];
      }
      x = new DoublePtr(carray);
    }",method,

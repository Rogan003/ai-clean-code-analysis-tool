code_snippet,type,score
"public class MergeSort_test {
	public static void main(String[] args) {
		int[] array = {3921,12,32,1,5234,321,32134};
		System.out.println(""Before sorting: "");
		for(int number : array){
			System.out.print(number + "" "");
		}
		MergeSort.mergeSort(array, 0, 3);
		System.out.println(""\n\nAfter Sorting first four elements: "");
		for(int number : array){
			System.out.print(number + "" "");
		}
		MergeSort.mergeSort(array, 0, array.length-1);
		System.out.println(""\n\nAfter sorting entire array: "");
		for(int number : array){
			System.out.print(number + "" "");
		}
	}
}",class,good
"public class mergeI 
{
	void mergeSort(int a[]) 
	{
		if(a.length < 2) 	//already sorted
			return;
		int diff = 1;		//to form groups of 2,4..etc to merge
		int startLeft, startRight;
		while(diff < a.length) 
		{
		 startLeft = 0;
			startRight = diff;
			while(startRight + diff <= a.length) // merge till right half is formed 
			{
				merge(a, startLeft, startLeft + diff, startRight, startRight + diff);
			 startLeft = startRight + diff;
				startRight = startLeft + diff;
			}
			if(startRight < a.length) 	// merge rest of the right part
				merge(a, startLeft, startLeft + diff, startRight, a.length);
			diff *= 2; 	//increase the group size 2 times
		}
	}
	void merge(int a[], int startLeft, int endLeft, int startRight, int endRight) 
	{
		// temporary arrays
		int right[] = new int[endRight - startRight + 1];
		int left[] = new int[endLeft - startLeft + 1];
		for(int i = 0, j = startRight; i < (right.length - 1); i++, j++) 
			right[i] = a[j];
		for(int i = 0, j = startLeft; i < (left.length - 1); i++, j++) 
			left[i] = a[j];
		// end points(sentinel values)
		right[right.length-1] = Integer.MAX_VALUE;
		left[left.length-1] = Integer.MAX_VALUE;
		for(int i = startLeft, j = 0,  k= 0; i < endRight; i++) 
		{
			if(left[j] <= right[k]) 
			{
				a[i] = left[j];
				j++;
			}
			else 
			{
				a[i] = right[k];
				k++;
			}
		}
	}
}",class,changes_recommended
"public class MergeSortIterative_test 
{
	public static void main(String args[]) 
	{
		int a[] = {1024,1,10,1111,4321,1029,101010};
		System.out.println(""Before sorting: "");
		for(int number : a)
			System.out.print(number + "" "");
		MergeSortIterative.mergeSort(a);
		System.out.println(""\nAfter sorting: "");
		for(int number : a)
			System.out.print(number + "" "");
	}
}",class,good
"public class Palindrome {
	public static boolean detect(String word) {
		// word gets whittled down to 1 char,
		// unless first and last characters don't match.
		// if it makes it, it's considered a palindrome
		if (word.length() <= 1)
			return true;
		if (word.charAt(0) != word.charAt(word.length()-1))
			return false;
		else
			return detect(word.substring(1, word.length()-1));
	}
	public static void main(String[] args) {
		// Test client
		System.out.println(detect(""test""));  // false
		System.out.println(detect(""lel""));  // true
		System.out.println(detect(""hahhah""));  // true
		if (! detect(""lel"") )
			throw new AssertionError();
		if (! detect(""hahhah"") )
			throw new AssertionError();
		if ( detect(""test"") )
			throw new AssertionError();
	}
}",class,good
"    @Test
    public void simpleSort() {
        int[] unsorted = {9, 8, 7, 6, 5, 4, 3, 2, 1};
        int[] sorted = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        int[] result = MergeSort.sort(unsorted);
        String errorMsg = String.format(""Failure - expected %s got %s"", Arrays.toString(sorted), Arrays.toString(result));
        Assert.assertArrayEquals(errorMsg, sorted, result);
    }",method,good
"	public static void mergeSort(int[] array, int start, int end){
		if (start < end){
			int middle = (end + start) / 2;
			mergeSort(array, start, middle);
			mergeSort(array, middle + 1, end);
			merge(array,start,middle,end);
		}
	}",method,good
"		if (start < end){
			int middle = (end + start) / 2;
			mergeSort(array, start, middle);
			mergeSort(array, middle + 1, end);
			merge(array,start,middle,end);
		}",method,good
"	private static void merge(int[]array, int start, int middle, int end){
		int size_1 = middle - start + 1;
		int size_2 = end - middle;
		int[] leftArray = new int[size_1];
		int[] rightArray = new int[size_2];
		for(int i = 0; i < size_1; i++){
			leftArray[i] = array[start + i];
		}
		for(int j = 0; j < size_2; j++){
			rightArray[j] = array[j + middle + 1];
		}
		int i = 0;
		int j = 0;
		for(int k = start; k <= end; k++){
			if(i == size_1){
				array[k] = rightArray[j];
				j++;
				continue;
			}
			if(j == size_2){
				array[k] = leftArray[i];
				i++;
				continue;
			}
			if(leftArray[i] <= rightArray[j]){
				array[k] = leftArray[i];
				i++;
			}else{
				array[k] = rightArray[j];
				j++;
			}
		}
	}",method,changes_recommended
"		for(int i = 0; i < size_1; i++){
			leftArray[i] = array[start + i];
		}",method,good
"		for(int j = 0; j < size_2; j++){
			rightArray[j] = array[j + middle + 1];
		}",method,good
"		for(int k = start; k <= end; k++){
			if(i == size_1){
				array[k] = rightArray[j];
				j++;
				continue;
			}
			if(j == size_2){
				array[k] = leftArray[i];
				i++;
				continue;
			}
			if(leftArray[i] <= rightArray[j]){
				array[k] = leftArray[i];
				i++;
			}else{
				array[k] = rightArray[j];
				j++;
			}
		}",method,good
"			if(i == size_1){
				array[k] = rightArray[j];
				j++;
				continue;
			}",method,good
"			if(j == size_2){
				array[k] = leftArray[i];
				i++;
				continue;
			}",method,good
"			if(leftArray[i] <= rightArray[j]){
				array[k] = leftArray[i];
				i++;
			}",method,good
"	public static void main(String[] args) {
		int[] array = {3921,12,32,1,5234,321,32134};
		System.out.println(""Before sorting: "");
		for(int number : array){
			System.out.print(number + "" "");
		}
		MergeSort.mergeSort(array, 0, 3);
		System.out.println(""\n\nAfter Sorting first four elements: "");
		for(int number : array){
			System.out.print(number + "" "");
		}
		MergeSort.mergeSort(array, 0, array.length-1);
		System.out.println(""\n\nAfter sorting entire array: "");
		for(int number : array){
			System.out.print(number + "" "");
		}
	}",method,good
"		for(int number : array){
			System.out.print(number + "" "");
		}",method,good
"		for(int number : array){
			System.out.print(number + "" "");
		}",method,good
"		for(int number : array){
			System.out.print(number + "" "");
		}",method,good
"	void mergeSort(int a[]) 
	{
		if(a.length < 2) 	//already sorted
			return;
		int diff = 1;		//to form groups of 2,4..etc to merge
		int startLeft, startRight;
		while(diff < a.length) 
		{
		 startLeft = 0;
			startRight = diff;
			while(startRight + diff <= a.length) // merge till right half is formed 
			{
				merge(a, startLeft, startLeft + diff, startRight, startRight + diff);
			 startLeft = startRight + diff;
				startRight = startLeft + diff;
			}
			if(startRight < a.length) 	// merge rest of the right part
				merge(a, startLeft, startLeft + diff, startRight, a.length);
			diff *= 2; 	//increase the group size 2 times
		}
	}",method,good
"		while(diff < a.length) 
		{
		 startLeft = 0;
			startRight = diff;
			while(startRight + diff <= a.length) // merge till right half is formed 
			{
				merge(a, startLeft, startLeft + diff, startRight, startRight + diff);
			 startLeft = startRight + diff;
				startRight = startLeft + diff;
			}
			if(startRight < a.length) 	// merge rest of the right part
				merge(a, startLeft, startLeft + diff, startRight, a.length);
			diff *= 2; 	//increase the group size 2 times
		}",method,good
"	void merge(int a[], int startLeft, int endLeft, int startRight, int endRight) 
	{
		// temporary arrays
		int right[] = new int[endRight - startRight + 1];
		int left[] = new int[endLeft - startLeft + 1];
		for(int i = 0, j = startRight; i < (right.length - 1); i++, j++) 
			right[i] = a[j];
		for(int i = 0, j = startLeft; i < (left.length - 1); i++, j++) 
			left[i] = a[j];
		// end points(sentinel values)
		right[right.length-1] = Integer.MAX_VALUE;
		left[left.length-1] = Integer.MAX_VALUE;
		for(int i = startLeft, j = 0,  k= 0; i < endRight; i++) 
		{
			if(left[j] <= right[k]) 
			{
				a[i] = left[j];
				j++;
			}
			else 
			{
				a[i] = right[k];
				k++;
			}
		}
	}",method,changes_recommended
"		for(int i = startLeft, j = 0,  k= 0; i < endRight; i++) 
		{
			if(left[j] <= right[k]) 
			{
				a[i] = left[j];
				j++;
			}
			else 
			{
				a[i] = right[k];
				k++;
			}
		}",method,good
"			if(left[j] <= right[k]) 
			{
				a[i] = left[j];
				j++;
			}",method,good
"	public static void main(String args[]) 
	{
		int a[] = {1024,1,10,1111,4321,1029,101010};
		System.out.println(""Before sorting: "");
		for(int number : a)
			System.out.print(number + "" "");
		MergeSortIterative.mergeSort(a);
		System.out.println(""\nAfter sorting: "");
		for(int number : a)
			System.out.print(number + "" "");
	}",method,good
"	public static boolean detect(String word) {
		// word gets whittled down to 1 char,
		// unless first and last characters don't match.
		// if it makes it, it's considered a palindrome
		if (word.length() <= 1)
			return true;
		if (word.charAt(0) != word.charAt(word.length()-1))
			return false;
		else
			return detect(word.substring(1, word.length()-1));
	}",method,good
"	public static void main(String[] args) {
		// Test client
		System.out.println(detect(""test""));  // false
		System.out.println(detect(""lel""));  // true
		System.out.println(detect(""hahhah""));  // true
		if (! detect(""lel"") )
			throw new AssertionError();
		if (! detect(""hahhah"") )
			throw new AssertionError();
		if ( detect(""test"") )
			throw new AssertionError();
	}",method,good
"public class GrTraditionalForClauseImpl extends GroovyPsiElementImpl implements GrTraditionalForClause {
  public GrTraditionalForClauseImpl(@NotNull ASTNode node) {
    super(node);
  }
  @Override
  public void accept(GroovyElementVisitor visitor) {
    visitor.visitTraditionalForClause(this);
  }
  public String toString() {
    return ""Traditional FOR clause"";
  }
  @Override
  public GrParameter getDeclaredVariable() {
    return findChildByClass(GrParameter.class);
  }
  @Override
  public GrCondition getInitialization() {
    return getConditionInner(0);
  }
  @Override
  public GrExpression getCondition() {
    final GrCondition condition = getConditionInner(1);
    return condition instanceof GrExpression ? (GrExpression)condition : null;
  }
  @Override
  public GrExpression getUpdate() {
    final GrCondition condition = getConditionInner(2);
    return condition instanceof GrExpression ? (GrExpression)condition : null;
  }
  private GrCondition getConditionInner(final int i) {
    int passed = 0;
    boolean waitForSemicolon = false;
    for (ASTNode child = getNode().getFirstChildNode(); child != null; child = child.getTreeNext()) {
      if (child.getElementType() == GroovyTokenTypes.mSEMI) {
        if (waitForSemicolon) {
          waitForSemicolon = false;
        }
        else {
          if (passed == i) {
            return null;
          }
          passed++;
        }
      }
      else if (child.getPsi() instanceof GrCondition) {
        if (passed == i) {
          return (GrCondition)child.getPsi();
        }
        passed++;
        waitForSemicolon = true;
      }
    }
    return null;
  }
  @Override
  public GrParameter[] getParameters() {
    final GrParameter declaredVariable = getDeclaredVariable();
    return declaredVariable == null ? GrParameter.EMPTY_ARRAY : new GrParameter[]{declaredVariable};
  }
  @Override
  public GrParameterList getParameterList() {
    return null;
  }
  @Override
  public boolean isVarArgs() {
    throw new IncorrectOperationException(""For clause cannot have varargs"");
  }
}",class,good
"  public GrTraditionalForClauseImpl(@NotNull ASTNode node) {
    super(node);
  }",method,good
"  @Override
  public void accept(GroovyElementVisitor visitor) {
    visitor.visitTraditionalForClause(this);
  }",method,good
"  public String toString() {
    return ""Traditional FOR clause"";
  }",method,good
"  @Override
  public GrParameter getDeclaredVariable() {
    return findChildByClass(GrParameter.class);
  }",method,good
"  @Override
  public GrCondition getInitialization() {
    return getConditionInner(0);
  }",method,good
"  @Override
  public GrExpression getCondition() {
    final GrCondition condition = getConditionInner(1);
    return condition instanceof GrExpression ? (GrExpression)condition : null;
  }",method,good
"  @Override
  public GrExpression getUpdate() {
    final GrCondition condition = getConditionInner(2);
    return condition instanceof GrExpression ? (GrExpression)condition : null;
  }",method,good
"  private GrCondition getConditionInner(final int i) {
    int passed = 0;
    boolean waitForSemicolon = false;
    for (ASTNode child = getNode().getFirstChildNode(); child != null; child = child.getTreeNext()) {
      if (child.getElementType() == GroovyTokenTypes.mSEMI) {
        if (waitForSemicolon) {
          waitForSemicolon = false;
        }
        else {
          if (passed == i) {
            return null;
          }
          passed++;
        }
      }
      else if (child.getPsi() instanceof GrCondition) {
        if (passed == i) {
          return (GrCondition)child.getPsi();
        }
        passed++;
        waitForSemicolon = true;
      }
    }
    return null;
  }",method,good
"        if (waitForSemicolon) {
          waitForSemicolon = false;
        }",method,good
"          if (passed == i) {
            return null;
          }",method,good
"        if (passed == i) {
          return (GrCondition)child.getPsi();
        }",method,good
"  @Override
  public GrParameter[] getParameters() {
    final GrParameter declaredVariable = getDeclaredVariable();
    return declaredVariable == null ? GrParameter.EMPTY_ARRAY : new GrParameter[]{declaredVariable};
  }",method,good
"  @Override
  public GrParameterList getParameterList() {
    return null;
  }",method,good
"  @Override
  public boolean isVarArgs() {
    throw new IncorrectOperationException(""For clause cannot have varargs"");
  }",method,good
"public abstract class BuilderAnnotationContributor implements AstTransformationSupport {
  public static final String BUILDER_PACKAGE = ""groovy.transform.builder"";
  public static final String BUILDER_FQN = BUILDER_PACKAGE + "".Builder"";
  public static final String ORIGIN_INFO = ""via @Builder"";
  public static final String STRATEGY_ATTRIBUTE = ""builderStrategy"";
  @Contract(""null, _ -> false"")
  public static boolean isApplicable(@Nullable PsiAnnotation annotation, @NotNull String strategy) {
    if (annotation == null) return false;
    PsiClass aClass = GrAnnotationUtil.inferClassAttribute(annotation, STRATEGY_ATTRIBUTE);
    if (aClass == null) return false;
    return StringUtil.getQualifiedName(BUILDER_PACKAGE, strategy).equals(aClass.getQualifiedName());
  }
  public static PsiField[] getFields(@NotNull TransformationContext context, boolean includeSuper) {
    return filterFields(includeSuper ? context.getAllFields(false) : context.getFields());
  }
  public static PsiField[] getFields(@NotNull GrTypeDefinition clazz, boolean includeSuper) {
    return filterFields(includeSuper ? asList(GrClassImplUtil.getAllFields(clazz, false)) : asList(clazz.getFields()));
  }
  private static PsiField[] filterFields(Collection<? extends PsiField> collectedFields) {
    return collectedFields.stream()
      .filter(field -> field.getName() != null)
      .filter(field -> !field.hasModifierProperty(PsiModifier.STATIC))
      .filter(field -> {
        PsiClass aClass = field.getContainingClass();
        if (aClass == null || aClass.getQualifiedName() == null) {
          return false;
        }
        String name = aClass.getQualifiedName();
        return !name.equals(GroovyCommonClassNames.GROOVY_OBJECT_SUPPORT) && !name.equals(GroovyCommonClassNames.GROOVY_OBJECT);
      })
      .toArray(PsiField[]::new);
  }
  public static boolean isIncludeSuperProperties(@NotNull PsiAnnotation annotation) {
    return PsiUtil.getAnnoAttributeValue(annotation, ""includeSuperProperties"", false);
  }
}",class,good
"  @Contract(""null, _ -> false"")
  public static boolean isApplicable(@Nullable PsiAnnotation annotation, @NotNull String strategy) {
    if (annotation == null) return false;
    PsiClass aClass = GrAnnotationUtil.inferClassAttribute(annotation, STRATEGY_ATTRIBUTE);
    if (aClass == null) return false;
    return StringUtil.getQualifiedName(BUILDER_PACKAGE, strategy).equals(aClass.getQualifiedName());
  }",method,good
"  public static PsiField[] getFields(@NotNull TransformationContext context, boolean includeSuper) {
    return filterFields(includeSuper ? context.getAllFields(false) : context.getFields());
  }",method,good
"  public static PsiField[] getFields(@NotNull GrTypeDefinition clazz, boolean includeSuper) {
    return filterFields(includeSuper ? asList(GrClassImplUtil.getAllFields(clazz, false)) : asList(clazz.getFields()));
  }",method,good
"  private static PsiField[] filterFields(Collection<? extends PsiField> collectedFields) {
    return collectedFields.stream()
      .filter(field -> field.getName() != null)
      .filter(field -> !field.hasModifierProperty(PsiModifier.STATIC))
      .filter(field -> {
        PsiClass aClass = field.getContainingClass();
        if (aClass == null || aClass.getQualifiedName() == null) {
          return false;
        }
        String name = aClass.getQualifiedName();
        return !name.equals(GroovyCommonClassNames.GROOVY_OBJECT_SUPPORT) && !name.equals(GroovyCommonClassNames.GROOVY_OBJECT);
      })
      .toArray(PsiField[]::new);
  }",method,good
"  public static boolean isIncludeSuperProperties(@NotNull PsiAnnotation annotation) {
    return PsiUtil.getAnnoAttributeValue(annotation, ""includeSuperProperties"", false);
  }",method,good
"public class RepositoryTest {
  @Resource
  private PersonRepository repository;
  Person peter = new Person(""Peter"", ""Sagan"", 17);
  Person nasta = new Person(""Nasta"", ""Kuzminova"", 25);
  Person john = new Person(""John"", ""lawrence"", 35);
  Person terry = new Person(""Terry"", ""Law"", 36);
  List<Person> persons = Arrays.asList(peter, nasta, john, terry);
  @Before
  public void setup() {
    repository.save(persons);
  }
  @Test
  public void testFindAll() {
    List<Person> actuals = Lists.newArrayList(repository.findAll());
    assertTrue(actuals.containsAll(persons) && persons.containsAll(actuals));
  }
  @Test
  public void testSave() {
    Person terry = repository.findByName(""Terry"");
    terry.setSurname(""Lee"");
    terry.setAge(47);
    repository.save(terry);
    terry = repository.findByName(""Terry"");
    assertEquals(terry.getSurname(), ""Lee"");
    assertEquals(47, terry.getAge());
  }
  @Test
  public void testDelete() {
    Person terry = repository.findByName(""Terry"");
    repository.delete(terry);
    assertEquals(3, repository.count());
    assertNull(repository.findByName(""Terry""));
  }
  @Test
  public void testCount() {
    assertEquals(4, repository.count());
  }
  @Test
  public void testFindAllByAgeBetweenSpec() {
    List<Person> persons = repository.findAll(new PersonSpecifications.AgeBetweenSpec(20, 40));
    assertEquals(3, persons.size());
    assertTrue(persons.stream().allMatch((item) -> {
      return item.getAge() > 20 && item.getAge() < 40;
    }));
  }
  @Test
  public void testFindOneByNameEqualSpec() {
    Person actual = repository.findOne(new PersonSpecifications.NameEqualSpec(""Terry""));
    assertEquals(terry, actual);
  }
  @After
  public void cleanup() {
    repository.deleteAll();
  }
}",class,changes_recommended
"  @Before
  public void setup() {
    repository.save(persons);
  }",method,good
"  @Test
  public void testFindAll() {
    List<Person> actuals = Lists.newArrayList(repository.findAll());
    assertTrue(actuals.containsAll(persons) && persons.containsAll(actuals));
  }",method,good
"  @Test
  public void testSave() {
    Person terry = repository.findByName(""Terry"");
    terry.setSurname(""Lee"");
    terry.setAge(47);
    repository.save(terry);
    terry = repository.findByName(""Terry"");
    assertEquals(terry.getSurname(), ""Lee"");
    assertEquals(47, terry.getAge());
  }",method,good
"  @Test
  public void testDelete() {
    Person terry = repository.findByName(""Terry"");
    repository.delete(terry);
    assertEquals(3, repository.count());
    assertNull(repository.findByName(""Terry""));
  }",method,good
"  @Test
  public void testCount() {
    assertEquals(4, repository.count());
  }",method,good
"  @Test
  public void testFindAllByAgeBetweenSpec() {
    List<Person> persons = repository.findAll(new PersonSpecifications.AgeBetweenSpec(20, 40));
    assertEquals(3, persons.size());
    assertTrue(persons.stream().allMatch((item) -> {
      return item.getAge() > 20 && item.getAge() < 40;
    }));
  }",method,good
"  @Test
  public void testFindOneByNameEqualSpec() {
    Person actual = repository.findOne(new PersonSpecifications.NameEqualSpec(""Terry""));
    assertEquals(terry, actual);
  }",method,good
"  @After
  public void cleanup() {
    repository.deleteAll();
  }",method,good
"public class InternalBucketMetricValue extends InternalNumericMetricsAggregation.SingleValue implements BucketMetricValue {
    public static final String NAME = ""bucket_metric_value"";
    static final ParseField KEYS_FIELD = new ParseField(""keys"");
    private double value;
    private String[] keys;
    public InternalBucketMetricValue(String name, String[] keys, double value, DocValueFormat formatter,
            List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {
        super(name, pipelineAggregators, metaData);
        this.keys = keys;
        this.value = value;
        this.format = formatter;
    }
    public InternalBucketMetricValue(StreamInput in) throws IOException {
        super(in);
        format = in.readNamedWriteable(DocValueFormat.class);
        value = in.readDouble();
        keys = in.readStringArray();
    }
    @Override
    protected void doWriteTo(StreamOutput out) throws IOException {
        out.writeNamedWriteable(format);
        out.writeDouble(value);
        out.writeStringArray(keys);
    }
    @Override
    public String getWriteableName() {
        return NAME;
    }
    @Override
    public double value() {
        return value;
    }
    @Override
    public String[] keys() {
        return keys;
    }
    DocValueFormat formatter() {
        return format;
    }
    @Override
    public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
        throw new UnsupportedOperationException(""Not supported"");
    }
    @Override
    public Object getProperty(List<String> path) {
        if (path.isEmpty()) {
            return this;
        } else if (path.size() == 1 && ""value"".equals(path.get(0))) {
            return value();
        } else if (path.size() == 1 && KEYS_FIELD.getPreferredName().equals(path.get(0))) {
            return keys();
        } else {
            throw new IllegalArgumentException(""path not supported for ["" + getName() + ""]: "" + path);
        }
    }
    @Override
    public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {
        boolean hasValue = !Double.isInfinite(value);
        builder.field(CommonFields.VALUE.getPreferredName(), hasValue ? value : null);
        if (hasValue && format != DocValueFormat.RAW) {
            builder.field(CommonFields.VALUE_AS_STRING.getPreferredName(), format.format(value));
        }
        builder.startArray(KEYS_FIELD.getPreferredName());
        for (String key : keys) {
            builder.value(key);
        }
        builder.endArray();
        return builder;
    }
    @Override
    protected int doHashCode() {
        return Objects.hash(value, Arrays.hashCode(keys));
    }
    @Override
    protected boolean doEquals(Object obj) {
        InternalBucketMetricValue other = (InternalBucketMetricValue) obj;
        return Objects.equals(value, other.value)
                && Arrays.equals(keys, other.keys);
    }
}",class,changes_recommended
"    public InternalBucketMetricValue(String name, String[] keys, double value, DocValueFormat formatter,
            List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {
        super(name, pipelineAggregators, metaData);
        this.keys = keys;
        this.value = value;
        this.format = formatter;
    }",method,good
"    public InternalBucketMetricValue(StreamInput in) throws IOException {
        super(in);
        format = in.readNamedWriteable(DocValueFormat.class);
        value = in.readDouble();
        keys = in.readStringArray();
    }",method,good
"    @Override
    protected void doWriteTo(StreamOutput out) throws IOException {
        out.writeNamedWriteable(format);
        out.writeDouble(value);
        out.writeStringArray(keys);
    }",method,good
"    @Override
    public String getWriteableName() {
        return NAME;
    }",method,good
"    @Override
    public double value() {
        return value;
    }",method,good
"    @Override
    public String[] keys() {
        return keys;
    }",method,good
"    DocValueFormat formatter() {
        return format;
    }",method,good
"    @Override
    public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
        throw new UnsupportedOperationException(""Not supported"");
    }",method,good
"    @Override
    public Object getProperty(List<String> path) {
        if (path.isEmpty()) {
            return this;
        } else if (path.size() == 1 && ""value"".equals(path.get(0))) {
            return value();
        } else if (path.size() == 1 && KEYS_FIELD.getPreferredName().equals(path.get(0))) {
            return keys();
        } else {
            throw new IllegalArgumentException(""path not supported for ["" + getName() + ""]: "" + path);
        }
    }",method,good
"    @Override
    public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {
        boolean hasValue = !Double.isInfinite(value);
        builder.field(CommonFields.VALUE.getPreferredName(), hasValue ? value : null);
        if (hasValue && format != DocValueFormat.RAW) {
            builder.field(CommonFields.VALUE_AS_STRING.getPreferredName(), format.format(value));
        }
        builder.startArray(KEYS_FIELD.getPreferredName());
        for (String key : keys) {
            builder.value(key);
        }
        builder.endArray();
        return builder;
    }",method,good
"        if (hasValue && format != DocValueFormat.RAW) {
            builder.field(CommonFields.VALUE_AS_STRING.getPreferredName(), format.format(value));
        }",method,good
"        for (String key : keys) {
            builder.value(key);
        }",method,good
"    @Override
    protected int doHashCode() {
        return Objects.hash(value, Arrays.hashCode(keys));
    }",method,good
"    @Override
    protected boolean doEquals(Object obj) {
        InternalBucketMetricValue other = (InternalBucketMetricValue) obj;
        return Objects.equals(value, other.value)
                && Arrays.equals(keys, other.keys);
    }",method,good
"public class SocksProxy extends TestProxyBase {
  private static final Logger log = LoggerFactory.getLogger(SocksProxy.class);
  private static final Buffer clientInit = Buffer.buffer(new byte[] { 5, 1, 0 });
  private static final Buffer serverReply = Buffer.buffer(new byte[] { 5, 0 });
  private static final Buffer clientRequest = Buffer.buffer(new byte[] { 5, 1, 0, 3 });
  private static final Buffer connectResponse = Buffer.buffer(new byte[] { 5, 0, 0, 1, 0x7f, 0, 0, 1, 0x27, 0x10 });
  private static final Buffer errorResponse = Buffer.buffer(new byte[] { 5, 4, 0, 1, 0, 0, 0, 0, 0, 0 });
  private static final Buffer clientInitAuth = Buffer.buffer(new byte[] { 5, 2, 0, 2 });
  private static final Buffer serverReplyAuth = Buffer.buffer(new byte[] { 5, 2 });
  private static final Buffer authSuccess = Buffer.buffer(new byte[] { 1, 0 });
  private static final Buffer authFailed = Buffer.buffer(new byte[] { 1, 1 });
  private static final int PORT = 11080;
  private NetServer server;
  public SocksProxy(String username) {
    super(username);
  }
  @Override
  public void start(Vertx vertx, Handler<Void> finishedHandler) {
    NetServerOptions options = new NetServerOptions();
    options.setHost(""localhost"").setPort(PORT);
    server = vertx.createNetServer(options);
    server.connectHandler(socket -> {
      socket.handler(buffer -> {
        Buffer expectedInit = username == null ? clientInit : clientInitAuth;
        if (!buffer.equals(expectedInit)) {
          throw new IllegalStateException(""expected "" + toHex(expectedInit) + "", got "" + toHex(buffer));
        }
        boolean useAuth = buffer.equals(clientInitAuth);
        log.debug(""got request: "" + toHex(buffer));
        final Handler<Buffer> handler = buffer2 -> {
          if (!buffer2.getBuffer(0, clientRequest.length()).equals(clientRequest)) {
            throw new IllegalStateException(""expected "" + toHex(clientRequest) + "", got "" + toHex(buffer2));
          }
          int stringLen = buffer2.getUnsignedByte(4);
          log.debug(""string len "" + stringLen);
          if (buffer2.length() != 7 + stringLen) {
            throw new IllegalStateException(""format error in client request, got "" + toHex(buffer2));
          }
          String host = buffer2.getString(5, 5 + stringLen);
          int port = buffer2.getUnsignedShort(5 + stringLen);
          log.debug(""got request: "" + toHex(buffer2));
          log.debug(""connect: "" + host + "":"" + port);
          socket.handler(null);
          lastUri = host + "":"" + port;
          if (forceUri != null) {
            host = forceUri.substring(0, forceUri.indexOf(':'));
            port = Integer.valueOf(forceUri.substring(forceUri.indexOf(':') + 1));
          }
          log.debug(""connecting to "" + host + "":"" + port);
          NetClient netClient = vertx.createNetClient(new NetClientOptions());
          netClient.connect(port, host, result -> {
            if (result.succeeded()) {
              log.debug(""writing: "" + toHex(connectResponse));
              socket.write(connectResponse);
              log.debug(""connected, starting pump"");
              NetSocket clientSocket = result.result();
              socket.closeHandler(v -> clientSocket.close());
              clientSocket.closeHandler(v -> socket.close());
              Pump.pump(socket, clientSocket).start();
              Pump.pump(clientSocket, socket).start();
            } else {
              log.error(""exception"", result.cause());
              socket.handler(null);
              log.debug(""writing: "" + toHex(errorResponse));
              socket.write(errorResponse);
              socket.close();
            }
          });
        };
        if (useAuth) {
          socket.handler(buffer3 -> {
            log.debug(""auth handler"");
            log.debug(""got request: "" + toHex(buffer3));
            Buffer authReply = Buffer.buffer(new byte[] { 1, (byte) username.length() });
            authReply.appendString(username);
            authReply.appendByte((byte) username.length());
            authReply.appendString(username);
            if (!buffer3.equals(authReply)) {
              log.debug(""expected "" + toHex(authReply) + "", got "" + toHex(buffer3));
              socket.handler(null);
              log.debug(""writing: "" + toHex(authFailed));
              socket.write(authFailed);
              socket.close();
            } else {
              socket.handler(handler);
              log.debug(""writing: "" + toHex(authSuccess));
              socket.write(authSuccess);
            }
          });
          log.debug(""writing: "" + toHex(serverReplyAuth));
          socket.write(serverReplyAuth);
        } else {
          socket.handler(handler);
          log.debug(""writing: "" + toHex(serverReply));
          socket.write(serverReply);
        }
      });
    });
    server.listen(result -> {
      log.debug(""socks5 server started"");
      finishedHandler.handle(null);
    });
  }
  private String toHex(Buffer buffer) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < buffer.length(); i++) {
      sb.append(String.format(""%02X "", buffer.getByte(i)));
    }
    return sb.toString();
  }
  @Override
  public void stop() {
    if (server != null) {
      server.close();
      server = null;
    }
  }
  @Override
  public int getPort() {
    return PORT;
  }
}",class,changes_required
"  public SocksProxy(String username) {
    super(username);
  }",method,good
"  @Override
  public void start(Vertx vertx, Handler<Void> finishedHandler) {
    NetServerOptions options = new NetServerOptions();
    options.setHost(""localhost"").setPort(PORT);
    server = vertx.createNetServer(options);
    server.connectHandler(socket -> {
      socket.handler(buffer -> {
        Buffer expectedInit = username == null ? clientInit : clientInitAuth;
        if (!buffer.equals(expectedInit)) {
          throw new IllegalStateException(""expected "" + toHex(expectedInit) + "", got "" + toHex(buffer));
        }
        boolean useAuth = buffer.equals(clientInitAuth);
        log.debug(""got request: "" + toHex(buffer));
        final Handler<Buffer> handler = buffer2 -> {
          if (!buffer2.getBuffer(0, clientRequest.length()).equals(clientRequest)) {
            throw new IllegalStateException(""expected "" + toHex(clientRequest) + "", got "" + toHex(buffer2));
          }
          int stringLen = buffer2.getUnsignedByte(4);
          log.debug(""string len "" + stringLen);
          if (buffer2.length() != 7 + stringLen) {
            throw new IllegalStateException(""format error in client request, got "" + toHex(buffer2));
          }
          String host = buffer2.getString(5, 5 + stringLen);
          int port = buffer2.getUnsignedShort(5 + stringLen);
          log.debug(""got request: "" + toHex(buffer2));
          log.debug(""connect: "" + host + "":"" + port);
          socket.handler(null);
          lastUri = host + "":"" + port;
          if (forceUri != null) {
            host = forceUri.substring(0, forceUri.indexOf(':'));
            port = Integer.valueOf(forceUri.substring(forceUri.indexOf(':') + 1));
          }
          log.debug(""connecting to "" + host + "":"" + port);
          NetClient netClient = vertx.createNetClient(new NetClientOptions());
          netClient.connect(port, host, result -> {
            if (result.succeeded()) {
              log.debug(""writing: "" + toHex(connectResponse));
              socket.write(connectResponse);
              log.debug(""connected, starting pump"");
              NetSocket clientSocket = result.result();
              socket.closeHandler(v -> clientSocket.close());
              clientSocket.closeHandler(v -> socket.close());
              Pump.pump(socket, clientSocket).start();
              Pump.pump(clientSocket, socket).start();
            } else {
              log.error(""exception"", result.cause());
              socket.handler(null);
              log.debug(""writing: "" + toHex(errorResponse));
              socket.write(errorResponse);
              socket.close();
            }
          });
        };
        if (useAuth) {
          socket.handler(buffer3 -> {
            log.debug(""auth handler"");
            log.debug(""got request: "" + toHex(buffer3));
            Buffer authReply = Buffer.buffer(new byte[] { 1, (byte) username.length() });
            authReply.appendString(username);
            authReply.appendByte((byte) username.length());
            authReply.appendString(username);
            if (!buffer3.equals(authReply)) {
              log.debug(""expected "" + toHex(authReply) + "", got "" + toHex(buffer3));
              socket.handler(null);
              log.debug(""writing: "" + toHex(authFailed));
              socket.write(authFailed);
              socket.close();
            } else {
              socket.handler(handler);
              log.debug(""writing: "" + toHex(authSuccess));
              socket.write(authSuccess);
            }
          });
          log.debug(""writing: "" + toHex(serverReplyAuth));
          socket.write(serverReplyAuth);
        } else {
          socket.handler(handler);
          log.debug(""writing: "" + toHex(serverReply));
          socket.write(serverReply);
        }
      });
    });
    server.listen(result -> {
      log.debug(""socks5 server started"");
      finishedHandler.handle(null);
    });
  }",method,changes_recommended
"          if (forceUri != null) {
            host = forceUri.substring(0, forceUri.indexOf(':'));
            port = Integer.valueOf(forceUri.substring(forceUri.indexOf(':') + 1));
          }",method,good
"        if (useAuth) {
          socket.handler(buffer3 -> {
            log.debug(""auth handler"");
            log.debug(""got request: "" + toHex(buffer3));
            Buffer authReply = Buffer.buffer(new byte[] { 1, (byte) username.length() });
            authReply.appendString(username);
            authReply.appendByte((byte) username.length());
            authReply.appendString(username);
            if (!buffer3.equals(authReply)) {
              log.debug(""expected "" + toHex(authReply) + "", got "" + toHex(buffer3));
              socket.handler(null);
              log.debug(""writing: "" + toHex(authFailed));
              socket.write(authFailed);
              socket.close();
            } else {
              socket.handler(handler);
              log.debug(""writing: "" + toHex(authSuccess));
              socket.write(authSuccess);
            }
          });
          log.debug(""writing: "" + toHex(serverReplyAuth));
          socket.write(serverReplyAuth);
        }",method,good
"  private String toHex(Buffer buffer) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < buffer.length(); i++) {
      sb.append(String.format(""%02X "", buffer.getByte(i)));
    }
    return sb.toString();
  }",method,good
"  @Override
  public void stop() {
    if (server != null) {
      server.close();
      server = null;
    }
  }",method,good
"    if (server != null) {
      server.close();
      server = null;
    }",method,good
"  @Override
  public int getPort() {
    return PORT;
  }",method,good
"public class HomeActivity extends AppCompatActivity {
    private static final Class<?>[] ACTIVITY = {AnimationUseActivity.class, MultipleItemUseActivity.class, HeaderAndFooterUseActivity.class, PullToRefreshUseActivity.class, SectionUseActivity.class, EmptyViewUseActivity.class, ItemDragAndSwipeUseActivity.class, ItemClickActivity.class, ExpandableUseActivity.class, DataBindingUseActivity.class,UpFetchUseActivity.class};
    private static final String[] TITLE = {""Animation"", ""MultipleItem"", ""Header/Footer"", ""PullToRefresh"", ""Section"", ""EmptyView"", ""DragAndSwipe"", ""ItemClick"", ""ExpandableItem"", ""DataBinding"", ""UpFetchData""};
    private static final int[] IMG = {R.mipmap.gv_animation, R.mipmap.gv_multipleltem, R.mipmap.gv_header_and_footer, R.mipmap.gv_pulltorefresh, R.mipmap.gv_section, R.mipmap.gv_empty, R.mipmap.gv_drag_and_swipe, R.mipmap.gv_item_click, R.mipmap.gv_expandable, R.mipmap.gv_databinding,R.drawable.gv_up_fetch};
    private ArrayList<HomeItem> mDataList;
    private RecyclerView mRecyclerView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_home);
        initView();
        initData();
        initAdapter();
    }
    private void initView() {
        mRecyclerView = (RecyclerView) findViewById(R.id.rv_list);
        mRecyclerView.setLayoutManager(new GridLayoutManager(this, 2));
    }
    @SuppressWarnings(""unchecked"")
    private void initAdapter() {
        BaseQuickAdapter homeAdapter = new HomeAdapter(R.layout.home_item_view, mDataList);
        homeAdapter.openLoadAnimation();
        View top = getLayoutInflater().inflate(R.layout.top_view, (ViewGroup) mRecyclerView.getParent(), false);
        homeAdapter.addHeaderView(top);
        homeAdapter.setOnItemClickListener(new BaseQuickAdapter.OnItemClickListener() {
            @Override
            public void onItemClick(BaseQuickAdapter adapter, View view, int position) {
                Intent intent = new Intent(HomeActivity.this, ACTIVITY[position]);
                startActivity(intent);
            }
        });
        mRecyclerView.setAdapter(homeAdapter);
    }
    private void initData() {
        mDataList = new ArrayList<>();
        for (int i = 0; i < TITLE.length; i++) {
            HomeItem item = new HomeItem();
            item.setTitle(TITLE[i]);
            item.setActivity(ACTIVITY[i]);
            item.setImageResource(IMG[i]);
            mDataList.add(item);
        }
    }
}",class,changes_recommended
"    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_home);
        initView();
        initData();
        initAdapter();
    }",method,good
"    private void initView() {
        mRecyclerView = (RecyclerView) findViewById(R.id.rv_list);
        mRecyclerView.setLayoutManager(new GridLayoutManager(this, 2));
    }",method,good
"    @SuppressWarnings(""unchecked"")
    private void initAdapter() {
        BaseQuickAdapter homeAdapter = new HomeAdapter(R.layout.home_item_view, mDataList);
        homeAdapter.openLoadAnimation();
        View top = getLayoutInflater().inflate(R.layout.top_view, (ViewGroup) mRecyclerView.getParent(), false);
        homeAdapter.addHeaderView(top);
        homeAdapter.setOnItemClickListener(new BaseQuickAdapter.OnItemClickListener() {
            @Override
            public void onItemClick(BaseQuickAdapter adapter, View view, int position) {
                Intent intent = new Intent(HomeActivity.this, ACTIVITY[position]);
                startActivity(intent);
            }
        });
        mRecyclerView.setAdapter(homeAdapter);
    }",method,good
"        homeAdapter.setOnItemClickListener(new BaseQuickAdapter.OnItemClickListener() {
            @Override
            public void onItemClick(BaseQuickAdapter adapter, View view, int position) {
                Intent intent = new Intent(HomeActivity.this, ACTIVITY[position]);
                startActivity(intent);
            }
        }",method,good
"            @Override
            public void onItemClick(BaseQuickAdapter adapter, View view, int position) {
                Intent intent = new Intent(HomeActivity.this, ACTIVITY[position]);
                startActivity(intent);
            }",method,good
"    private void initData() {
        mDataList = new ArrayList<>();
        for (int i = 0; i < TITLE.length; i++) {
            HomeItem item = new HomeItem();
            item.setTitle(TITLE[i]);
            item.setActivity(ACTIVITY[i]);
            item.setImageResource(IMG[i]);
            mDataList.add(item);
        }
    }",method,good
"        for (int i = 0; i < TITLE.length; i++) {
            HomeItem item = new HomeItem();
            item.setTitle(TITLE[i]);
            item.setActivity(ACTIVITY[i]);
            item.setImageResource(IMG[i]);
            mDataList.add(item);
        }",method,good
"public class ThreadUtils {
	// ===========================================================
	// Constants
	// ===========================================================
	private static final int STACKTRACE_CALLER_DEPTH = 3;
	// ===========================================================
	// Fields
	// ===========================================================
	// ===========================================================
	// Constructors
	// ===========================================================
	// ===========================================================
	// Getter & Setter
	// ===========================================================
	// ===========================================================
	// Methods for/from SuperClass/Interfaces
	// ===========================================================
	// ===========================================================
	// Methods
	// ===========================================================
	public static void dumpCurrentThreadInfo() {
		ThreadUtils.dumpCurrentThreadInfo(DebugLevel.DEBUG, Thread.currentThread().getStackTrace()[ThreadUtils.STACKTRACE_CALLER_DEPTH]);
	}
	public static void dumpCurrentThreadInfo(final DebugLevel pDebugLevel) {
		ThreadUtils.dumpCurrentThreadInfo(pDebugLevel, Thread.currentThread().getStackTrace()[ThreadUtils.STACKTRACE_CALLER_DEPTH]);
	}
	private static void dumpCurrentThreadInfo(final DebugLevel pDebugLevel, final StackTraceElement pCaller) {
		Debug.log(pDebugLevel, pCaller.getClassName() + ""."" + pCaller.getMethodName() + ""("" + pCaller.getFileName() + "".java:"" + pCaller.getLineNumber() + "") @(Thread: '"" + Thread.currentThread().getName() + ""')"");
	}
	// ===========================================================
	// Inner and Anonymous Classes
	// ===========================================================
}",class,good
"	public static void dumpCurrentThreadInfo() {
		ThreadUtils.dumpCurrentThreadInfo(DebugLevel.DEBUG, Thread.currentThread().getStackTrace()[ThreadUtils.STACKTRACE_CALLER_DEPTH]);
	}",method,good
"	public static void dumpCurrentThreadInfo(final DebugLevel pDebugLevel) {
		ThreadUtils.dumpCurrentThreadInfo(pDebugLevel, Thread.currentThread().getStackTrace()[ThreadUtils.STACKTRACE_CALLER_DEPTH]);
	}",method,good
"	private static void dumpCurrentThreadInfo(final DebugLevel pDebugLevel, final StackTraceElement pCaller) {
		Debug.log(pDebugLevel, pCaller.getClassName() + ""."" + pCaller.getMethodName() + ""("" + pCaller.getFileName() + "".java:"" + pCaller.getLineNumber() + "") @(Thread: '"" + Thread.currentThread().getName() + ""')"");
	}",method,good
"public abstract class BaseBounceView<T extends View> extends FrameLayout {
    private int mOrientation = OrientationHelper.VERTICAL;
    protected WXSwipeLayout swipeLayout;
    private T mInnerView;
    public BaseBounceView(Context context,int orientation) {
        this(context, null,orientation);
    }
    public BaseBounceView(Context context, AttributeSet attrs,int orientation) {
        super(context, attrs);
        mOrientation = orientation;
    }
    public int getOrientation(){
        return mOrientation;
    }
    public void init(Context context) {
        createBounceView(context);
    }
    boolean isVertical(){
        return mOrientation==OrientationHelper.VERTICAL;
    }
    public void setOnRefreshListener(WXSwipeLayout.WXOnRefreshListener onRefreshListener) {
        if (swipeLayout != null)
            swipeLayout.setOnRefreshListener(onRefreshListener);
    }
    public void setOnLoadingListener(WXSwipeLayout.WXOnLoadingListener onLoadingListener) {
        if (swipeLayout != null)
            swipeLayout.setOnLoadingListener(onLoadingListener);
    }
    public void finishPullRefresh() {
        if (swipeLayout != null)
            swipeLayout.finishPullRefresh();
    }
    public void finishPullLoad() {
        if (swipeLayout != null)
            swipeLayout.finishPullLoad();
    }
    private WXSwipeLayout createBounceView(Context context) {
        swipeLayout = new WXSwipeLayout(context);
        swipeLayout.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));
        mInnerView = setInnerView(context);
        if (mInnerView == null)
            return null;
        swipeLayout.addTargetView(mInnerView);
        addView(swipeLayout, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
        return swipeLayout;
    }
    public T getInnerView() {
        return mInnerView;
    }
    public abstract T setInnerView(Context context);
    public void setHeaderView(WXComponent refresh) {
        setRefreshEnable(true);
        if (swipeLayout != null) {
            WXRefreshView refreshView = swipeLayout.getHeaderView();
            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = refresh.getDomObject();
                if (immutableDomObject != null) {
                    int refreshHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setRefreshHeight(refreshHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setRefreshBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(refresh.getHostView());
                }
            }
        }
    }
    public void setFooterView(WXComponent loading) {
        setLoadmoreEnable(true);
        if (swipeLayout != null) {
            WXRefreshView refreshView = swipeLayout.getFooterView();
            if (refreshView != null) {
                ImmutableDomObject immutableDomObject = loading.getDomObject();
                if (immutableDomObject != null) {
                    int loadingHeight = (int) immutableDomObject.getLayoutHeight();
                    swipeLayout.setLoadingHeight(loadingHeight);
                    String colorStr = (String) immutableDomObject.getStyles().get(Constants.Name.BACKGROUND_COLOR);
                    String bgColor = WXUtils.getString(colorStr, null);
                    if (bgColor != null) {
                        if (!TextUtils.isEmpty(bgColor)) {
                            int colorInt = WXResourceUtils.getColor(bgColor);
                            if (!(colorInt == Color.TRANSPARENT)) {
                                swipeLayout.setLoadingBgColor(colorInt);
                            }
                        }
                    }
                    refreshView.setRefreshView(loading.getHostView());
                }
            }
        }
    }
    public void removeFooterView(WXComponent loading){
        setLoadmoreEnable(false);
        if(swipeLayout!=null){
            if(swipeLayout.getFooterView()!=null){
                swipeLayout.setLoadingHeight(0);
                swipeLayout.getFooterView().removeView(loading.getHostView());
                swipeLayout.finishPullLoad();
            }
        }
    }
    //TODO There are bugs, will be more than a rolling height
    public void removeHeaderView(WXComponent refresh){
        setRefreshEnable(false);
        if(swipeLayout!=null){
            if(swipeLayout.getHeaderView()!=null){
                swipeLayout.setRefreshHeight(0);
                swipeLayout.getHeaderView().removeView(refresh.getHostView());
                swipeLayout.finishPullRefresh();
            }
        }
    }
    public void setRefreshEnable(boolean enable) {
        if (swipeLayout != null)
            swipeLayout.setPullRefreshEnable(enable);
    }
    public void setLoadmoreEnable(boolean enable) {
        if (swipeLayout != null)
            swipeLayout.setPullLoadEnable(enable);
    }
  @Override
  public void removeView(View view) {
    if (view instanceof WXLoadingLayout) {
      finishPullLoad();
      setLoadmoreEnable(false);
      if (swipeLayout != null) {
        swipeLayout.removeView(swipeLayout.getFooterView());
      }
    } else if (view instanceof WXRefreshLayout) {
      finishPullRefresh();
      setRefreshEnable(false);
      if (swipeLayout != null) {
        swipeLayout.removeView(swipeLayout.getHeaderView());
      }
    } else {
      super.removeView(view);
    }
  }
    public WXSwipeLayout getSwipeLayout() {
        return swipeLayout;
    }
    public abstract void onRefreshingComplete();
    public abstract void onLoadmoreComplete();
}",class,changes_recommended
"    public BaseBounceView(Context context,int orientation) {
        this(context, null,orientation);
    }",method,good
"    public BaseBounceView(Context context, AttributeSet attrs,int orientation) {
        super(context, attrs);
        mOrientation = orientation;
    }",method,good
"    public int getOrientation(){
        return mOrientation;
    }",method,good
"    public void init(Context context) {
        createBounceView(context);
    }",method,good
"    boolean isVertical(){
        return mOrientation==OrientationHelper.VERTICAL;
    }",method,good
"    public void setOnRefreshListener(WXSwipeLayout.WXOnRefreshListener onRefreshListener) {
        if (swipeLayout != null)
            swipeLayout.setOnRefreshListener(onRefreshListener);
    }",method,good
"    public void setOnLoadingListener(WXSwipeLayout.WXOnLoadingListener onLoadingListener) {
        if (swipeLayout != null)
            swipeLayout.setOnLoadingListener(onLoadingListener);
    }",method,good
"    public void finishPullRefresh() {
        if (swipeLayout != null)
            swipeLayout.finishPullRefresh();
    }",method,good

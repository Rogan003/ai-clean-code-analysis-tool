code_snippet,type,score
"	private static String test5(Object obj) {
		String res = ""good"";
		try {
			res = """" + exc(obj);
			boolean f = exc2(""a"");
			if (!f) {
				res = ""f == false"";
			}
		} catch (Exception e) {
			res = ""exc"";
		}
		return res;
	}",method,
"			if (!f) {
				res = ""f == false"";
			}",method,
"	private static boolean test6(Object obj) {
		boolean res = false;
		while (true) {
			try {
				res = exc2(obj);
				return res;
			} catch (IOException e) {
				res = true;
			} catch (Throwable e) {
				if (obj == null) {
					obj = new Object();
				}
			}
		}
	}",method,
"		while (true) {
			try {
				res = exc2(obj);
				return res;
			} catch (IOException e) {
				res = true;
			} catch (Throwable e) {
				if (obj == null) {
					obj = new Object();
				}
			}
		}",method,
"				if (obj == null) {
					obj = new Object();
				}",method,
"	private static boolean test7() {
		boolean res = false;
		Object obj = null;
		while (true) {
			try {
				res = exc2(obj);
				return res;
			} catch (IOException e) {
				res = true;
				obj = new Object();
			} catch (Throwable e) {
				if (obj == null) {
					res = false;
				}
			}
		}
	}",method,
"		while (true) {
			try {
				res = exc2(obj);
				return res;
			} catch (IOException e) {
				res = true;
				obj = new Object();
			} catch (Throwable e) {
				if (obj == null) {
					res = false;
				}
			}
		}",method,
"				if (obj == null) {
					res = false;
				}",method,
"	private boolean test8(Object obj) {
		this.mDiscovering = false;
		try {
			exc(obj);
		} catch (Exception e) {
			e.toString();
		} finally {
			mDiscovering = true;
		}
		return mDiscovering;
	}",method,
"	private boolean test8a(Object obj) {
		this.mDiscovering = false;
		try {
			exc(obj);
		} catch (Exception e) {
			e.toString();
		} finally {
			if (!mDiscovering) {
				mDiscovering = true;
			}
		}
		return mDiscovering;
	}",method,
"			if (!mDiscovering) {
				mDiscovering = true;
			}",method,
"	private static boolean testSynchronize(Object obj) throws InterruptedException {
		synchronized (obj) {
			if (obj instanceof String) {
				return false;
			}
			obj.wait(5);
		}
		return true;
	}",method,
"		synchronized (obj) {
			if (obj instanceof String) {
				return false;
			}
			obj.wait(5);
		}",method,
"			if (obj instanceof String) {
				return false;
			}",method,
"	private synchronized static boolean testSynchronize2(Object obj) throws InterruptedException {
		return obj.toString() != null;
	}",method,
"	private boolean testSynchronize3() {
		boolean b = false;
		synchronized (mObject) {
			b = this.mDiscovering;
		}
		return b;
	}",method,
"		synchronized (mObject) {
			b = this.mDiscovering;
		}",method,
"	public int catchInLoop(int i, int j) {
		while (true) {
			try {
				while (i < j) {
					i = j++ / i;
				}
			} catch (RuntimeException e) {
				i = 10;
				continue;
			}
			break;
		}
		return j;
	}",method,
"		while (true) {
			try {
				while (i < j) {
					i = j++ / i;
				}
			} catch (RuntimeException e) {
				i = 10;
				continue;
			}
			break;
		}",method,
"				while (i < j) {
					i = j++ / i;
				}",method,
"	@Override
	public boolean testRun() throws Exception {
		Object obj = new Object();
		assertTrue(test0(obj));
		assertTrue(test1(obj));
		assertTrue(test2(obj));
		assertTrue(test3(obj));
		assertTrue(test4(obj) != null);
		assertTrue(test5(null) != null);
		assertTrue(test6(obj));
		assertTrue(test7());
		assertTrue(testSynchronize(obj));
		assertFalse(testSynchronize(""str""));
		assertTrue(testSynchronize2(""str""));
		assertTrue(testSynchronize3());
		assertTrue(test8(""a""));
		assertTrue(test8(null));
		assertTrue(test8a(""a""));
		assertTrue(test8a(null));
		assertEquals(catchInLoop(1, 0), 0);
		assertEquals(catchInLoop(0, 1), 2);
		assertEquals(catchInLoop(788, 100), 100);
		return true;
	}",method,
"	public static void main(String[] args) throws Exception {
		new TestTryCatch().testRun();
	}",method,
"	public TestTypeResolver() {
		this.f1 = 2;
	}",method,
"	public TestTypeResolver(int b1, int b2) {
		// test 'this' move and constructor invocation on moved register
		this(b1, b2, 0, 0, 0);
	}",method,
"	public TestTypeResolver(int a1, int a2, int a3, int a4, int a5) {
		this.f1 = a1;
	}",method,
"		public TestTernaryInSuper(int c) {
//			super(c > 0 ? c : -c, 1);
		}",method,
"	@Override
	public boolean testRun() throws Exception {
		// assertTrue((Integer) testVarsPropagation(5) == 1);
		// assertTrue(testVarsPropagation(1).getClass() == Exception.class);
		//
		// assertTrue(testMoveThis(f1) == this);
		return true;
	}",method,
"	public static void main(String[] args) throws Exception {
		new TestTypeResolver().testRun();
	}",method,
"	public void testOverloadedMethods() {
		Object s1 = ""The"";
		Object s2 = ""answer"";
		doPrint((Object) ""You should know:"");
		for (int i = 0; i < 2; i++) {
			doPrint(s1);
			doPrint(s2);
			s1 = ""is"";
			s2 = new Integer(42);
		}
	}",method,
"		for (int i = 0; i < 2; i++) {
			doPrint(s1);
			doPrint(s2);
			s1 = ""is"";
			s2 = new Integer(42);
		}",method,
"	private static void doPrint(String s1) {
		fail();
	}",method,
"	private static void doPrint(Integer s1) {
		fail();
	}",method,
"	private static void doPrint(Object s1) {
		// correct call
		result += s1 + "" "";
	}",method,
"	@Override
	public boolean testRun() throws Exception {
		testOverloadedMethods();
		assertEquals(result, ""You should know: The answer is 42 "");
		return true;
	}",method,
"	public static void main(String[] args) throws Exception {
		(new TestTypeResolver2()).testRun();
	}",method,
"public class MockitoJUnitRunner extends Runner implements Filterable {
    public static class Silent extends MockitoJUnitRunner {
        public Silent(Class<?> klass) throws InvocationTargetException {
            super(new RunnerFactory().create(klass));
        }
    }
    public static class Strict extends MockitoJUnitRunner {
        public Strict(Class<?> klass) throws InvocationTargetException {
            super(new StrictRunner(new RunnerFactory().createStrict(klass), klass));
        }
    }
    public static class StrictStubs extends MockitoJUnitRunner {
        public StrictStubs(Class<?> klass) throws InvocationTargetException {
            super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
        }
    }
    private final InternalRunner runner;
    public MockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {
        //by default, StrictRunner is used. We can change that potentially based on feedback from users
        this(new StrictRunner(new RunnerFactory().createStrict(klass), klass));
    }
    MockitoJUnitRunner(InternalRunner runner) throws InvocationTargetException {
        this.runner = runner;
    }
    @Override
    public void run(final RunNotifier notifier) {
        runner.run(notifier);
    }
    @Override
    public Description getDescription() {
        return runner.getDescription();
    }
    public void filter(Filter filter) throws NoTestsRemainException {
        //filter is required because without it UnrootedTests show up in Eclipse
        runner.filter(filter);
    }
}",class,
"    public static class Silent extends MockitoJUnitRunner {
        public Silent(Class<?> klass) throws InvocationTargetException {
            super(new RunnerFactory().create(klass));
        }
    }",class,
"    public static class Strict extends MockitoJUnitRunner {
        public Strict(Class<?> klass) throws InvocationTargetException {
            super(new StrictRunner(new RunnerFactory().createStrict(klass), klass));
        }
    }",class,
"    public static class StrictStubs extends MockitoJUnitRunner {
        public StrictStubs(Class<?> klass) throws InvocationTargetException {
            super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
        }
    }",class,
"        public Silent(Class<?> klass) throws InvocationTargetException {
            super(new RunnerFactory().create(klass));
        }",method,
"        public Strict(Class<?> klass) throws InvocationTargetException {
            super(new StrictRunner(new RunnerFactory().createStrict(klass), klass));
        }",method,
"        public StrictStubs(Class<?> klass) throws InvocationTargetException {
            super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
        }",method,
"    public MockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {
        //by default, StrictRunner is used. We can change that potentially based on feedback from users
        this(new StrictRunner(new RunnerFactory().createStrict(klass), klass));
    }",method,
"    MockitoJUnitRunner(InternalRunner runner) throws InvocationTargetException {
        this.runner = runner;
    }",method,
"    @Override
    public void run(final RunNotifier notifier) {
        runner.run(notifier);
    }",method,
"    @Override
    public Description getDescription() {
        return runner.getDescription();
    }",method,
"    public void filter(Filter filter) throws NoTestsRemainException {
        //filter is required because without it UnrootedTests show up in Eclipse
        runner.filter(filter);
    }",method,
"public class TaskSystemTable
        implements SystemTable
{
    public static final SchemaTableName TASK_TABLE_NAME = new SchemaTableName(""runtime"", ""tasks"");
    public static final ConnectorTableMetadata TASK_TABLE = tableMetadataBuilder(TASK_TABLE_NAME)
            .column(""node_id"", createUnboundedVarcharType())
            .column(""task_id"", createUnboundedVarcharType())
            .column(""stage_id"", createUnboundedVarcharType())
            .column(""query_id"", createUnboundedVarcharType())
            .column(""state"", createUnboundedVarcharType())
            .column(""splits"", BIGINT)
            .column(""queued_splits"", BIGINT)
            .column(""running_splits"", BIGINT)
            .column(""completed_splits"", BIGINT)
            .column(""split_scheduled_time_ms"", BIGINT)
            .column(""split_cpu_time_ms"", BIGINT)
            .column(""split_user_time_ms"", BIGINT)
            .column(""split_blocked_time_ms"", BIGINT)
            .column(""raw_input_bytes"", BIGINT)
            .column(""raw_input_rows"", BIGINT)
            .column(""processed_input_bytes"", BIGINT)
            .column(""processed_input_rows"", BIGINT)
            .column(""output_bytes"", BIGINT)
            .column(""output_rows"", BIGINT)
            .column(""created"", TIMESTAMP)
            .column(""start"", TIMESTAMP)
            .column(""last_heartbeat"", TIMESTAMP)
            .column(""end"", TIMESTAMP)
            .build();
    private final TaskManager taskManager;
    private final String nodeId;
    @Inject
    public TaskSystemTable(TaskManager taskManager, NodeInfo nodeInfo)
    {
        this.taskManager = taskManager;
        this.nodeId = nodeInfo.getNodeId();
    }
    @Override
    public Distribution getDistribution()
    {
        return ALL_NODES;
    }
    @Override
    public ConnectorTableMetadata getTableMetadata()
    {
        return TASK_TABLE;
    }
    @Override
    public RecordCursor cursor(ConnectorTransactionHandle transactionHandle, ConnectorSession session, TupleDomain<Integer> constraint)
    {
        Builder table = InMemoryRecordSet.builder(TASK_TABLE);
        for (TaskInfo taskInfo : taskManager.getAllTaskInfo()) {
            TaskStats stats = taskInfo.getStats();
            TaskStatus taskStatus = taskInfo.getTaskStatus();
            table.addRow(
                    nodeId,
                    taskStatus.getTaskId().toString(),
                    taskStatus.getTaskId().getStageId().toString(),
                    taskStatus.getTaskId().getQueryId().toString(),
                    taskStatus.getState().toString(),
                    (long) stats.getTotalDrivers(),
                    (long) stats.getQueuedDrivers(),
                    (long) stats.getRunningDrivers(),
                    (long) stats.getCompletedDrivers(),
                    toMillis(stats.getTotalScheduledTime()),
                    toMillis(stats.getTotalCpuTime()),
                    toMillis(stats.getTotalUserTime()),
                    toMillis(stats.getTotalBlockedTime()),
                    toBytes(stats.getRawInputDataSize()),
                    stats.getRawInputPositions(),
                    toBytes(stats.getProcessedInputDataSize()),
                    stats.getProcessedInputPositions(),
                    toBytes(stats.getOutputDataSize()),
                    stats.getOutputPositions(),
                    toTimeStamp(stats.getCreateTime()),
                    toTimeStamp(stats.getFirstStartTime()),
                    toTimeStamp(taskInfo.getLastHeartbeat()),
                    toTimeStamp(stats.getEndTime()));
        }
        return table.build().cursor();
    }
    private static Long toMillis(Duration duration)
    {
        if (duration == null) {
            return null;
        }
        return duration.toMillis();
    }
    private static Long toBytes(DataSize dataSize)
    {
        if (dataSize == null) {
            return null;
        }
        return dataSize.toBytes();
    }
    private static Long toTimeStamp(DateTime dateTime)
    {
        if (dateTime == null) {
            return null;
        }
        return dateTime.getMillis();
    }
}",class,
"    @Inject
    public TaskSystemTable(TaskManager taskManager, NodeInfo nodeInfo)
    {
        this.taskManager = taskManager;
        this.nodeId = nodeInfo.getNodeId();
    }",method,
"    @Override
    public Distribution getDistribution()
    {
        return ALL_NODES;
    }",method,
"    @Override
    public ConnectorTableMetadata getTableMetadata()
    {
        return TASK_TABLE;
    }",method,
"    @Override
    public RecordCursor cursor(ConnectorTransactionHandle transactionHandle, ConnectorSession session, TupleDomain<Integer> constraint)
    {
        Builder table = InMemoryRecordSet.builder(TASK_TABLE);
        for (TaskInfo taskInfo : taskManager.getAllTaskInfo()) {
            TaskStats stats = taskInfo.getStats();
            TaskStatus taskStatus = taskInfo.getTaskStatus();
            table.addRow(
                    nodeId,
                    taskStatus.getTaskId().toString(),
                    taskStatus.getTaskId().getStageId().toString(),
                    taskStatus.getTaskId().getQueryId().toString(),
                    taskStatus.getState().toString(),
                    (long) stats.getTotalDrivers(),
                    (long) stats.getQueuedDrivers(),
                    (long) stats.getRunningDrivers(),
                    (long) stats.getCompletedDrivers(),
                    toMillis(stats.getTotalScheduledTime()),
                    toMillis(stats.getTotalCpuTime()),
                    toMillis(stats.getTotalUserTime()),
                    toMillis(stats.getTotalBlockedTime()),
                    toBytes(stats.getRawInputDataSize()),
                    stats.getRawInputPositions(),
                    toBytes(stats.getProcessedInputDataSize()),
                    stats.getProcessedInputPositions(),
                    toBytes(stats.getOutputDataSize()),
                    stats.getOutputPositions(),
                    toTimeStamp(stats.getCreateTime()),
                    toTimeStamp(stats.getFirstStartTime()),
                    toTimeStamp(taskInfo.getLastHeartbeat()),
                    toTimeStamp(stats.getEndTime()));
        }
        return table.build().cursor();
    }",method,
"    private static Long toMillis(Duration duration)
    {
        if (duration == null) {
            return null;
        }
        return duration.toMillis();
    }",method,
"        if (duration == null) {
            return null;
        }",method,
"    private static Long toBytes(DataSize dataSize)
    {
        if (dataSize == null) {
            return null;
        }
        return dataSize.toBytes();
    }",method,
"        if (dataSize == null) {
            return null;
        }",method,
"    private static Long toTimeStamp(DateTime dateTime)
    {
        if (dateTime == null) {
            return null;
        }
        return dateTime.getMillis();
    }",method,
"        if (dateTime == null) {
            return null;
        }",method,
"public class HandlerMethodMappingTests {
	private AbstractHandlerMethodMapping<String> mapping;
	private MyHandler handler;
	private Method method1;
	private Method method2;
	@Before
	public void setup() throws Exception {
		this.mapping = new MyHandlerMethodMapping();
		this.handler = new MyHandler();
		this.method1 = handler.getClass().getMethod(""handlerMethod1"");
		this.method2 = handler.getClass().getMethod(""handlerMethod2"");
	}
	@Test(expected = IllegalStateException.class)
	public void registerDuplicates() {
		this.mapping.registerMapping(""foo"", this.handler, this.method1);
		this.mapping.registerMapping(""foo"", this.handler, this.method2);
	}
	@Test
	public void directMatch() throws Exception {
		String key = ""foo"";
		this.mapping.registerMapping(key, this.handler, this.method1);
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get(key));
		Mono<Object> result = this.mapping.getHandler(exchange);
		assertEquals(this.method1, ((HandlerMethod) result.block()).getMethod());
	}
	@Test
	public void patternMatch() throws Exception {
		this.mapping.registerMapping(""/fo*"", this.handler, this.method1);
		this.mapping.registerMapping(""/f*"", this.handler, this.method2);
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get(""/foo""));
		Mono<Object> result = this.mapping.getHandler(exchange);
		assertEquals(this.method1, ((HandlerMethod) result.block()).getMethod());
	}
	@Test
	public void ambiguousMatch() throws Exception {
		this.mapping.registerMapping(""/f?o"", this.handler, this.method1);
		this.mapping.registerMapping(""/fo?"", this.handler, this.method2);
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get(""/foo""));
		Mono<Object> result = this.mapping.getHandler(exchange);
		StepVerifier.create(result).expectError(IllegalStateException.class).verify();
	}
	@Test
	public void registerMapping() throws Exception {
		String key1 = ""/foo"";
		String key2 = ""/foo*"";
		this.mapping.registerMapping(key1, this.handler, this.method1);
		this.mapping.registerMapping(key2, this.handler, this.method2);
		assertThat(this.mapping.getMappingRegistry().getMappings().keySet(),
				Matchers.contains(key1, key2));
	}
	@Test
	public void registerMappingWithSameMethodAndTwoHandlerInstances() throws Exception {
		String key1 = ""foo"";
		String key2 = ""bar"";
		MyHandler handler1 = new MyHandler();
		MyHandler handler2 = new MyHandler();
		this.mapping.registerMapping(key1, handler1, this.method1);
		this.mapping.registerMapping(key2, handler2, this.method1);
		assertThat(this.mapping.getMappingRegistry().getMappings().keySet(), Matchers.contains(key1, key2));
	}
	@Test
	public void unregisterMapping() throws Exception {
		String key = ""foo"";
		this.mapping.registerMapping(key, this.handler, this.method1);
		Mono<Object> result = this.mapping.getHandler(MockServerWebExchange.from(MockServerHttpRequest.get(key)));
		assertNotNull(result.block());
		this.mapping.unregisterMapping(key);
		result = this.mapping.getHandler(MockServerWebExchange.from(MockServerHttpRequest.get(key)));
		assertNull(result.block());
		assertThat(this.mapping.getMappingRegistry().getMappings().keySet(), Matchers.not(Matchers.contains(key)));
	}
	private static class MyHandlerMethodMapping extends AbstractHandlerMethodMapping<String> {
		private PathPatternParser parser = new PathPatternParser();
		@Override
		protected boolean isHandler(Class<?> beanType) {
			return true;
		}
		@Override
		protected String getMappingForMethod(Method method, Class<?> handlerType) {
			String methodName = method.getName();
			return methodName.startsWith(""handler"") ? methodName : null;
		}
		@Override
		protected String getMatchingMapping(String pattern, ServerWebExchange exchange) {
			PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication();
			PathPattern parsedPattern = this.parser.parse(pattern);
			return (parsedPattern.matches(lookupPath) ? pattern : null);
		}
		@Override
		protected Comparator<String> getMappingComparator(ServerWebExchange exchange) {
			return (o1, o2) -> PathPattern.SPECIFICITY_COMPARATOR.compare(parser.parse(o1), parser.parse(o2));
		}
	}
	@Controller
	private static class MyHandler {
		@RequestMapping
		@SuppressWarnings(""unused"")
		public void handlerMethod1() {
		}
		@RequestMapping
		@SuppressWarnings(""unused"")
		public void handlerMethod2() {
		}
	}
}",class,
"	private static class MyHandlerMethodMapping extends AbstractHandlerMethodMapping<String> {
		private PathPatternParser parser = new PathPatternParser();
		@Override
		protected boolean isHandler(Class<?> beanType) {
			return true;
		}
		@Override
		protected String getMappingForMethod(Method method, Class<?> handlerType) {
			String methodName = method.getName();
			return methodName.startsWith(""handler"") ? methodName : null;
		}
		@Override
		protected String getMatchingMapping(String pattern, ServerWebExchange exchange) {
			PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication();
			PathPattern parsedPattern = this.parser.parse(pattern);
			return (parsedPattern.matches(lookupPath) ? pattern : null);
		}
		@Override
		protected Comparator<String> getMappingComparator(ServerWebExchange exchange) {
			return (o1, o2) -> PathPattern.SPECIFICITY_COMPARATOR.compare(parser.parse(o1), parser.parse(o2));
		}
	}",class,
"	private static class MyHandler {
		@RequestMapping
		@SuppressWarnings(""unused"")
		public void handlerMethod1() {
		}
		@RequestMapping
		@SuppressWarnings(""unused"")
		public void handlerMethod2() {
		}
	}",class,
"	@Before
	public void setup() throws Exception {
		this.mapping = new MyHandlerMethodMapping();
		this.handler = new MyHandler();
		this.method1 = handler.getClass().getMethod(""handlerMethod1"");
		this.method2 = handler.getClass().getMethod(""handlerMethod2"");
	}",method,
"	@Test(expected = IllegalStateException.class)
	public void registerDuplicates() {
		this.mapping.registerMapping(""foo"", this.handler, this.method1);
		this.mapping.registerMapping(""foo"", this.handler, this.method2);
	}",method,
"	@Test
	public void directMatch() throws Exception {
		String key = ""foo"";
		this.mapping.registerMapping(key, this.handler, this.method1);
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get(key));
		Mono<Object> result = this.mapping.getHandler(exchange);
		assertEquals(this.method1, ((HandlerMethod) result.block()).getMethod());
	}",method,
"	@Test
	public void patternMatch() throws Exception {
		this.mapping.registerMapping(""/fo*"", this.handler, this.method1);
		this.mapping.registerMapping(""/f*"", this.handler, this.method2);
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get(""/foo""));
		Mono<Object> result = this.mapping.getHandler(exchange);
		assertEquals(this.method1, ((HandlerMethod) result.block()).getMethod());
	}",method,
"	@Test
	public void ambiguousMatch() throws Exception {
		this.mapping.registerMapping(""/f?o"", this.handler, this.method1);
		this.mapping.registerMapping(""/fo?"", this.handler, this.method2);
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get(""/foo""));
		Mono<Object> result = this.mapping.getHandler(exchange);
		StepVerifier.create(result).expectError(IllegalStateException.class).verify();
	}",method,
"	@Test
	public void registerMapping() throws Exception {
		String key1 = ""/foo"";
		String key2 = ""/foo*"";
		this.mapping.registerMapping(key1, this.handler, this.method1);
		this.mapping.registerMapping(key2, this.handler, this.method2);
		assertThat(this.mapping.getMappingRegistry().getMappings().keySet(),
				Matchers.contains(key1, key2));
	}",method,
"	@Test
	public void registerMappingWithSameMethodAndTwoHandlerInstances() throws Exception {
		String key1 = ""foo"";
		String key2 = ""bar"";
		MyHandler handler1 = new MyHandler();
		MyHandler handler2 = new MyHandler();
		this.mapping.registerMapping(key1, handler1, this.method1);
		this.mapping.registerMapping(key2, handler2, this.method1);
		assertThat(this.mapping.getMappingRegistry().getMappings().keySet(), Matchers.contains(key1, key2));
	}",method,
"	@Test
	public void unregisterMapping() throws Exception {
		String key = ""foo"";
		this.mapping.registerMapping(key, this.handler, this.method1);
		Mono<Object> result = this.mapping.getHandler(MockServerWebExchange.from(MockServerHttpRequest.get(key)));
		assertNotNull(result.block());
		this.mapping.unregisterMapping(key);
		result = this.mapping.getHandler(MockServerWebExchange.from(MockServerHttpRequest.get(key)));
		assertNull(result.block());
		assertThat(this.mapping.getMappingRegistry().getMappings().keySet(), Matchers.not(Matchers.contains(key)));
	}",method,
"		@Override
		protected boolean isHandler(Class<?> beanType) {
			return true;
		}",method,
"		@Override
		protected String getMappingForMethod(Method method, Class<?> handlerType) {
			String methodName = method.getName();
			return methodName.startsWith(""handler"") ? methodName : null;
		}",method,
"		@Override
		protected String getMatchingMapping(String pattern, ServerWebExchange exchange) {
			PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication();
			PathPattern parsedPattern = this.parser.parse(pattern);
			return (parsedPattern.matches(lookupPath) ? pattern : null);
		}",method,
"		@Override
		protected Comparator<String> getMappingComparator(ServerWebExchange exchange) {
			return (o1, o2) -> PathPattern.SPECIFICITY_COMPARATOR.compare(parser.parse(o1), parser.parse(o2));
		}",method,
"		@RequestMapping
		@SuppressWarnings(""unused"")
		public void handlerMethod1() {
		}",method,
"		@RequestMapping
		@SuppressWarnings(""unused"")
		public void handlerMethod2() {
		}",method,
"public abstract class DrmInitData {
     DrmInitData() {
    }
    public abstract SchemeInitData get(UUID schemeUuid);
    public static final class SchemeInitData {
        public final String mimeType;
        public final byte[] data;
        public SchemeInitData(String mimeType, byte[] data) {
            this.mimeType = mimeType;
            this.data = data;
        }
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof SchemeInitData)) {
                return false;
            }
            if (obj == this) {
                return true;
            }
            SchemeInitData other = (SchemeInitData) obj;
            return mimeType.equals(other.mimeType) && Arrays.equals(data, other.data);
        }
        @Override
        public int hashCode() {
            return mimeType.hashCode() + 31 * Arrays.hashCode(data);
        }
    }
}",class,
"    public static final class SchemeInitData {
        public final String mimeType;
        public final byte[] data;
        public SchemeInitData(String mimeType, byte[] data) {
            this.mimeType = mimeType;
            this.data = data;
        }
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof SchemeInitData)) {
                return false;
            }
            if (obj == this) {
                return true;
            }
            SchemeInitData other = (SchemeInitData) obj;
            return mimeType.equals(other.mimeType) && Arrays.equals(data, other.data);
        }
        @Override
        public int hashCode() {
            return mimeType.hashCode() + 31 * Arrays.hashCode(data);
        }
    }",class,
"     DrmInitData() {
    }",method,
"        public SchemeInitData(String mimeType, byte[] data) {
            this.mimeType = mimeType;
            this.data = data;
        }",method,
"        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof SchemeInitData)) {
                return false;
            }
            if (obj == this) {
                return true;
            }
            SchemeInitData other = (SchemeInitData) obj;
            return mimeType.equals(other.mimeType) && Arrays.equals(data, other.data);
        }",method,
"            if (obj == this) {
                return true;
            }",method,
"        @Override
        public int hashCode() {
            return mimeType.hashCode() + 31 * Arrays.hashCode(data);
        }",method,
"public class MainActivity extends AppCompatActivity {
    private static final String TAG = MainActivity.class.getSimpleName();
    private ProductAdapter adapter;
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.shr_main);
        Toolbar appBar = (Toolbar) findViewById(R.id.app_bar);
        setSupportActionBar(appBar);
        ArrayList<ProductEntry> products = readProductsList();
        ImageRequester imageRequester = ImageRequester.getInstance(this);
        ProductEntry headerProduct = getHeaderProduct(products);
        NetworkImageView headerImage = (NetworkImageView) findViewById(R.id.app_bar_image);
        imageRequester.setImageFromUrl(headerImage, headerProduct.url);
        final RecyclerView recyclerView = (RecyclerView) findViewById(R.id.product_list);
        recyclerView.setHasFixedSize(true);
        recyclerView.setLayoutManager(
                new GridLayoutManager(this, getResources().getInteger(R.integer.shr_column_count)));
        adapter = new ProductAdapter(products, imageRequester);
        recyclerView.setAdapter(adapter);
        BottomNavigationView bottomNavigation =
                (BottomNavigationView) findViewById(R.id.bottom_navigation);
        bottomNavigation.setOnNavigationItemSelectedListener(
                new BottomNavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
                shuffleProducts();
                return true;
            }
        });
        bottomNavigation.setOnNavigationItemReselectedListener(
                new BottomNavigationView.OnNavigationItemReselectedListener() {
            @Override
            public void onNavigationItemReselected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
            }
        });
        if (savedInstanceState == null) {
            bottomNavigation.setSelectedItemId(R.id.category_home);
        }
    }
    private ProductEntry getHeaderProduct(List<ProductEntry> products) {
        if (products.size() == 0) {
            throw new IllegalArgumentException(""There must be at least one product"");
        }
        for (int i = 0; i < products.size(); i++) {
            if (""Perfect Goldfish Bowl"".equals(products.get(i).title)) {
                return products.get(i);
            }
        }
        return products.get(0);
    }
    private void shuffleProducts() {
        ArrayList<ProductEntry> products = readProductsList();
        Collections.shuffle(products);
        adapter.setProducts(products);
    }
    private ArrayList<ProductEntry> readProductsList() {
        InputStream inputStream = getResources().openRawResource(R.raw.products);
        Type productListType = new TypeToken<ArrayList<ProductEntry>>() {}.getType();
        try {
            return JsonReader.readJsonStream(inputStream, productListType);
        } catch (IOException e) {
            Log.e(TAG, ""Error reading JSON product list"", e);
            return new ArrayList<>();
        }
    }
    private static final class ProductAdapter extends RecyclerView.Adapter<ProductViewHolder> {
        private List<ProductEntry> products;
        private final ImageRequester imageRequester;
        ProductAdapter(List<ProductEntry> products, ImageRequester imageRequester) {
            this.products = products;
            this.imageRequester = imageRequester;
        }
        void setProducts(List<ProductEntry> products) {
            this.products = products;
            notifyDataSetChanged();
        }
        @Override
        public ProductViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) {
            return new ProductViewHolder(viewGroup);
        }
        @Override
        public void onBindViewHolder(ProductViewHolder viewHolder, int i) {
            viewHolder.bind(products.get(i), imageRequester);
        }
        @Override
        public int getItemCount() {
            return products.size();
        }
    }
    private static final class ProductViewHolder extends RecyclerView.ViewHolder {
        private final NetworkImageView imageView;
        private final TextView priceView;
        ProductViewHolder(ViewGroup parent) {
            super(LayoutInflater.from(parent.getContext()).inflate(
                    R.layout.shr_product_entry, parent, false));
            imageView = (NetworkImageView) itemView.findViewById(R.id.image);
            priceView = (TextView) itemView.findViewById(R.id.price);
            itemView.setOnClickListener(clickListener);
        }
        private final View.OnClickListener clickListener =
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        ProductEntry product = (ProductEntry) v.getTag(R.id.tag_product_entry);
                        // TODO: show product details
                    }
                };
        void bind(ProductEntry product, ImageRequester imageRequester) {
            itemView.setTag(R.id.tag_product_entry, product);
            imageRequester.setImageFromUrl(imageView, product.url);
            priceView.setText(product.price);
        }
    }
}",class,
"    private static final class ProductAdapter extends RecyclerView.Adapter<ProductViewHolder> {
        private List<ProductEntry> products;
        private final ImageRequester imageRequester;
        ProductAdapter(List<ProductEntry> products, ImageRequester imageRequester) {
            this.products = products;
            this.imageRequester = imageRequester;
        }
        void setProducts(List<ProductEntry> products) {
            this.products = products;
            notifyDataSetChanged();
        }
        @Override
        public ProductViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) {
            return new ProductViewHolder(viewGroup);
        }
        @Override
        public void onBindViewHolder(ProductViewHolder viewHolder, int i) {
            viewHolder.bind(products.get(i), imageRequester);
        }
        @Override
        public int getItemCount() {
            return products.size();
        }
    }",class,
"    private static final class ProductViewHolder extends RecyclerView.ViewHolder {
        private final NetworkImageView imageView;
        private final TextView priceView;
        ProductViewHolder(ViewGroup parent) {
            super(LayoutInflater.from(parent.getContext()).inflate(
                    R.layout.shr_product_entry, parent, false));
            imageView = (NetworkImageView) itemView.findViewById(R.id.image);
            priceView = (TextView) itemView.findViewById(R.id.price);
            itemView.setOnClickListener(clickListener);
        }
        private final View.OnClickListener clickListener =
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        ProductEntry product = (ProductEntry) v.getTag(R.id.tag_product_entry);
                        // TODO: show product details
                    }
                };
        void bind(ProductEntry product, ImageRequester imageRequester) {
            itemView.setTag(R.id.tag_product_entry, product);
            imageRequester.setImageFromUrl(imageView, product.url);
            priceView.setText(product.price);
        }
    }",class,
"public class ProductEntry {
    public final String title;
    public final String url;
    public final String price;
    public final String description;
    public ProductEntry(String title, String url, String price, String description) {
        this.title = title;
        this.url = url;
        this.price = price;
        this.description = description;
    }
}",class,
"    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.shr_main);
        Toolbar appBar = (Toolbar) findViewById(R.id.app_bar);
        setSupportActionBar(appBar);
        ArrayList<ProductEntry> products = readProductsList();
        ImageRequester imageRequester = ImageRequester.getInstance(this);
        ProductEntry headerProduct = getHeaderProduct(products);
        NetworkImageView headerImage = (NetworkImageView) findViewById(R.id.app_bar_image);
        imageRequester.setImageFromUrl(headerImage, headerProduct.url);
        final RecyclerView recyclerView = (RecyclerView) findViewById(R.id.product_list);
        recyclerView.setHasFixedSize(true);
        recyclerView.setLayoutManager(
                new GridLayoutManager(this, getResources().getInteger(R.integer.shr_column_count)));
        adapter = new ProductAdapter(products, imageRequester);
        recyclerView.setAdapter(adapter);
        BottomNavigationView bottomNavigation =
                (BottomNavigationView) findViewById(R.id.bottom_navigation);
        bottomNavigation.setOnNavigationItemSelectedListener(
                new BottomNavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
                shuffleProducts();
                return true;
            }
        });
        bottomNavigation.setOnNavigationItemReselectedListener(
                new BottomNavigationView.OnNavigationItemReselectedListener() {
            @Override
            public void onNavigationItemReselected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
            }
        });
        if (savedInstanceState == null) {
            bottomNavigation.setSelectedItemId(R.id.category_home);
        }
    }",method,
"        bottomNavigation.setOnNavigationItemSelectedListener(
                new BottomNavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
                shuffleProducts();
                return true;
            }
        }",method,
"            @Override
            public boolean onNavigationItemSelected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
                shuffleProducts();
                return true;
            }",method,
"        bottomNavigation.setOnNavigationItemReselectedListener(
                new BottomNavigationView.OnNavigationItemReselectedListener() {
            @Override
            public void onNavigationItemReselected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
            }
        }",method,
"            @Override
            public void onNavigationItemReselected(@NonNull MenuItem item) {
                GridLayoutManager layoutManager =
                        (GridLayoutManager) recyclerView.getLayoutManager();
                layoutManager.scrollToPositionWithOffset(0, 0);
            }",method,
"        if (savedInstanceState == null) {
            bottomNavigation.setSelectedItemId(R.id.category_home);
        }",method,
"    private ProductEntry getHeaderProduct(List<ProductEntry> products) {
        if (products.size() == 0) {
            throw new IllegalArgumentException(""There must be at least one product"");
        }
        for (int i = 0; i < products.size(); i++) {
            if (""Perfect Goldfish Bowl"".equals(products.get(i).title)) {
                return products.get(i);
            }
        }
        return products.get(0);
    }",method,
"    private void shuffleProducts() {
        ArrayList<ProductEntry> products = readProductsList();
        Collections.shuffle(products);
        adapter.setProducts(products);
    }",method,
"    private ArrayList<ProductEntry> readProductsList() {
        InputStream inputStream = getResources().openRawResource(R.raw.products);
        Type productListType = new TypeToken<ArrayList<ProductEntry>>() {}.getType();
        try {
            return JsonReader.readJsonStream(inputStream, productListType);
        } catch (IOException e) {
            Log.e(TAG, ""Error reading JSON product list"", e);
            return new ArrayList<>();
        }
    }",method,
"        ProductAdapter(List<ProductEntry> products, ImageRequester imageRequester) {
            this.products = products;
            this.imageRequester = imageRequester;
        }",method,
"        void setProducts(List<ProductEntry> products) {
            this.products = products;
            notifyDataSetChanged();
        }",method,
"        @Override
        public ProductViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) {
            return new ProductViewHolder(viewGroup);
        }",method,
"        @Override
        public void onBindViewHolder(ProductViewHolder viewHolder, int i) {
            viewHolder.bind(products.get(i), imageRequester);
        }",method,
"        @Override
        public int getItemCount() {
            return products.size();
        }",method,
"        ProductViewHolder(ViewGroup parent) {
            super(LayoutInflater.from(parent.getContext()).inflate(
                    R.layout.shr_product_entry, parent, false));
            imageView = (NetworkImageView) itemView.findViewById(R.id.image);
            priceView = (TextView) itemView.findViewById(R.id.price);
            itemView.setOnClickListener(clickListener);
        }",method,

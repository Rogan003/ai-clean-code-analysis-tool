code_snippet,type,score
"  public InvalidCoordinatesException(String message) {
    super(message);
  }",method,
"public abstract class ForwardingSortedSetMultimap<K, V> extends ForwardingSetMultimap<K, V>
    implements SortedSetMultimap<K, V> {
  protected ForwardingSortedSetMultimap() {}
  @Override
  protected abstract SortedSetMultimap<K, V> delegate();
  @Override
  public SortedSet<V> get(@Nullable K key) {
    return delegate().get(key);
  }
  @Override
  public SortedSet<V> removeAll(@Nullable Object key) {
    return delegate().removeAll(key);
  }
  @Override
  public SortedSet<V> replaceValues(K key, Iterable<? extends V> values) {
    return delegate().replaceValues(key, values);
  }
  @Override
  public Comparator<? super V> valueComparator() {
    return delegate().valueComparator();
  }
}",class,
  protected ForwardingSortedSetMultimap() {},method,
"  @Override
  public SortedSet<V> get(@Nullable K key) {
    return delegate().get(key);
  }",method,
"  @Override
  public SortedSet<V> removeAll(@Nullable Object key) {
    return delegate().removeAll(key);
  }",method,
"  @Override
  public SortedSet<V> replaceValues(K key, Iterable<? extends V> values) {
    return delegate().replaceValues(key, values);
  }",method,
"  @Override
  public Comparator<? super V> valueComparator() {
    return delegate().valueComparator();
  }",method,
"    if (qualifier == null) {
      throw new IncorrectOperationException();
    }",method,
"    if (oldIdentifier == null){
      throw new IncorrectOperationException();
    }",method,
"  private PsiElement replaceWithRegularImport(final PsiClass psiClass) throws IncorrectOperationException {
    PsiImportStaticStatement baseStatement = PsiTreeUtil.getParentOfType(getElement(), PsiImportStaticStatement.class);
    PsiImportStatement statement = JavaPsiFacade.getInstance(getProject()).getElementFactory().createImportStatement(psiClass);
    statement = (PsiImportStatement) baseStatement.replace(statement);
    final PsiJavaCodeReferenceElement reference = statement.getImportReference();
    assert reference != null;
    return reference;
  }",method,
"  @Override
  public void processVariants(@NotNull PsiScopeProcessor processor) {
    FilterScopeProcessor proc = new FilterScopeProcessor(new ClassFilter(PsiModifierListOwner.class), processor);
    PsiScopesUtil.resolveAndWalk(proc, this, null, true);
  }",method,
"  @Override
  @NotNull
  public Object[] getVariants() {
    // IMPLEMENT[dsl]
    return ArrayUtil.EMPTY_OBJECT_ARRAY;
  }",method,
"  @Override
  public void accept(@NotNull PsiElementVisitor visitor) {
    if (visitor instanceof JavaElementVisitor) {
      ((JavaElementVisitor)visitor).visitImportStaticReferenceElement(this);
    }
    else {
      visitor.visitElement(this);
    }
  }",method,
"    if (visitor instanceof JavaElementVisitor) {
      ((JavaElementVisitor)visitor).visitImportStaticReferenceElement(this);
    }",method,
"public class AssertEqualsCalledOnArrayInspection extends BaseInspection {
  @Nls
  @NotNull
  @Override
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""assertequals.called.on.arrays.display.name"");
  }
  @NotNull
  @Override
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""assertequals.called.on.arrays.problem.descriptor"");
  }
  @Override
  protected InspectionGadgetsFix buildFix(Object... infos) {
    return new ReplaceAssertEqualsFix(""assertArrayEquals"");
  }
  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new AssertEqualsOnArrayVisitor();
  }
  private static class AssertEqualsOnArrayVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethodCallExpression(PsiMethodCallExpression expression) {
      super.visitMethodCallExpression(expression);
      final AssertHint assertHint = AssertHint.createAssertEqualsHint(expression, false);
      if (assertHint == null) {
        return;
      }
      final PsiExpressionList argumentList = expression.getArgumentList();
      final PsiExpression[] arguments = argumentList.getExpressions();
      final int argIndex = assertHint.getArgIndex();
      final PsiType type1 = arguments[argIndex].getType();
      final PsiType type2 = arguments[argIndex + 1].getType();
      if (!(type1 instanceof PsiArrayType) || !(type2 instanceof PsiArrayType)) {
        return;
      }
      registerMethodCallError(expression);
    }
  }
}",class,
"  private static class AssertEqualsOnArrayVisitor extends BaseInspectionVisitor {
    @Override
    public void visitMethodCallExpression(PsiMethodCallExpression expression) {
      super.visitMethodCallExpression(expression);
      final AssertHint assertHint = AssertHint.createAssertEqualsHint(expression, false);
      if (assertHint == null) {
        return;
      }
      final PsiExpressionList argumentList = expression.getArgumentList();
      final PsiExpression[] arguments = argumentList.getExpressions();
      final int argIndex = assertHint.getArgIndex();
      final PsiType type1 = arguments[argIndex].getType();
      final PsiType type2 = arguments[argIndex + 1].getType();
      if (!(type1 instanceof PsiArrayType) || !(type2 instanceof PsiArrayType)) {
        return;
      }
      registerMethodCallError(expression);
    }
  }",class,
"  @Nls
  @NotNull
  @Override
  public String getDisplayName() {
    return InspectionGadgetsBundle.message(""assertequals.called.on.arrays.display.name"");
  }",method,
"  @NotNull
  @Override
  protected String buildErrorString(Object... infos) {
    return InspectionGadgetsBundle.message(""assertequals.called.on.arrays.problem.descriptor"");
  }",method,
"  @Override
  protected InspectionGadgetsFix buildFix(Object... infos) {
    return new ReplaceAssertEqualsFix(""assertArrayEquals"");
  }",method,
"  @Override
  public BaseInspectionVisitor buildVisitor() {
    return new AssertEqualsOnArrayVisitor();
  }",method,
"    @Override
    public void visitMethodCallExpression(PsiMethodCallExpression expression) {
      super.visitMethodCallExpression(expression);
      final AssertHint assertHint = AssertHint.createAssertEqualsHint(expression, false);
      if (assertHint == null) {
        return;
      }
      final PsiExpressionList argumentList = expression.getArgumentList();
      final PsiExpression[] arguments = argumentList.getExpressions();
      final int argIndex = assertHint.getArgIndex();
      final PsiType type1 = arguments[argIndex].getType();
      final PsiType type2 = arguments[argIndex + 1].getType();
      if (!(type1 instanceof PsiArrayType) || !(type2 instanceof PsiArrayType)) {
        return;
      }
      registerMethodCallError(expression);
    }",method,
"      if (assertHint == null) {
        return;
      }",method,
"public class AccuRevHistoryParser implements Executor.StreamHandler {
    private AccuRevRepository repository;
    private History history;
    private boolean foundHistory;
    History parse(File file, Repository repos) throws HistoryException {
        repository = (AccuRevRepository) repos;
        history = null;
        foundHistory = false;
        String relPath = repository.getDepotRelativePath(file);
        if (relPath.equals(""/./"")) {
            List<HistoryEntry> entries = new ArrayList<HistoryEntry>();
            entries.add(new HistoryEntry(
                    """", new Date(), ""OpenGrok"", ""Workspace Root"", true));
            history = new History(entries);
        } else {
            try {
                Executor executor = repository.getHistoryLogExecutor(file);
                executor.exec(true, this);
                if (!foundHistory) {
                    executor = repository.getHistoryLogExecutor(file);
                    executor.exec(true, this);
                }
            } catch (IOException e) {
                throw new HistoryException(
                        ""Failed to get history for: \""""
                        + file.getAbsolutePath() + ""\"""" + e);
            }
        }
        return history;
    }
    public void processStream(InputStream input) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(input));
        List<HistoryEntry> entries = new ArrayList<HistoryEntry>();
        DateFormat df = repository.getDateFormat();
        String line;
        String user;
        Date date;
        HistoryEntry entry = null;
        history = new History();
        while ((line = in.readLine()) != null) {
            if (line.startsWith(""e"")) {
                continue;
            } // ignore element, eid
            if (line.startsWith(""t"")) {             // found transaction
                String data[] = line.split(""; "");
                entry = new HistoryEntry();
                foundHistory = true;
                user = data[3].replaceFirst(""user: "", """");
                entry.setMessage("""");
                entry.setAuthor(user);
                try {
                    date = df.parse(data[2]);
                    entry.setDate(date);
                } catch (ParseException pe) {
                    OpenGrokLogger.getLogger().log(
                            Level.WARNING, ""Could not parse date: "" + line, pe);
                }
            } else if (line.startsWith(""  #"")) {  // found comment
                entry.appendMessage(line.substring(3));
            } else if (line.startsWith(""  v"")) {  // found version
                String data[] = line.split(""\\s+"");
                entry.setRevision(data[2]);
                entry.setActive(true);
                entries.add(entry);
            }
        }
        history.setHistoryEntries(entries);
    }
}",class,
"    History parse(File file, Repository repos) throws HistoryException {
        repository = (AccuRevRepository) repos;
        history = null;
        foundHistory = false;
        String relPath = repository.getDepotRelativePath(file);
        if (relPath.equals(""/./"")) {
            List<HistoryEntry> entries = new ArrayList<HistoryEntry>();
            entries.add(new HistoryEntry(
                    """", new Date(), ""OpenGrok"", ""Workspace Root"", true));
            history = new History(entries);
        } else {
            try {
                Executor executor = repository.getHistoryLogExecutor(file);
                executor.exec(true, this);
                if (!foundHistory) {
                    executor = repository.getHistoryLogExecutor(file);
                    executor.exec(true, this);
                }
            } catch (IOException e) {
                throw new HistoryException(
                        ""Failed to get history for: \""""
                        + file.getAbsolutePath() + ""\"""" + e);
            }
        }
        return history;
    }",method,
"                if (!foundHistory) {
                    executor = repository.getHistoryLogExecutor(file);
                    executor.exec(true, this);
                }",method,
"    public void processStream(InputStream input) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(input));
        List<HistoryEntry> entries = new ArrayList<HistoryEntry>();
        DateFormat df = repository.getDateFormat();
        String line;
        String user;
        Date date;
        HistoryEntry entry = null;
        history = new History();
        while ((line = in.readLine()) != null) {
            if (line.startsWith(""e"")) {
                continue;
            } // ignore element, eid
            if (line.startsWith(""t"")) {             // found transaction
                String data[] = line.split(""; "");
                entry = new HistoryEntry();
                foundHistory = true;
                user = data[3].replaceFirst(""user: "", """");
                entry.setMessage("""");
                entry.setAuthor(user);
                try {
                    date = df.parse(data[2]);
                    entry.setDate(date);
                } catch (ParseException pe) {
                    OpenGrokLogger.getLogger().log(
                            Level.WARNING, ""Could not parse date: "" + line, pe);
                }
            } else if (line.startsWith(""  #"")) {  // found comment
                entry.appendMessage(line.substring(3));
            } else if (line.startsWith(""  v"")) {  // found version
                String data[] = line.split(""\\s+"");
                entry.setRevision(data[2]);
                entry.setActive(true);
                entries.add(entry);
            }
        }
        history.setHistoryEntries(entries);
    }",method,
"public class SmaliUtils {
    protected static final int    DEFAULT_API_LEVEL   = 19;
    public static boolean disassembleDexFile(File dex, File outputDir,
                                             final Set<String> includeClasses) throws IOException {
        final baksmaliOptions options = createBaksmaliOptions();
        if (!outputDir.exists()) {
            outputDir.mkdirs();
        }
        DexFile dexFile = DexFileFactory.loadDexFile(dex, DEFAULT_API_LEVEL, true);
        options.outputDirectory = outputDir.getAbsolutePath();
        //1. 设置线程数
        options.jobs = 3;
        if (options.registerInfo != 0 || options.deodex) {
            try {
                Iterable<String> extraClassPathEntries;
                if (options.extraClassPathEntries != null) {
                    extraClassPathEntries = options.extraClassPathEntries;
                } else {
                    extraClassPathEntries = ImmutableList.of();
                }
                options.classPath = ClassPath.fromClassPath(options.bootClassPathDirs,
                                                            Iterables.concat(options.bootClassPathEntries,
                                                                             extraClassPathEntries),
                                                            dexFile, options.apiLevel,
                                                            options.checkPackagePrivateAccess, options.experimental);
                if (options.customInlineDefinitions != null) {
                    options.inlineResolver = new CustomInlineMethodResolver(options.classPath,
                                                                            options.customInlineDefinitions);
                }
            } catch (Exception ex) {
                System.err.println(""\n\nError occurred while loading boot class path files. Aborting."");
                ex.printStackTrace(System.err);
                return false;
            }
        }
        if (options.resourceIdFileEntries != null) {
            class PublicHandler extends DefaultHandler {
                String prefix = null;
                public PublicHandler(String prefix){
                    super();
                    this.prefix = prefix;
                }
                public void startElement(String uri, String localName, String qName,
                                         Attributes attr) throws SAXException {
                    if (qName.equals(""public"")) {
                        String type = attr.getValue(""type"");
                        String name = attr.getValue(""name"").replace('.', '_');
                        Integer public_key = Integer.decode(attr.getValue(""id""));
                        String public_val = new StringBuffer().append(prefix).append(""."").append(type).append(""."").append(name).toString();
                        options.resourceIds.put(public_key, public_val);
                    }
                }
            }
            ;
            for (Map.Entry<String, String> entry : options.resourceIdFileEntries.entrySet()) {
                try {
                    SAXParser saxp = SAXParserFactory.newInstance().newSAXParser();
                    String prefix = entry.getValue();
                    saxp.parse(entry.getKey(), new PublicHandler(prefix));
                } catch (ParserConfigurationException e) {
                    continue;
                } catch (SAXException e) {
                    continue;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        File outputDirectoryFile = new File(options.outputDirectory);
        if (!outputDirectoryFile.exists()) {
            if (!outputDirectoryFile.mkdirs()) {
                System.err.println(""Can't create the output directory "" + options.outputDirectory);
                return false;
            }
        }
        // sort the classes, so that if we're on a case-insensitive file system and need to handle classes with file
        // name collisions, then we'll use the same name for each class, if the dex file goes through multiple
        // baksmali/smali cycles for some reason. If a class with a colliding name is added or removed, the filenames
        // may still change of course
        List<? extends ClassDef> classDefs = Ordering.natural().sortedCopy(dexFile.getClasses());
        if (!options.noAccessorComments) {
            options.syntheticAccessorResolver = new SyntheticAccessorResolver(classDefs);
        }
        final ClassFileNameHandler fileNameHandler = new ClassFileNameHandler(outputDirectoryFile, "".smali"");
        ExecutorService executor = Executors.newFixedThreadPool(options.jobs);
        List<Future<Boolean>> tasks = Lists.newArrayList();
        for (final ClassDef classDef : classDefs) {
            tasks.add(executor.submit(new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    String className = getDalvikClassName(classDef.getType());
                    if (null != includeClasses) {
                        if (includeClasses.contains(className)) {
                            BakSmali.disassembleClass(classDef, fileNameHandler, options);
                        }
                        return true;
                    } else {
                        return BakSmali.disassembleClass(classDef, fileNameHandler, options);
                    }
                }
            }));
        }
        boolean errorOccurred = false;
        try {
            for (Future<Boolean> task : tasks) {
                while (true) {
                    try {
                        if (!task.get()) {
                            errorOccurred = true;
                        }
                    } catch (InterruptedException ex) {
                        continue;
                    } catch (ExecutionException ex) {
                        throw new RuntimeException(ex);
                    }
                    break;
                }
            }
        } finally {
            executor.shutdown();
        }
        return !errorOccurred;
    }
    public static boolean disassembleDexFile(File dexFile, File outputDir) throws IOException {
       return disassembleDexFile(dexFile,outputDir,null);
    }
    public static boolean assembleSmaliFile(File smaliFolder,File outDexFile) throws IOException, RecognitionException {
        Collection<File> smaliFiles =  FileUtils.listFiles(smaliFolder, new String[]{""smali""}, true);
        if(null!= smaliFiles && smaliFiles.size() > 0){
            DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
            for(File smaliFile:smaliFiles){
                SmaliMod.assembleSmaliFile(smaliFile, dexBuilder, true, true);
            }
            dexBuilder.writeTo(new FileDataStore(outDexFile));
            return true;
        }else{
            return false;
        }
    }
    private static baksmaliOptions createBaksmaliOptions() {
        baksmaliOptions options = new baksmaliOptions();
        options.deodex = false;
        options.noParameterRegisters = false;
        options.useLocalsDirective = true;
        options.useSequentialLabels = true;
        options.outputDebugInfo = true;
        options.addCodeOffsets = false;
        options.jobs = -1;
        options.noAccessorComments = false;
        options.registerInfo = 0;// 128
        options.ignoreErrors = false;
        options.inlineResolver = null;
        options.checkPackagePrivateAccess = false;
        options.apiLevel = DEFAULT_API_LEVEL;
        return options;
    }
    public static String getDalvikClassName(String className) {
        if (className.charAt(0) != 'L' || className.charAt(className.length() - 1) != ';') {
            throw new RuntimeException(""Not a valid dalvik class name""+className);
        }
        return StringUtils.replace(className.substring(1, className.length() - 1), ""/"", ""."");
    }
    public static void main(String [] args) throws IOException {
        File dexFile = new File(""/Users/shenghua/Downloads/taobao-android.ap/android.apk/classes.dex"");
        SmaliUtils.disassembleDexFile(dexFile,new File(""/Users/shenghua/Downloads/taobao-android.ap/smali""));
    }
}",class,
"                System.err.println(""\n\nError occurred while loading boot class path files. Aborting."");
                ex.printStackTrace(System.err);
                return false;
            }
        }
        if (options.resourceIdFileEntries != null) {
            class PublicHandler extends DefaultHandler {
                String prefix = null;
                public PublicHandler(String prefix){
                    super();
                    this.prefix = prefix;
                }
                public void startElement(String uri, String localName, String qName,
                                         Attributes attr) throws SAXException {
                    if (qName.equals(""public"")) {
                        String type = attr.getValue(""type"");
                        String name = attr.getValue(""name"").replace('.', '_');
                        Integer public_key = Integer.decode(attr.getValue(""id""));
                        String public_val = new StringBuffer().append(prefix).append(""."").append(type).append(""."").append(name).toString();
                        options.resourceIds.put(public_key, public_val);
                    }
                }
            }
            ;
            for (Map.Entry<String, String> entry : options.resourceIdFileEntries.entrySet()) {
                try {
                    SAXParser saxp = SAXParserFactory.newInstance().newSAXParser();
                    String prefix = entry.getValue();
                    saxp.parse(entry.getKey(), new PublicHandler(prefix));
                } catch (ParserConfigurationException e) {
                    continue;
                } catch (SAXException e) {
                    continue;
                } catch (IOException e) {
                    continue;
                }
            }
        }",class,
"            class PublicHandler extends DefaultHandler {
                String prefix = null;
                public PublicHandler(String prefix){
                    super();
                    this.prefix = prefix;
                }
                public void startElement(String uri, String localName, String qName,
                                         Attributes attr) throws SAXException {
                    if (qName.equals(""public"")) {
                        String type = attr.getValue(""type"");
                        String name = attr.getValue(""name"").replace('.', '_');
                        Integer public_key = Integer.decode(attr.getValue(""id""));
                        String public_val = new StringBuffer().append(prefix).append(""."").append(type).append(""."").append(name).toString();
                        options.resourceIds.put(public_key, public_val);
                    }
                }
            }",class,
"        // baksmali/smali cycles for some reason. If a class with a colliding name is added or removed, the filenames
        // may still change of course
        List<? extends ClassDef> classDefs = Ordering.natural().sortedCopy(dexFile.getClasses());
        if (!options.noAccessorComments) {
            options.syntheticAccessorResolver = new SyntheticAccessorResolver(classDefs);
        }",class,
"            throw new RuntimeException(""Not a valid dalvik class name""+className);
        }
        return StringUtils.replace(className.substring(1, className.length() - 1), ""/"", ""."");
    }
    public static void main(String [] args) throws IOException {
        File dexFile = new File(""/Users/shenghua/Downloads/taobao-android.ap/android.apk/classes.dex"");
        SmaliUtils.disassembleDexFile(dexFile,new File(""/Users/shenghua/Downloads/taobao-android.ap/smali""));
    }",class,
"    public static boolean disassembleDexFile(File dex, File outputDir,
                                             final Set<String> includeClasses) throws IOException {
        final baksmaliOptions options = createBaksmaliOptions();
        if (!outputDir.exists()) {
            outputDir.mkdirs();
        }
        DexFile dexFile = DexFileFactory.loadDexFile(dex, DEFAULT_API_LEVEL, true);
        options.outputDirectory = outputDir.getAbsolutePath();
        //1. 设置线程数
        options.jobs = 3;
        if (options.registerInfo != 0 || options.deodex) {
            try {
                Iterable<String> extraClassPathEntries;
                if (options.extraClassPathEntries != null) {
                    extraClassPathEntries = options.extraClassPathEntries;
                } else {
                    extraClassPathEntries = ImmutableList.of();
                }
                options.classPath = ClassPath.fromClassPath(options.bootClassPathDirs,
                                                            Iterables.concat(options.bootClassPathEntries,
                                                                             extraClassPathEntries),
                                                            dexFile, options.apiLevel,
                                                            options.checkPackagePrivateAccess, options.experimental);
                if (options.customInlineDefinitions != null) {
                    options.inlineResolver = new CustomInlineMethodResolver(options.classPath,
                                                                            options.customInlineDefinitions);
                }
            } catch (Exception ex) {
                System.err.println(""\n\nError occurred while loading boot class path files. Aborting."");
                ex.printStackTrace(System.err);
                return false;
            }
        }
        if (options.resourceIdFileEntries != null) {
            class PublicHandler extends DefaultHandler {
                String prefix = null;
                public PublicHandler(String prefix){
                    super();
                    this.prefix = prefix;
                }
                public void startElement(String uri, String localName, String qName,
                                         Attributes attr) throws SAXException {
                    if (qName.equals(""public"")) {
                        String type = attr.getValue(""type"");
                        String name = attr.getValue(""name"").replace('.', '_');
                        Integer public_key = Integer.decode(attr.getValue(""id""));
                        String public_val = new StringBuffer().append(prefix).append(""."").append(type).append(""."").append(name).toString();
                        options.resourceIds.put(public_key, public_val);
                    }
                }
            }
            ;
            for (Map.Entry<String, String> entry : options.resourceIdFileEntries.entrySet()) {
                try {
                    SAXParser saxp = SAXParserFactory.newInstance().newSAXParser();
                    String prefix = entry.getValue();
                    saxp.parse(entry.getKey(), new PublicHandler(prefix));
                } catch (ParserConfigurationException e) {
                    continue;
                } catch (SAXException e) {
                    continue;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        File outputDirectoryFile = new File(options.outputDirectory);
        if (!outputDirectoryFile.exists()) {
            if (!outputDirectoryFile.mkdirs()) {
                System.err.println(""Can't create the output directory "" + options.outputDirectory);
                return false;
            }
        }
        // sort the classes, so that if we're on a case-insensitive file system and need to handle classes with file
        // name collisions, then we'll use the same name for each class, if the dex file goes through multiple
        // baksmali/smali cycles for some reason. If a class with a colliding name is added or removed, the filenames
        // may still change of course
        List<? extends ClassDef> classDefs = Ordering.natural().sortedCopy(dexFile.getClasses());
        if (!options.noAccessorComments) {
            options.syntheticAccessorResolver = new SyntheticAccessorResolver(classDefs);
        }
        final ClassFileNameHandler fileNameHandler = new ClassFileNameHandler(outputDirectoryFile, "".smali"");
        ExecutorService executor = Executors.newFixedThreadPool(options.jobs);
        List<Future<Boolean>> tasks = Lists.newArrayList();
        for (final ClassDef classDef : classDefs) {
            tasks.add(executor.submit(new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    String className = getDalvikClassName(classDef.getType());
                    if (null != includeClasses) {
                        if (includeClasses.contains(className)) {
                            BakSmali.disassembleClass(classDef, fileNameHandler, options);
                        }
                        return true;
                    } else {
                        return BakSmali.disassembleClass(classDef, fileNameHandler, options);
                    }
                }
            }));
        }
        boolean errorOccurred = false;
        try {
            for (Future<Boolean> task : tasks) {
                while (true) {
                    try {
                        if (!task.get()) {
                            errorOccurred = true;
                        }
                    } catch (InterruptedException ex) {
                        continue;
                    } catch (ExecutionException ex) {
                        throw new RuntimeException(ex);
                    }
                    break;
                }
            }
        } finally {
            executor.shutdown();
        }
        return !errorOccurred;
    }",method,
"        if (options.registerInfo != 0 || options.deodex) {
            try {
                Iterable<String> extraClassPathEntries;
                if (options.extraClassPathEntries != null) {
                    extraClassPathEntries = options.extraClassPathEntries;
                } else {
                    extraClassPathEntries = ImmutableList.of();
                }
                options.classPath = ClassPath.fromClassPath(options.bootClassPathDirs,
                                                            Iterables.concat(options.bootClassPathEntries,
                                                                             extraClassPathEntries),
                                                            dexFile, options.apiLevel,
                                                            options.checkPackagePrivateAccess, options.experimental);
                if (options.customInlineDefinitions != null) {
                    options.inlineResolver = new CustomInlineMethodResolver(options.classPath,
                                                                            options.customInlineDefinitions);
                }
            } catch (Exception ex) {
                System.err.println(""\n\nError occurred while loading boot class path files. Aborting."");
                ex.printStackTrace(System.err);
                return false;
            }
        }",method,
"                if (options.extraClassPathEntries != null) {
                    extraClassPathEntries = options.extraClassPathEntries;
                }",method,
"                if (options.customInlineDefinitions != null) {
                    options.inlineResolver = new CustomInlineMethodResolver(options.classPath,
                                                                            options.customInlineDefinitions);
                }",method,
"        if (options.resourceIdFileEntries != null) {
            class PublicHandler extends DefaultHandler {
                String prefix = null;
                public PublicHandler(String prefix){
                    super();
                    this.prefix = prefix;
                }
                public void startElement(String uri, String localName, String qName,
                                         Attributes attr) throws SAXException {
                    if (qName.equals(""public"")) {
                        String type = attr.getValue(""type"");
                        String name = attr.getValue(""name"").replace('.', '_');
                        Integer public_key = Integer.decode(attr.getValue(""id""));
                        String public_val = new StringBuffer().append(prefix).append(""."").append(type).append(""."").append(name).toString();
                        options.resourceIds.put(public_key, public_val);
                    }
                }
            }
            ;
            for (Map.Entry<String, String> entry : options.resourceIdFileEntries.entrySet()) {
                try {
                    SAXParser saxp = SAXParserFactory.newInstance().newSAXParser();
                    String prefix = entry.getValue();
                    saxp.parse(entry.getKey(), new PublicHandler(prefix));
                } catch (ParserConfigurationException e) {
                    continue;
                } catch (SAXException e) {
                    continue;
                } catch (IOException e) {
                    continue;
                }
            }
        }",method,
"                public PublicHandler(String prefix){
                    super();
                    this.prefix = prefix;
                }",method,
"                public void startElement(String uri, String localName, String qName,
                                         Attributes attr) throws SAXException {
                    if (qName.equals(""public"")) {
                        String type = attr.getValue(""type"");
                        String name = attr.getValue(""name"").replace('.', '_');
                        Integer public_key = Integer.decode(attr.getValue(""id""));
                        String public_val = new StringBuffer().append(prefix).append(""."").append(type).append(""."").append(name).toString();
                        options.resourceIds.put(public_key, public_val);
                    }
                }",method,
"        if (!options.noAccessorComments) {
            options.syntheticAccessorResolver = new SyntheticAccessorResolver(classDefs);
        }",method,
"        for (final ClassDef classDef : classDefs) {
            tasks.add(executor.submit(new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    String className = getDalvikClassName(classDef.getType());
                    if (null != includeClasses) {
                        if (includeClasses.contains(className)) {
                            BakSmali.disassembleClass(classDef, fileNameHandler, options);
                        }
                        return true;
                    } else {
                        return BakSmali.disassembleClass(classDef, fileNameHandler, options);
                    }
                }
            }));
        }",method,
"            tasks.add(executor.submit(new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    String className = getDalvikClassName(classDef.getType());
                    if (null != includeClasses) {
                        if (includeClasses.contains(className)) {
                            BakSmali.disassembleClass(classDef, fileNameHandler, options);
                        }
                        return true;
                    } else {
                        return BakSmali.disassembleClass(classDef, fileNameHandler, options);
                    }
                }
            }",method,
"                @Override
                public Boolean call() throws Exception {
                    String className = getDalvikClassName(classDef.getType());
                    if (null != includeClasses) {
                        if (includeClasses.contains(className)) {
                            BakSmali.disassembleClass(classDef, fileNameHandler, options);
                        }
                        return true;
                    } else {
                        return BakSmali.disassembleClass(classDef, fileNameHandler, options);
                    }
                }",method,
"                    if (null != includeClasses) {
                        if (includeClasses.contains(className)) {
                            BakSmali.disassembleClass(classDef, fileNameHandler, options);
                        }
                        return true;
                    }",method,
"            for (Future<Boolean> task : tasks) {
                while (true) {
                    try {
                        if (!task.get()) {
                            errorOccurred = true;
                        }
                    } catch (InterruptedException ex) {
                        continue;
                    } catch (ExecutionException ex) {
                        throw new RuntimeException(ex);
                    }
                    break;
                }
            }",method,
"                while (true) {
                    try {
                        if (!task.get()) {
                            errorOccurred = true;
                        }
                    } catch (InterruptedException ex) {
                        continue;
                    } catch (ExecutionException ex) {
                        throw new RuntimeException(ex);
                    }
                    break;
                }",method,
"    public static boolean disassembleDexFile(File dexFile, File outputDir) throws IOException {
       return disassembleDexFile(dexFile,outputDir,null);
    }",method,
"    public static boolean assembleSmaliFile(File smaliFolder,File outDexFile) throws IOException, RecognitionException {
        Collection<File> smaliFiles =  FileUtils.listFiles(smaliFolder, new String[]{""smali""}, true);
        if(null!= smaliFiles && smaliFiles.size() > 0){
            DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
            for(File smaliFile:smaliFiles){
                SmaliMod.assembleSmaliFile(smaliFile, dexBuilder, true, true);
            }
            dexBuilder.writeTo(new FileDataStore(outDexFile));
            return true;
        }else{
            return false;
        }
    }",method,
"            for(File smaliFile:smaliFiles){
                SmaliMod.assembleSmaliFile(smaliFile, dexBuilder, true, true);
            }",method,
"    private static baksmaliOptions createBaksmaliOptions() {
        baksmaliOptions options = new baksmaliOptions();
        options.deodex = false;
        options.noParameterRegisters = false;
        options.useLocalsDirective = true;
        options.useSequentialLabels = true;
        options.outputDebugInfo = true;
        options.addCodeOffsets = false;
        options.jobs = -1;
        options.noAccessorComments = false;
        options.registerInfo = 0;// 128
        options.ignoreErrors = false;
        options.inlineResolver = null;
        options.checkPackagePrivateAccess = false;
        options.apiLevel = DEFAULT_API_LEVEL;
        return options;
    }",method,
"    public static String getDalvikClassName(String className) {
        if (className.charAt(0) != 'L' || className.charAt(className.length() - 1) != ';') {
            throw new RuntimeException(""Not a valid dalvik class name""+className);
        }
        return StringUtils.replace(className.substring(1, className.length() - 1), ""/"", ""."");
    }",method,
"    public static void main(String [] args) throws IOException {
        File dexFile = new File(""/Users/shenghua/Downloads/taobao-android.ap/android.apk/classes.dex"");
        SmaliUtils.disassembleDexFile(dexFile,new File(""/Users/shenghua/Downloads/taobao-android.ap/smali""));
    }",method,
"public class MergeAction extends AnAction {
  private static final Logger LOG = Logger.getInstance(""#com.intellij.cvsSupport2.actions.merge.MergeAction"");
  private final CvsActionVisibility myVisibility = new CvsActionVisibility();
  public MergeAction() {
    myVisibility.shouldNotBePerformedOnDirectory();
    myVisibility.canBePerformedOnSeveralFiles();
    myVisibility.addCondition(new CvsActionVisibility.Condition() {
      public boolean isPerformedOn(CvsContext context) {
        VirtualFile[] files = context.getSelectedFiles();
        for(VirtualFile file: files) {
          FileStatus status = FileStatusManager.getInstance(context.getProject()).getStatus(file);
          if (status != FileStatus.MERGE && status != FileStatus.MERGED_WITH_CONFLICTS) {
            return false;
          }
        }
        return true;
      }
    });
  }
  public void actionPerformed(AnActionEvent e) {
    try {
      final VcsContext context = CvsContextWrapper.createCachedInstance(e);
      final VirtualFile[] files = context.getSelectedFiles();
      if (files.length == 0) return;
      final Project project = context.getProject();
      final ReadonlyStatusHandler.OperationStatus operationStatus =
        ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(files);
      if (operationStatus.hasReadonlyFiles()) {
        return;
      }
      AbstractVcsHelper.getInstance(project).showMergeDialog(Arrays.asList(files), new CvsMergeProvider());
    }
    catch (Exception e1) {
      LOG.error(e1);
    }
  }
  public void update(AnActionEvent e) {
    myVisibility.applyToEvent(e);
  }
}",class,
"  public MergeAction() {
    myVisibility.shouldNotBePerformedOnDirectory();
    myVisibility.canBePerformedOnSeveralFiles();
    myVisibility.addCondition(new CvsActionVisibility.Condition() {
      public boolean isPerformedOn(CvsContext context) {
        VirtualFile[] files = context.getSelectedFiles();
        for(VirtualFile file: files) {
          FileStatus status = FileStatusManager.getInstance(context.getProject()).getStatus(file);
          if (status != FileStatus.MERGE && status != FileStatus.MERGED_WITH_CONFLICTS) {
            return false;
          }
        }
        return true;
      }
    });
  }",method,
"    myVisibility.addCondition(new CvsActionVisibility.Condition() {
      public boolean isPerformedOn(CvsContext context) {
        VirtualFile[] files = context.getSelectedFiles();
        for(VirtualFile file: files) {
          FileStatus status = FileStatusManager.getInstance(context.getProject()).getStatus(file);
          if (status != FileStatus.MERGE && status != FileStatus.MERGED_WITH_CONFLICTS) {
            return false;
          }
        }
        return true;
      }
    }",method,
"      public boolean isPerformedOn(CvsContext context) {
        VirtualFile[] files = context.getSelectedFiles();
        for(VirtualFile file: files) {
          FileStatus status = FileStatusManager.getInstance(context.getProject()).getStatus(file);
          if (status != FileStatus.MERGE && status != FileStatus.MERGED_WITH_CONFLICTS) {
            return false;
          }
        }
        return true;
      }",method,
"        for(VirtualFile file: files) {
          FileStatus status = FileStatusManager.getInstance(context.getProject()).getStatus(file);
          if (status != FileStatus.MERGE && status != FileStatus.MERGED_WITH_CONFLICTS) {
            return false;
          }
        }",method,
"          if (status != FileStatus.MERGE && status != FileStatus.MERGED_WITH_CONFLICTS) {
            return false;
          }",method,
"  public void actionPerformed(AnActionEvent e) {
    try {
      final VcsContext context = CvsContextWrapper.createCachedInstance(e);
      final VirtualFile[] files = context.getSelectedFiles();
      if (files.length == 0) return;
      final Project project = context.getProject();
      final ReadonlyStatusHandler.OperationStatus operationStatus =
        ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(files);
      if (operationStatus.hasReadonlyFiles()) {
        return;
      }
      AbstractVcsHelper.getInstance(project).showMergeDialog(Arrays.asList(files), new CvsMergeProvider());
    }
    catch (Exception e1) {
      LOG.error(e1);
    }
  }",method,
"    catch (Exception e1) {
      LOG.error(e1);
    }",method,
"  public void update(AnActionEvent e) {
    myVisibility.applyToEvent(e);
  }",method,
"public class MissingAggregatorTests extends AggregatorTestCase {
    public void testMatchNoDocs() throws IOException {
        int numDocs = randomIntBetween(10, 200);
        testBothCases(numDocs,
            ""field"",
            Queries.newMatchAllQuery(),
            doc -> doc.add(new SortedNumericDocValuesField(""field"", randomLong())),
            internalMissing -> assertEquals(internalMissing.getDocCount(), 0));
    }
    public void testMatchAllDocs() throws IOException {
        int numDocs = randomIntBetween(10, 200);
        testBothCases(numDocs,
            ""field"",
            Queries.newMatchAllQuery(),
            doc -> doc.add(new SortedNumericDocValuesField(""another_field"", randomLong())),
            internalMissing -> assertEquals(internalMissing.getDocCount(), numDocs));
    }
    public void testMatchSparse() throws IOException {
        int numDocs = randomIntBetween(100, 200);
        final AtomicInteger count = new AtomicInteger();
        testBothCases(numDocs,
            ""field"",
            Queries.newMatchAllQuery(),
            doc -> {
                if (randomBoolean()) {
                    doc.add(new SortedNumericDocValuesField(""another_field"", randomLong()));
                    count.incrementAndGet();
                } else {
                    doc.add(new SortedNumericDocValuesField(""field"", randomLong()));
                }
            },
            internalMissing -> {
                assertEquals(internalMissing.getDocCount(), count.get());
                count.set(0);
            });
    }
    public void testMissingField() throws IOException {
        int numDocs = randomIntBetween(10, 20);
        testBothCases(numDocs,
            ""unknown_field"",
            Queries.newMatchAllQuery(),
            doc -> {
                doc.add(new SortedNumericDocValuesField(""field"", randomLong()));
            },
            internalMissing -> {
                assertEquals(internalMissing.getDocCount(), numDocs);
            });
    }
    private void testBothCases(int numDocs,
                               String fieldName,
                               Query query,
                               Consumer<Document> consumer,
                               Consumer<InternalMissing> verify) throws IOException {
        executeTestCase(numDocs, fieldName, query, consumer, verify, false);
        executeTestCase(numDocs, fieldName, query, consumer, verify, true);
    }
    private void executeTestCase(int numDocs,
                                 String fieldName,
                                 Query query,
                                 Consumer<Document> consumer,
                                 Consumer<InternalMissing> verify,
                                 boolean reduced) throws IOException {
        try (Directory directory = newDirectory()) {
            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {
                Document document = new Document();
                for (int i = 0; i < numDocs; i++) {
                    if (frequently()) {
                        indexWriter.commit();
                    }
                    consumer.accept(document);
                    indexWriter.addDocument(document);
                    document.clear();
                }
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                IndexSearcher indexSearcher =
                    newSearcher(indexReader, true, true);
                MissingAggregationBuilder builder =
                    new MissingAggregationBuilder(""_name"", ValueType.LONG);
                builder.field(fieldName);
                NumberFieldMapper.Builder mapperBuilder = new NumberFieldMapper.Builder(""_name"",
                    NumberFieldMapper.NumberType.LONG);
                MappedFieldType fieldType = mapperBuilder.fieldType();
                fieldType.setHasDocValues(true);
                fieldType.setName(builder.field());
                InternalMissing missing;
                if (reduced) {
                    missing = searchAndReduce(indexSearcher, query, builder, fieldType);
                } else {
                    missing = search(indexSearcher, query, builder, fieldType);
                }
                verify.accept(missing);
            }
        }
    }
}",class,
"    public void testMatchNoDocs() throws IOException {
        int numDocs = randomIntBetween(10, 200);
        testBothCases(numDocs,
            ""field"",
            Queries.newMatchAllQuery(),
            doc -> doc.add(new SortedNumericDocValuesField(""field"", randomLong())),
            internalMissing -> assertEquals(internalMissing.getDocCount(), 0));
    }",method,
"    public void testMatchAllDocs() throws IOException {
        int numDocs = randomIntBetween(10, 200);
        testBothCases(numDocs,
            ""field"",
            Queries.newMatchAllQuery(),
            doc -> doc.add(new SortedNumericDocValuesField(""another_field"", randomLong())),
            internalMissing -> assertEquals(internalMissing.getDocCount(), numDocs));
    }",method,
"    public void testMatchSparse() throws IOException {
        int numDocs = randomIntBetween(100, 200);
        final AtomicInteger count = new AtomicInteger();
        testBothCases(numDocs,
            ""field"",
            Queries.newMatchAllQuery(),
            doc -> {
                if (randomBoolean()) {
                    doc.add(new SortedNumericDocValuesField(""another_field"", randomLong()));
                    count.incrementAndGet();
                } else {
                    doc.add(new SortedNumericDocValuesField(""field"", randomLong()));
                }
            },
            internalMissing -> {
                assertEquals(internalMissing.getDocCount(), count.get());
                count.set(0);
            });
    }",method,
"    public void testMissingField() throws IOException {
        int numDocs = randomIntBetween(10, 20);
        testBothCases(numDocs,
            ""unknown_field"",
            Queries.newMatchAllQuery(),
            doc -> {
                doc.add(new SortedNumericDocValuesField(""field"", randomLong()));
            },
            internalMissing -> {
                assertEquals(internalMissing.getDocCount(), numDocs);
            });
    }",method,
"    private void testBothCases(int numDocs,
                               String fieldName,
                               Query query,
                               Consumer<Document> consumer,
                               Consumer<InternalMissing> verify) throws IOException {
        executeTestCase(numDocs, fieldName, query, consumer, verify, false);
        executeTestCase(numDocs, fieldName, query, consumer, verify, true);
    }",method,
"    private void executeTestCase(int numDocs,
                                 String fieldName,
                                 Query query,
                                 Consumer<Document> consumer,
                                 Consumer<InternalMissing> verify,
                                 boolean reduced) throws IOException {
        try (Directory directory = newDirectory()) {
            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {
                Document document = new Document();
                for (int i = 0; i < numDocs; i++) {
                    if (frequently()) {
                        indexWriter.commit();
                    }
                    consumer.accept(document);
                    indexWriter.addDocument(document);
                    document.clear();
                }
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                IndexSearcher indexSearcher =
                    newSearcher(indexReader, true, true);
                MissingAggregationBuilder builder =
                    new MissingAggregationBuilder(""_name"", ValueType.LONG);
                builder.field(fieldName);
                NumberFieldMapper.Builder mapperBuilder = new NumberFieldMapper.Builder(""_name"",
                    NumberFieldMapper.NumberType.LONG);
                MappedFieldType fieldType = mapperBuilder.fieldType();
                fieldType.setHasDocValues(true);
                fieldType.setName(builder.field());
                InternalMissing missing;
                if (reduced) {
                    missing = searchAndReduce(indexSearcher, query, builder, fieldType);
                } else {
                    missing = search(indexSearcher, query, builder, fieldType);
                }
                verify.accept(missing);
            }
        }
    }",method,
"                for (int i = 0; i < numDocs; i++) {
                    if (frequently()) {
                        indexWriter.commit();
                    }
                    consumer.accept(document);
                    indexWriter.addDocument(document);
                    document.clear();
                }",method,
"                if (reduced) {
                    missing = searchAndReduce(indexSearcher, query, builder, fieldType);
                }",method,
"public class RParserTest {
  @Before
  public void setUp() {
  }
  @Test
  public void one() throws IOException {
    SEXP r = parseSingle(""1\n\n"");
    assertThat(r, CoreMatchers.instanceOf(DoubleArrayVector.class));
  }
  @Test(expected = ParseException.class)
  public void error() throws IOException {
    parseSingle(""switch(x, 1= 2= 'foo')"");
  }
  @Ignore
  @Test
  public void parseWithSourceRefs() throws IOException {
    ExpressionVector sexps = RParser.parseAllSource(new StringReader(""x+1\nx+y\n""));
    assertThat(sexps.getAttributes().get(Symbols.SRC_REF), not(CoreMatchers.<SEXP>is(Null.INSTANCE)));
  }
  @Test
  public void onePlusOne() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""1 + 1;"");
    assertThat(r.length(), equalTo(3));
    assertThat(r.getElementAsSEXP(0), symbolNamed(""+""));
    assertThat(r.getElementAsSEXP(1), realVectorEqualTo(1));
    assertThat(r.getElementAsSEXP(2), realVectorEqualTo(1));
  }
  @Test
  public void symbol() throws IOException {
    SEXP s = parseSingle(""a;"");
    assertThat(s, symbolNamed(""a""));
  }
  @Test
  public void na() throws IOException {
    SEXP s = parseSingle(""NA;"");
    assertThat(s, logicalVectorOf(Logical.NA));
  }
  @Test
  public void assignment() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""a <- 3;"");
    assertThat(r.length(), equalTo(3));
    assertThat(r.getElementAsSEXP(0), symbolNamed(""<-""));
    assertThat(r.getElementAsSEXP(1), symbolNamed(""a""));
    assertThat(r.getElementAsSEXP(2), realVectorEqualTo(3));
  }
  @Test
  public void exprList() throws IOException {
    SEXP r = parseSingle("" { a<-1; b<-2; a*b } \n"");
    System.out.println(r);
  }
  @Test
  public void logical() throws IOException {
    LogicalVector x = (LogicalVector) parseSingle(""TRUE\n"");
    assertThat(x.length(), equalTo(1));
    assertThat(x.getElementAsInt(0), equalTo(1));
  }
  @Test
  public void functionDef() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""function (a, b) { a + b }\n"");
    assertThat(""result length"", r.length(), equalTo(4));
    PairList.Node formals = r.getElementAsSEXP(1);
    assertThat(formals.length(), equalTo(2));
    assertThat(formals.getNode(0).getRawTag(), symbolNamed(""a""));
    assertThat(formals.getNode(1).getRawTag(), symbolNamed(""b""));
    System.out.println(r);
  }
  @Test
  public void functionWithoutArgs() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""function () { a + b }\n"");
  }
  @Test
  public void ifElse() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""if(TRUE) 1 else 2;"");
    System.out.println(r);
  }
  @Test
  public void functionDefWithBodyLength2() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""function (a, b) { a * b\na + b; }\n"");
  }
  @Test
  public void functionDefWithNewlines() throws IOException {
    parseSingle(""function (a, b) {  \n "" +
        ""a + b\n"" +
        ""}\n"");
  }
  @Test
  public void commentsAndLeadingNewLines() throws IOException {
    ExpressionVector s = parseAll(""# this is a comment\n\n3.145;"");
    assertThat(s.length(), equalTo(1));
    assertThat(s.get(0), realVectorEqualTo(3.145));
  }
  @Test
  public void functionDefWithMultipleExpr() throws IOException {
    String source = ""function (a, b) { \n"" +
        ""x <- a\n"" +
        ""x <- x * b\n"" +
        ""x * b\n };"";
    System.out.println(source);
    FunctionCall r = (FunctionCall) parseSingle(source);
    System.out.println(r);
  }
  @Test
  public void precededByNewLine() throws IOException {
    ExpressionVector exprList = parseAll(""\n1;"");
    assertThat(exprList.length(), equalTo(1));
  }
  @Test
  public void crOnlyLineEndings() throws IOException {
    parseAll(""f <- function(x) {\rc(x)\r}\r"");
  }
  @Test
  public void crlfLineEndings() throws IOException {
    parseAll(""f <- function(x) {\r\nc(x)\r\n}\r\n"");
  }
  @Test
  public void stringWithEscapes() throws IOException {
    StringVector s = (StringVector) parseSingle(""\""a\\n\""\n"");
    assertThat(s.getElementAsString(0), equalTo(""a\n""));
  }
  @Test
  public void parseMultiline() throws IOException {
    ExpressionVector result = parseAll(""1\n2\n3\n"");
    assertThat(result.length(), equalTo(3));
  }
  @Test
  public void parseWithCommentsPreceding() throws IOException {
    ExpressionVector result = parseAll(
        ""# file header\r\n"" +
        ""\r\n"" +
        ""x<-function (y) {\r\n"" +
        ""   y * 2\n"" +
        ""}\r\n"");
    assertThat(result.length(), equalTo(1));
  }
  @Test
  public void parseElseWithNewline() throws IOException {
    ExpressionVector result = parseAll(""if(TRUE) 1 else\n2\n"");
    assertThat(result.length(), equalTo(1));
  }
  @Test
  public void parseRealScript() throws IOException {
    ExpressionVector result = (ExpressionVector) parseResource(""/testScript.R"");
    assertThat(result.length(), equalTo(1));
  }
  @Ignore
  @Test
  public void parseAddPs() throws IOException {
    ExpressionVector result = (ExpressionVector) parseResource(""add.ps.R"");
  }
  private ExpressionVector parseAll(String source) throws IOException {
    return RParser.parseSource(new StringReader(source));
  }
  private SEXP parseSingle(String source) throws IOException {
    ExpressionVector exp = RParser.parseSource(source);
    return exp.get(0);
  }
  private SEXP parseResource(String source) throws IOException {
    InputStream stream = getClass().getResourceAsStream(source);
    ExpressionVector result = RParser.parseSource(new InputStreamReader(stream));
    stream.close();
    return result;
  }
  @Test
  public void matrixProduct() throws IOException{ 
   ExpressionVector result = RParser.parseSource(new StringReader(""c(1,2,3) %*% c(7,8,7)\n""));
   FunctionCall call = (FunctionCall)result.getElementAsSEXP(0);
   Symbol function = (Symbol) call.getFunction();
   assertThat(function.getPrintName(), equalTo(""%*%"")); 
  }
}",class,
"  @Before
  public void setUp() {
  }",method,
"  @Test
  public void one() throws IOException {
    SEXP r = parseSingle(""1\n\n"");
    assertThat(r, CoreMatchers.instanceOf(DoubleArrayVector.class));
  }",method,
"  @Test(expected = ParseException.class)
  public void error() throws IOException {
    parseSingle(""switch(x, 1= 2= 'foo')"");
  }",method,
"  @Ignore
  @Test
  public void parseWithSourceRefs() throws IOException {
    ExpressionVector sexps = RParser.parseAllSource(new StringReader(""x+1\nx+y\n""));
    assertThat(sexps.getAttributes().get(Symbols.SRC_REF), not(CoreMatchers.<SEXP>is(Null.INSTANCE)));
  }",method,
"  @Test
  public void onePlusOne() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""1 + 1;"");
    assertThat(r.length(), equalTo(3));
    assertThat(r.getElementAsSEXP(0), symbolNamed(""+""));
    assertThat(r.getElementAsSEXP(1), realVectorEqualTo(1));
    assertThat(r.getElementAsSEXP(2), realVectorEqualTo(1));
  }",method,
"  @Test
  public void symbol() throws IOException {
    SEXP s = parseSingle(""a;"");
    assertThat(s, symbolNamed(""a""));
  }",method,
"  @Test
  public void na() throws IOException {
    SEXP s = parseSingle(""NA;"");
    assertThat(s, logicalVectorOf(Logical.NA));
  }",method,
"  @Test
  public void assignment() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""a <- 3;"");
    assertThat(r.length(), equalTo(3));
    assertThat(r.getElementAsSEXP(0), symbolNamed(""<-""));
    assertThat(r.getElementAsSEXP(1), symbolNamed(""a""));
    assertThat(r.getElementAsSEXP(2), realVectorEqualTo(3));
  }",method,
"  @Test
  public void exprList() throws IOException {
    SEXP r = parseSingle("" { a<-1; b<-2; a*b } \n"");
    System.out.println(r);
  }",method,
"  @Test
  public void logical() throws IOException {
    LogicalVector x = (LogicalVector) parseSingle(""TRUE\n"");
    assertThat(x.length(), equalTo(1));
    assertThat(x.getElementAsInt(0), equalTo(1));
  }",method,
"  @Test
  public void functionDef() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""function (a, b) { a + b }\n"");
    assertThat(""result length"", r.length(), equalTo(4));
    PairList.Node formals = r.getElementAsSEXP(1);
    assertThat(formals.length(), equalTo(2));
    assertThat(formals.getNode(0).getRawTag(), symbolNamed(""a""));
    assertThat(formals.getNode(1).getRawTag(), symbolNamed(""b""));
    System.out.println(r);
  }",method,
"  @Test
  public void functionWithoutArgs() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""function () { a + b }\n"");
  }",method,
"  @Test
  public void ifElse() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""if(TRUE) 1 else 2;"");
    System.out.println(r);
  }",method,
"  @Test
  public void functionDefWithBodyLength2() throws IOException {
    FunctionCall r = (FunctionCall) parseSingle(""function (a, b) { a * b\na + b; }\n"");
  }",method,
"  @Test
  public void functionDefWithNewlines() throws IOException {
    parseSingle(""function (a, b) {  \n "" +
        ""a + b\n"" +
        ""}\n"");
  }",method,
"    parseSingle(""function (a, b) {  \n "" +
        ""a + b\n"" +
        ""}\n"");
  }
  @Test
  public void commentsAndLeadingNewLines() throws IOException {
    ExpressionVector s = parseAll(""# this is a comment\n\n3.145;"");
    assertThat(s.length(), equalTo(1));
    assertThat(s.get(0), realVectorEqualTo(3.145));
  }",method,
"  @Test
  public void commentsAndLeadingNewLines() throws IOException {
    ExpressionVector s = parseAll(""# this is a comment\n\n3.145;"");
    assertThat(s.length(), equalTo(1));
    assertThat(s.get(0), realVectorEqualTo(3.145));
  }",method,
"  @Test
  public void functionDefWithMultipleExpr() throws IOException {
    String source = ""function (a, b) { \n"" +
        ""x <- a\n"" +
        ""x <- x * b\n"" +
        ""x * b\n };"";
    System.out.println(source);
    FunctionCall r = (FunctionCall) parseSingle(source);
    System.out.println(r);
  }",method,
"  @Test
  public void precededByNewLine() throws IOException {
    ExpressionVector exprList = parseAll(""\n1;"");
    assertThat(exprList.length(), equalTo(1));
  }",method,
"  @Test
  public void crOnlyLineEndings() throws IOException {
    parseAll(""f <- function(x) {\rc(x)\r}\r"");
  }",method,
"    parseAll(""f <- function(x) {\rc(x)\r}\r"");
  }
  @Test
  public void crlfLineEndings() throws IOException {
    parseAll(""f <- function(x) {\r\nc(x)\r\n}\r\n"");
  }",method,
"  @Test
  public void crlfLineEndings() throws IOException {
    parseAll(""f <- function(x) {\r\nc(x)\r\n}\r\n"");
  }",method,
"    parseAll(""f <- function(x) {\r\nc(x)\r\n}\r\n"");
  }
  @Test
  public void stringWithEscapes() throws IOException {
    StringVector s = (StringVector) parseSingle(""\""a\\n\""\n"");
    assertThat(s.getElementAsString(0), equalTo(""a\n""));
  }",method,
"  @Test
  public void stringWithEscapes() throws IOException {
    StringVector s = (StringVector) parseSingle(""\""a\\n\""\n"");
    assertThat(s.getElementAsString(0), equalTo(""a\n""));
  }",method,
"  @Test
  public void parseMultiline() throws IOException {
    ExpressionVector result = parseAll(""1\n2\n3\n"");
    assertThat(result.length(), equalTo(3));
  }",method,
"  @Test
  public void parseWithCommentsPreceding() throws IOException {
    ExpressionVector result = parseAll(
        ""# file header\r\n"" +
        ""\r\n"" +
        ""x<-function (y) {\r\n"" +
        ""   y * 2\n"" +
        ""}\r\n"");
    assertThat(result.length(), equalTo(1));
  }",method,
"  @Test
  public void parseElseWithNewline() throws IOException {
    ExpressionVector result = parseAll(""if(TRUE) 1 else\n2\n"");
    assertThat(result.length(), equalTo(1));
  }",method,
"  @Test
  public void parseRealScript() throws IOException {
    ExpressionVector result = (ExpressionVector) parseResource(""/testScript.R"");
    assertThat(result.length(), equalTo(1));
  }",method,
"  @Ignore
  @Test
  public void parseAddPs() throws IOException {
    ExpressionVector result = (ExpressionVector) parseResource(""add.ps.R"");
  }",method,
"  private ExpressionVector parseAll(String source) throws IOException {
    return RParser.parseSource(new StringReader(source));
  }",method,
"  private SEXP parseSingle(String source) throws IOException {
    ExpressionVector exp = RParser.parseSource(source);
    return exp.get(0);
  }",method,
